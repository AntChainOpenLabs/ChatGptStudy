[
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IDue} from './interfaces/IDue.sol';\nimport {IERC721Receiver} from '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport {IConvenience} from './interfaces/IConvenience.sol';\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ERC721Permit} from './base/ERC721Permit.sol';\nimport {SafeMetadata} from './libraries/SafeMetadata.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {NFTTokenURIScaffold} from './libraries/NFTTokenURIScaffold.sol';\n\ncontract CollateralizedDebt is IDue, ERC721Permit {\n    using Strings for uint256;\n    using SafeMetadata for IERC20;\n\n    IConvenience public immutable override convenience;\n    IPair public immutable override pair;\n    uint256 public immutable override maturity;\n\n    function name() external view override returns (string memory) {\n        string memory assetName = pair.asset().safeName();\n        string memory collateralName = pair.collateral().safeName();\n        return\n            string(\n                abi.encodePacked(\n                    'Timeswap Collateralized Debt - ',\n                    assetName,\n                    ' - ',\n                    collateralName,\n                    ' - ',\n                    maturity.toString()\n                )\n            );\n    }\n\n    function symbol() external view override returns (string memory) {\n        string memory assetSymbol = pair.asset().safeSymbol();\n        string memory collateralSymbol = pair.collateral().safeSymbol();\n        return string(abi.encodePacked('TS-CDT-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));\n    }\n\n    function tokenURI(uint256 id) external view override returns (string memory) {\n        require(ownerOf[id] != address(0), 'E404');\n        return NFTTokenURIScaffold.tokenURI(id, pair, dueOf(id), maturity);\n    }\n\n    function assetDecimals() external view override returns (uint8) {\n        return pair.asset().safeDecimals();\n    }\n\n    function collateralDecimals() external view override returns (uint8) {\n        return pair.collateral().safeDecimals();\n    }\n\n    function dueOf(uint256 id) public view override returns (IPair.Due memory) {\n        return pair.dueOf(maturity, address(this), id);\n    }\n\n    constructor(\n        IConvenience _convenience,\n        IPair _pair,\n        uint256 _maturity\n    ) ERC721Permit('Timeswap Collateralized Debt') {\n        convenience = _convenience;\n        pair = _pair;\n        maturity = _maturity;\n    }\n\n    modifier onlyConvenience() {\n        require(msg.sender == address(convenience), 'E403');\n        _;\n    }\n\n    function mint(address to, uint256 id) external override onlyConvenience {\n        _safeMint(to, id);\n    }\n\n    function burn(\n        address to,\n        uint256[] memory ids,\n        uint112[] memory assetsIn,\n        uint112[] memory collateralsOut,\n        bytes calldata data\n    ) external override onlyConvenience returns (uint128 assetIn, uint128 collateralOut) {\n        (assetIn, collateralOut) = pair.pay(maturity, to, address(this), ids, assetsIn, collateralsOut, data);\n    }\n\n    function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override {\n        require(msg.sender == address(pair), 'E401');\n\n        convenience.collateralizedDebtCallback(pair, maturity, assetIn, data);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-timeswap-findings.json",
                "Location": "CollateralizedDebt.sol#mint()",
                "Type": "Reentrancy",
                "Description": "Functions with callbacks should have reentrancy guards in place for protection against possible malicious actors both from inside and outside the protocol.",
                "Repair": "Add a reentrancy guard modifier on the mint() function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IShelter } from \"./interfaces/IShelter.sol\";\nimport { IShelterClient } from \"./interfaces/IShelterClient.sol\";\n\ncontract Shelter is IShelter {\n    using SafeERC20 for IERC20;\n\n    IShelterClient public immutable client;\n\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    mapping(IERC20 => mapping(address => bool)) public override claimed;\n\n    mapping(IERC20 => uint256) public activated;\n\n    mapping(IERC20 => uint256) public savedTokens;\n\n    modifier onlyClient {\n        require(msg.sender == address(client), \"!client\");\n        _;\n    }\n\n    constructor(IShelterClient _client){\n        client = _client;\n    }\n\n    function donate(IERC20 _token, uint256 _amount) external {\n        require(activated[_token] != 0, \"!activated\");\n        savedTokens[_token] += _amount;\n        _token.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function activate(IERC20 _token) external override onlyClient {\n        activated[_token] = block.timestamp;\n        savedTokens[_token] = _token.balanceOf(address(this));\n        emit ShelterActivated(_token);\n    }\n\n    function deactivate(IERC20 _token) external override onlyClient {\n        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, \"too late\");\n        activated[_token] = 0;\n        savedTokens[_token] = 0;\n        _token.safeTransfer(msg.sender, _token.balanceOf(address(this)));\n        emit ShelterDeactivated(_token);\n    }\n\n    function withdraw(IERC20 _token, address _to) external override {\n        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, \"shelter not activated\");\n        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);\n        claimed[_token][_to] = true;\n        emit ExitShelter(_token, msg.sender, _to, amount);\n        _token.safeTransfer(_to, amount);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-02-concur-findings.json",
                "Location": "Shelter.sol withdraw() function",
                "Type": "Reentrancy",
                "Description": "Repeated calls to Shelter.withdraw can drain all funds in Shelter, allowing an attacker that can successfully call withdraw() once on a shelter, to call it repeatedly to steal the funds of others.",
                "Repair": "Check claims against msg.sender and record who is withdrawing"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IConcurRewardClaim} from \"./interfaces/IConcurRewardClaim.sol\";\n\ncontract ConcurRewardPool is IConcurRewardClaim {\n    using SafeERC20 for IERC20;\n    address public immutable rewardNotifier;\n\n    mapping(address => mapping(address => uint256)) public reward;\n\n    constructor(address _notifier) {\n        rewardNotifier = _notifier;\n    }\n\n    /// @notice push reward to `_recipient`\n    /// @param _recipient reward recipient address\n    /// @param _token token to reward\n    /// @param _amount amount of tokens to allocate to `_recipient`\n    function pushReward(\n        address _recipient,\n        address _token,\n        uint256 _amount\n    ) external override {\n        require(msg.sender == rewardNotifier, \"!notifier\");\n        reward[_recipient][_token] += _amount;\n    }\n\n    /// @notice claim rewards of `msg.sender`\n    /// @param _tokens array of tokens to claim\n    function claimRewards(address[] calldata _tokens) external override {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 getting = reward[msg.sender][_tokens[i]];\n            IERC20(_tokens[i]).safeTransfer(msg.sender, getting);\n            reward[msg.sender][_tokens[i]] = 0;\n        }\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-02-concur-findings.json",
                "Location": "ConcurRewardPool.sol#L34",
                "Type": "Reentrancy",
                "Description": "The reward tokens are transferred before the balances are set to 0, making it possible to perform a reentrancy attack if the reward token has some kind of call back functionality.",
                "Repair": "Use a nonReentrant modifier, set balances to 0 first before disbursing the rewards"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n\n// WARNING!!!\n// Combining BoringBatchable with msg.value can cause double spending issues\n// https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/\n\ncontract BoringBatchable {\n  error BatchError(bytes innerError);\n\n  /// @dev Helper function to extract a useful revert message from a failed call.\n  /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n  function _getRevertMsg(bytes memory _returnData) internal pure {\n    // If the _res length is less than 68, then\n    // the transaction failed with custom error or silently (without a revert message)\n    if (_returnData.length < 68) revert BatchError(_returnData);\n\n    assembly {\n      // Slice the sighash.\n      _returnData := add(_returnData, 0x04)\n    }\n    revert(abi.decode(_returnData, (string))); // All that remains is the revert string\n  }\n\n  /// @notice Allows batched call to self (this contract).\n  /// @param calls An array of inputs for each call.\n  /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n  // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n  // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n  // C3: The length of the loop is fully under user control, so can't be exploited\n  // C7: Delegatecall is only used on the same contract, so it's safe\n  function batch(bytes[] calldata calls, bool revertOnFail) external payable {\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n      if (!success && revertOnFail) {\n        _getRevertMsg(result);\n      }\n    }\n  }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-08-mimo-findings.json",
                "Location": "BoringBatchable contract",
                "Type": "Reentrancy",
                "Description": "Persisted msg.value in a loop of delegate calls can be used to drain ETH from your proxy",
                "Repair": "Remove payable from batch() function in BoringBatchable contract"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RealEstatePlatform {\n\n    mapping(address => uint) public propertyPrices;\n    mapping(address => uint) public ownerBalances;\n\n    function listProperty(uint price) public {\n        propertyPrices[msg.sender] = price;\n    }\n\n    function buyProperty(address payable propertyOwner) public payable {\n        require(msg.value >= propertyPrices[propertyOwner], 'Insufficient funds to buy this property.');\n\n        ownerBalances[propertyOwner] += msg.value;\n\n        (bool success,) = propertyOwner.call{value: ownerBalances[propertyOwner]}('');\n        require(success, 'Transfer failed.');\n\n        ownerBalances[propertyOwner] = 0;\n        propertyPrices[propertyOwner] = 0;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "1",
            "Location": "(bool success,) = propertyOwner.call{value: ownerBalances[propertyOwner]}('');\nrequire(success, 'Transfer failed.');",
            "Type": "Reentrancy",
            "Description": "The function buyProperty has a reentrancy vulnerability because it uses a low-level call to transfer ether to propertyOwner, which can potentially trigger the fallback function in the recipient's contract. If the recipient contract's fallback function in turn calls back into buyProperty, it could potentially withdraw more ether than intended.",
            "Repair": "The best practice is to apply the Checks-Effects-Interactions pattern. This can be done by moving the ether transfer to the end of the function, after all the internal state has been updated. Additionally, use the transfer() function instead of call.value() to prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CryptoExchange {\n\n    mapping(address => uint) public tokenBalances;\n    mapping(address => mapping(address => uint)) public tokenAllowances;\n\n    event Deposit(address indexed user, uint amount);\n    event Withdraw(address indexed user, uint amount);\n\n    function depositTokens(address token, uint amount) public {\n        require(tokenBalances[msg.sender] >= amount, 'Insufficient token balance.');\n        tokenBalances[msg.sender] -= amount;\n        tokenAllowances[token][msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdrawTokens(address token, uint amount) public {\n        require(tokenAllowances[token][msg.sender] >= amount, 'Insufficient allowance.');\n\n        tokenAllowances[token][msg.sender] -= amount;\n        tokenBalances[msg.sender] += amount;\n\n        (bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Transfer failed.');\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "2",
            "Location": "(bool success,) = msg.sender.call{value: amount}('');\nrequire(success, 'Transfer failed.');",
            "Type": "Reentrancy",
            "Description": "In the function withdrawTokens, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to msg.sender, which can potentially trigger the fallback function in the recipient's contract. If the recipient contract's fallback function in turn calls back into withdrawTokens, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineMarketplace {\n\n    struct Product {\n        string name;\n        uint price;\n        address payable owner;\n    }\n\n    mapping(uint => Product) public products;\n\n    event ProductPurchased(uint productId, address buyer, uint price);\n\n    function addProduct(string memory name, uint price) public {\n        uint newProductId = uint(keccak256(abi.encodePacked(name, msg.sender)));\n        products[newProductId] = Product(name, price, payable(msg.sender));\n    }\n\n    function buyProduct(uint productId) public payable {\n        Product storage product = products[productId];\n\n        require(msg.value >= product.price, 'Insufficient funds to buy this product.');\n\n        (bool transferSucceeded,) = product.owner.call{value: msg.value}('');\n        require(transferSucceeded, 'Failed to transfer funds to the product owner.');\n\n        emit ProductPurchased(productId, msg.sender, msg.value);\n\n        delete products[productId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "3",
            "Location": "(bool transferSucceeded,) = product.owner.call{value: msg.value}('');\nrequire(transferSucceeded, 'Failed to transfer funds to the product owner.');",
            "Type": "Reentrancy",
            "Description": "In the function buyProduct, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the product owner, which can potentially trigger the fallback function in the owner's contract. If the owner's contract's fallback function in turn calls back into buyProduct, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DigitalBank {\n    mapping(address => uint) public accountBalances;\n    event Withdrawal(address indexed accountHolder, uint amount);\n\n    function deposit() public payable {\n        accountBalances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        require(accountBalances[msg.sender] >= amount, 'Insufficient funds.');\n\n        (bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Failed to transfer Ether.');\n\n        accountBalances[msg.sender] -= amount;\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    function balance() public view returns (uint) {\n        return accountBalances[msg.sender];\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "4",
            "Location": "(bool success,) = msg.sender.call{value: amount}('');\nrequire(success, 'Failed to transfer Ether.');",
            "Type": "Reentrancy",
            "Description": "In the function withdraw, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to msg.sender, which can potentially trigger the fallback function in the recipient's contract. If the recipient contract's fallback function in turn calls back into withdraw, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CrowdfundingCampaign {\n\n    struct Contribution {\n        uint amount;\n        address payable contributor;\n    }\n\n    mapping(uint => Contribution) public contributions;\n    uint public contributionsCount = 0;\n    uint public totalFunds = 0;\n\n    function contribute() public payable {\n        uint newContributionId = contributionsCount++;\n        contributions[newContributionId] = Contribution(msg.value, payable(msg.sender));\n        totalFunds += msg.value;\n    }\n\n    function refund(uint contributionId) public {\n        Contribution storage contrib = contributions[contributionId];\n\n        require(contrib.contributor == msg.sender, 'Not the contributor.');\n\n        (bool success,) = contrib.contributor.call{value: contrib.amount}('');\n        require(success, 'Failed to refund.');\n\n        totalFunds -= contrib.amount;\n        delete contributions[contributionId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "5",
            "Location": "(bool success,) = contrib.contributor.call{value: contrib.amount}('');\nrequire(success, 'Failed to refund.');",
            "Type": "Reentrancy",
            "Description": "In the function refund, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the contributor, which can potentially trigger the fallback function in the contributor's contract. If the contributor's contract's fallback function in turn calls back into refund, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineMarket {\n\n    struct Item {\n        uint price;\n        address payable seller;\n    }\n\n    mapping(uint => Item) public items;\n    uint public itemCount = 0;\n\n    function addItem(uint price) public {\n        uint newItemId = itemCount++;\n        items[newItemId] = Item(price, payable(msg.sender));\n    }\n\n    function buyItem(uint itemId) public payable {\n        Item storage item = items[itemId];\n\n        require(msg.value >= item.price, 'Not enough Ether sent.');\n\n        (bool success,) = item.seller.call{value: item.price}('');\n        require(success, 'Failed to transfer Ether to seller.');\n\n        delete items[itemId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "6",
            "Location": "(bool success,) = item.seller.call{value: item.price}('');\nrequire(success, 'Failed to transfer Ether to seller.');",
            "Type": "Reentrancy",
            "Description": "In the function buyItem, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the seller, which can potentially trigger the fallback function in the seller's contract. If the seller's contract's fallback function in turn calls back into buyItem, it could potentially purchase more items than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RealEstateAgency {\n\n    struct Property {\n        uint price;\n        address payable owner;\n    }\n\n    mapping(uint => Property) public properties;\n    uint public propertyCount = 0;\n\n    function listProperty(uint price) public {\n        uint newPropertyId = propertyCount++;\n        properties[newPropertyId] = Property(price, payable(msg.sender));\n    }\n\n    function purchaseProperty(uint propertyId) public payable {\n        Property storage property = properties[propertyId];\n\n        require(msg.value >= property.price, 'Not enough Ether sent.');\n\n        (bool success,) = property.owner.call{value: property.price}('');\n        require(success, 'Failed to transfer Ether to owner.');\n\n        delete properties[propertyId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "7",
            "Location": "(bool success,) = property.owner.call{value: property.price}('');\nrequire(success, 'Failed to transfer Ether to owner.');",
            "Type": "Reentrancy",
            "Description": "In the function purchaseProperty, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the property owner, which can potentially trigger the fallback function in the owner's contract. If the owner's contract's fallback function in turn calls back into purchaseProperty, it could potentially purchase more properties than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineAuction {\n\n    struct Bid {\n        uint amount;\n        address payable bidder;\n    }\n\n    mapping(uint => Bid) public bids;\n    uint public bidCount = 0;\n\n    function makeBid(uint amount) public payable {\n        uint newBidId = bidCount++;\n        bids[newBidId] = Bid(amount, payable(msg.sender));\n    }\n\n    function acceptBid(uint bidId) public {\n        Bid storage bid = bids[bidId];\n\n        (bool success,) = bid.bidder.call{value: bid.amount}('');\n        require(success, 'Failed to transfer Ether to bidder.');\n\n        delete bids[bidId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "8",
            "Location": "(bool success,) = bid.bidder.call{value: bid.amount}('');\nrequire(success, 'Failed to transfer Ether to bidder.');",
            "Type": "Reentrancy",
            "Description": "In the function acceptBid, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the bidder, which can potentially trigger the fallback function in the bidder's contract. If the bidder's contract's fallback function in turn calls back into acceptBid, it could potentially cause unexpected behavior.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineMarketplace {\n\n    struct Product {\n        uint price;\n        address payable seller;\n    }\n\n    mapping(uint => Product) public products;\n    uint public productCount = 0;\n\n    function listProduct(uint price) public {\n        uint newProductId = productCount++;\n        products[newProductId] = Product(price, payable(msg.sender));\n    }\n\n    function purchaseProduct(uint productId) public payable {\n        Product storage product = products[productId];\n\n        require(msg.value >= product.price, 'Not enough Ether sent.');\n\n        (bool success,) = product.seller.call{value: product.price}('');\n        require(success, 'Failed to transfer Ether to seller.');\n\n        delete products[productId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "9",
            "Location": "(bool success,) = product.seller.call{value: product.price}('');\nrequire(success, 'Failed to transfer Ether to seller.');",
            "Type": "Reentrancy",
            "Description": "In the function purchaseProduct, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the product seller, which can potentially trigger the fallback function in the seller's contract. If the seller's contract's fallback function in turn calls back into purchaseProduct, it could potentially purchase more products than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DigitalExchange {\n\n    struct Share {\n        uint price;\n        address payable owner;\n    }\n\n    mapping(uint => Share) public shares;\n    uint public shareCount = 0;\n\n    function listShare(uint price) public {\n        uint newShareId = shareCount++;\n        shares[newShareId] = Share(price, payable(msg.sender));\n    }\n\n    function buyShare(uint shareId) public payable {\n        Share storage share = shares[shareId];\n\n        require(msg.value >= share.price, 'Not enough Ether sent.');\n\n        (bool success,) = share.owner.call{value: share.price}('');\n        require(success, 'Failed to transfer Ether to owner.');\n\n        delete shares[shareId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "10",
            "Location": "(bool success,) = share.owner.call{value: share.price}('');\nrequire(success, 'Failed to transfer Ether to owner.');",
            "Type": "Reentrancy",
            "Description": "In the function buyShare, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the share owner, which can potentially trigger the fallback function in the owner's contract. If the owner's contract's fallback function in turn calls back into buyShare, it could potentially buy more shares than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract FineArtAuction {\n\n    struct Artwork {\n        uint bid;\n        address payable artist;\n    }\n\n    mapping(uint => Artwork) public artworks;\n    uint public artworkCount = 0;\n\n    function listArtwork() public {\n        uint newArtworkId = artworkCount++;\n        artworks[newArtworkId] = Artwork(0, payable(msg.sender));\n    }\n\n    function placeBid(uint artworkId) public payable {\n        Artwork storage artwork = artworks[artworkId];\n\n        require(msg.value > artwork.bid, 'Bid is not high enough.');\n\n        (bool success,) = artwork.artist.call{value: msg.value}('');\n        require(success, 'Failed to transfer Ether to artist.');\n\n        artwork.bid = msg.value;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "11",
            "Location": "(bool success,) = artwork.artist.call{value: msg.value}('');\nrequire(success, 'Failed to transfer Ether to artist.');",
            "Type": "Reentrancy",
            "Description": "In the function placeBid, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the artist, which can potentially trigger the fallback function in the artist's contract. If the artist's contract's fallback function in turn calls back into placeBid, it could potentially place more bids than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CrowdfundingCampaign {\n\n    struct Project {\n        uint fundingGoal;\n        uint amountRaised;\n        address payable creator;\n    }\n\n    mapping(uint => Project) public projects;\n    uint public projectCount = 0;\n\n    function createProject(uint fundingGoal) public {\n        uint newProjectId = projectCount++;\n        projects[newProjectId] = Project(fundingGoal, 0, payable(msg.sender));\n    }\n\n    function contribute(uint projectId) public payable {\n        Project storage project = projects[projectId];\n\n        require(msg.value + project.amountRaised <= project.fundingGoal, 'Funding goal exceeded.');\n\n        (bool success,) = project.creator.call{value: msg.value}('');\n        require(success, 'Failed to transfer Ether to project creator.');\n\n        project.amountRaised += msg.value;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "12",
            "Location": "(bool success,) = project.creator.call{value: msg.value}('');\nrequire(success, 'Failed to transfer Ether to project creator.');",
            "Type": "Reentrancy",
            "Description": "In the function contribute, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the project creator, which can potentially trigger the fallback function in the creator's contract. If the creator's contract's fallback function in turn calls back into contribute, it could potentially contribute more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CapitalVenture {\n\n    struct Investor {\n        uint invested;\n        uint lastInvest;\n        address payable addr;\n    }\n\n    mapping(address => Investor) public investors;\n\n    function invest() public payable {\n        Investor storage investor = investors[msg.sender];\n        investor.addr = payable(msg.sender);\n        investor.invested += msg.value;\n        investor.lastInvest = block.timestamp;\n\n        (bool success,) = investor.addr.call{value: msg.value}('');\n        require(success, 'Failed to transfer Ether.');\n    }\n\n    function getInvestedAmount(address addr) public view returns (uint) {\n        return investors[addr].invested;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "13",
            "Location": "(bool success,) = investor.addr.call{value: msg.value}('');\nrequire(success, 'Failed to transfer Ether.');",
            "Type": "Reentrancy",
            "Description": "In the invest function, there is a reentrancy vulnerability because it uses a low-level call to transfer ether back to the investor, potentially triggering the fallback function of the investor's contract. If the investor's contract's fallback function in turn calls back into invest, it could potentially invest more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract FundRaiser {\n\n    struct Donor {\n        uint amount;\n        address payable addr;\n    }\n\n    mapping(address => Donor) public donors;\n\n    function donate() public payable {\n        Donor storage donor = donors[msg.sender];\n        donor.addr = payable(msg.sender);\n        donor.amount += msg.value;\n\n        (bool success,) = donor.addr.call{value: msg.value / 10}('');\n        require(success, 'Failed to transfer Ether.');\n    }\n\n    function getDonationAmount(address addr) public view returns (uint) {\n        return donors[addr].amount;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "14",
            "Location": "(bool success,) = donor.addr.call{value: msg.value / 10}('');\nrequire(success, 'Failed to transfer Ether.');",
            "Type": "Reentrancy",
            "Description": "In the donate function, there is a reentrancy vulnerability because it uses a low-level call to transfer a portion of the donated ether back to the donor, potentially triggering the fallback function of the donor's contract. If the donor's contract's fallback function in turn calls back into donate, it could potentially donate more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract MembershipClub {\n    mapping(address => uint) public memberFees;\n\n    function joinClub() public payable {\n        memberFees[msg.sender] += msg.value;\n        require(memberFees[msg.sender] >= 1 ether, 'Membership fee is at least 1 Ether');\n\n        (bool sent,) = msg.sender.call{value: msg.value / 10}('');\n        require(sent, 'Failed to send Ether');\n    }\n\n    function getFee(address member) public view returns (uint) {\n        return memberFees[member];\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "15",
            "Location": "(bool sent,) = msg.sender.call{value: msg.value / 10}('');\n        require(sent, 'Failed to send Ether');",
            "Type": "Reentrancy",
            "Description": "In the joinClub function, there is a reentrancy vulnerability because it uses a low-level call to refund part of the membership fee to the caller, potentially triggering the fallback function of the caller's contract. If the caller's contract's fallback function in turn calls back into joinClub, it could potentially join the club with less fee than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract AssetPortfolio {\n    mapping(address => uint) public investments;\n\n    function invest() public payable {\n        investments[msg.sender] += msg.value;\n    }\n\n    function divest(uint amount) public {\n        require(investments[msg.sender] >= amount, 'Insufficient investment');\n        investments[msg.sender] -= amount;\n        (bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Transfer failed');\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "16",
            "Location": "(bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Transfer failed');",
            "Type": "Reentrancy",
            "Description": "In the divest function, there is a reentrancy vulnerability. Before updating the internal state (i.e., the investor's investment amount), transferring money to the investor may trigger the fallback function of his contract, which may cause the investor to withdraw more than his original investment amount if the function calls divest again.",
            "Repair": "Adopt the Checks-Effects-Interactions pattern, move the ether transfer to the end of the function, and execute it after all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the gas available to the payee and prevent the payee's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract WealthManager {\n    mapping(address => uint) public deposits;\n\n    function makeDeposit() public payable {\n        deposits[msg.sender] += msg.value;\n    }\n\n    function makeWithdrawal(uint _amount) public {\n        require(deposits[msg.sender] >= _amount, 'Insufficient deposit');\n        deposits[msg.sender] -= _amount;\n        (bool success,) = msg.sender.call{value: _amount}('');\n        require(success, 'Transfer failed');\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "17",
            "Location": "(bool success,) = msg.sender.call{value: _amount}('');\n        require(success, 'Transfer failed');",
            "Type": "Reentrancy",
            "Description": "In the makeWithdrawal function, there is a reentrancy vulnerability. Before updating the internal state (i.e. the user's deposit), transferring funds to the user may trigger the fallback function of their contract, which may cause the user to withdraw more than their original deposit if the function calls makeWithdrawal again.",
            "Repair": "The way to fix it is to use the Checks-Effects-Interactions pattern, move the ether transfer to the end of the function, and execute it after all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the gas available to the payee and prevent the payee's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract AssetLocker {\n    mapping(address => uint256) public assetBalance;\n\n    event AssetDeposited(address indexed depositor, uint256 amount);\n    event AssetWithdrawn(address indexed withdrawer, uint256 amount);\n\n    function depositAsset() public payable {\n        assetBalance[msg.sender] += msg.value;\n        emit AssetDeposited(msg.sender, msg.value);\n    }\n\n    function withdrawAsset(uint256 amount) public {\n        require(assetBalance[msg.sender] >= amount, 'Not enough asset to withdraw');\n        (bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Asset transfer failed');\n        assetBalance[msg.sender] -= amount;\n        emit AssetWithdrawn(msg.sender, amount);\n    }\n\n    function getBalance() public view returns(uint256) {\n        return assetBalance[msg.sender];\n    }\n\n    function totalAssets() public view returns(uint256) {\n        return address(this).balance;\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "18",
            "Location": "(bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Asset transfer failed');\n        assetBalance[msg.sender] -= amount;",
            "Type": "Reentrancy",
            "Description": "In the withdrawAsset function, there is a reentrancy vulnerability. Before updating the internal state (i.e. the user's asset balance), transferring money to the user may trigger the fallback function of their contract, which may allow the user to withdraw more than their original deposit if the function calls withdrawAsset again.",
            "Repair": "The way to fix it is to use the Checks-Effects-Interactions pattern, move the ether transfer to the end of the function, and execute it after all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the gas available to the payee and prevent the payee's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract PropertyRegistry {\n    mapping(address => uint256) public propertyBalance;\n    address payable public registryOwner;\n\n    constructor() {\n        registryOwner = payable(msg.sender);\n    }\n\n    function deposit() public payable {\n        propertyBalance[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(propertyBalance[msg.sender] >= amount, 'Insufficient balance');\n        (bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Failed to send ether');\n        propertyBalance[msg.sender] -= amount;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return propertyBalance[msg.sender];\n    }\n\n    function contractBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function closeRegistry() public {\n        require(msg.sender == registryOwner, 'Only owner can close the registry');\n        selfdestruct(registryOwner);\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "19",
            "Location": "(bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Failed to send ether');\n        propertyBalance[msg.sender] -= amount;",
            "Type": "Reentrancy",
            "Description": "In the withdraw function, there is a reentrancy vulnerability. Before updating the internal state (i.e., the user's property balance), sending ether to the user could trigger their contract's fallback function. If that function calls withdraw again, it could allow the user to withdraw more than their original deposit.",
            "Repair": "The way to fix it is to use the Checks-Effects-Interactions pattern, moving the ether transfer to the end of the function when all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the amount of gas available to the recipient, preventing the recipient's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CashbackLoyaltyProgram {\n    mapping(address => uint256) public loyaltyPoints;\n    mapping(address => uint256) public etherBalance;\n    address payable public companyWallet;\n\n    constructor() {\n        companyWallet = payable(msg.sender);\n    }\n\n    function purchaseItem() public payable {\n        companyWallet.transfer(msg.value);\n        loyaltyPoints[msg.sender] += msg.value / 100;\n    }\n\n    function redeemPoints(uint256 points) public {\n        require(loyaltyPoints[msg.sender] >= points, 'Not enough loyalty points');\n        uint256 etherToRedeem = points / 100;\n        require(etherBalance[companyWallet] >= etherToRedeem, 'Not enough funds in the company wallet');\n        (bool sent, ) = msg.sender.call{value: etherToRedeem}('');\n        require(sent, 'Failed to send Ether');\n        loyaltyPoints[msg.sender] -= points;\n        etherBalance[companyWallet] -= etherToRedeem;\n    }\n\n    function getPoints() public view returns (uint256) {\n        return loyaltyPoints[msg.sender];\n    }\n\n    function getCompanyBalance() public view returns (uint256) {\n        return etherBalance[companyWallet];\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "20",
            "Location": "(bool sent, ) = msg.sender.call{value: etherToRedeem}('');\n        require(sent, 'Failed to send Ether');\n        loyaltyPoints[msg.sender] -= points;\n        etherBalance[companyWallet] -= etherToRedeem;",
            "Type": "Reentrancy",
            "Description": "In the redeemPoints function, a reentrancy vulnerability is present. Before the internal state (i.e., the user's loyalty points and the company's ether balance) is updated, ether is sent to the user. If the user's contract's fallback function is triggered and calls redeemPoints again, it could allow the user to redeem more than their original loyalty points for ether.",
            "Repair": "To fix it, the Checks-Effects-Interactions pattern should be used, moving the ether transfer to the end of the function after all internal states have been updated. It would be safer to use the transfer() function instead of call.value() to limit the amount of gas available to the recipient, thus preventing the recipient's contract from executing a large amount of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract VentureCapital {\n    mapping(address => uint) public investments;\n    address payable public entrepreneur;\n\n    constructor() {\n        entrepreneur = payable(msg.sender);\n    }\n\n    function invest() public payable {\n        investments[msg.sender] += msg.value;\n    }\n\n    function profitDistribution() public {\n        require(msg.sender == entrepreneur, 'Only the entrepreneur can distribute profits');\n        for (address investor: getInvestors()) {\n            uint profitShare = investments[investor] / 10;\n            (bool sent, ) = investor.call{value: profitShare}('');\n            require(sent, 'Failed to send Ether');\n        }\n    }\n\n    function getInvestors() public view returns (address[] memory) {\n        address[] memory investors = new address[](address(this).balance);\n        uint count = 0;\n        for (uint i = 0; i < investors.length; i++) {\n            if (investments[investors[i]] > 0) {\n                investors[count] = investors[i];\n                count++;\n            }\n        }\n        return investors;\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "21",
            "Location": "(bool sent, ) = investor.call{value: profitShare}('');\n        require(sent, 'Failed to send Ether');",
            "Type": "Reentrancy",
            "Description": "In the profitDistribution function, there is a reentrancy vulnerability. Ether is being sent to investors before the state (i.e., the balance of this contract) is updated. This allows the investor's fallback function to be triggered and call profitDistribution again, possibly leading to a withdrawal of more profits than intended.",
            "Repair": "To mitigate this, one should apply the Checks-Effects-Interactions pattern, ensuring state changes happen prior to calling external contracts. In addition, Solidity's transfer function could be used instead of call.value() to limit the gas provided to the external call, which could limit the potential for reentrancy by preventing the called contract from performing other operations."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\ncontract Trader is ITrader {\n  \n    string private constant EIP712_DOMAIN_NAME = \"Tracer Protocol\";\n    string private constant EIP712_DOMAIN_VERSION = \"1.0\";\n    bytes32 private constant EIP712_DOMAIN_SEPERATOR =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n\n    bytes32 private constant ORDER_TYPE =\n        keccak256(\n            \"Order(address maker,address market,uint256 price,uint256 amount,uint256 side,uint256 expires,uint256 created)\"\n        );\n\n    uint256 public constant override chainId = 1337; // Changes per chain\n    bytes32 public immutable override EIP712_DOMAIN;\n\n    mapping(bytes32 => Perpetuals.Order) public orders;\n  \n    mapping(bytes32 => Types.SignedLimitOrder) public orderToSig;\n\n    mapping(bytes32 => uint256) public override filled;\n\n    mapping(bytes32 => uint256) public override averageExecutionPrice;\n\n    constructor() {\n\n        EIP712_DOMAIN = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_SEPERATOR,\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\n                chainId,\n                address(this)\n            )\n        );\n    }\n    function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers)\n        external\n        override\n    {\n        require(makers.length == takers.length, \"TDR: Lengths differ\");\n        uint256 n = makers.length;\n\n        require(n > 0, \"TDR: Received empty arrays\");\n\n        for (uint256 i = 0; i < n; i++) {\n            if (\n                !isValidSignature(makers[i].order.maker, makers[i]) ||\n                !isValidSignature(takers[i].order.maker, takers[i]) ||\n                !isValidPair(takers[i], makers[i])\n            ) {\n                continue;\n            }\n\n \n            Perpetuals.Order memory makeOrder = grabOrder(makers, i);\n            Perpetuals.Order memory takeOrder = grabOrder(takers, i);\n\n            bytes32 makerOrderId = Perpetuals.orderId(makeOrder);\n            bytes32 takerOrderId = Perpetuals.orderId(takeOrder);\n\n            uint256 makeOrderFilled = filled[makerOrderId];\n            uint256 takeOrderFilled = filled[takerOrderId];\n\n            uint256 fillAmount = Balances.fillAmount(makeOrder, makeOrderFilled, takeOrder, takeOrderFilled);\n\n            uint256 executionPrice = Perpetuals.getExecutionPrice(makeOrder, takeOrder);\n            uint256 newMakeAverage = Perpetuals.calculateAverageExecutionPrice(\n                makeOrderFilled,\n                averageExecutionPrice[makerOrderId],\n                fillAmount,\n                executionPrice\n            );\n            uint256 newTakeAverage = Perpetuals.calculateAverageExecutionPrice(\n                takeOrderFilled,\n                averageExecutionPrice[takerOrderId],\n                fillAmount,\n                executionPrice\n            );\n            (bool success, ) = makeOrder.market.call(\n                abi.encodePacked(\n                    ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,\n                    abi.encode(makeOrder, takeOrder, fillAmount)\n                )\n            );\n\n            if (!success) continue;\n\n\n            filled[makerOrderId] = makeOrderFilled + fillAmount;\n            filled[takerOrderId] = takeOrderFilled + fillAmount;\n            averageExecutionPrice[makerOrderId] = newMakeAverage;\n            averageExecutionPrice[takerOrderId] = newTakeAverage;\n        }\n    }\n    function getOrder(Perpetuals.Order calldata order) external view override returns (Perpetuals.Order memory) {\n        bytes32 orderId = Perpetuals.orderId(order);\n        return orders[orderId];\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-06-tracer-findings.json",
                "Location": "executeTrade function in Trader contract",
                "Type": "Reentrancy",
                "Description": "Reentrancy could happen in the executeTrade function of Trader since the makeOrder.market can be a user-controlled external contract.",
                "Repair": "Add a reentrancy guard to prevent users from reentering critical functions"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\ncontract Basket is IBasket, ERC20Upgradeable {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant TIMELOCK_DURATION = 4 * 60 * 24;\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory) {\n        return (pendingWeights.tokens, pendingWeights.weights);\n    }\n\n\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        handleFees();\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        require(balanceOf(msg.sender) >= amount);\n\n        handleFees();\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction external override {\n        handleFees();\n\n        _burn(msg.sender, amount);\n\n        emit Burned(msg.sender, amount);\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-09-defiProtocol-findings.json",
                "Location": "mintTo() and burn() functions in Basket.sol",
                "Type": "Reentrancy",
                "Description": "The functions make external calls prior to updating the state, allowing attackers to mint free basket tokens and reenter the function to mint more tokens than deposited.",
                "Repair": "Move external calls after state updates in accordance with the check-effect-interact pattern"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\nstruct UserState {\n  uint256 bonded;\n  uint256 bondedEpoch;\n}\nstruct EpochState {\n  uint256 lastTotalBonded;\n  uint256 lastUpdateTime;\n  uint256 cumulativeTotalBonded;\n}\ncontract Bonding is Initializable, Permissions {\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public stakeToken;\n  IDAO public dao;\n  IMiningService public miningService;\n  IDexHandler public dexHandler;\n  IMaltDataLab public maltDataLab;\n\n  uint256 internal _globalBonded;\n  uint256 internal _currentEpoch;\n  address internal offering;\n  mapping(address => UserState) internal userState;\n  mapping(uint256 => EpochState) internal epochState;\n\n  event Bond(address indexed account, uint256 value);\n  event Unbond(address indexed account, uint256 value);\n  event UnbondAndBreak(address indexed account, uint256 amountLPToken, uint256 amountMalt, uint256 amountReward);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _malt,\n    address _rewardToken,\n    address _stakeToken,\n    address _dao,\n    address _miningService,\n    address _offering,\n    address _dexHandler,\n    address _maltDataLab\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    dao = IDAO(_dao);\n    offering = _offering;\n    stakeToken = ERC20(_stakeToken);\n    miningService = IMiningService(_miningService);\n    dexHandler = IDexHandler(_dexHandler);\n    malt = ERC20(_malt);\n    rewardToken = ERC20(_rewardToken);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n  }\n\n  function bond(uint256 amount) external {\n    bondToAccount(msg.sender, amount);\n  }\n\n  function bondToAccount(address account, uint256 amount)\n    public\n  {\n    if (msg.sender != offering) {\n      _notSameBlock();\n    }\n    require(amount > 0, \"Cannot bond 0\");\n\n    miningService.onBond(account, amount);\n\n    _bond(account, amount);\n  }\n\n \n  function _removeFromBonded(address account, uint256 amount, string memory reason) internal {\n    userState[account].bonded = userState[account].bonded.sub(amount, reason);\n\n    _updateEpochState(_globalBonded.sub(amount, reason));\n  }\n\n  function _updateEpochState(uint256 newTotalBonded) internal {\n    EpochState storage state = epochState[_currentEpoch];\n    uint256 epoch = dao.epoch();\n    uint256 epochStartTime = dao.getEpochStartTime(_currentEpoch);\n    uint256 lastUpdateTime = state.lastUpdateTime;\n    uint256 lengthOfEpoch = dao.epochLength();\n    uint256 epochEndTime = epochStartTime + lengthOfEpoch;\n\n    if (lastUpdateTime == 0) {\n      lastUpdateTime = epochStartTime;\n    }\n\n    if (lastUpdateTime > epochEndTime) {\n      lastUpdateTime = epochEndTime;\n    }\n\n    if (epoch == _currentEpoch) {\n      uint256 finalTime = block.timestamp;\n      if (block.timestamp > epochEndTime) {\n        finalTime = epochEndTime;\n      } \n\n      uint256 diff = finalTime - lastUpdateTime;\n\n      if (diff > 0) {\n        state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));\n\n        state.lastUpdateTime = finalTime;\n        state.lastTotalBonded = newTotalBonded;\n      }\n    } else {\n      // We have crossed at least 1 epoch boundary\n\n      // Won't underflow due to check on lastUpdateTime above\n      uint256 diff = epochEndTime - lastUpdateTime;\n\n      state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));\n      state.lastUpdateTime = epochEndTime;\n      state.lastTotalBonded = _globalBonded;\n\n      for (uint256 i = _currentEpoch + 1; i <= epoch; i += 1) {\n        state = epochState[i];\n        epochStartTime = dao.getEpochStartTime(i);\n        epochEndTime = epochStartTime + lengthOfEpoch;\n        state.lastTotalBonded = _globalBonded;\n\n        if (epochEndTime < block.timestamp) {\n          // The desired epoch is in the past\n          diff = lengthOfEpoch;\n          state.lastUpdateTime = epochEndTime;\n        } else {\n          diff = block.timestamp - epochStartTime;\n          state.lastUpdateTime = block.timestamp;\n        }\n\n        state.cumulativeTotalBonded = state.lastTotalBonded.mul(diff);\n      }\n\n      state.lastTotalBonded = newTotalBonded;\n      _currentEpoch = epoch;\n    } \n\n    _globalBonded = newTotalBonded;\n  }\n\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-11-malt-findings.json",
                "Location": "bondToAccount functione",
                "Type": "Reentrancy",
                "Description": "The _notSameBlock() function in Bonding.sol can be circumvented in bondToAccount() by calling it via a smart contract, leading to potential risks from reentrancy attacks.",
                "Repair": "Add access controls to the function bondToAccount() to prevent reentrancy attacks"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\ncontract Basket is IBasket, ERC20Upgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n   \n    uint256 public constant TIMELOCK_DURATION = 1 days; // 1 day\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    uint256 public maxSupply;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n    PendingMaxSupply public pendingMaxSupply;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    bool public override initialized;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) external override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        maxSupply = proposal.maxSupply;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n\n        initialized = true;\n    }\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length > 0);\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n    function mintTo(uint256 amount, address to) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        uint256 startSupply = totalSupply();\n        require(startSupply + amount <= maxSupply);\n\n        handleFees(startSupply);\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        require(totalSupply() <= maxSupply);\n\n        emit Minted(to, amount);\n    }\n    function burn(uint256 amount) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            require(tokenAmount > 0);\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-12-defiprotocol-findings.json",
                "Location": "Basket contract's initialize() method",
                "Type": "Reentrancy",
                "Description": "A malicious publisher can create a basket proposal that mixes real ERC20 tokens with a malicious ERC20 token containing a reentrancy callback in its approve() method.",
                "Repair": "Use the initializer modifier available in ERC20Upgradeable to prevent reentrancy attacks"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.4;\nimport \"./Governable.sol\";\nimport \"hardhat/console.sol\";\nimport \"../facades/Burnable.sol\";\n\ncontract FlashGovernanceArbiter is Governable {\n\n  event flashDecision(address actor, address deposit_asset, uint256 amount, address target);\n\n  mapping(address => bool) enforceLimitsActive;\n\n  constructor(address dao) Governable(dao) {}\n\n  struct FlashGovernanceConfig {\n    address asset;\n    uint256 amount;\n    uint256 unlockTime;\n    bool assetBurnable;\n  }\n\n\n  struct SecurityParameters {\n    uint8 maxGovernanceChangePerEpoch; \n    uint256 epochSize;\n    uint256 lastFlashGovernanceAct;\n    uint8 changeTolerance; \n  }\n\n\n  FlashGovernanceConfig public flashGovernanceConfig;\n  SecurityParameters public security;\n\n  mapping(address => mapping(address => FlashGovernanceConfig)) public pendingFlashDecision; //contract->user->config\n\n\n  function assertGovernanceApproved(\n    address sender,\n    address target,\n    bool emergency\n  ) public {\n    if (\n      IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&\n      pendingFlashDecision[target][sender].unlockTime < block.timestamp\n    ) {\n      require(\n        emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),\n        \"Limbo: flash governance disabled for rest of epoch\"\n      );\n      pendingFlashDecision[target][sender] = flashGovernanceConfig;\n      pendingFlashDecision[target][sender].unlockTime += block.timestamp;\n\n      security.lastFlashGovernanceAct = block.timestamp;\n      emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);\n    } else {\n      revert(\"LIMBO: governance decision rejected.\");\n    }\n  }\n\n\n  function configureFlashGovernance(\n    address asset,\n    uint256 amount,\n    uint256 unlockTime,\n    bool assetBurnable\n  ) public virtual onlySuccessfulProposal {\n    flashGovernanceConfig.asset = asset;\n    flashGovernanceConfig.amount = amount;\n    flashGovernanceConfig.unlockTime = unlockTime;\n    flashGovernanceConfig.assetBurnable = assetBurnable;\n  }\n\n  function configureSecurityParameters(\n    uint8 maxGovernanceChangePerEpoch,\n    uint256 epochSize,\n    uint8 changeTolerance\n  ) public virtual onlySuccessfulProposal {\n    security.maxGovernanceChangePerEpoch = maxGovernanceChangePerEpoch;\n    security.epochSize = epochSize;\n    require(security.changeTolerance < 100, \"Limbo: % between 0 and 100\");\n    security.changeTolerance = changeTolerance;\n  }\n  function withdrawGovernanceAsset(address targetContract, address asset) public virtual {\n    require(\n      pendingFlashDecision[targetContract][msg.sender].asset == asset &&\n        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&\n        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,\n      \"Limbo: Flashgovernance decision pending.\"\n    );\n    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(\n      msg.sender,\n      pendingFlashDecision[targetContract][msg.sender].amount\n    );\n    delete pendingFlashDecision[targetContract][msg.sender];\n  }\n\n  function enforceToleranceInt(int256 v1, int256 v2) public view {\n    if (!configured) return;\n    uint256 uv1 = uint256(v1 > 0 ? v1 : -1 * v1);\n    uint256 uv2 = uint256(v2 > 0 ? v2 : -1 * v2);\n    enforceTolerance(uv1, uv2);\n  }\n\n  function enforceTolerance(uint256 v1, uint256 v2) public view {\n    if (!configured || !enforceLimitsActive[msg.sender]) return;\n    //bonus points for readability\n    if (v1 > v2) {\n      if (v2 == 0) require(v1 <= 1, \"FE1\");\n      else require(((v1 - v2) * 100) < security.changeTolerance * v1, \"FE1\");\n    } else {\n      if (v1 == 0) require(v2 <= 1, \"FE1\");\n      else require(((v2 - v1) * 100) < security.changeTolerance * v1, \"FE1\");\n    }\n  }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-behodler-findings.json",
                "Location": "withdrawGovernanceAsset function of FlashGovernanceArbiter.sol",
                "Type": "Reentrancy",
                "Description": "The function withdrawGovernanceAsset is vulnerable to reentrancy.",
                "Repair": "Implement the check-effects-interactions pattern or delete the pendingFlashDecision before making the external call"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.10;\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n    using Counters for Counters.Counter;\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n    using Address for address;\n    using ERC165Query for address;\n    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n    uint256 public constant SHARES_MULTIPLIER = 10**18;\n    IERC20 public override(IVault) underlying;\n    IStrategy public strategy;\n    uint256 public investPerc;\n    uint256 public immutable override(IVault) minLockPeriod;\n    uint256 public override(IVaultSponsoring) totalSponsored;\n    Depositors public depositors;\n    Claimers public claimers;\n    Counters.Counter private _depositGroupIds;\n    constructor(\n        IERC20 _underlying,\n        uint256 _minLockPeriod,\n        uint256 _investPerc,\n        address _owner\n    ) Trust(_owner) {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n        require(\n            address(_underlying) != address(0x0),\n            \"VaultContext: underlying cannot be 0x0\"\n        );\n        investPerc = _investPerc;\n        underlying = _underlying;\n        minLockPeriod = _minLockPeriod;\n\n        depositors = new Depositors(address(this), \"depositors\", \"p\");\n        claimers = new Claimers(address(this));\n    }\n    function deposit(DepositParams calldata _params) external {\n        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);\n        _transferAndCheckUnderlying(_msgSender(), _params.amount);\n    }\n\n    \n    \n    function _withdrawDeposit(\n        uint256 _tokenId,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored,\n        address _to,\n        bool _force\n    ) internal returns (uint256) {\n        require(\n            depositors.ownerOf(_tokenId) == _msgSender(),\n            \"Vault: you are not the owner of a deposit\"\n        );\n\n        (\n            uint256 depositAmount,\n            uint256 claimerId,\n            uint256 lockedUntil\n        ) = depositors.deposits(_tokenId);\n        require(lockedUntil <= block.timestamp, \"Vault: deposit is locked\");\n\n        require(claimerId != 0, \"Vault: token id is not a withdraw\");\n\n        uint256 claimerShares = claimers.sharesOf(claimerId);\n\n        uint256 depositShares = _computeShares(\n            depositAmount,\n            _totalShares,\n            _totalUnderlyingMinusSponsored\n        );\n\n        if (_force && depositShares > claimerShares) {\n            depositShares = claimerShares;\n        } else if (!_force) {\n            require(\n                claimerShares >= depositShares,\n                \"Vault: cannot withdraw more than the available amount\"\n            );\n        }\n\n        claimers.onWithdraw(claimerId, depositAmount, depositShares);\n        depositors.burn(_tokenId);\n\n        address claimer = claimers.ownerOf(claimerId);\n\n        if (_isIntegration(claimer)) {\n            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);\n\n            require(ret == IIntegration(claimer).onDepositBurned.selector);\n        }\n\n        emit DepositBurned(_tokenId, depositShares, _to);\n\n        return\n            _computeAmount(\n                depositShares,\n                _totalShares,\n                _totalUnderlyingMinusSponsored\n            );\n    }\n    function _computeShares(\n        uint256 _amount,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_amount == 0) return 0;\n        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;\n\n        require(\n            _totalUnderlyingMinusSponsored > 0,\n            \"Vault: cannot compute shares when there's no principal\"\n        );\n\n        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;\n    }\n\n    \n    function _isIntegration(address addr) internal view returns (bool) {\n        return\n            addr.doesContractImplementInterface(type(IIntegration).interfaceId);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-sandclock-findings.json",
                "Location": "deposit() function in Vault.sol",
                "Type": "Reentrancy",
                "Description": "The deposit() function in Vault.sol is vulnerable to reentrancy attacks due to the lack of reentrancy guard modifiers.",
                "Repair": "Add reentrancy guard modifiers to deposit(), withdraw(), and other important protocol functions"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.7;\nimport { ITransactionManager } from \"../Interfaces/ITransactionManager.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\ncontract NXTPFacet is ILiFi, Swapper {\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.nxtp\");\n    struct Storage {ITransactionManager nxtpTxManager;}\n    event NXTPBridgeStarted(\n        bytes32 indexed lifiTransactionId,\n        bytes32 nxtpTransactionId,\n        ITransactionManager.TransactionData txData);\n    function initNXTP(ITransactionManager _txMgrAddr) external {Storage storage s = getStorage();LibDiamond.enforceIsContractOwner();s.nxtpTxManager = _txMgrAddr;}\n    function startBridgeTokensViaNXTP(LiFiData memory _lifiData, ITransactionManager.PrepareArgs memory _nxtpData) public payable{address sendingAssetId = _nxtpData.invariantData.sendingAssetId;\n        if (sendingAssetId == address(0)) require(msg.value == _nxtpData.amount, \"ERR_INVALID_AMOUNT\");\n        else {uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _nxtpData.amount);\n            require(LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _nxtpData.amount,\"ERR_INVALID_AMOUNT\");}\n        _startBridge(_lifiData.transactionId, _nxtpData);\n        emit LiFiTransferStarted(_lifiData.transactionId,_lifiData.integrator,_lifiData.referrer,_lifiData.sendingAssetId,_lifiData.receivingAssetId,_lifiData.receiver,_lifiData.amount,_lifiData.destinationChainId,block.timestamp);}\n    function swapAndStartBridgeTokensViaNXTP(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        ITransactionManager.PrepareArgs memory _nxtpData) public payable {\n        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;\n        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n        _executeSwaps(_lifiData, _swapData);\n        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;\n        require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n        _nxtpData.amount = _postSwapBalance;\n        _startBridge(_lifiData.transactionId, _nxtpData);emit LiFiTransferStarted(_lifiData.transactionId,_lifiData.integrator,_lifiData.referrer,_lifiData.sendingAssetId,_lifiData.receivingAssetId,_lifiData.receiver,_lifiData.amount,_lifiData.destinationChainId,block.timestamp);}\n    function swapAndCompleteBridgeTokensViaNXTP(LiFiData memory _lifiData,LibSwap.SwapData[] calldata _swapData,address finalAssetId,address receiver\n    ) public payable {\n        uint256 startingBalance = LibAsset.getOwnBalance(finalAssetId);_executeSwaps(_lifiData, _swapData);uint256 postSwapBalance = LibAsset.getOwnBalance(finalAssetId);uint256 finalBalance;\n        if (postSwapBalance > startingBalance) {finalBalance = postSwapBalance - startingBalance;LibAsset.transferAsset(finalAssetId, payable(receiver), finalBalance);\n        }emit LiFiTransferCompleted(_lifiData.transactionId, finalAssetId, receiver, finalBalance, block.timestamp);}}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-03-lifinance-findings.json",
                "Location": "Functions which call Swapper._executeSwap() such as NXTPFacet.swapAndStartBridgeTokensViaNXTP(), and NXTPFacet.swapAndCompleteBridgeTokensViaNXTP()",
                "Type": "Reentrancy",
                "Description": "There is a reentrancy vulnerability in functions which call Swapper._executeSwap() which would allow the attacker to change their postSwapBalance. The issue occurs since it is possible for an attacker to reenter this function during _executeSwaps(), that is because execute swap makes numerous external calls, such as to the AMM, or to untrusted ERC20 token addresses.",
                "Repair": "Add a reentrancy guard over every function which may send or receive tokens. Ensure the same slot is used to store the reentrancy guard so all required functions are covered by a single guard."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\ncontract YVault is ERC20, Ownable {\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n    event Deposit(address indexed depositor, uint256 wantAmount);\n    event Withdrawal(address indexed withdrawer, uint256 wantAmount);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n    ERC20 public immutable token;\n    IController public controller;\n    address public farm;\n    Rate internal availableTokensRate;\n    mapping(address => bool) public whitelistedContracts;\n    constructor(\n        address _token,\n        address _controller,\n        Rate memory _availableTokensRate\n    )\n        ERC20(\n            string(\n                abi.encodePacked(\"JPEG\\xE2\\x80\\x99d \", ERC20(_token).name())\n            ),\n            string(abi.encodePacked(\"JPEGD\", ERC20(_token).symbol()))\n        )\n    {\n        setController(_controller);\n        setAvailableTokensRate(_availableTokensRate);\n        token = ERC20(_token);\n    }\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts not allowed\"\n        );\n        _;\n    }\n    function earn() external {\n        uint256 _bal = available();\n        token.safeTransfer(address(controller), _bal);\n        controller.earn(address(token), _bal);\n    }\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n    function deposit(uint256 _amount) public noContract(msg.sender) {\n        require(_amount > 0, \"INVALID_AMOUNT\");\n        uint256 balanceBefore = balance();\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 supply = totalSupply();\n        uint256 shares;\n        if (supply == 0) {\n            shares = _amount;\n        } else {\n            //balanceBefore can't be 0 if totalSupply is > 0\n            shares = (_amount * supply) / balanceBefore;\n        }\n        _mint(msg.sender, shares);\n\n        emit Deposit(msg.sender, _amount);\n    }\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n    function withdraw(uint256 _shares) public noContract(msg.sender) {\n        require(_shares > 0, \"INVALID_AMOUNT\");\n\n        uint256 supply = totalSupply();\n        require(supply > 0, \"NO_TOKENS_DEPOSITED\");\n\n        uint256 backingTokens = (balance() * _shares) / supply;\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 vaultBalance = token.balanceOf(address(this));\n        if (vaultBalance < backingTokens) {\n            uint256 toWithdraw = backingTokens - vaultBalance;\n            controller.withdraw(address(token), toWithdraw);\n        }\n\n        token.safeTransfer(msg.sender, backingTokens);\n        emit Withdrawal(msg.sender, backingTokens);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-jpegd-findings.json",
                "Location": "yVault.sol#deposit()",
                "Type": "Reentrancy",
                "Description": "In deposit, the balance is cached and then a token.transferFrom is triggered which can lead to exploits if the token is a token that gives control to the sender, like ERC777 tokens.",
                "Repair": "Make safeTransferFrom the last call in deposit"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.6.12;\ncontract ConvexMasterChef is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt; \n\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; \n        uint256 allocPoint;\n        uint256 lastRewardBlock; \n        uint256 accCvxPerShare; \n        IRewarder rewarder;\n    }\n\n    IERC20 public immutable cvx;\n    uint256 public immutable rewardPerBlock;\n    uint256 public constant BONUS_MULTIPLIER = 2;\n    PoolInfo[] public poolInfo;\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    uint256 public totalAllocPoint = 0;\n    uint256 public immutable startBlock;\n    uint256 public immutable endBlock;\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount\n    );\n\n    constructor(\n        IERC20 _cvx,\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _endBlock\n    ) public {\n        cvx = _cvx;\n        rewardPerBlock = _rewardPerBlock;\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n    }\n    function deposit(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) {\n            uint256 pending = user\n                .amount\n                .mul(pool.accCvxPerShare)\n                .div(1e12)\n                .sub(user.rewardDebt);\n            safeRewardTransfer(msg.sender, pending);\n        }\n        pool.lpToken.safeTransferFrom(\n            address(msg.sender),\n            address(this),\n            _amount\n        );\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);\n        }\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n    function withdraw(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw: not good\");\n        updatePool(_pid);\n        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(\n            user.rewardDebt\n        );\n        safeRewardTransfer(msg.sender, pending);\n        user.amount = user.amount.sub(_amount);\n        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);\n        emit RewardPaid(msg.sender, _pid, pending);\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n    function emergencyWithdraw(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-aura-findings.json",
                "Location": "ConvexMasterChef.sol#deposit",
                "Type": "Reentrancy",
                "Description": "Reward token accounting update in deposit() and withdraw() happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future, the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.",
                "Repair": "Consider adding a direct reentrancy control, e.g. nonReentrant modifier. Also, consider finishing all internal state updates prior to external calls."
            }
        ]
    },
    {
        "Code": "pragma solidity 0.6.12;\ncontract ConvexMasterChef is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt; \n\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; \n        uint256 allocPoint;\n        uint256 lastRewardBlock; \n        uint256 accCvxPerShare; \n        IRewarder rewarder;\n    }\n\n    IERC20 public immutable cvx;\n    uint256 public immutable rewardPerBlock;\n    uint256 public constant BONUS_MULTIPLIER = 2;\n    PoolInfo[] public poolInfo;\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    uint256 public totalAllocPoint = 0;\n    uint256 public immutable startBlock;\n    uint256 public immutable endBlock;\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount\n    );\n\n    constructor(\n        IERC20 _cvx,\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _endBlock\n    ) public {\n        cvx = _cvx;\n        rewardPerBlock = _rewardPerBlock;\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n    }\n    function deposit(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) {\n            uint256 pending = user\n                .amount\n                .mul(pool.accCvxPerShare)\n                .div(1e12)\n                .sub(user.rewardDebt);\n            safeRewardTransfer(msg.sender, pending);\n        }\n        pool.lpToken.safeTransferFrom(\n            address(msg.sender),\n            address(this),\n            _amount\n        );\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);\n        }\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n    function withdraw(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw: not good\");\n        updatePool(_pid);\n        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(\n            user.rewardDebt\n        );\n        safeRewardTransfer(msg.sender, pending);\n        user.amount = user.amount.sub(_amount);\n        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);\n        emit RewardPaid(msg.sender, _pid, pending);\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n    function emergencyWithdraw(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-aura-findings.json",
                "Location": "ConvexMasterChef.sol#withdraw",
                "Type": "Reentrancy",
                "Description": "Reward token accounting update in deposit() and withdraw() happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future, the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.",
                "Repair": "Consider adding a direct reentrancy control, e.g. nonReentrant modifier. Also, consider finishing all internal state updates prior to external calls."
            }
        ]
    },
    {
        "Code": "pragma solidity =0.7.6;\ncontract BathToken {\n    using SafeMath for uint256;\n    bool public initialized;\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n    address public RubiconMarketAddress;\n    address public bathHouse;\n    address public feeTo;\n    IERC20 public underlyingToken;\n    uint256 public feeBPS;\n    uint256 public totalSupply;\n    uint256 public outstandingAmount;\n    uint256[] deprecatedStorageArray; \n    mapping(uint256 => uint256) deprecatedMapping;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    bytes32 public DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n    address[] public bonusTokens;\n    IBathBuddy public rewardsVestingWallet;\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n        initialized = true;\n    }\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n    function deposit(uint256 assets) public returns (uint256 shares) {\n\n        return _deposit(assets, msg.sender);\n    }\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        underlyingToken.transferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); \n\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(_pool);\n        _mint(receiver, shares);\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n   \n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-rubicon-findings.json",
                "Location": "BathToken.sol#_deposit()",
                "Type": "Reentrancy",
                "Description": "There is a risk of re-entrancy attack to mint more shares due to the lack of reentrancy guard on the _deposit() function.",
                "Repair": "Add reentrancy guards or break the CEI pattern for deposits and perform the interaction first"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.6;\ncontract Community is\n    ICommunity,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n\n    using SafeERC20Upgradeable for IDebtToken;\n\n    address internal tokenCurrency1;\n    address internal tokenCurrency2;\n    address internal tokenCurrency3;\n\n    mapping(uint256 => CommunityStruct) internal _communities;\n\n    IHomeFi public override homeFi;\n    bool public override restrictedToAdmin;\n\n    uint256 public override communityCount;\n\n    mapping(address => uint256) public override projectPublished;\n\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n    modifier nonZero(address _address) {\n        require(_address != address(0), \"Community::0 address\");\n        _;\n    }\n\n    modifier onlyHomeFiAdmin() {\n        require(_msgSender() == homeFi.admin(), \"Community::!admin\");\n        _;\n    }\n\n    modifier isPublishedToCommunity(uint256 _communityID, address _project) {\n        // Revert if _project is not published to _communityID\n        require(\n            projectPublished[_project] == _communityID,\n            \"Community::!published\"\n        );\n        _;\n    }\n\n    modifier onlyProjectBuilder(address _project) {\n  \n        require(\n            _msgSender() == IProject(_project).builder(),\n            \"Community::!Builder\"\n        );\n        _;\n    }\n\n\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n\n        __Pausable_init();\n\n  \n        homeFi = IHomeFi(_homeFi);\n        tokenCurrency1 = homeFi.tokenCurrency1();\n        tokenCurrency2 = homeFi.tokenCurrency2();\n        tokenCurrency3 = homeFi.tokenCurrency3();\n\n        restrictedToAdmin = true;\n    }\n\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        override\n        whenNotPaused\n    {\n        address _sender = _msgSender();\n        require(\n            !restrictedToAdmin || _sender == homeFi.admin(),\n            \"Community::!admin\"\n        );\n\n        homeFi.validCurrency(_currency);\n\n        communityCount++;\n\n        CommunityStruct storage _community = _communities[communityCount];\n        _community.owner = _sender;\n        _community.currency = IDebtToken(_currency);\n        _community.memberCount = 1;\n        _community.members[0] = _sender;\n        _community.isMember[_sender] = true;\n\n        emit CommunityAdded(communityCount, _sender, _currency, _hash);\n    }\n\n \n    function escrow(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        (\n            uint256 _communityID,\n            address _builder,\n            address _lender,\n            address _agent,\n            address _project,\n            uint256 _repayAmount,\n            bytes memory _details\n        ) = abi.decode(\n                _data,\n                (uint256, address, address, address, address, uint256, bytes)\n            );\n        bytes32 _hash = keccak256(_data);\n        IProject _projectInstance = IProject(_project);\n        require(_builder == _projectInstance.builder(), \"Community::!Builder\");\n        require(\n            _lender == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n        checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be builder\n        checkSignatureValidity(_agent, _hash, _signature, 2); \n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n        emit DebtReducedByEscrow(_agent);\n    }\n\n  \n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-08-rigor-findings.json",
                "Location": "Community.sol#L509",
                "Type": "Reentrancy",
                "Description": "Builder can call Community.escrow again to reduce debt further using same signatures.",
                "Repair": "Add a new field into the ProjectDetails struct called escrowNonce and modify function escrow to check this nonce and update it after the debt has been reduced."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-11-stakehouse-findings.json",
                "Location": "GiantMevAndFeesPool.claimRewards()",
                "Type": "Reentrancy",
                "Description": "GiantMevAndFeesPool.claimRewards() is vulnerable to reentrancy attack as GiantMevAndFeesPool.claimRewards() does not have the nonReentrant modifier. This allows the user to call any function in the fallback.",
                "Repair": "Add 'idleETH -= _amount' before sending ETH to the user"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\ncontract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n    event LPBurnedForDETH(address indexed savETHVaultLPToken, address indexed sender, uint256 amount);\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(0), \"GiantETHLP\", \"gETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n    function withdrawDETH(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                LPToken token = _lpTokens[i][j];\n                uint256 amount = _amounts[i][j];\n\n                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");\n\n               \n                lpTokenETH.burn(msg.sender, amount);\n\n                emit LPBurnedForDETH(address(token), msg.sender, amount);\n            }\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;\n        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n    }\n    function batchRotateLPTokens(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _savETHVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            SavETHVault(_savETHVaults[i]).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n  \n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-11-stakehouse-findings.json",
                "Location": "function withdrawDETH in GiantSavETHVaultPool",
                "Type": "Reentrancy",
                "Description": "Possible reentrancy and fund theft in withdrawDETH() of GiantSavETHVaultPool because there is no whitelist check for user provided Vaults and there is no reentrancy defense.",
                "Repair": "Check the provided addresses and have some reentrancy defense mechanism"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n    event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n    event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n    event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n    event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n    event WalletCredited(address indexed smartWallet, uint256 amount);\n    event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n    event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n    event StakehouseJoined(bytes blsPubKey);\n    event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n    event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n    event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n    event NetworkTickerUpdated(string newTicker);\n    event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n    event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n    event NodeRunnerBanned(address indexed nodeRunner);\n    event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n    event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n    event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n    address public brand;\n    address public override stakehouse;\n    address public syndicate;\n    address public dao;\n    OptionalHouseGatekeeper public gatekeeper;\n    ISyndicateFactory public syndicateFactory;\n    IOwnableSmartWalletFactory public smartWalletFactory;\n    string public stakehouseTicker;\n    StakingFundsVault public stakingFundsVault;\n    SavETHVault public savETHVault;\n    bool public enableWhitelisting;\n    mapping(address => bool) public isNodeRunnerWhitelisted;\n    mapping(address => address) public smartWalletRepresentative;\n    mapping(bytes => address) public smartWalletOfKnot;\n    mapping(address => address) public smartWalletOfNodeRunner;\n    mapping(address => address) public nodeRunnerOfSmartWallet;\n    mapping(address => uint256) public stakedKnotsOfSmartWallet;\n    mapping(address => address) public smartWalletDormantRepresentative;\n    mapping(bytes => address) public bannedBLSPublicKeys;\n    mapping(address => bool) public bannedNodeRunners;\n    uint256 public numberOfKnots;\n    uint256 public daoCommissionPercentage;\n    uint256 public MODULO = 100_00000;\n\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Must be DAO\");\n        _;\n    }\n    constructor() initializer {}\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external virtual override initializer {\n        _init(\n            _dao,\n            _syndicateFactory,\n            _smartWalletFactory,\n            _lpTokenFactory,\n            _brand,\n            _savETHVaultDeployer,\n            _stakingFundsVaultDeployer,\n            _optionalGatekeeperDeployer,\n            _optionalCommission,\n            _deployOptionalGatekeeper,\n            _stakehouseTicker\n        );\n    }\n\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-11-stakehouse-findings.json",
                "Location": "withdrawETHForKnot function in LiquidStakingManager.sol",
                "Type": "Reentrancy",
                "Description": "The reentrancy bug in the withdrawETHForKnot function allows a node runner to reenter the LiquidStakingManager and stake deposited funds from the vaults before the BLS key is banned, causing a permanent freeze of user funds and making the protocol insolvent.",
                "Repair": "Use mutex locks to prevent reentrancy or use the Checks-Effects-Interactions pattern to ensure that all state changes are made before any external calls are made"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.17;\ncontract Pair is ERC20, ERC721TokenReceiver {\n    using SafeTransferLib for address;\n    using SafeTransferLib for ERC20;\n\n    uint256 public constant ONE = 1e18;\n    uint256 public constant CLOSE_GRACE_PERIOD = 7 days;\n\n    address public immutable nft;\n    address public immutable baseToken; // address(0) for ETH\n    bytes32 public immutable merkleRoot;\n    LpToken public immutable lpToken;\n    Caviar public immutable caviar;\n    uint256 public closeTimestamp;\n\n    event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Buy(uint256 inputAmount, uint256 outputAmount);\n    event Sell(uint256 inputAmount, uint256 outputAmount);\n    event Wrap(uint256[] tokenIds);\n    event Unwrap(uint256[] tokenIds);\n    event Close(uint256 closeTimestamp);\n    event Withdraw(uint256 tokenId);\n\n    constructor(\n        address _nft,\n        address _baseToken,\n        bytes32 _merkleRoot,\n        string memory pairSymbol,\n        string memory nftName,\n        string memory nftSymbol\n    ) ERC20(string.concat(nftName, \" fractional token\"), string.concat(\"f\", nftSymbol), 18) {\n        nft = _nft;\n        baseToken = _baseToken; \n        merkleRoot = _merkleRoot;\n        lpToken = new LpToken(pairSymbol);\n        caviar = Caviar(msg.sender);\n    }\n    function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)\n        public\n        payable\n        returns (uint256 lpTokenAmount)\n    {\n        require(baseTokenAmount > 0 && fractionalTokenAmount > 0, \"Input token amount is zero\");\n        require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, \"Invalid ether input\");\n        lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);\n        require(lpTokenAmount >= minLpTokenAmount, \"Slippage: lp token amount out\");\n        _transferFrom(msg.sender, address(this), fractionalTokenAmount);\n        lpToken.mint(msg.sender, lpTokenAmount);\n        if (baseToken != address(0)) {\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n        }\n\n        emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);\n    }\n\n    function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n        require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\n        inputAmount = buyQuote(outputAmount);\n        require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\n        _transferFrom(address(this), msg.sender, outputAmount);\n        if (baseToken == address(0)) {\n            uint256 refundAmount = maxInputAmount - inputAmount;\n            if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);\n        } else {\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n        }\n        emit Buy(inputAmount, outputAmount);\n    }\n\n    function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {\n        outputAmount = sellQuote(inputAmount);\n        require(outputAmount >= minOutputAmount, \"Slippage: amount out\");\n        _transferFrom(msg.sender, address(this), inputAmount);\n\n        if (baseToken == address(0)) {\n            msg.sender.safeTransferETH(outputAmount);\n        } else {\n\n            ERC20(baseToken).safeTransfer(msg.sender, outputAmount);\n        }\n        emit Sell(inputAmount, outputAmount);\n    }\n    function _transferFrom(address from, address to, uint256 amount) internal returns (bool) {\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n    function _baseTokenReserves() internal view returns (uint256) {\n        return baseToken == address(0)\n            ? address(this).balance - msg.value \n            : ERC20(baseToken).balanceOf(address(this));\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-12-caviar-findings.json",
                "Location": "buy and sell functions in Pair.sol",
                "Type": "Reentrancy",
                "Description": "Current implementation of functions add, remove, buy and sell first transfer fractional tokens, and then base tokens. Allows to drain funds of a pairs which implements an ERC-777 token.",
                "Repair": "Add OpenZeppelin nonReentrant modifier to mentioned functions, or state clear in the documentation that this protocol should not be used with ERC777 tokens."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; \ncontract Position is ERC721Enumerable, MetaContext, IPosition { \n \n    function ownerOf(uint _id) public view override(ERC721, IERC721, IPosition) returns (address) { \n        return ERC721.ownerOf(_id); \n    } \n    using Counters for Counters.Counter; \n    uint constant public DIVISION_CONSTANT = 1e10; \n    mapping(uint => mapping(address => uint)) public vaultFundingPercent; \n    mapping(address => bool) private _isMinter; \n    mapping(uint256 => Trade) private _trades; \n    uint256[] private _openPositions; \n    mapping(uint256 => uint256) private _openPositionsIndexes; \n    mapping(uint256 => uint256[]) private _assetOpenPositions; \n    mapping(uint256 => mapping(uint256 => uint256)) private _assetOpenPositionsIndexes; \n    mapping(uint256 => uint256[]) private _limitOrders; \n    mapping(uint256 => mapping(uint256 => uint256)) private _limitOrderIndexes;\n    mapping(uint256 => mapping(address => int256)) public fundingDeltaPerSec; \n    mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi; \n    mapping(uint256 => mapping(address => uint256)) private lastUpdate; \n    mapping(uint256 => int256) private initId; \n    mapping(uint256 => mapping(address => uint256)) private longOi; \n    mapping(uint256 => mapping(address => uint256)) private shortOi; \n    function isMinter(address _address) public view returns (bool) { return _isMinter[_address]; } \n    function openPositions() public view returns (uint256[] memory) { return _openPositions; } \n    function openPositionsIndexes(uint _id) public view returns (uint256) { return _openPositionsIndexes[_id]; } \n    function assetOpenPositions(uint _asset) public view returns (uint256[] memory) { return _assetOpenPositions[_asset]; } \n    function assetOpenPositionsIndexes(uint _asset, uint _id) public view returns (uint256) { return _assetOpenPositionsIndexes[_asset][_id]; } \n    function limitOrders(uint _asset) public view returns (uint256[] memory) { return _limitOrders[_asset]; } \n    function limitOrderIndexes(uint _asset, uint _id) public view returns (uint256) { return _limitOrderIndexes[_asset][_id]; } \n    Counters.Counter private _tokenIds; \n    string public baseURI; \n    constructor(string memory _setBaseURI, string memory _name, string memory _symbol) ERC721(_name, _symbol) { \n        baseURI = _setBaseURI; \n        _tokenIds.increment(); \n    } \n    function mint( \n        MintTrade memory _mintTrade \n    ) external onlyMinter { \n        uint newTokenID = _tokenIds.current(); \n        Trade storage newTrade = _trades[newTokenID]; \n        newTrade.margin = _mintTrade.margin; \n        newTrade.leverage = _mintTrade.leverage; \n        newTrade.asset = _mintTrade.asset; \n        newTrade.direction = _mintTrade.direction; \n        newTrade.price = _mintTrade.price; \n        newTrade.tpPrice = _mintTrade.tp; \n        newTrade.slPrice = _mintTrade.sl; \n        newTrade.orderType = _mintTrade.orderType; \n        newTrade.id = newTokenID; \n        newTrade.tigAsset = _mintTrade.tigAsset; \n        _safeMint(_mintTrade.account, newTokenID); \n        if (_mintTrade.orderType > 0) { \n            _limitOrders[_mintTrade.asset].push(newTokenID); \n            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1; \n        } else { \n            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18; \n            _openPositions.push(newTokenID); \n            _openPositionsIndexes[newTokenID] = _openPositions.length-1; \n \n            _assetOpenPositions[_mintTrade.asset].push(newTokenID); \n            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1; \n        } \n        _tokenIds.increment(); \n    } \n    modifier onlyMinter() { \n        require(_isMinter[_msgSender()], \"!Minter\"); \n        _; \n    }  \n    function _msgSender() internal view override(Context, MetaContext) returns (address sender) { \n        return MetaContext._msgSender(); \n    } \n    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) { \n        return MetaContext._msgData(); \n    } \n} ",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-12-tigris-findings.json",
                "Location": "Position contract's mint() function",
                "Type": "Reentrancy",
                "Description": "The mint() function in the Position contract doesn't follow check-effect-interaction pattern and it's possible to perform reentrancy attack during mint() function which can lead to removing of the other user's limit orders or stealing contract funds because initId is set low value.",
                "Repair": "Follow the check-effect-interaction pattern"
            }
        ]
    }
]