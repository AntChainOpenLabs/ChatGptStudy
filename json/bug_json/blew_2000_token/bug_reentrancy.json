[
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 4 * 60 * 24;\n    uint256 private constant BLOCK_DECREMENT = 10000;\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondTimestamp;\n    bool public override initialized;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(!initialized);\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondTimestamp = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY > block.number);\n        require(msg.sender == auctionBonder);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basketAsERC20.transfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY <= block.number);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty memory bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).transfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-09-defiProtocol-findings.json",
                "Location": "settleAuction() function in Auction.sol",
                "Type": "Reentrancy",
                "Description": "The function calls withdrawBounty() before setting auctionOngoing = false, allowing reentrancy and enabling a malicious publisher to bypass the index timelock mechanism and rug the basket.",
                "Repair": "Move basketAsERC20.transfer() and withdrawBounty() to the end of the function, conforming with Checks Effects Interactions pattern"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IDue} from './interfaces/IDue.sol';\nimport {IERC721Receiver} from '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport {IConvenience} from './interfaces/IConvenience.sol';\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ERC721Permit} from './base/ERC721Permit.sol';\nimport {SafeMetadata} from './libraries/SafeMetadata.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {NFTTokenURIScaffold} from './libraries/NFTTokenURIScaffold.sol';\n\ncontract CollateralizedDebt is IDue, ERC721Permit {\n    using Strings for uint256;\n    using SafeMetadata for IERC20;\n\n    IConvenience public immutable override convenience;\n    IPair public immutable override pair;\n    uint256 public immutable override maturity;\n\n    function name() external view override returns (string memory) {\n        string memory assetName = pair.asset().safeName();\n        string memory collateralName = pair.collateral().safeName();\n        return\n            string(\n                abi.encodePacked(\n                    'Timeswap Collateralized Debt - ',\n                    assetName,\n                    ' - ',\n                    collateralName,\n                    ' - ',\n                    maturity.toString()\n                )\n            );\n    }\n\n    function symbol() external view override returns (string memory) {\n        string memory assetSymbol = pair.asset().safeSymbol();\n        string memory collateralSymbol = pair.collateral().safeSymbol();\n        return string(abi.encodePacked('TS-CDT-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));\n    }\n\n    function tokenURI(uint256 id) external view override returns (string memory) {\n        require(ownerOf[id] != address(0), 'E404');\n        return NFTTokenURIScaffold.tokenURI(id, pair, dueOf(id), maturity);\n    }\n\n    function assetDecimals() external view override returns (uint8) {\n        return pair.asset().safeDecimals();\n    }\n\n    function collateralDecimals() external view override returns (uint8) {\n        return pair.collateral().safeDecimals();\n    }\n\n    function dueOf(uint256 id) public view override returns (IPair.Due memory) {\n        return pair.dueOf(maturity, address(this), id);\n    }\n\n    constructor(\n        IConvenience _convenience,\n        IPair _pair,\n        uint256 _maturity\n    ) ERC721Permit('Timeswap Collateralized Debt') {\n        convenience = _convenience;\n        pair = _pair;\n        maturity = _maturity;\n    }\n\n    modifier onlyConvenience() {\n        require(msg.sender == address(convenience), 'E403');\n        _;\n    }\n\n    function mint(address to, uint256 id) external override onlyConvenience {\n        _safeMint(to, id);\n    }\n\n    function burn(\n        address to,\n        uint256[] memory ids,\n        uint112[] memory assetsIn,\n        uint112[] memory collateralsOut,\n        bytes calldata data\n    ) external override onlyConvenience returns (uint128 assetIn, uint128 collateralOut) {\n        (assetIn, collateralOut) = pair.pay(maturity, to, address(this), ids, assetsIn, collateralsOut, data);\n    }\n\n    function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override {\n        require(msg.sender == address(pair), 'E401');\n\n        convenience.collateralizedDebtCallback(pair, maturity, assetIn, data);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-timeswap-findings.json",
                "Location": "CollateralizedDebt.sol#mint()",
                "Type": "Reentrancy",
                "Description": "Functions with callbacks should have reentrancy guards in place for protection against possible malicious actors both from inside and outside the protocol.",
                "Repair": "Add a reentrancy guard modifier on the mint() function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IShelter } from \"./interfaces/IShelter.sol\";\nimport { IShelterClient } from \"./interfaces/IShelterClient.sol\";\n\ncontract Shelter is IShelter {\n    using SafeERC20 for IERC20;\n\n    IShelterClient public immutable client;\n\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    mapping(IERC20 => mapping(address => bool)) public override claimed;\n\n    mapping(IERC20 => uint256) public activated;\n\n    mapping(IERC20 => uint256) public savedTokens;\n\n    modifier onlyClient {\n        require(msg.sender == address(client), \"!client\");\n        _;\n    }\n\n    constructor(IShelterClient _client){\n        client = _client;\n    }\n\n    function donate(IERC20 _token, uint256 _amount) external {\n        require(activated[_token] != 0, \"!activated\");\n        savedTokens[_token] += _amount;\n        _token.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function activate(IERC20 _token) external override onlyClient {\n        activated[_token] = block.timestamp;\n        savedTokens[_token] = _token.balanceOf(address(this));\n        emit ShelterActivated(_token);\n    }\n\n    function deactivate(IERC20 _token) external override onlyClient {\n        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, \"too late\");\n        activated[_token] = 0;\n        savedTokens[_token] = 0;\n        _token.safeTransfer(msg.sender, _token.balanceOf(address(this)));\n        emit ShelterDeactivated(_token);\n    }\n\n    function withdraw(IERC20 _token, address _to) external override {\n        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, \"shelter not activated\");\n        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);\n        claimed[_token][_to] = true;\n        emit ExitShelter(_token, msg.sender, _to, amount);\n        _token.safeTransfer(_to, amount);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-02-concur-findings.json",
                "Location": "Shelter.sol withdraw() function",
                "Type": "Reentrancy",
                "Description": "Repeated calls to Shelter.withdraw can drain all funds in Shelter, allowing an attacker that can successfully call withdraw() once on a shelter, to call it repeatedly to steal the funds of others.",
                "Repair": "Check claims against msg.sender and record who is withdrawing"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IConcurRewardClaim} from \"./interfaces/IConcurRewardClaim.sol\";\n\ncontract ConcurRewardPool is IConcurRewardClaim {\n    using SafeERC20 for IERC20;\n    address public immutable rewardNotifier;\n\n    mapping(address => mapping(address => uint256)) public reward;\n\n    constructor(address _notifier) {\n        rewardNotifier = _notifier;\n    }\n\n    /// @notice push reward to `_recipient`\n    /// @param _recipient reward recipient address\n    /// @param _token token to reward\n    /// @param _amount amount of tokens to allocate to `_recipient`\n    function pushReward(\n        address _recipient,\n        address _token,\n        uint256 _amount\n    ) external override {\n        require(msg.sender == rewardNotifier, \"!notifier\");\n        reward[_recipient][_token] += _amount;\n    }\n\n    /// @notice claim rewards of `msg.sender`\n    /// @param _tokens array of tokens to claim\n    function claimRewards(address[] calldata _tokens) external override {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 getting = reward[msg.sender][_tokens[i]];\n            IERC20(_tokens[i]).safeTransfer(msg.sender, getting);\n            reward[msg.sender][_tokens[i]] = 0;\n        }\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-02-concur-findings.json",
                "Location": "ConcurRewardPool.sol#L34",
                "Type": "Reentrancy",
                "Description": "The reward tokens are transferred before the balances are set to 0, making it possible to perform a reentrancy attack if the reward token has some kind of call back functionality.",
                "Repair": "Use a nonReentrant modifier, set balances to 0 first before disbursing the rewards"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./VestingWallet.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title BathBuddy\n * @dev *** This contract is a lightly modified version of Vesting Wallet by OpenZeppelin\n * @dev PLEASE FIND OZ DOCUMENTATION FOR THIS CONTRACT HERE: https://docs.openzeppelin.com/contracts/4.x/api/finance#VestingWallet\n *\n * @dev The only entrypoint used in the system is the release function called by the Bath Token. Extra care should be taken to make sure only the beneficiary can ever access the funds and send them to the withdrawer (and fee to self)\n *\n * @dev This contract handles the vesting ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract BathBuddy is IBathBuddy {\n    using SafeMath for uint256;\n\n    // Public versions of the base VestingWallet storage\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n\n    // Beneficiary must be the Bath Token vault recipient that will call release() for its withdrawer\n    address public beneficiary;\n    uint64 public start;\n    uint64 public duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(\n        address beneficiaryAddress,\n        uint64 startTimestamp,\n        uint64 durationSeconds\n    ) {\n        require(\n            beneficiaryAddress != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        beneficiary = beneficiaryAddress;\n        start = startTimestamp;\n        duration = durationSeconds;\n    }\n\n    // OZ\n    event EtherReleased(uint256 amount);\n    event ERC20Released(address indexed token, uint256 amount);\n\n    /// @notice Log bonus token reward event\n    event LogClaimBonusToken(\n        address indexed receiver,\n        address indexed callingPool,\n        uint256 amountReceived,\n        uint256 shares,\n        IERC20 bonusToken,\n        uint256 releasableAmountToWholePool\n    );\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /// @inheritdoc IBathBuddy\n    /// @dev Added and modified release function. Should be the only callable release function\n    function release(\n        IERC20 token,\n        address recipient,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply,\n        uint256 poolFee\n    ) external override {\n        require(\n            msg.sender == beneficiary,\n            \"Caller is not the Bath Token beneficiary of these rewards\"\n        );\n        uint256 releasable = vestedAmount(\n            address(token),\n            uint64(block.timestamp)\n        ) - released(address(token));\n        if (releasable > 0) {\n            uint256 amount = releasable.mul(sharesWithdrawn).div(\n                initialTotalSupply\n            );\n            uint256 _fee = amount.mul(poolFee).div(10000);\n\n            // If FeeTo == address(this) then the fee is effectively accrued by the pool\n            // Assume the caller is the liquidity pool and they receive the fee\n            // Keep tokens here by not transfering the _fee anywhere, it is accrued to the Bath Token's Bath Buddy\n            // token.transfer(address(this), _fee);\n\n            uint256 amountWithdrawn = amount.sub(_fee);\n            token.transfer(recipient, amountWithdrawn);\n\n            _erc20Released[address(token)] += amount;\n            emit ERC20Released(address(token), amount);\n\n            emit LogClaimBonusToken(\n                recipient,\n                msg.sender,\n                amountWithdrawn,\n                sharesWithdrawn,\n                token,\n                releasable\n            );\n        }\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _vestingSchedule(\n                IERC20(token).balanceOf(address(this)) + released(token),\n                timestamp\n            );\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        if (timestamp < start) {\n            return 0;\n        } else if (timestamp > start + duration) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start)) / duration;\n        }\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-rubicon-findings.json",
                "Location": "release() function in BathBuddy.sol",
                "Type": "Reentrancy",
                "Description": "If a token with callback capabilities is used as a token to vested, then a malicious beneficiary may get the vested amount back without waiting for the vesting period. In the function release, there\u2019s no modifier to stop reentrancy, in the other contracts it would be the synchronized modifier. If a token could reenter with a hook in a malicious contract (an ERC777 token, for example, which is backwards compatible with ERC20), released token counter array wouldn\u2019t be updated, enabling the withdrawal of the vested amount before the vesting period ends.",
                "Repair": "Add a mutex such as nonReentrant, or the synchronized modifier used in the other contracts. Implement checks-effects-interactions pattern."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n\n// WARNING!!!\n// Combining BoringBatchable with msg.value can cause double spending issues\n// https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/\n\ncontract BoringBatchable {\n  error BatchError(bytes innerError);\n\n  /// @dev Helper function to extract a useful revert message from a failed call.\n  /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n  function _getRevertMsg(bytes memory _returnData) internal pure {\n    // If the _res length is less than 68, then\n    // the transaction failed with custom error or silently (without a revert message)\n    if (_returnData.length < 68) revert BatchError(_returnData);\n\n    assembly {\n      // Slice the sighash.\n      _returnData := add(_returnData, 0x04)\n    }\n    revert(abi.decode(_returnData, (string))); // All that remains is the revert string\n  }\n\n  /// @notice Allows batched call to self (this contract).\n  /// @param calls An array of inputs for each call.\n  /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n  // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n  // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n  // C3: The length of the loop is fully under user control, so can't be exploited\n  // C7: Delegatecall is only used on the same contract, so it's safe\n  function batch(bytes[] calldata calls, bool revertOnFail) external payable {\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n      if (!success && revertOnFail) {\n        _getRevertMsg(result);\n      }\n    }\n  }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-08-mimo-findings.json",
                "Location": "BoringBatchable contract",
                "Type": "Reentrancy",
                "Description": "Persisted msg.value in a loop of delegate calls can be used to drain ETH from your proxy",
                "Repair": "Remove payable from batch() function in BoringBatchable contract"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RealEstatePlatform {\n\n    mapping(address => uint) public propertyPrices;\n    mapping(address => uint) public ownerBalances;\n\n    function listProperty(uint price) public {\n        propertyPrices[msg.sender] = price;\n    }\n\n    function buyProperty(address payable propertyOwner) public payable {\n        require(msg.value >= propertyPrices[propertyOwner], 'Insufficient funds to buy this property.');\n\n        ownerBalances[propertyOwner] += msg.value;\n\n        (bool success,) = propertyOwner.call{value: ownerBalances[propertyOwner]}('');\n        require(success, 'Transfer failed.');\n\n        ownerBalances[propertyOwner] = 0;\n        propertyPrices[propertyOwner] = 0;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "1",
            "Location": "(bool success,) = propertyOwner.call{value: ownerBalances[propertyOwner]}('');\nrequire(success, 'Transfer failed.');",
            "Type": "Reentrancy",
            "Description": "The function buyProperty has a reentrancy vulnerability because it uses a low-level call to transfer ether to propertyOwner, which can potentially trigger the fallback function in the recipient's contract. If the recipient contract's fallback function in turn calls back into buyProperty, it could potentially withdraw more ether than intended.",
            "Repair": "The best practice is to apply the Checks-Effects-Interactions pattern. This can be done by moving the ether transfer to the end of the function, after all the internal state has been updated. Additionally, use the transfer() function instead of call.value() to prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CryptoExchange {\n\n    mapping(address => uint) public tokenBalances;\n    mapping(address => mapping(address => uint)) public tokenAllowances;\n\n    event Deposit(address indexed user, uint amount);\n    event Withdraw(address indexed user, uint amount);\n\n    function depositTokens(address token, uint amount) public {\n        require(tokenBalances[msg.sender] >= amount, 'Insufficient token balance.');\n        tokenBalances[msg.sender] -= amount;\n        tokenAllowances[token][msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdrawTokens(address token, uint amount) public {\n        require(tokenAllowances[token][msg.sender] >= amount, 'Insufficient allowance.');\n\n        tokenAllowances[token][msg.sender] -= amount;\n        tokenBalances[msg.sender] += amount;\n\n        (bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Transfer failed.');\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "2",
            "Location": "(bool success,) = msg.sender.call{value: amount}('');\nrequire(success, 'Transfer failed.');",
            "Type": "Reentrancy",
            "Description": "In the function withdrawTokens, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to msg.sender, which can potentially trigger the fallback function in the recipient's contract. If the recipient contract's fallback function in turn calls back into withdrawTokens, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineMarketplace {\n\n    struct Product {\n        string name;\n        uint price;\n        address payable owner;\n    }\n\n    mapping(uint => Product) public products;\n\n    event ProductPurchased(uint productId, address buyer, uint price);\n\n    function addProduct(string memory name, uint price) public {\n        uint newProductId = uint(keccak256(abi.encodePacked(name, msg.sender)));\n        products[newProductId] = Product(name, price, payable(msg.sender));\n    }\n\n    function buyProduct(uint productId) public payable {\n        Product storage product = products[productId];\n\n        require(msg.value >= product.price, 'Insufficient funds to buy this product.');\n\n        (bool transferSucceeded,) = product.owner.call{value: msg.value}('');\n        require(transferSucceeded, 'Failed to transfer funds to the product owner.');\n\n        emit ProductPurchased(productId, msg.sender, msg.value);\n\n        delete products[productId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "3",
            "Location": "(bool transferSucceeded,) = product.owner.call{value: msg.value}('');\nrequire(transferSucceeded, 'Failed to transfer funds to the product owner.');",
            "Type": "Reentrancy",
            "Description": "In the function buyProduct, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the product owner, which can potentially trigger the fallback function in the owner's contract. If the owner's contract's fallback function in turn calls back into buyProduct, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DigitalBank {\n    mapping(address => uint) public accountBalances;\n    event Withdrawal(address indexed accountHolder, uint amount);\n\n    function deposit() public payable {\n        accountBalances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        require(accountBalances[msg.sender] >= amount, 'Insufficient funds.');\n\n        (bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Failed to transfer Ether.');\n\n        accountBalances[msg.sender] -= amount;\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    function balance() public view returns (uint) {\n        return accountBalances[msg.sender];\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "4",
            "Location": "(bool success,) = msg.sender.call{value: amount}('');\nrequire(success, 'Failed to transfer Ether.');",
            "Type": "Reentrancy",
            "Description": "In the function withdraw, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to msg.sender, which can potentially trigger the fallback function in the recipient's contract. If the recipient contract's fallback function in turn calls back into withdraw, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CrowdfundingCampaign {\n\n    struct Contribution {\n        uint amount;\n        address payable contributor;\n    }\n\n    mapping(uint => Contribution) public contributions;\n    uint public contributionsCount = 0;\n    uint public totalFunds = 0;\n\n    function contribute() public payable {\n        uint newContributionId = contributionsCount++;\n        contributions[newContributionId] = Contribution(msg.value, payable(msg.sender));\n        totalFunds += msg.value;\n    }\n\n    function refund(uint contributionId) public {\n        Contribution storage contrib = contributions[contributionId];\n\n        require(contrib.contributor == msg.sender, 'Not the contributor.');\n\n        (bool success,) = contrib.contributor.call{value: contrib.amount}('');\n        require(success, 'Failed to refund.');\n\n        totalFunds -= contrib.amount;\n        delete contributions[contributionId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "5",
            "Location": "(bool success,) = contrib.contributor.call{value: contrib.amount}('');\nrequire(success, 'Failed to refund.');",
            "Type": "Reentrancy",
            "Description": "In the function refund, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the contributor, which can potentially trigger the fallback function in the contributor's contract. If the contributor's contract's fallback function in turn calls back into refund, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineMarket {\n\n    struct Item {\n        uint price;\n        address payable seller;\n    }\n\n    mapping(uint => Item) public items;\n    uint public itemCount = 0;\n\n    function addItem(uint price) public {\n        uint newItemId = itemCount++;\n        items[newItemId] = Item(price, payable(msg.sender));\n    }\n\n    function buyItem(uint itemId) public payable {\n        Item storage item = items[itemId];\n\n        require(msg.value >= item.price, 'Not enough Ether sent.');\n\n        (bool success,) = item.seller.call{value: item.price}('');\n        require(success, 'Failed to transfer Ether to seller.');\n\n        delete items[itemId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "6",
            "Location": "(bool success,) = item.seller.call{value: item.price}('');\nrequire(success, 'Failed to transfer Ether to seller.');",
            "Type": "Reentrancy",
            "Description": "In the function buyItem, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the seller, which can potentially trigger the fallback function in the seller's contract. If the seller's contract's fallback function in turn calls back into buyItem, it could potentially purchase more items than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RealEstateAgency {\n\n    struct Property {\n        uint price;\n        address payable owner;\n    }\n\n    mapping(uint => Property) public properties;\n    uint public propertyCount = 0;\n\n    function listProperty(uint price) public {\n        uint newPropertyId = propertyCount++;\n        properties[newPropertyId] = Property(price, payable(msg.sender));\n    }\n\n    function purchaseProperty(uint propertyId) public payable {\n        Property storage property = properties[propertyId];\n\n        require(msg.value >= property.price, 'Not enough Ether sent.');\n\n        (bool success,) = property.owner.call{value: property.price}('');\n        require(success, 'Failed to transfer Ether to owner.');\n\n        delete properties[propertyId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "7",
            "Location": "(bool success,) = property.owner.call{value: property.price}('');\nrequire(success, 'Failed to transfer Ether to owner.');",
            "Type": "Reentrancy",
            "Description": "In the function purchaseProperty, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the property owner, which can potentially trigger the fallback function in the owner's contract. If the owner's contract's fallback function in turn calls back into purchaseProperty, it could potentially purchase more properties than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineAuction {\n\n    struct Bid {\n        uint amount;\n        address payable bidder;\n    }\n\n    mapping(uint => Bid) public bids;\n    uint public bidCount = 0;\n\n    function makeBid(uint amount) public payable {\n        uint newBidId = bidCount++;\n        bids[newBidId] = Bid(amount, payable(msg.sender));\n    }\n\n    function acceptBid(uint bidId) public {\n        Bid storage bid = bids[bidId];\n\n        (bool success,) = bid.bidder.call{value: bid.amount}('');\n        require(success, 'Failed to transfer Ether to bidder.');\n\n        delete bids[bidId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "8",
            "Location": "(bool success,) = bid.bidder.call{value: bid.amount}('');\nrequire(success, 'Failed to transfer Ether to bidder.');",
            "Type": "Reentrancy",
            "Description": "In the function acceptBid, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the bidder, which can potentially trigger the fallback function in the bidder's contract. If the bidder's contract's fallback function in turn calls back into acceptBid, it could potentially cause unexpected behavior.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineMarketplace {\n\n    struct Product {\n        uint price;\n        address payable seller;\n    }\n\n    mapping(uint => Product) public products;\n    uint public productCount = 0;\n\n    function listProduct(uint price) public {\n        uint newProductId = productCount++;\n        products[newProductId] = Product(price, payable(msg.sender));\n    }\n\n    function purchaseProduct(uint productId) public payable {\n        Product storage product = products[productId];\n\n        require(msg.value >= product.price, 'Not enough Ether sent.');\n\n        (bool success,) = product.seller.call{value: product.price}('');\n        require(success, 'Failed to transfer Ether to seller.');\n\n        delete products[productId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "9",
            "Location": "(bool success,) = product.seller.call{value: product.price}('');\nrequire(success, 'Failed to transfer Ether to seller.');",
            "Type": "Reentrancy",
            "Description": "In the function purchaseProduct, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the product seller, which can potentially trigger the fallback function in the seller's contract. If the seller's contract's fallback function in turn calls back into purchaseProduct, it could potentially purchase more products than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DigitalExchange {\n\n    struct Share {\n        uint price;\n        address payable owner;\n    }\n\n    mapping(uint => Share) public shares;\n    uint public shareCount = 0;\n\n    function listShare(uint price) public {\n        uint newShareId = shareCount++;\n        shares[newShareId] = Share(price, payable(msg.sender));\n    }\n\n    function buyShare(uint shareId) public payable {\n        Share storage share = shares[shareId];\n\n        require(msg.value >= share.price, 'Not enough Ether sent.');\n\n        (bool success,) = share.owner.call{value: share.price}('');\n        require(success, 'Failed to transfer Ether to owner.');\n\n        delete shares[shareId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "10",
            "Location": "(bool success,) = share.owner.call{value: share.price}('');\nrequire(success, 'Failed to transfer Ether to owner.');",
            "Type": "Reentrancy",
            "Description": "In the function buyShare, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the share owner, which can potentially trigger the fallback function in the owner's contract. If the owner's contract's fallback function in turn calls back into buyShare, it could potentially buy more shares than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract FineArtAuction {\n\n    struct Artwork {\n        uint bid;\n        address payable artist;\n    }\n\n    mapping(uint => Artwork) public artworks;\n    uint public artworkCount = 0;\n\n    function listArtwork() public {\n        uint newArtworkId = artworkCount++;\n        artworks[newArtworkId] = Artwork(0, payable(msg.sender));\n    }\n\n    function placeBid(uint artworkId) public payable {\n        Artwork storage artwork = artworks[artworkId];\n\n        require(msg.value > artwork.bid, 'Bid is not high enough.');\n\n        (bool success,) = artwork.artist.call{value: msg.value}('');\n        require(success, 'Failed to transfer Ether to artist.');\n\n        artwork.bid = msg.value;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "11",
            "Location": "(bool success,) = artwork.artist.call{value: msg.value}('');\nrequire(success, 'Failed to transfer Ether to artist.');",
            "Type": "Reentrancy",
            "Description": "In the function placeBid, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the artist, which can potentially trigger the fallback function in the artist's contract. If the artist's contract's fallback function in turn calls back into placeBid, it could potentially place more bids than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CrowdfundingCampaign {\n\n    struct Project {\n        uint fundingGoal;\n        uint amountRaised;\n        address payable creator;\n    }\n\n    mapping(uint => Project) public projects;\n    uint public projectCount = 0;\n\n    function createProject(uint fundingGoal) public {\n        uint newProjectId = projectCount++;\n        projects[newProjectId] = Project(fundingGoal, 0, payable(msg.sender));\n    }\n\n    function contribute(uint projectId) public payable {\n        Project storage project = projects[projectId];\n\n        require(msg.value + project.amountRaised <= project.fundingGoal, 'Funding goal exceeded.');\n\n        (bool success,) = project.creator.call{value: msg.value}('');\n        require(success, 'Failed to transfer Ether to project creator.');\n\n        project.amountRaised += msg.value;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "12",
            "Location": "(bool success,) = project.creator.call{value: msg.value}('');\nrequire(success, 'Failed to transfer Ether to project creator.');",
            "Type": "Reentrancy",
            "Description": "In the function contribute, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the project creator, which can potentially trigger the fallback function in the creator's contract. If the creator's contract's fallback function in turn calls back into contribute, it could potentially contribute more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CapitalVenture {\n\n    struct Investor {\n        uint invested;\n        uint lastInvest;\n        address payable addr;\n    }\n\n    mapping(address => Investor) public investors;\n\n    function invest() public payable {\n        Investor storage investor = investors[msg.sender];\n        investor.addr = payable(msg.sender);\n        investor.invested += msg.value;\n        investor.lastInvest = block.timestamp;\n\n        (bool success,) = investor.addr.call{value: msg.value}('');\n        require(success, 'Failed to transfer Ether.');\n    }\n\n    function getInvestedAmount(address addr) public view returns (uint) {\n        return investors[addr].invested;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "13",
            "Location": "(bool success,) = investor.addr.call{value: msg.value}('');\nrequire(success, 'Failed to transfer Ether.');",
            "Type": "Reentrancy",
            "Description": "In the invest function, there is a reentrancy vulnerability because it uses a low-level call to transfer ether back to the investor, potentially triggering the fallback function of the investor's contract. If the investor's contract's fallback function in turn calls back into invest, it could potentially invest more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract FundRaiser {\n\n    struct Donor {\n        uint amount;\n        address payable addr;\n    }\n\n    mapping(address => Donor) public donors;\n\n    function donate() public payable {\n        Donor storage donor = donors[msg.sender];\n        donor.addr = payable(msg.sender);\n        donor.amount += msg.value;\n\n        (bool success,) = donor.addr.call{value: msg.value / 10}('');\n        require(success, 'Failed to transfer Ether.');\n    }\n\n    function getDonationAmount(address addr) public view returns (uint) {\n        return donors[addr].amount;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "14",
            "Location": "(bool success,) = donor.addr.call{value: msg.value / 10}('');\nrequire(success, 'Failed to transfer Ether.');",
            "Type": "Reentrancy",
            "Description": "In the donate function, there is a reentrancy vulnerability because it uses a low-level call to transfer a portion of the donated ether back to the donor, potentially triggering the fallback function of the donor's contract. If the donor's contract's fallback function in turn calls back into donate, it could potentially donate more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract MembershipClub {\n    mapping(address => uint) public memberFees;\n\n    function joinClub() public payable {\n        memberFees[msg.sender] += msg.value;\n        require(memberFees[msg.sender] >= 1 ether, 'Membership fee is at least 1 Ether');\n\n        (bool sent,) = msg.sender.call{value: msg.value / 10}('');\n        require(sent, 'Failed to send Ether');\n    }\n\n    function getFee(address member) public view returns (uint) {\n        return memberFees[member];\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "15",
            "Location": "(bool sent,) = msg.sender.call{value: msg.value / 10}('');\n        require(sent, 'Failed to send Ether');",
            "Type": "Reentrancy",
            "Description": "In the joinClub function, there is a reentrancy vulnerability because it uses a low-level call to refund part of the membership fee to the caller, potentially triggering the fallback function of the caller's contract. If the caller's contract's fallback function in turn calls back into joinClub, it could potentially join the club with less fee than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract AssetPortfolio {\n    mapping(address => uint) public investments;\n\n    function invest() public payable {\n        investments[msg.sender] += msg.value;\n    }\n\n    function divest(uint amount) public {\n        require(investments[msg.sender] >= amount, 'Insufficient investment');\n        investments[msg.sender] -= amount;\n        (bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Transfer failed');\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "16",
            "Location": "(bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Transfer failed');",
            "Type": "Reentrancy",
            "Description": "In the divest function, there is a reentrancy vulnerability. Before updating the internal state (i.e., the investor's investment amount), transferring money to the investor may trigger the fallback function of his contract, which may cause the investor to withdraw more than his original investment amount if the function calls divest again.",
            "Repair": "Adopt the Checks-Effects-Interactions pattern, move the ether transfer to the end of the function, and execute it after all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the gas available to the payee and prevent the payee's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract WealthManager {\n    mapping(address => uint) public deposits;\n\n    function makeDeposit() public payable {\n        deposits[msg.sender] += msg.value;\n    }\n\n    function makeWithdrawal(uint _amount) public {\n        require(deposits[msg.sender] >= _amount, 'Insufficient deposit');\n        deposits[msg.sender] -= _amount;\n        (bool success,) = msg.sender.call{value: _amount}('');\n        require(success, 'Transfer failed');\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "17",
            "Location": "(bool success,) = msg.sender.call{value: _amount}('');\n        require(success, 'Transfer failed');",
            "Type": "Reentrancy",
            "Description": "In the makeWithdrawal function, there is a reentrancy vulnerability. Before updating the internal state (i.e. the user's deposit), transferring funds to the user may trigger the fallback function of their contract, which may cause the user to withdraw more than their original deposit if the function calls makeWithdrawal again.",
            "Repair": "The way to fix it is to use the Checks-Effects-Interactions pattern, move the ether transfer to the end of the function, and execute it after all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the gas available to the payee and prevent the payee's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract AssetLocker {\n    mapping(address => uint256) public assetBalance;\n\n    event AssetDeposited(address indexed depositor, uint256 amount);\n    event AssetWithdrawn(address indexed withdrawer, uint256 amount);\n\n    function depositAsset() public payable {\n        assetBalance[msg.sender] += msg.value;\n        emit AssetDeposited(msg.sender, msg.value);\n    }\n\n    function withdrawAsset(uint256 amount) public {\n        require(assetBalance[msg.sender] >= amount, 'Not enough asset to withdraw');\n        (bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Asset transfer failed');\n        assetBalance[msg.sender] -= amount;\n        emit AssetWithdrawn(msg.sender, amount);\n    }\n\n    function getBalance() public view returns(uint256) {\n        return assetBalance[msg.sender];\n    }\n\n    function totalAssets() public view returns(uint256) {\n        return address(this).balance;\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "18",
            "Location": "(bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Asset transfer failed');\n        assetBalance[msg.sender] -= amount;",
            "Type": "Reentrancy",
            "Description": "In the withdrawAsset function, there is a reentrancy vulnerability. Before updating the internal state (i.e. the user's asset balance), transferring money to the user may trigger the fallback function of their contract, which may allow the user to withdraw more than their original deposit if the function calls withdrawAsset again.",
            "Repair": "The way to fix it is to use the Checks-Effects-Interactions pattern, move the ether transfer to the end of the function, and execute it after all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the gas available to the payee and prevent the payee's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract PropertyRegistry {\n    mapping(address => uint256) public propertyBalance;\n    address payable public registryOwner;\n\n    constructor() {\n        registryOwner = payable(msg.sender);\n    }\n\n    function deposit() public payable {\n        propertyBalance[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(propertyBalance[msg.sender] >= amount, 'Insufficient balance');\n        (bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Failed to send ether');\n        propertyBalance[msg.sender] -= amount;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return propertyBalance[msg.sender];\n    }\n\n    function contractBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function closeRegistry() public {\n        require(msg.sender == registryOwner, 'Only owner can close the registry');\n        selfdestruct(registryOwner);\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "19",
            "Location": "(bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Failed to send ether');\n        propertyBalance[msg.sender] -= amount;",
            "Type": "Reentrancy",
            "Description": "In the withdraw function, there is a reentrancy vulnerability. Before updating the internal state (i.e., the user's property balance), sending ether to the user could trigger their contract's fallback function. If that function calls withdraw again, it could allow the user to withdraw more than their original deposit.",
            "Repair": "The way to fix it is to use the Checks-Effects-Interactions pattern, moving the ether transfer to the end of the function when all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the amount of gas available to the recipient, preventing the recipient's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CashbackLoyaltyProgram {\n    mapping(address => uint256) public loyaltyPoints;\n    mapping(address => uint256) public etherBalance;\n    address payable public companyWallet;\n\n    constructor() {\n        companyWallet = payable(msg.sender);\n    }\n\n    function purchaseItem() public payable {\n        companyWallet.transfer(msg.value);\n        loyaltyPoints[msg.sender] += msg.value / 100;\n    }\n\n    function redeemPoints(uint256 points) public {\n        require(loyaltyPoints[msg.sender] >= points, 'Not enough loyalty points');\n        uint256 etherToRedeem = points / 100;\n        require(etherBalance[companyWallet] >= etherToRedeem, 'Not enough funds in the company wallet');\n        (bool sent, ) = msg.sender.call{value: etherToRedeem}('');\n        require(sent, 'Failed to send Ether');\n        loyaltyPoints[msg.sender] -= points;\n        etherBalance[companyWallet] -= etherToRedeem;\n    }\n\n    function getPoints() public view returns (uint256) {\n        return loyaltyPoints[msg.sender];\n    }\n\n    function getCompanyBalance() public view returns (uint256) {\n        return etherBalance[companyWallet];\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "20",
            "Location": "(bool sent, ) = msg.sender.call{value: etherToRedeem}('');\n        require(sent, 'Failed to send Ether');\n        loyaltyPoints[msg.sender] -= points;\n        etherBalance[companyWallet] -= etherToRedeem;",
            "Type": "Reentrancy",
            "Description": "In the redeemPoints function, a reentrancy vulnerability is present. Before the internal state (i.e., the user's loyalty points and the company's ether balance) is updated, ether is sent to the user. If the user's contract's fallback function is triggered and calls redeemPoints again, it could allow the user to redeem more than their original loyalty points for ether.",
            "Repair": "To fix it, the Checks-Effects-Interactions pattern should be used, moving the ether transfer to the end of the function after all internal states have been updated. It would be safer to use the transfer() function instead of call.value() to limit the amount of gas available to the recipient, thus preventing the recipient's contract from executing a large amount of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract VentureCapital {\n    mapping(address => uint) public investments;\n    address payable public entrepreneur;\n\n    constructor() {\n        entrepreneur = payable(msg.sender);\n    }\n\n    function invest() public payable {\n        investments[msg.sender] += msg.value;\n    }\n\n    function profitDistribution() public {\n        require(msg.sender == entrepreneur, 'Only the entrepreneur can distribute profits');\n        for (address investor: getInvestors()) {\n            uint profitShare = investments[investor] / 10;\n            (bool sent, ) = investor.call{value: profitShare}('');\n            require(sent, 'Failed to send Ether');\n        }\n    }\n\n    function getInvestors() public view returns (address[] memory) {\n        address[] memory investors = new address[](address(this).balance);\n        uint count = 0;\n        for (uint i = 0; i < investors.length; i++) {\n            if (investments[investors[i]] > 0) {\n                investors[count] = investors[i];\n                count++;\n            }\n        }\n        return investors;\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "21",
            "Location": "(bool sent, ) = investor.call{value: profitShare}('');\n        require(sent, 'Failed to send Ether');",
            "Type": "Reentrancy",
            "Description": "In the profitDistribution function, there is a reentrancy vulnerability. Ether is being sent to investors before the state (i.e., the balance of this contract) is updated. This allows the investor's fallback function to be triggered and call profitDistribution again, possibly leading to a withdrawal of more profits than intended.",
            "Repair": "To mitigate this, one should apply the Checks-Effects-Interactions pattern, ensuring state changes happen prior to calling external contracts. In addition, Solidity's transfer function could be used instead of call.value() to limit the gas provided to the external call, which could limit the potential for reentrancy by preventing the called contract from performing other operations."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\ncontract Trader is ITrader {\n  \n    string private constant EIP712_DOMAIN_NAME = \"Tracer Protocol\";\n    string private constant EIP712_DOMAIN_VERSION = \"1.0\";\n    bytes32 private constant EIP712_DOMAIN_SEPERATOR =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n\n    bytes32 private constant ORDER_TYPE =\n        keccak256(\n            \"Order(address maker,address market,uint256 price,uint256 amount,uint256 side,uint256 expires,uint256 created)\"\n        );\n\n    uint256 public constant override chainId = 1337; // Changes per chain\n    bytes32 public immutable override EIP712_DOMAIN;\n\n    mapping(bytes32 => Perpetuals.Order) public orders;\n  \n    mapping(bytes32 => Types.SignedLimitOrder) public orderToSig;\n\n    mapping(bytes32 => uint256) public override filled;\n\n    mapping(bytes32 => uint256) public override averageExecutionPrice;\n\n    constructor() {\n\n        EIP712_DOMAIN = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_SEPERATOR,\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\n                chainId,\n                address(this)\n            )\n        );\n    }\n    function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers)\n        external\n        override\n    {\n        require(makers.length == takers.length, \"TDR: Lengths differ\");\n        uint256 n = makers.length;\n\n        require(n > 0, \"TDR: Received empty arrays\");\n\n        for (uint256 i = 0; i < n; i++) {\n            if (\n                !isValidSignature(makers[i].order.maker, makers[i]) ||\n                !isValidSignature(takers[i].order.maker, takers[i]) ||\n                !isValidPair(takers[i], makers[i])\n            ) {\n                continue;\n            }\n\n \n            Perpetuals.Order memory makeOrder = grabOrder(makers, i);\n            Perpetuals.Order memory takeOrder = grabOrder(takers, i);\n\n            bytes32 makerOrderId = Perpetuals.orderId(makeOrder);\n            bytes32 takerOrderId = Perpetuals.orderId(takeOrder);\n\n            uint256 makeOrderFilled = filled[makerOrderId];\n            uint256 takeOrderFilled = filled[takerOrderId];\n\n            uint256 fillAmount = Balances.fillAmount(makeOrder, makeOrderFilled, takeOrder, takeOrderFilled);\n\n            uint256 executionPrice = Perpetuals.getExecutionPrice(makeOrder, takeOrder);\n            uint256 newMakeAverage = Perpetuals.calculateAverageExecutionPrice(\n                makeOrderFilled,\n                averageExecutionPrice[makerOrderId],\n                fillAmount,\n                executionPrice\n            );\n            uint256 newTakeAverage = Perpetuals.calculateAverageExecutionPrice(\n                takeOrderFilled,\n                averageExecutionPrice[takerOrderId],\n                fillAmount,\n                executionPrice\n            );\n            (bool success, ) = makeOrder.market.call(\n                abi.encodePacked(\n                    ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,\n                    abi.encode(makeOrder, takeOrder, fillAmount)\n                )\n            );\n\n            if (!success) continue;\n\n\n            filled[makerOrderId] = makeOrderFilled + fillAmount;\n            filled[takerOrderId] = takeOrderFilled + fillAmount;\n            averageExecutionPrice[makerOrderId] = newMakeAverage;\n            averageExecutionPrice[takerOrderId] = newTakeAverage;\n        }\n    }\n    function getOrder(Perpetuals.Order calldata order) external view override returns (Perpetuals.Order memory) {\n        bytes32 orderId = Perpetuals.orderId(order);\n        return orders[orderId];\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-06-tracer-findings.json",
                "Location": "executeTrade function in Trader contract",
                "Type": "Reentrancy",
                "Description": "Reentrancy could happen in the executeTrade function of Trader since the makeOrder.market can be a user-controlled external contract.",
                "Repair": "Add a reentrancy guard to prevent users from reentering critical functions"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\ncontract Basket is IBasket, ERC20Upgradeable {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant TIMELOCK_DURATION = 4 * 60 * 24;\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory) {\n        return (pendingWeights.tokens, pendingWeights.weights);\n    }\n\n\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        handleFees();\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        require(balanceOf(msg.sender) >= amount);\n\n        handleFees();\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction external override {\n        handleFees();\n\n        _burn(msg.sender, amount);\n\n        emit Burned(msg.sender, amount);\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-09-defiProtocol-findings.json",
                "Location": "mintTo() and burn() functions in Basket.sol",
                "Type": "Reentrancy",
                "Description": "The functions make external calls prior to updating the state, allowing attackers to mint free basket tokens and reenter the function to mint more tokens than deposited.",
                "Repair": "Move external calls after state updates in accordance with the check-effect-interact pattern"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\nstruct UserState {\n  uint256 bonded;\n  uint256 bondedEpoch;\n}\nstruct EpochState {\n  uint256 lastTotalBonded;\n  uint256 lastUpdateTime;\n  uint256 cumulativeTotalBonded;\n}\ncontract Bonding is Initializable, Permissions {\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public stakeToken;\n  IDAO public dao;\n  IMiningService public miningService;\n  IDexHandler public dexHandler;\n  IMaltDataLab public maltDataLab;\n\n  uint256 internal _globalBonded;\n  uint256 internal _currentEpoch;\n  address internal offering;\n  mapping(address => UserState) internal userState;\n  mapping(uint256 => EpochState) internal epochState;\n\n  event Bond(address indexed account, uint256 value);\n  event Unbond(address indexed account, uint256 value);\n  event UnbondAndBreak(address indexed account, uint256 amountLPToken, uint256 amountMalt, uint256 amountReward);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _malt,\n    address _rewardToken,\n    address _stakeToken,\n    address _dao,\n    address _miningService,\n    address _offering,\n    address _dexHandler,\n    address _maltDataLab\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    dao = IDAO(_dao);\n    offering = _offering;\n    stakeToken = ERC20(_stakeToken);\n    miningService = IMiningService(_miningService);\n    dexHandler = IDexHandler(_dexHandler);\n    malt = ERC20(_malt);\n    rewardToken = ERC20(_rewardToken);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n  }\n\n  function bond(uint256 amount) external {\n    bondToAccount(msg.sender, amount);\n  }\n\n  function bondToAccount(address account, uint256 amount)\n    public\n  {\n    if (msg.sender != offering) {\n      _notSameBlock();\n    }\n    require(amount > 0, \"Cannot bond 0\");\n\n    miningService.onBond(account, amount);\n\n    _bond(account, amount);\n  }\n\n \n  function _removeFromBonded(address account, uint256 amount, string memory reason) internal {\n    userState[account].bonded = userState[account].bonded.sub(amount, reason);\n\n    _updateEpochState(_globalBonded.sub(amount, reason));\n  }\n\n  function _updateEpochState(uint256 newTotalBonded) internal {\n    EpochState storage state = epochState[_currentEpoch];\n    uint256 epoch = dao.epoch();\n    uint256 epochStartTime = dao.getEpochStartTime(_currentEpoch);\n    uint256 lastUpdateTime = state.lastUpdateTime;\n    uint256 lengthOfEpoch = dao.epochLength();\n    uint256 epochEndTime = epochStartTime + lengthOfEpoch;\n\n    if (lastUpdateTime == 0) {\n      lastUpdateTime = epochStartTime;\n    }\n\n    if (lastUpdateTime > epochEndTime) {\n      lastUpdateTime = epochEndTime;\n    }\n\n    if (epoch == _currentEpoch) {\n      uint256 finalTime = block.timestamp;\n      if (block.timestamp > epochEndTime) {\n        finalTime = epochEndTime;\n      } \n\n      uint256 diff = finalTime - lastUpdateTime;\n\n      if (diff > 0) {\n        state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));\n\n        state.lastUpdateTime = finalTime;\n        state.lastTotalBonded = newTotalBonded;\n      }\n    } else {\n      // We have crossed at least 1 epoch boundary\n\n      // Won't underflow due to check on lastUpdateTime above\n      uint256 diff = epochEndTime - lastUpdateTime;\n\n      state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));\n      state.lastUpdateTime = epochEndTime;\n      state.lastTotalBonded = _globalBonded;\n\n      for (uint256 i = _currentEpoch + 1; i <= epoch; i += 1) {\n        state = epochState[i];\n        epochStartTime = dao.getEpochStartTime(i);\n        epochEndTime = epochStartTime + lengthOfEpoch;\n        state.lastTotalBonded = _globalBonded;\n\n        if (epochEndTime < block.timestamp) {\n          // The desired epoch is in the past\n          diff = lengthOfEpoch;\n          state.lastUpdateTime = epochEndTime;\n        } else {\n          diff = block.timestamp - epochStartTime;\n          state.lastUpdateTime = block.timestamp;\n        }\n\n        state.cumulativeTotalBonded = state.lastTotalBonded.mul(diff);\n      }\n\n      state.lastTotalBonded = newTotalBonded;\n      _currentEpoch = epoch;\n    } \n\n    _globalBonded = newTotalBonded;\n  }\n\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-11-malt-findings.json",
                "Location": "bondToAccount functione",
                "Type": "Reentrancy",
                "Description": "The _notSameBlock() function in Bonding.sol can be circumvented in bondToAccount() by calling it via a smart contract, leading to potential risks from reentrancy attacks.",
                "Repair": "Add access controls to the function bondToAccount() to prevent reentrancy attacks"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\ncontract Basket is IBasket, ERC20Upgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n   \n    uint256 public constant TIMELOCK_DURATION = 1 days; // 1 day\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    uint256 public maxSupply;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n    PendingMaxSupply public pendingMaxSupply;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    bool public override initialized;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) external override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        maxSupply = proposal.maxSupply;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n\n        initialized = true;\n    }\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length > 0);\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n    function mintTo(uint256 amount, address to) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        uint256 startSupply = totalSupply();\n        require(startSupply + amount <= maxSupply);\n\n        handleFees(startSupply);\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        require(totalSupply() <= maxSupply);\n\n        emit Minted(to, amount);\n    }\n    function burn(uint256 amount) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            require(tokenAmount > 0);\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-12-defiprotocol-findings.json",
                "Location": "Basket contract's initialize() method",
                "Type": "Reentrancy",
                "Description": "A malicious publisher can create a basket proposal that mixes real ERC20 tokens with a malicious ERC20 token containing a reentrancy callback in its approve() method.",
                "Repair": "Use the initializer modifier available in ERC20Upgradeable to prevent reentrancy attacks"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.4;\nimport \"./Governable.sol\";\nimport \"hardhat/console.sol\";\nimport \"../facades/Burnable.sol\";\n\ncontract FlashGovernanceArbiter is Governable {\n\n  event flashDecision(address actor, address deposit_asset, uint256 amount, address target);\n\n  mapping(address => bool) enforceLimitsActive;\n\n  constructor(address dao) Governable(dao) {}\n\n  struct FlashGovernanceConfig {\n    address asset;\n    uint256 amount;\n    uint256 unlockTime;\n    bool assetBurnable;\n  }\n\n\n  struct SecurityParameters {\n    uint8 maxGovernanceChangePerEpoch; \n    uint256 epochSize;\n    uint256 lastFlashGovernanceAct;\n    uint8 changeTolerance; \n  }\n\n\n  FlashGovernanceConfig public flashGovernanceConfig;\n  SecurityParameters public security;\n\n  mapping(address => mapping(address => FlashGovernanceConfig)) public pendingFlashDecision; //contract->user->config\n\n\n  function assertGovernanceApproved(\n    address sender,\n    address target,\n    bool emergency\n  ) public {\n    if (\n      IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&\n      pendingFlashDecision[target][sender].unlockTime < block.timestamp\n    ) {\n      require(\n        emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),\n        \"Limbo: flash governance disabled for rest of epoch\"\n      );\n      pendingFlashDecision[target][sender] = flashGovernanceConfig;\n      pendingFlashDecision[target][sender].unlockTime += block.timestamp;\n\n      security.lastFlashGovernanceAct = block.timestamp;\n      emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);\n    } else {\n      revert(\"LIMBO: governance decision rejected.\");\n    }\n  }\n\n\n  function configureFlashGovernance(\n    address asset,\n    uint256 amount,\n    uint256 unlockTime,\n    bool assetBurnable\n  ) public virtual onlySuccessfulProposal {\n    flashGovernanceConfig.asset = asset;\n    flashGovernanceConfig.amount = amount;\n    flashGovernanceConfig.unlockTime = unlockTime;\n    flashGovernanceConfig.assetBurnable = assetBurnable;\n  }\n\n  function configureSecurityParameters(\n    uint8 maxGovernanceChangePerEpoch,\n    uint256 epochSize,\n    uint8 changeTolerance\n  ) public virtual onlySuccessfulProposal {\n    security.maxGovernanceChangePerEpoch = maxGovernanceChangePerEpoch;\n    security.epochSize = epochSize;\n    require(security.changeTolerance < 100, \"Limbo: % between 0 and 100\");\n    security.changeTolerance = changeTolerance;\n  }\n  function withdrawGovernanceAsset(address targetContract, address asset) public virtual {\n    require(\n      pendingFlashDecision[targetContract][msg.sender].asset == asset &&\n        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&\n        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,\n      \"Limbo: Flashgovernance decision pending.\"\n    );\n    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(\n      msg.sender,\n      pendingFlashDecision[targetContract][msg.sender].amount\n    );\n    delete pendingFlashDecision[targetContract][msg.sender];\n  }\n\n  function enforceToleranceInt(int256 v1, int256 v2) public view {\n    if (!configured) return;\n    uint256 uv1 = uint256(v1 > 0 ? v1 : -1 * v1);\n    uint256 uv2 = uint256(v2 > 0 ? v2 : -1 * v2);\n    enforceTolerance(uv1, uv2);\n  }\n\n  function enforceTolerance(uint256 v1, uint256 v2) public view {\n    if (!configured || !enforceLimitsActive[msg.sender]) return;\n    //bonus points for readability\n    if (v1 > v2) {\n      if (v2 == 0) require(v1 <= 1, \"FE1\");\n      else require(((v1 - v2) * 100) < security.changeTolerance * v1, \"FE1\");\n    } else {\n      if (v1 == 0) require(v2 <= 1, \"FE1\");\n      else require(((v2 - v1) * 100) < security.changeTolerance * v1, \"FE1\");\n    }\n  }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-behodler-findings.json",
                "Location": "withdrawGovernanceAsset function of FlashGovernanceArbiter.sol",
                "Type": "Reentrancy",
                "Description": "The function withdrawGovernanceAsset is vulnerable to reentrancy.",
                "Repair": "Implement the check-effects-interactions pattern or delete the pendingFlashDecision before making the external call"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.10;\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n    using Counters for Counters.Counter;\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n    using Address for address;\n    using ERC165Query for address;\n    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n    uint256 public constant SHARES_MULTIPLIER = 10**18;\n    IERC20 public override(IVault) underlying;\n    IStrategy public strategy;\n    uint256 public investPerc;\n    uint256 public immutable override(IVault) minLockPeriod;\n    uint256 public override(IVaultSponsoring) totalSponsored;\n    Depositors public depositors;\n    Claimers public claimers;\n    Counters.Counter private _depositGroupIds;\n    constructor(\n        IERC20 _underlying,\n        uint256 _minLockPeriod,\n        uint256 _investPerc,\n        address _owner\n    ) Trust(_owner) {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n        require(\n            address(_underlying) != address(0x0),\n            \"VaultContext: underlying cannot be 0x0\"\n        );\n        investPerc = _investPerc;\n        underlying = _underlying;\n        minLockPeriod = _minLockPeriod;\n\n        depositors = new Depositors(address(this), \"depositors\", \"p\");\n        claimers = new Claimers(address(this));\n    }\n    function deposit(DepositParams calldata _params) external {\n        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);\n        _transferAndCheckUnderlying(_msgSender(), _params.amount);\n    }\n\n    function sponsor(uint256 _amount, uint256 _lockedUntil)\n        external\n        override(IVaultSponsoring)\n    {\n        if (_lockedUntil == 0)\n            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;\n        else\n            require(\n                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,\n                \"Vault: lock time is too small\"\n            );\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            _amount,\n            0,\n            _lockedUntil\n        );\n\n        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);\n\n        totalSponsored += _amount;\n        _transferAndCheckUnderlying(_msgSender(), _amount);\n    }     \n   function _withdrawDeposit(\n        uint256 _tokenId,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored,\n        address _to,\n        bool _force\n    ) internal returns (uint256) {\n        require(\n            depositors.ownerOf(_tokenId) == _msgSender(),\n            \"Vault: you are not the owner of a deposit\"\n        );\n\n        (\n            uint256 depositAmount,\n            uint256 claimerId,\n            uint256 lockedUntil\n        ) = depositors.deposits(_tokenId);\n        require(lockedUntil <= block.timestamp, \"Vault: deposit is locked\");\n\n        require(claimerId != 0, \"Vault: token id is not a withdraw\");\n\n        uint256 claimerShares = claimers.sharesOf(claimerId);\n\n        uint256 depositShares = _computeShares(\n            depositAmount,\n            _totalShares,\n            _totalUnderlyingMinusSponsored\n        );\n\n        if (_force && depositShares > claimerShares) {\n            depositShares = claimerShares;\n        } else if (!_force) {\n            require(\n                claimerShares >= depositShares,\n                \"Vault: cannot withdraw more than the available amount\"\n            );\n        }\n\n        claimers.onWithdraw(claimerId, depositAmount, depositShares);\n        depositors.burn(_tokenId);\n        address claimer = claimers.ownerOf(claimerId);\n        if (_isIntegration(claimer)) {\n            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);\n            require(ret == IIntegration(claimer).onDepositBurned.selector);\n        }\n\n        emit DepositBurned(_tokenId, depositShares, _to);\n\n        return\n            _computeAmount(\n                depositShares,\n                _totalShares,\n                _totalUnderlyingMinusSponsored\n            );\n    }\n  function _isIntegration(address addr) internal view returns (bool) {\n        return\n            addr.doesContractImplementInterface(type(IIntegration).interfaceId);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-sandclock-findings.json",
                "Location": "onDepositBurned function in Vault.sol",
                "Type": "Reentrancy",
                "Description": "The impact of this is that users can get significantly more UST withdrawn than they would be allotted if they had done non-reentrant withdraw calls.",
                "Repair": "Add reentrancy guards. Simplify some of the shares logic."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.10;\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n    using Counters for Counters.Counter;\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n    using Address for address;\n    using ERC165Query for address;\n    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n    uint256 public constant SHARES_MULTIPLIER = 10**18;\n    IERC20 public override(IVault) underlying;\n    IStrategy public strategy;\n    uint256 public investPerc;\n    uint256 public immutable override(IVault) minLockPeriod;\n    uint256 public override(IVaultSponsoring) totalSponsored;\n    Depositors public depositors;\n    Claimers public claimers;\n    Counters.Counter private _depositGroupIds;\n    constructor(\n        IERC20 _underlying,\n        uint256 _minLockPeriod,\n        uint256 _investPerc,\n        address _owner\n    ) Trust(_owner) {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n        require(\n            address(_underlying) != address(0x0),\n            \"VaultContext: underlying cannot be 0x0\"\n        );\n        investPerc = _investPerc;\n        underlying = _underlying;\n        minLockPeriod = _minLockPeriod;\n\n        depositors = new Depositors(address(this), \"depositors\", \"p\");\n        claimers = new Claimers(address(this));\n    }\n\n    function sponsor(uint256 _amount, uint256 _lockedUntil)\n        external\n        override(IVaultSponsoring)\n    {\n        if (_lockedUntil == 0)\n            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;\n        else\n            require(\n                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            _amount,\n            0,\n            _lockedUntil\n        );\n\n        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);\n\n        totalSponsored += _amount;\n        _transferAndCheckUnderlying(_msgSender(), _amount);\n    }     \n    function _createClaim(\n        uint256 _depositGroupId,\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams memory _claim,\n        uint256 _localTotalShares,\n        uint256 _localTotalPrincipal\n    ) internal {\n        uint256 amount = _amount.percOf(_claim.pct);\n\n        uint256 newShares = _computeShares(\n            amount,\n            _localTotalShares,\n            _localTotalPrincipal\n        );\n\n        uint256 claimerId = claimers.mint(\n            _claim.beneficiary,\n            amount,\n            newShares\n        );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            amount,\n            claimerId,\n            _lockedUntil\n        );\n\n        if (_isIntegration(_claim.beneficiary)) {\n            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(\n                tokenId,\n                newShares,\n                _claim.data\n            );\n\n            require(\n                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector\n            );\n        }\n\n        emit DepositMinted(\n            tokenId,\n            _depositGroupId,\n            amount,\n            newShares,\n            _msgSender(),\n            _claim.beneficiary,\n            claimerId,\n            _lockedUntil\n        );\n    }\n    function _transferAndCheckUnderlying(address _from, uint256 _amount)\n        internal\n    {\n        uint256 balanceBefore = totalUnderlying();\n        underlying.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = totalUnderlying();\n\n        require(\n            balanceAfter == balanceBefore + _amount,\n            \"Vault: amount received does not match params\"\n        );\n    }\n    function _isIntegration(address addr) internal view returns (bool) {\n        return\n            addr.doesContractImplementInterface(type(IIntegration).interfaceId);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-sandclock-findings.json",
                "Location": "sponsor() function in Vault.sol",
                "Type": "Reentrancy",
                "Description": "In Vault.sol the sponsor() function does not have a reentrancy guard allowing an attacker to reenter the function because the depositors.mint() function has as callback to the msg.sender.",
                "Repair": "Add a reentrancy guard modifier to the sponsor() function in Vault.sol"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.10;\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n    using Counters for Counters.Counter;\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n    using Address for address;\n    using ERC165Query for address;\n    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n    uint256 public constant SHARES_MULTIPLIER = 10**18;\n    IERC20 public override(IVault) underlying;\n    IStrategy public strategy;\n    uint256 public investPerc;\n    uint256 public immutable override(IVault) minLockPeriod;\n    uint256 public override(IVaultSponsoring) totalSponsored;\n    Depositors public depositors;\n    Claimers public claimers;\n    Counters.Counter private _depositGroupIds;\n    constructor(\n        IERC20 _underlying,\n        uint256 _minLockPeriod,\n        uint256 _investPerc,\n        address _owner\n    ) Trust(_owner) {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n        require(\n            address(_underlying) != address(0x0),\n            \"VaultContext: underlying cannot be 0x0\"\n        );\n        investPerc = _investPerc;\n        underlying = _underlying;\n        minLockPeriod = _minLockPeriod;\n\n        depositors = new Depositors(address(this), \"depositors\", \"p\");\n        claimers = new Claimers(address(this));\n    }\n    function deposit(DepositParams calldata _params) external {\n        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);\n        _transferAndCheckUnderlying(_msgSender(), _params.amount);\n    }\n\n    \n    \n    function _withdrawDeposit(\n        uint256 _tokenId,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored,\n        address _to,\n        bool _force\n    ) internal returns (uint256) {\n        require(\n            depositors.ownerOf(_tokenId) == _msgSender(),\n            \"Vault: you are not the owner of a deposit\"\n        );\n\n        (\n            uint256 depositAmount,\n            uint256 claimerId,\n            uint256 lockedUntil\n        ) = depositors.deposits(_tokenId);\n        require(lockedUntil <= block.timestamp, \"Vault: deposit is locked\");\n\n        require(claimerId != 0, \"Vault: token id is not a withdraw\");\n\n        uint256 claimerShares = claimers.sharesOf(claimerId);\n\n        uint256 depositShares = _computeShares(\n            depositAmount,\n            _totalShares,\n            _totalUnderlyingMinusSponsored\n        );\n\n        if (_force && depositShares > claimerShares) {\n            depositShares = claimerShares;\n        } else if (!_force) {\n            require(\n                claimerShares >= depositShares,\n                \"Vault: cannot withdraw more than the available amount\"\n            );\n        }\n\n        claimers.onWithdraw(claimerId, depositAmount, depositShares);\n        depositors.burn(_tokenId);\n\n        address claimer = claimers.ownerOf(claimerId);\n\n        if (_isIntegration(claimer)) {\n            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);\n\n            require(ret == IIntegration(claimer).onDepositBurned.selector);\n        }\n\n        emit DepositBurned(_tokenId, depositShares, _to);\n\n        return\n            _computeAmount(\n                depositShares,\n                _totalShares,\n                _totalUnderlyingMinusSponsored\n            );\n    }\n    function _computeShares(\n        uint256 _amount,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_amount == 0) return 0;\n        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;\n\n        require(\n            _totalUnderlyingMinusSponsored > 0,\n            \"Vault: cannot compute shares when there's no principal\"\n        );\n\n        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;\n    }\n\n    \n    function _isIntegration(address addr) internal view returns (bool) {\n        return\n            addr.doesContractImplementInterface(type(IIntegration).interfaceId);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-sandclock-findings.json",
                "Location": "deposit() function in Vault.sol",
                "Type": "Reentrancy",
                "Description": "The deposit() function in Vault.sol is vulnerable to reentrancy attacks due to the lack of reentrancy guard modifiers.",
                "Repair": "Add reentrancy guard modifiers to deposit(), withdraw(), and other important protocol functions"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.7;\nimport { ITransactionManager } from \"../Interfaces/ITransactionManager.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\ncontract NXTPFacet is ILiFi, Swapper {\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.nxtp\");\n    struct Storage {ITransactionManager nxtpTxManager;}\n    event NXTPBridgeStarted(\n        bytes32 indexed lifiTransactionId,\n        bytes32 nxtpTransactionId,\n        ITransactionManager.TransactionData txData);\n    function initNXTP(ITransactionManager _txMgrAddr) external {Storage storage s = getStorage();LibDiamond.enforceIsContractOwner();s.nxtpTxManager = _txMgrAddr;}\n    function startBridgeTokensViaNXTP(LiFiData memory _lifiData, ITransactionManager.PrepareArgs memory _nxtpData) public payable{address sendingAssetId = _nxtpData.invariantData.sendingAssetId;\n        if (sendingAssetId == address(0)) require(msg.value == _nxtpData.amount, \"ERR_INVALID_AMOUNT\");\n        else {uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _nxtpData.amount);\n            require(LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _nxtpData.amount,\"ERR_INVALID_AMOUNT\");}\n        _startBridge(_lifiData.transactionId, _nxtpData);\n        emit LiFiTransferStarted(_lifiData.transactionId,_lifiData.integrator,_lifiData.referrer,_lifiData.sendingAssetId,_lifiData.receivingAssetId,_lifiData.receiver,_lifiData.amount,_lifiData.destinationChainId,block.timestamp);}\n    function swapAndStartBridgeTokensViaNXTP(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        ITransactionManager.PrepareArgs memory _nxtpData) public payable {\n        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;\n        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n        _executeSwaps(_lifiData, _swapData);\n        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;\n        require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n        _nxtpData.amount = _postSwapBalance;\n        _startBridge(_lifiData.transactionId, _nxtpData);emit LiFiTransferStarted(_lifiData.transactionId,_lifiData.integrator,_lifiData.referrer,_lifiData.sendingAssetId,_lifiData.receivingAssetId,_lifiData.receiver,_lifiData.amount,_lifiData.destinationChainId,block.timestamp);}\n    function swapAndCompleteBridgeTokensViaNXTP(LiFiData memory _lifiData,LibSwap.SwapData[] calldata _swapData,address finalAssetId,address receiver\n    ) public payable {\n        uint256 startingBalance = LibAsset.getOwnBalance(finalAssetId);_executeSwaps(_lifiData, _swapData);uint256 postSwapBalance = LibAsset.getOwnBalance(finalAssetId);uint256 finalBalance;\n        if (postSwapBalance > startingBalance) {finalBalance = postSwapBalance - startingBalance;LibAsset.transferAsset(finalAssetId, payable(receiver), finalBalance);\n        }emit LiFiTransferCompleted(_lifiData.transactionId, finalAssetId, receiver, finalBalance, block.timestamp);}}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-03-lifinance-findings.json",
                "Location": "Functions which call Swapper._executeSwap() such as NXTPFacet.swapAndStartBridgeTokensViaNXTP(), and NXTPFacet.swapAndCompleteBridgeTokensViaNXTP()",
                "Type": "Reentrancy",
                "Description": "There is a reentrancy vulnerability in functions which call Swapper._executeSwap() which would allow the attacker to change their postSwapBalance. The issue occurs since it is possible for an attacker to reenter this function during _executeSwaps(), that is because execute swap makes numerous external calls, such as to the AMM, or to untrusted ERC20 token addresses.",
                "Repair": "Add a reentrancy guard over every function which may send or receive tokens. Ensure the same slot is used to store the reentrancy guard so all required functions are covered by a single guard."
            }
        ]
    },
    {
        "Code": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"./interfaces/IERC721.sol\";\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n}\ninterface ILendingClub {\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n    function asset() external view returns (IERC20);\n    function masterContract() external view returns (address);\n    function bentoBox() external view returns (IBentoBoxV1);\n    function removeCollateral(uint256 tokenId, address to) external;}\ncontract NFTPair is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;using BoringMath128 for uint128;using RebaseLibrary for Rebase;using BoringERC20 for IERC20;\n    event LogRequestLoan(address indexed borrower, uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPair public immutable masterContract;address public feeTo;IERC721 public collateral;IERC20 public asset;uint256 public feesEarnedShare;\n    mapping(uint256 => TokenLoanParams) public tokenLoanParams;\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {address borrower;address lender;uint64 startTime;uint8 status;}\n    mapping(uint256 => TokenLoan) public tokenLoan;\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n    mapping(address => uint256) public nonces;\n    constructor(IBentoBoxV1 bentoBox_) public {bentoBox = bentoBox_;masterContract = this;}\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), \"NFTPair: already initialized\");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), \"NFTPair: bad pair\");}\n    function _requestLoan(address collateralProvider,uint256 tokenId,TokenLoanParams memory params,address to,bool skim) private {equire(tokenLoan[tokenId].status == LOAN_INITIAL, \"NFTPair: loan exists\");\n        if (skim) {require(collateral.ownerOf(tokenId) == address(this), \"NFTPair: skim failed\");\n        } else {collateral.transferFrom(collateralProvider, address(this), tokenId);}\n        TokenLoan memory loan;loan.borrower = to;loan.status = LOAN_REQUESTED;tokenLoan[tokenId] = loan;tokenLoanParams[tokenId] = params;\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS);}\n    function requestLoan(uint256 tokenId,TokenLoanParams memory params,address to,bool skim) public {_requestLoan(msg.sender, tokenId, params, to, skim);}\n    function requestAndBorrow(uint256 tokenId,address lender,address recipient,TokenLoanParams memory params,bool skimCollateral,bool anyTokenId,uint256 deadline,uint8 v,bytes32 r,bytes32 s\n    ) public {if (v == 0 && r == bytes32(0) && s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), \"NFTPair: LendingClub does not like you\");} else {\n            require(block.timestamp <= deadline, \"NFTPair: signature expired\");\n            uint256 nonce = nonces[lender]++;bytes32 dataHash = keccak256(abi.encode(LEND_SIGNATURE_HASH,address(this),anyTokenId ? 0 : tokenId,anyTokenId,params.valuation,params.duration,params.annualInterestBPS,nonce,deadline));\n            require(ecrecover(_getDigest(dataHash), v, r, s) == lender, \"NFTPair: signature invalid\");}\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);_lend(lender, tokenId, params, false);}\n    function takeCollateralAndLend(uint256 tokenId,address borrower,TokenLoanParams memory params,bool skimFunds,uint256 deadline,uint8 v,bytes32 r,bytes32 s\n    ) public {require(block.timestamp <= deadline, \"NFTPair: signature expired\");uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(abi.encode(BORROW_SIGNATURE_HASH,address(this),tokenId,params.valuation,params.duration,params.annualInterestBPS,nonce,deadline));\n        require(ecrecover(_getDigest(dataHash), v, r, s) == borrower, \"NFTPair: signature invalid\");\n        _requestLoan(borrower, tokenId, params, borrower, false);_lend(msg.sender, tokenId, params, skimFunds); }  }",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-abranft-findings.json",
                "Location": "collateral.transferFrom(collateralProvider, address(this), tokenId); in _requestLoan function",
                "Type": "Reentrancy",
                "Description": "The NFTPair contract can be reentered, and a loan can be requested without the borrower supplying the collateral.",
                "Repair": "Move the external call to the end of the function to conform with checks-effects-interaction pattern"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.9;\nimport { IAxelarGatewayMultisig } from './interfaces/IAxelarGatewayMultisig.sol';\nimport { ECDSA } from './ECDSA.sol';\nimport { AxelarGateway } from './AxelarGateway.sol';\ncontract AxelarGatewayMultisig is IAxelarGatewayMultisig, AxelarGateway {\n    error InvalidAddress();error InvalidOwners();error InvalidOwnerThreshold();error DuplicateOwner(address owner);error InvalidOperators();error InvalidOperatorThreshold();\n    error DuplicateOperator(address operator);error NotProxy();error InvalidChainId();error MalformedSigners();error InvalidCommands();\n    bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch');\n    bytes32 internal constant PREFIX_OWNER = keccak256('owner');\n    bytes32 internal constant PREFIX_OWNER_COUNT = keccak256('owner-count');\n    bytes32 internal constant PREFIX_OWNER_THRESHOLD = keccak256('owner-threshold');\n    bytes32 internal constant PREFIX_IS_OWNER = keccak256('is-owner');\n    bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch');\n    bytes32 internal constant PREFIX_OPERATOR = keccak256('operator');\n    bytes32 internal constant PREFIX_OPERATOR_COUNT = keccak256('operator-count');\n    bytes32 internal constant PREFIX_OPERATOR_THRESHOLD = keccak256('operator-threshold');\n    bytes32 internal constant PREFIX_IS_OPERATOR = keccak256('is-operator');\n    constructor(address tokenDeployer) AxelarGateway(tokenDeployer) {}\n    function execute(bytes calldata input) external override { (bytes memory data, bytes[] memory signatures) = abi.decode(input, (bytes, bytes[])); _execute(data, signatures);}\n    function _execute(bytes memory data, bytes[] memory signatures) internal {\n        uint256 signatureCount = signatures.length;\n        address[] memory signers = new address[](signatureCount);\n        for (uint256 i; i < signatureCount; i++) {\n            signers[i] = ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(data)), signatures[i]);}\n        (    uint256 chainId,\n            Role signersRole,\n            bytes32[] memory commandIds,\n            string[] memory commands,\n            bytes[] memory params) = abi.decode(data, (uint256, Role, bytes32[], string[], bytes[]));\n        if (chainId != block.chainid) revert InvalidChainId();\n        if (!_isSortedAscAndContainsNoDuplicate(signers)) revert MalformedSigners();\n        uint256 commandsLength = commandIds.length;\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n        bool areValidCurrentOwners;bool areValidRecentOwners;bool areValidRecentOperators;\n        if (signersRole == Role.Owner) {\n            areValidCurrentOwners = _areValidOwnersInEpoch(_ownerEpoch(), signers);\n            areValidRecentOwners = areValidCurrentOwners || _areValidPreviousOwners(signers);} else if (signersRole == Role.Operator) {\n            areValidRecentOperators = _areValidRecentOperators(signers);}\n        for (uint256 i; i < commandsLength; i++) {\n            bytes32 commandId = commandIds[i];\n            if (isCommandExecuted(commandId)) continue; \n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                if (!areValidRecentOwners) continue;commandSelector = AxelarGatewayMultisig.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n                commandSelector = AxelarGatewayMultisig.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n                commandSelector = AxelarGatewayMultisig.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n                commandSelector = AxelarGatewayMultisig.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n                commandSelector = AxelarGatewayMultisig.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {\n                if (!areValidCurrentOwners) continue;\n                commandSelector = AxelarGatewayMultisig.transferOwnership.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!areValidCurrentOwners) continue;\n                commandSelector = AxelarGatewayMultisig.transferOperatorship.selector;\n            } else {continue; }\n            _setCommandExecuted(commandId, true);\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n            _setCommandExecuted(commandId, success);\n            if (success) {emit Executed(commandId);}}}}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-axelar-findings.json",
                "Location": "execute function and  if (isCommandExecuted(commandId)) continue; in _executef function",
                "Type": "Reentrancy",
                "Description": "The _execute function and its wrapper execute are both reentrant. If an attacker manages to reenter the _execute function with the same batch of commands and signatures, previously successfully executed and ongoing commands will be skipped due to premature marking of the success flag. This allows later commands to be executed before the current ongoing command is finished. The reentrant attack can be nested to perform further reordering of commands.",
                "Repair": "Make execute nonReentrant, Add an ever increasing nonce to signatures to prevent replay"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.12;\ncontract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {\n    using SafeTransferLib for ERC20;\n    uint8 public constant override INTEREST_RATE_DECIMALS = 3;\n    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;\n    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);\n    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);\n    address public override lendTicketContract;\n    address public override borrowTicketContract;\n    mapping(uint256 => Loan) public loanInfo;\n    uint256 private _nonce = 1;\n    modifier notClosed(uint256 loanId) { \n        require(!loanInfo[loanId].closed, \"NFTLoanFacilitator: loan closed\");\n    }\n    constructor(address _manager) {\n        transferOwnership(_manager);\n    }\n    function lend(\n        uint256 loanId,\n        uint16 interestRate,\n        uint128 amount,\n        uint32 durationSeconds,\n        address sendLendTicketTo\n    ) external override notClosed(loanId)\n    {\n        Loan storage loan = loanInfo[loanId];\n        if (loan.lastAccumulatedTimestamp == 0) {\n          ...\n            );IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);\n        } else {\n            uint256 previousLoanAmount = loan.loanAmount;\n            uint256 amountIncrease = amount - previousLoanAmount;\n\n            {\n                uint256 previousInterestRate = loan.perAnumInterestRate;\n                uint256 previousDurationSeconds = loan.durationSeconds;\n                require(interestRate <= previousInterestRate, \"NFTLoanFacilitator: rate too high\");\n                require(durationSeconds >= previousDurationSeconds, \"NFTLoanFacilitator: duration too low\");\n                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease\n                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds \n                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0\n                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), \n                \"NFTLoanFacilitator: proposed terms must be better than existing terms\");\n            }\n            uint256 accumulatedInterest = _interestOwed(\n                previousLoanAmount,\n                loan.lastAccumulatedTimestamp,\n                loan.perAnumInterestRate,\n                loan.accumulatedInterest\n            );\n            require(accumulatedInterest <= type(uint128).max,\n            \"NFTLoanFacilitator: accumulated interest exceeds uint128\");\n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n            loan.accumulatedInterest = uint128(accumulatedInterest);\n            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);\n            if (amountIncrease > 0) { address loanAssetContractAddress = loan.loanAssetContractAddress;ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender,address(this),amount + accumulatedInterest);\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    IERC721(borrowTicketContract).ownerOf(loanId),\n                    amountIncrease - facilitatorTake\n                );\n            } else {\n                ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n            }\n            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n            \n            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);\n        }\n\n        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-backed-findings.json",
                "Location": "ERC20(loanAssetContractAddress).safeTransfer( currentLoanOwner,accumulatedInterest + previousLoanAmount); and  ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender,currentLoanOwner,accumulatedInterest + previousLoanAmount);  in lend function",
                "Type": "Reentrancy",
                "Description": "An attacker can manipulate loanInfo by reentrancy attack when any lenders try to buyout. The attacker can set bad values of lendInfo (e.g. very long duration, and 0 interest rate) that the lender who wants to buyout don't expect.",
                "Repair": "Use nonReentrant modifier on lend() to prevent reentrancy attack or block ERC777 tokens"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.12;\ncontract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {\n    using SafeTransferLib for ERC20;\n    uint8 public constant override INTEREST_RATE_DECIMALS = 3;\n    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;\n    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);\n    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);\n    mapping(uint256 => Loan) public loanInfo;\n    uint256 private _nonce = 1;\n    constructor(address _manager) {\n        transferOwnership(_manager);\n    }\n    function (\n        uint256 loanId,\n        uint16 interestRate,\n        uint128 amount,\n        uint32 durationSeconds,\n        address sendLendTicketTo\n    )\n        external\n        override\n        notClosed(loanId)\n    {\n        Loan storage loan = loanInfo[loanId];\n        \n        if (loan.lastAccumulatedTimestamp == 0) {\n            ...\n        } else {\n            uint256 previousLoanAmount = loan.loanAmount;\n            uint256 amountIncrease = amount - previousLoanAmount;\n\n            {\n                  ...\n            }\n\n            uint256 accumulatedInterest = _interestOwed(\n                previousLoanAmount,\n                loan.lastAccumulatedTimestamp,\n                loan.perAnumInterestRate,\n                loan.accumulatedInterest\n            );\n              ...\n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n            loan.accumulatedInterest = uint128(accumulatedInterest);\n\n            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);\n            if (amountIncrease > 0) {\n                address loanAssetContractAddress = loan.loanAssetContractAddress;\n                ERC20(loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amount + accumulatedInterest\n                );\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    IERC721(borrowTicketContract).ownerOf(loanId),\n                    amountIncrease - facilitatorTake\n                );\n            } else {\n                ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n            }\n            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n            \n            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);\n        }\n\n        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);\n    }\n    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {\n        Loan storage loan = loanInfo[loanId];\n\n        uint256 interest = _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n        address lender = IERC721(lendTicketContract).ownerOf(loanId);\n        loan.closed = true;\n        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            IERC721(borrowTicketContract).ownerOf(loanId),\n            loan.collateralTokenId\n        );\n\n        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);\n        emit Close(loanId);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-backed-findings.json",
                "Location": "NFTLoanFacilitator.sol#repayAndCloseLoan",
                "Type": "Reentrancy",
                "Description": "If borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest.",
                "Repair": "Move the line to transfer the lend ticket to the new lender above the line to transfer to funds to the original lender. Or, use reentrancyGuard from OpenZeppelin to remove the risk of reentrant calls completely. If desired, also require that the lender cannot be the same account as the borrower of a loan."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\ncontract YVault is ERC20, Ownable {\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n    event Deposit(address indexed depositor, uint256 wantAmount);\n    event Withdrawal(address indexed withdrawer, uint256 wantAmount);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n    ERC20 public immutable token;\n    IController public controller;\n    address public farm;\n    Rate internal availableTokensRate;\n    mapping(address => bool) public whitelistedContracts;\n    constructor(\n        address _token,\n        address _controller,\n        Rate memory _availableTokensRate\n    )\n        ERC20(\n            string(\n                abi.encodePacked(\"JPEG\\xE2\\x80\\x99d \", ERC20(_token).name())\n            ),\n            string(abi.encodePacked(\"JPEGD\", ERC20(_token).symbol()))\n        )\n    {\n        setController(_controller);\n        setAvailableTokensRate(_availableTokensRate);\n        token = ERC20(_token);\n    }\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts not allowed\"\n        );\n        _;\n    }\n    function earn() external {\n        uint256 _bal = available();\n        token.safeTransfer(address(controller), _bal);\n        controller.earn(address(token), _bal);\n    }\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n    function deposit(uint256 _amount) public noContract(msg.sender) {\n        require(_amount > 0, \"INVALID_AMOUNT\");\n        uint256 balanceBefore = balance();\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 supply = totalSupply();\n        uint256 shares;\n        if (supply == 0) {\n            shares = _amount;\n        } else {\n            //balanceBefore can't be 0 if totalSupply is > 0\n            shares = (_amount * supply) / balanceBefore;\n        }\n        _mint(msg.sender, shares);\n\n        emit Deposit(msg.sender, _amount);\n    }\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n    function withdraw(uint256 _shares) public noContract(msg.sender) {\n        require(_shares > 0, \"INVALID_AMOUNT\");\n\n        uint256 supply = totalSupply();\n        require(supply > 0, \"NO_TOKENS_DEPOSITED\");\n\n        uint256 backingTokens = (balance() * _shares) / supply;\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 vaultBalance = token.balanceOf(address(this));\n        if (vaultBalance < backingTokens) {\n            uint256 toWithdraw = backingTokens - vaultBalance;\n            controller.withdraw(address(token), toWithdraw);\n        }\n\n        token.safeTransfer(msg.sender, backingTokens);\n        emit Withdrawal(msg.sender, backingTokens);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-jpegd-findings.json",
                "Location": "yVault.sol#deposit()",
                "Type": "Reentrancy",
                "Description": "In deposit, the balance is cached and then a token.transferFrom is triggered which can lead to exploits if the token is a token that gives control to the sender, like ERC777 tokens.",
                "Repair": "Make safeTransferFrom the last call in deposit"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.6.12;\ncontract ConvexMasterChef is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt; \n\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; \n        uint256 allocPoint;\n        uint256 lastRewardBlock; \n        uint256 accCvxPerShare; \n        IRewarder rewarder;\n    }\n\n    IERC20 public immutable cvx;\n    uint256 public immutable rewardPerBlock;\n    uint256 public constant BONUS_MULTIPLIER = 2;\n    PoolInfo[] public poolInfo;\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    uint256 public totalAllocPoint = 0;\n    uint256 public immutable startBlock;\n    uint256 public immutable endBlock;\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount\n    );\n\n    constructor(\n        IERC20 _cvx,\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _endBlock\n    ) public {\n        cvx = _cvx;\n        rewardPerBlock = _rewardPerBlock;\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n    }\n    function deposit(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) {\n            uint256 pending = user\n                .amount\n                .mul(pool.accCvxPerShare)\n                .div(1e12)\n                .sub(user.rewardDebt);\n            safeRewardTransfer(msg.sender, pending);\n        }\n        pool.lpToken.safeTransferFrom(\n            address(msg.sender),\n            address(this),\n            _amount\n        );\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);\n        }\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n    function withdraw(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw: not good\");\n        updatePool(_pid);\n        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(\n            user.rewardDebt\n        );\n        safeRewardTransfer(msg.sender, pending);\n        user.amount = user.amount.sub(_amount);\n        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);\n        emit RewardPaid(msg.sender, _pid, pending);\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n    function emergencyWithdraw(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-aura-findings.json",
                "Location": "ConvexMasterChef.sol#deposit",
                "Type": "Reentrancy",
                "Description": "Reward token accounting update in deposit() and withdraw() happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future, the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.",
                "Repair": "Consider adding a direct reentrancy control, e.g. nonReentrant modifier. Also, consider finishing all internal state updates prior to external calls."
            }
        ]
    },
    {
        "Code": "pragma solidity 0.6.12;\ncontract ConvexMasterChef is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt; \n\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; \n        uint256 allocPoint;\n        uint256 lastRewardBlock; \n        uint256 accCvxPerShare; \n        IRewarder rewarder;\n    }\n\n    IERC20 public immutable cvx;\n    uint256 public immutable rewardPerBlock;\n    uint256 public constant BONUS_MULTIPLIER = 2;\n    PoolInfo[] public poolInfo;\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    uint256 public totalAllocPoint = 0;\n    uint256 public immutable startBlock;\n    uint256 public immutable endBlock;\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount\n    );\n\n    constructor(\n        IERC20 _cvx,\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _endBlock\n    ) public {\n        cvx = _cvx;\n        rewardPerBlock = _rewardPerBlock;\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n    }\n    function deposit(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) {\n            uint256 pending = user\n                .amount\n                .mul(pool.accCvxPerShare)\n                .div(1e12)\n                .sub(user.rewardDebt);\n            safeRewardTransfer(msg.sender, pending);\n        }\n        pool.lpToken.safeTransferFrom(\n            address(msg.sender),\n            address(this),\n            _amount\n        );\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);\n        }\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n    function withdraw(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw: not good\");\n        updatePool(_pid);\n        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(\n            user.rewardDebt\n        );\n        safeRewardTransfer(msg.sender, pending);\n        user.amount = user.amount.sub(_amount);\n        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);\n        emit RewardPaid(msg.sender, _pid, pending);\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n    function emergencyWithdraw(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-aura-findings.json",
                "Location": "ConvexMasterChef.sol#withdraw",
                "Type": "Reentrancy",
                "Description": "Reward token accounting update in deposit() and withdraw() happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future, the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.",
                "Repair": "Consider adding a direct reentrancy control, e.g. nonReentrant modifier. Also, consider finishing all internal state updates prior to external calls."
            }
        ]
    },
    {
        "Code": "pragma solidity =0.7.6;\ncontract BathToken {\n    using SafeMath for uint256;\n    bool public initialized;\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n    address public RubiconMarketAddress;\n    address public bathHouse;\n    address public feeTo;\n    IERC20 public underlyingToken;\n    uint256 public feeBPS;\n    uint256 public totalSupply;\n    uint256 public outstandingAmount;\n    uint256[] deprecatedStorageArray; \n    mapping(uint256 => uint256) deprecatedMapping; \n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    bytes32 public DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n    address[] public bonusTokens;\n    IBathBuddy public rewardsVestingWallet;\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); /\n        feeBPS = 3; \n        initialized = true;\n    }\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"bathToken: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n\n    function underlyingERC20() external view returns (address) {\n        return address(underlyingToken);\n    }\n\n    function underlyingBalance() public view returns (uint256) {\n        uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n        return _pool.add(outstandingAmount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-rubicon-findings.json",
                "Location": "BathToken.initialize()",
                "Type": "Reentrancy",
                "Description": "Malicious pools can be deployed through BathHouse. Reentrancy in BathToken.initialize() can be exploited and this allows to create a pool which has a legitimate underlying token (even one for which a pool already exists), and has given full approval of underlying Token to an attacker.",
                "Repair": "Add onlyBathHouse modifier to initialize function in BathToken to avoid reentrancy from malicious tokens."
            }
        ]
    },
    {
        "Code": "pragma solidity =0.7.6;\ncontract BathToken {\n    using SafeMath for uint256;\n    bool public initialized;\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n    address public RubiconMarketAddress;\n    address public bathHouse;\n    address public feeTo;\n    IERC20 public underlyingToken;\n    uint256 public feeBPS;\n    uint256 public totalSupply;\n    uint256 public outstandingAmount;\n    uint256[] deprecatedStorageArray; \n    mapping(uint256 => uint256) deprecatedMapping;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    bytes32 public DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n    address[] public bonusTokens;\n    IBathBuddy public rewardsVestingWallet;\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n        initialized = true;\n    }\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n    function deposit(uint256 assets) public returns (uint256 shares) {\n\n        return _deposit(assets, msg.sender);\n    }\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        underlyingToken.transferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); \n\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(_pool);\n        _mint(receiver, shares);\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n   \n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-rubicon-findings.json",
                "Location": "BathToken.sol#_deposit()",
                "Type": "Reentrancy",
                "Description": "There is a risk of re-entrancy attack to mint more shares due to the lack of reentrancy guard on the _deposit() function.",
                "Repair": "Add reentrancy guards or break the CEI pattern for deposits and perform the interaction first"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.10;\ncontract MIMOAutoRebalance is MIMOAutoAction, MIMOFlashloan, IMIMOAutoRebalance {\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  address public immutable mimoRebalance;\n  constructor(\n    IAddressProvider _a,\n    IPool _lendingPool,\n    IMIMOProxyRegistry _proxyRegistry,\n    address _mimoRebalance\n  ) MIMOAutoAction(_a, _proxyRegistry) MIMOFlashloan(_lendingPool) {\n    if (_mimoRebalance == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    mimoRebalance = _mimoRebalance;\n  }\n\n  function rebalance(uint256 vaultId, IMIMOSwap.SwapData calldata swapData) external override {\n    AutomatedVault memory autoVault = _automatedVaults[vaultId];\n\n    (uint256 vaultARatioBefore, VaultState memory vaultAState) = _getVaultStats(vaultId);\n\n    _preRebalanceChecks(autoVault, vaultId, vaultARatioBefore);\n\n    IVaultsDataProvider vaultsData = a.vaultsData();\n    address vaultOwner = vaultsData.vaultOwner(vaultId);\n    uint256 vaultBId = vaultsData.vaultId(address(autoVault.toCollateral), vaultOwner);\n    uint256 vaultBBalanceBefore = vaultsData.vaultCollateralBalance(vaultBId);\n\n    (IMIMORebalance.RebalanceData memory rbData, FlashLoanData memory flData, uint256 autoFee) = _getRebalanceParams(\n      autoVault,\n      vaultAState,\n      IERC20(autoVault.toCollateral),\n      vaultId\n    );\n\n    _takeFlashLoan(flData, abi.encode(vaultOwner, autoFee, rbData, swapData));\n    _postRebalanceChecks(autoVault, flData.amount, vaultBBalanceBefore, vaultId, vaultOwner, vaultsData);\n\n    _operationTracker[vaultId] = block.timestamp;\n\n    IERC20(a.stablex()).safeTransfer(msg.sender, autoFee);\n  }\n\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (\n      address mimoProxy,\n      uint256 managerFee,\n      IMIMORebalance.RebalanceData memory rbData,\n      IMIMOSwap.SwapData memory swapData\n    ) = abi.decode(params, (address, uint256, IMIMORebalance.RebalanceData, IMIMOSwap.SwapData));\n\n    if (initiator != address(this)) {\n      revert CustomErrors.INITIATOR_NOT_AUTHORIZED(initiator, address(this));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert CustomErrors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 fromCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    fromCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      mimoRebalance,\n      abi.encodeWithSignature(\n        \"rebalanceOperation(address,uint256,uint256,uint256,(address,uint256,uint256),(uint256,bytes))\",\n        fromCollateral,\n        amount,\n        flashloanRepayAmount,\n        managerFee,\n        rbData,\n        swapData\n      )\n    );\n\n    fromCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  function _getAmounts(\n    AutomatedVault memory autoVault,\n    VaultState memory vaultState,\n    address toCollateral\n  )\n    internal\n    view\n    returns (\n      uint256 rebalanceAmount,\n      uint256 mintAmount,\n      uint256 autoFee\n    )\n  {\n    IAddressProvider _a = a;\n\n    uint256 targetRatio = autoVault.targetRatio + 1e15; // add 0.1% to account for rounding\n    uint256 toVaultMcr = _a.config().collateralMinCollateralRatio(address(toCollateral));\n    uint256 rebalanceValue = (targetRatio.wadMul(vaultState.vaultDebt + autoVault.fixedFee) -\n      vaultState.collateralValue).wadDiv(\n        (targetRatio.wadDiv(toVaultMcr + autoVault.mcrBuffer) - targetRatio.wadMul(autoVault.varFee) - WadRayMath.WAD)\n      );\n    autoFee = autoVault.fixedFee + rebalanceValue.wadMul(autoVault.varFee);\n    rebalanceAmount = _a.priceFeed().convertTo(vaultState.collateralType, rebalanceValue);\n    mintAmount = rebalanceValue.wadDiv(toVaultMcr + autoVault.mcrBuffer) - autoFee;\n  }\n  function _preRebalanceChecks(\n    AutomatedVault memory autoVault,\n    uint256 vaultId,\n    uint256 vaultARatio\n  ) internal view {\n    if (!autoVault.isAutomated) {\n      revert CustomErrors.VAULT_NOT_AUTOMATED();\n    }\n    if (_operationTracker[vaultId] > block.timestamp - 1 days) {\n      revert CustomErrors.MAX_OPERATIONS_REACHED();\n    }\n    if (vaultARatio > autoVault.triggerRatio) {\n      revert CustomErrors.VAULT_TRIGGER_RATIO_NOT_REACHED(vaultARatio, autoVault.triggerRatio);\n    }\n  }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-08-mimo-findings.json",
                "Location": "MIMOAutoRebalance.sol#rebalance",
                "Type": "Reentrancy",
                "Description": "An attacker can exploit the vulnerability to steal funds by swapping through a malicious token that transfers control to the caller.",
                "Repair": "Add nonReentrant modifier to the function"
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.6;\ncontract Community is\n    ICommunity,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n\n    using SafeERC20Upgradeable for IDebtToken;\n\n    address internal tokenCurrency1;\n    address internal tokenCurrency2;\n    address internal tokenCurrency3;\n\n    mapping(uint256 => CommunityStruct) internal _communities;\n\n    IHomeFi public override homeFi;\n    bool public override restrictedToAdmin;\n\n    uint256 public override communityCount;\n\n    mapping(address => uint256) public override projectPublished;\n\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n    modifier nonZero(address _address) {\n        require(_address != address(0), \"Community::0 address\");\n        _;\n    }\n\n    modifier onlyHomeFiAdmin() {\n        require(_msgSender() == homeFi.admin(), \"Community::!admin\");\n        _;\n    }\n\n    modifier isPublishedToCommunity(uint256 _communityID, address _project) {\n        // Revert if _project is not published to _communityID\n        require(\n            projectPublished[_project] == _communityID,\n            \"Community::!published\"\n        );\n        _;\n    }\n\n    modifier onlyProjectBuilder(address _project) {\n  \n        require(\n            _msgSender() == IProject(_project).builder(),\n            \"Community::!Builder\"\n        );\n        _;\n    }\n\n\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n\n        __Pausable_init();\n\n  \n        homeFi = IHomeFi(_homeFi);\n        tokenCurrency1 = homeFi.tokenCurrency1();\n        tokenCurrency2 = homeFi.tokenCurrency2();\n        tokenCurrency3 = homeFi.tokenCurrency3();\n\n        restrictedToAdmin = true;\n    }\n\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        override\n        whenNotPaused\n    {\n        address _sender = _msgSender();\n        require(\n            !restrictedToAdmin || _sender == homeFi.admin(),\n            \"Community::!admin\"\n        );\n\n        homeFi.validCurrency(_currency);\n\n        communityCount++;\n\n        CommunityStruct storage _community = _communities[communityCount];\n        _community.owner = _sender;\n        _community.currency = IDebtToken(_currency);\n        _community.memberCount = 1;\n        _community.members[0] = _sender;\n        _community.isMember[_sender] = true;\n\n        emit CommunityAdded(communityCount, _sender, _currency, _hash);\n    }\n\n \n    function escrow(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        (\n            uint256 _communityID,\n            address _builder,\n            address _lender,\n            address _agent,\n            address _project,\n            uint256 _repayAmount,\n            bytes memory _details\n        ) = abi.decode(\n                _data,\n                (uint256, address, address, address, address, uint256, bytes)\n            );\n        bytes32 _hash = keccak256(_data);\n        IProject _projectInstance = IProject(_project);\n        require(_builder == _projectInstance.builder(), \"Community::!Builder\");\n        require(\n            _lender == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n        checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be builder\n        checkSignatureValidity(_agent, _hash, _signature, 2); \n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n        emit DebtReducedByEscrow(_agent);\n    }\n\n  \n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-08-rigor-findings.json",
                "Location": "Community.sol#L509",
                "Type": "Reentrancy",
                "Description": "Builder can call Community.escrow again to reduce debt further using same signatures.",
                "Repair": "Add a new field into the ProjectDetails struct called escrowNonce and modify function escrow to check this nonce and update it after the debt has been reduced."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-10-inverse-findings.json",
                "Location": "withdrawInternal function in Market.sol",
                "Type": "Reentrancy",
                "Description": "ERC777 reentrancy when withdrawing can be used to withdraw all collateral",
                "Repair": "Mark the affected functions as nonReentrant"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-11-stakehouse-findings.json",
                "Location": "GiantMevAndFeesPool.claimRewards()",
                "Type": "Reentrancy",
                "Description": "GiantMevAndFeesPool.claimRewards() is vulnerable to reentrancy attack as GiantMevAndFeesPool.claimRewards() does not have the nonReentrant modifier. This allows the user to call any function in the fallback.",
                "Repair": "Add 'idleETH -= _amount' before sending ETH to the user"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\ncontract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n    event LPBurnedForDETH(address indexed savETHVaultLPToken, address indexed sender, uint256 amount);\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(0), \"GiantETHLP\", \"gETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n    function withdrawDETH(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                LPToken token = _lpTokens[i][j];\n                uint256 amount = _amounts[i][j];\n\n                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");\n\n               \n                lpTokenETH.burn(msg.sender, amount);\n\n                emit LPBurnedForDETH(address(token), msg.sender, amount);\n            }\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;\n        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n    }\n    function batchRotateLPTokens(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _savETHVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            SavETHVault(_savETHVaults[i]).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n  \n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-11-stakehouse-findings.json",
                "Location": "function withdrawDETH in GiantSavETHVaultPool",
                "Type": "Reentrancy",
                "Description": "Possible reentrancy and fund theft in withdrawDETH() of GiantSavETHVaultPool because there is no whitelist check for user provided Vaults and there is no reentrancy defense.",
                "Repair": "Check the provided addresses and have some reentrancy defense mechanism"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n    event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n    event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n    event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n    event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n    event WalletCredited(address indexed smartWallet, uint256 amount);\n    event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n    event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n    event StakehouseJoined(bytes blsPubKey);\n    event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n    event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n    event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n    event NetworkTickerUpdated(string newTicker);\n    event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n    event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n    event NodeRunnerBanned(address indexed nodeRunner);\n    event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n    event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n    event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n    address public brand;\n    address public override stakehouse;\n    address public syndicate;\n    address public dao;\n    OptionalHouseGatekeeper public gatekeeper;\n    ISyndicateFactory public syndicateFactory;\n    IOwnableSmartWalletFactory public smartWalletFactory;\n    string public stakehouseTicker;\n    StakingFundsVault public stakingFundsVault;\n    SavETHVault public savETHVault;\n    bool public enableWhitelisting;\n    mapping(address => bool) public isNodeRunnerWhitelisted;\n    mapping(address => address) public smartWalletRepresentative;\n    mapping(bytes => address) public smartWalletOfKnot;\n    mapping(address => address) public smartWalletOfNodeRunner;\n    mapping(address => address) public nodeRunnerOfSmartWallet;\n    mapping(address => uint256) public stakedKnotsOfSmartWallet;\n    mapping(address => address) public smartWalletDormantRepresentative;\n    mapping(bytes => address) public bannedBLSPublicKeys;\n    mapping(address => bool) public bannedNodeRunners;\n    uint256 public numberOfKnots;\n    uint256 public daoCommissionPercentage;\n    uint256 public MODULO = 100_00000;\n\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Must be DAO\");\n        _;\n    }\n    constructor() initializer {}\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external virtual override initializer {\n        _init(\n            _dao,\n            _syndicateFactory,\n            _smartWalletFactory,\n            _lpTokenFactory,\n            _brand,\n            _savETHVaultDeployer,\n            _stakingFundsVaultDeployer,\n            _optionalGatekeeperDeployer,\n            _optionalCommission,\n            _deployOptionalGatekeeper,\n            _stakehouseTicker\n        );\n    }\n\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-11-stakehouse-findings.json",
                "Location": "withdrawETHForKnot function in LiquidStakingManager.sol",
                "Type": "Reentrancy",
                "Description": "The reentrancy bug in the withdrawETHForKnot function allows a node runner to reenter the LiquidStakingManager and stake deposited funds from the vaults before the BLS key is banned, causing a permanent freeze of user funds and making the protocol insolvent.",
                "Repair": "Use mutex locks to prevent reentrancy or use the Checks-Effects-Interactions pattern to ensure that all state changes are made before any external calls are made"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n    event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n    event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n    event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n    event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n    event WalletCredited(address indexed smartWallet, uint256 amount);\n    event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n    event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n    event StakehouseJoined(bytes blsPubKey);\n    event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n    event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n    event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n    event NetworkTickerUpdated(string newTicker);\n    event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n    event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n    event NodeRunnerBanned(address indexed nodeRunner);\n    event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n    event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n    event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n    address public brand;\n    address public override stakehouse;\n    address public syndicate;\n    address public dao;\n    OptionalHouseGatekeeper public gatekeeper;\n    ISyndicateFactory public syndicateFactory;\n    IOwnableSmartWalletFactory public smartWalletFactory;\n    string public stakehouseTicker;\n    StakingFundsVault public stakingFundsVault;\n    SavETHVault public savETHVault;\n    bool public enableWhitelisting;\n    mapping(address => bool) public isNodeRunnerWhitelisted;\n    mapping(address => address) public smartWalletRepresentative;\n    mapping(bytes => address) public smartWalletOfKnot;\n    mapping(address => address) public smartWalletOfNodeRunner;\n    mapping(address => address) public nodeRunnerOfSmartWallet;\n    mapping(address => uint256) public stakedKnotsOfSmartWallet;\n    mapping(address => address) public smartWalletDormantRepresentative;\n    mapping(bytes => address) public bannedBLSPublicKeys;\n    mapping(address => bool) public bannedNodeRunners;\n    uint256 public numberOfKnots;\n    uint256 public daoCommissionPercentage;\n    uint256 public MODULO = 100_00000;\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Must be DAO\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc ILiquidStakingManager\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external virtual override initializer {\n        _init(\n            _dao,\n            _syndicateFactory,\n            _smartWalletFactory,\n            _lpTokenFactory,\n            _brand,\n            _savETHVaultDeployer,\n            _stakingFundsVaultDeployer,\n            _optionalGatekeeperDeployer,\n            _optionalCommission,\n            _deployOptionalGatekeeper,\n            _stakehouseTicker\n        );\n    }\n\n\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n\n    \n    function _initSavETHVault(address _savETHVaultDeployer, address _lpTokenFactory) internal virtual {\n        // Use an external deployer to reduce the size of the liquid staking manager\n        savETHVault = SavETHVault(\n            SavETHVaultDeployer(_savETHVaultDeployer).deploySavETHVault(address(this), _lpTokenFactory)\n        );\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-11-stakehouse-findings.json",
                "Location": "LiquidStakingManager.sol#withdrawETHForKnot",
                "Type": "Reentrancy",
                "Description": "The _recipient is a smart contract, it can re-enter the withdraw function to withdraw another 4 ETH multiple times before the public key is banned.",
                "Repair": "Ban the public key first then send the fund out, and use openzeppelin nonReentrant modifier to avoid reentrancy."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.17;\ncontract Pair is ERC20, ERC721TokenReceiver {\n    using SafeTransferLib for address;\n    using SafeTransferLib for ERC20;\n\n    uint256 public constant ONE = 1e18;\n    uint256 public constant CLOSE_GRACE_PERIOD = 7 days;\n\n    address public immutable nft;\n    address public immutable baseToken; // address(0) for ETH\n    bytes32 public immutable merkleRoot;\n    LpToken public immutable lpToken;\n    Caviar public immutable caviar;\n    uint256 public closeTimestamp;\n\n    event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Buy(uint256 inputAmount, uint256 outputAmount);\n    event Sell(uint256 inputAmount, uint256 outputAmount);\n    event Wrap(uint256[] tokenIds);\n    event Unwrap(uint256[] tokenIds);\n    event Close(uint256 closeTimestamp);\n    event Withdraw(uint256 tokenId);\n\n    constructor(\n        address _nft,\n        address _baseToken,\n        bytes32 _merkleRoot,\n        string memory pairSymbol,\n        string memory nftName,\n        string memory nftSymbol\n    ) ERC20(string.concat(nftName, \" fractional token\"), string.concat(\"f\", nftSymbol), 18) {\n        nft = _nft;\n        baseToken = _baseToken; \n        merkleRoot = _merkleRoot;\n        lpToken = new LpToken(pairSymbol);\n        caviar = Caviar(msg.sender);\n    }\n    function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)\n        public\n        payable\n        returns (uint256 lpTokenAmount)\n    {\n        require(baseTokenAmount > 0 && fractionalTokenAmount > 0, \"Input token amount is zero\");\n        require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, \"Invalid ether input\");\n        lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);\n        require(lpTokenAmount >= minLpTokenAmount, \"Slippage: lp token amount out\");\n        _transferFrom(msg.sender, address(this), fractionalTokenAmount);\n        lpToken.mint(msg.sender, lpTokenAmount);\n        if (baseToken != address(0)) {\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n        }\n\n        emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);\n    }\n\n    function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n        require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\n        inputAmount = buyQuote(outputAmount);\n        require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\n        _transferFrom(address(this), msg.sender, outputAmount);\n        if (baseToken == address(0)) {\n            uint256 refundAmount = maxInputAmount - inputAmount;\n            if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);\n        } else {\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n        }\n        emit Buy(inputAmount, outputAmount);\n    }\n\n    function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {\n        outputAmount = sellQuote(inputAmount);\n        require(outputAmount >= minOutputAmount, \"Slippage: amount out\");\n        _transferFrom(msg.sender, address(this), inputAmount);\n\n        if (baseToken == address(0)) {\n            msg.sender.safeTransferETH(outputAmount);\n        } else {\n\n            ERC20(baseToken).safeTransfer(msg.sender, outputAmount);\n        }\n        emit Sell(inputAmount, outputAmount);\n    }\n    function _transferFrom(address from, address to, uint256 amount) internal returns (bool) {\n        balanceOf[from] -= amount;\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n    function _baseTokenReserves() internal view returns (uint256) {\n        return baseToken == address(0)\n            ? address(this).balance - msg.value \n            : ERC20(baseToken).balanceOf(address(this));\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-12-caviar-findings.json",
                "Location": "buy and sell functions in Pair.sol",
                "Type": "Reentrancy",
                "Description": "Current implementation of functions add, remove, buy and sell first transfer fractional tokens, and then base tokens. Allows to drain funds of a pairs which implements an ERC-777 token.",
                "Repair": "Add OpenZeppelin nonReentrant modifier to mentioned functions, or state clear in the documentation that this protocol should not be used with ERC777 tokens."
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; \ncontract Position is ERC721Enumerable, MetaContext, IPosition { \n \n    function ownerOf(uint _id) public view override(ERC721, IERC721, IPosition) returns (address) { \n        return ERC721.ownerOf(_id); \n    } \n    using Counters for Counters.Counter; \n    uint constant public DIVISION_CONSTANT = 1e10; \n    mapping(uint => mapping(address => uint)) public vaultFundingPercent; \n    mapping(address => bool) private _isMinter; \n    mapping(uint256 => Trade) private _trades; \n    uint256[] private _openPositions; \n    mapping(uint256 => uint256) private _openPositionsIndexes; \n    mapping(uint256 => uint256[]) private _assetOpenPositions; \n    mapping(uint256 => mapping(uint256 => uint256)) private _assetOpenPositionsIndexes; \n    mapping(uint256 => uint256[]) private _limitOrders; \n    mapping(uint256 => mapping(uint256 => uint256)) private _limitOrderIndexes;\n    mapping(uint256 => mapping(address => int256)) public fundingDeltaPerSec; \n    mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi; \n    mapping(uint256 => mapping(address => uint256)) private lastUpdate; \n    mapping(uint256 => int256) private initId; \n    mapping(uint256 => mapping(address => uint256)) private longOi; \n    mapping(uint256 => mapping(address => uint256)) private shortOi; \n    function isMinter(address _address) public view returns (bool) { return _isMinter[_address]; } \n    function openPositions() public view returns (uint256[] memory) { return _openPositions; } \n    function openPositionsIndexes(uint _id) public view returns (uint256) { return _openPositionsIndexes[_id]; } \n    function assetOpenPositions(uint _asset) public view returns (uint256[] memory) { return _assetOpenPositions[_asset]; } \n    function assetOpenPositionsIndexes(uint _asset, uint _id) public view returns (uint256) { return _assetOpenPositionsIndexes[_asset][_id]; } \n    function limitOrders(uint _asset) public view returns (uint256[] memory) { return _limitOrders[_asset]; } \n    function limitOrderIndexes(uint _asset, uint _id) public view returns (uint256) { return _limitOrderIndexes[_asset][_id]; } \n    Counters.Counter private _tokenIds; \n    string public baseURI; \n    constructor(string memory _setBaseURI, string memory _name, string memory _symbol) ERC721(_name, _symbol) { \n        baseURI = _setBaseURI; \n        _tokenIds.increment(); \n    } \n    function mint( \n        MintTrade memory _mintTrade \n    ) external onlyMinter { \n        uint newTokenID = _tokenIds.current(); \n        Trade storage newTrade = _trades[newTokenID]; \n        newTrade.margin = _mintTrade.margin; \n        newTrade.leverage = _mintTrade.leverage; \n        newTrade.asset = _mintTrade.asset; \n        newTrade.direction = _mintTrade.direction; \n        newTrade.price = _mintTrade.price; \n        newTrade.tpPrice = _mintTrade.tp; \n        newTrade.slPrice = _mintTrade.sl; \n        newTrade.orderType = _mintTrade.orderType; \n        newTrade.id = newTokenID; \n        newTrade.tigAsset = _mintTrade.tigAsset; \n        _safeMint(_mintTrade.account, newTokenID); \n        if (_mintTrade.orderType > 0) { \n            _limitOrders[_mintTrade.asset].push(newTokenID); \n            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1; \n        } else { \n            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18; \n            _openPositions.push(newTokenID); \n            _openPositionsIndexes[newTokenID] = _openPositions.length-1; \n \n            _assetOpenPositions[_mintTrade.asset].push(newTokenID); \n            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1; \n        } \n        _tokenIds.increment(); \n    } \n    modifier onlyMinter() { \n        require(_isMinter[_msgSender()], \"!Minter\"); \n        _; \n    }  \n    function _msgSender() internal view override(Context, MetaContext) returns (address sender) { \n        return MetaContext._msgSender(); \n    } \n    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) { \n        return MetaContext._msgData(); \n    } \n} ",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-12-tigris-findings.json",
                "Location": "Position contract's mint() function",
                "Type": "Reentrancy",
                "Description": "The mint() function in the Position contract doesn't follow check-effect-interaction pattern and it's possible to perform reentrancy attack during mint() function which can lead to removing of the other user's limit orders or stealing contract funds because initId is set low value.",
                "Repair": "Follow the check-effect-interaction pattern"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0; \ncontract BondNFT is ERC721Enumerable, Ownable {  \n    uint constant private DAY = 24 * 60 * 60; \n    struct Bond { \n        uint id; \n        address owner; \n        address asset; \n        uint amount; \n        uint mintEpoch; \n        uint mintTime; \n        uint expireEpoch; \n        uint pending; \n        uint shares; \n        uint period; \n        bool expired; \n    } \n    mapping(address => uint256) public epoch; \n    uint private totalBonds; \n    string public baseURI; \n    address public manager; \n    address[] public assets; \n    mapping(address => bool) public allowedAsset; \n    mapping(address => uint) private assetsIndex; \n    mapping(uint256 => mapping(address => uint256)) private bondPaid; \n    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare \n    mapping(uint => Bond) private _idToBond; \n    mapping(address => uint) public totalShares; \n    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount \n    constructor( \n        string memory _setBaseURI, \n        string memory _name, \n        string memory _symbol \n    ) ERC721(_name, _symbol) { \n        baseURI = _setBaseURI; \n    } \n    function claim( \n        uint _id, \n        address _claimer \n    ) public onlyManager() returns(uint amount, address tigAsset) { \n        Bond memory bond = idToBond(_id); \n        require(_claimer == bond.owner, \"!owner\"); \n        amount = bond.pending; \n        tigAsset = bond.asset; \n        unchecked { \n            if (bond.expired) { \n                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]); \n                if (totalShares[bond.asset] > 0) { \n                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset]; \n                } \n            } \n            bondPaid[_id][bond.asset] += amount; \n        } \n        IERC20(tigAsset).transfer(manager, amount); \n        emit ClaimFees(tigAsset, amount, _claimer, _id); \n    } \n \n\n    function claimDebt( \n        address _user, \n        address _tigAsset \n    ) public onlyManager() returns(uint amount) { \n        amount = userDebt[_user][_tigAsset]; \n        userDebt[_user][_tigAsset] = 0; \n        IERC20(_tigAsset).transfer(manager, amount); \n        emit ClaimDebt(_tigAsset, amount, _user); \n    } \n    function _mint( \n        address to, \n        Bond memory bond \n    ) internal { \n        unchecked { \n            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18; \n        } \n        _mint(to, bond.id); \n    } \n \n    function _burn( \n        uint256 _id \n    ) internal override { \n        delete _idToBond[_id]; \n        super._burn(_id); \n    } \n    function _transfer( \n        address from, \n        address to, \n        uint256 _id \n    ) internal override { \n        Bond memory bond = idToBond(_id); \n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\"); \n        require(!bond.expired, \"Expired!\"); \n        unchecked { \n            require(block.timestamp > bond.mintTime + 300, \"Recent update\"); \n            userDebt[from][bond.asset] += bond.pending; \n            bondPaid[_id][bond.asset] += bond.pending; \n        } \n        super._transfer(from, to, _id); \n    } \n    function setBaseURI(string calldata _newBaseURI) external onlyOwner { \n        baseURI = _newBaseURI; \n    } \n    modifier onlyManager() { \n        require(msg.sender == manager, \"!manager\"); \n        _; \n    } \n    event Distribution(address _tigAsset, uint256 _amount); \n    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id); \n    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id); \n    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id); \n    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id); \n    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner); \n} ",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-12-tigris-findings.json",
                "Location": "BondNFT.claim() function",
                "Type": "Reentrancy",
                "Description": "A malicious user can exploit this vulnerability to steal all assets in BondNFT contract by repeatedly calling claim() function of an expired bond, which updates accRewardsPerShare and increases pending rewards of all other users.",
                "Repair": "Forcing an expired bond to release() and adding a check to claim() function to revert if an expired bond is claimed"
            }
        ]
    }
]