[
    {
        "Code": "function swapWithSynthsWithLimit(uint inputAmount, address inputToken, bool inSynth, address outputToken, bool outSynth, uint slipLimit) public returns (uint outputAmount) {\n        address _member = msg.sender;\n        if(!inSynth){\n            moveTokenToPools(inputToken, inputAmount);\n        } else {\n            moveTokenToPools(iPOOLS(POOLS).getSynth(inputToken), inputAmount);\n        }\n        address _base;\n        if(iPOOLS(POOLS).isAnchor(inputToken) || iPOOLS(POOLS).isAnchor(outputToken)) {\n            _base = VADER;\n        } else {\n            _base = USDV;\n        }\n        if (isBase(outputToken)) {\n            // Token||Synth -> BASE\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, inputToken, _member, true);\n            } else {\n                outputAmount = iPOOLS(POOLS).burnSynth(_base, inputToken, _member);\n            }\n        } else if (isBase(inputToken)) {\n            // BASE -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        } else if (!isBase(inputToken) && !isBase(outputToken)) {\n            // Token||Synth -> Token||Synth\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getTokenAmount(inputToken)) <= slipLimit);\n            if(!inSynth){\n                iPOOLS(POOLS).swap(_base, inputToken, POOLS, true);\n            } else {\n                iPOOLS(POOLS).burnSynth(_base, inputToken, POOLS);\n            }\n            require(iUTILS(UTILS()).calcSwapSlip(inputAmount, iPOOLS(POOLS).getBaseAmount(outputToken)) <= slipLimit);\n            if(!outSynth){\n                outputAmount = iPOOLS(POOLS).swap(_base, outputToken, _member, false);\n            } else {\n                outputAmount = iPOOLS(POOLS).mintSynth(_base, outputToken, _member);\n            }\n        }\n        _handlePoolReward(_base, inputToken);\n        _handlePoolReward(_base, outputToken);\n        _handleAnchorPriceUpdate(inputToken);\n        _handleAnchorPriceUpdate(outputToken); \n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-04-vader#h-15-wrong-slippage-protection-on-token---token-trades",
                "Location": "require(iUTILS(UTILS()).calcSwapSlip(\n    inputAmount, // should use outToken here from prev trade\n    iPOOLS(POOLS).getBaseAmount(outputToken)\n  ) <= slipLimit\n);",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The Router.swapWithSynthsWithLimit allows trading token to token and specifying slippage protection. A token to token trade consists of two trades: token to base base to token The slippage protection of the second trade (base to token) is computed wrong. It compares the token input amount (of the first trade) to the base reserve of the second pair. Slippage protection fails and either the trade is cancelled when it shouldn\ufffd\ufffdt be or it is accepted even though the user suffered more losses than expected. Recommend it should use the base output from the first trade to check for slippage protection. Note that this still just computes the slippage protection of each trade individually. An even better way would be to come up with a formula to compute the slippage on the two trades at once.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"../Interfaces/IOracle.sol\";\nimport \"../Interfaces/IChainlinkOracle.sol\";\nimport \"../lib/LibMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\n/**\n * @dev The following is a sample Gas Price Oracle Implementation for a Tracer Oracle.\n *      It references the Chainlink fast gas price and ETH/USD price to get a gas cost\n *      estimate in USD.\n */\ncontract GasOracle is IOracle, Ownable {\n    using LibMath for uint256;\n    IChainlinkOracle public gasOracle;\n    IChainlinkOracle public priceOracle;\n    uint8 public override decimals = 18;\n    uint256 private constant MAX_DECIMALS = 18;\n\n    constructor(address _priceOracle, address _gasOracle) {\n        gasOracle = IChainlinkOracle(_gasOracle); /* Gas cost oracle */\n        priceOracle = IChainlinkOracle(_priceOracle); /* Quote/ETH oracle */\n    }\n\n    /**\n     * @notice Calculates the latest USD/Gas price\n     * @dev Returned value is USD/Gas * 10^18 for compatibility with rest of calculations\n     */\n    function latestAnswer() external view override returns (uint256) {\n        uint256 gasPrice = uint256(gasOracle.latestAnswer());\n        uint256 ethPrice = uint256(priceOracle.latestAnswer());\n\n        uint256 result = PRBMathUD60x18.mul(gasPrice, ethPrice);\n        return result;\n    }\n\n    /**\n     * @notice converts a raw value to a WAD value.\n     * @dev this allows consistency for oracles used throughout the protocol\n     *      and allows oracles to have their decimals changed withou affecting\n     *      the market itself\n     */\n    function toWad(uint256 raw, IChainlinkOracle _oracle) internal view returns (uint256) {\n        IChainlinkOracle oracle = IChainlinkOracle(_oracle);\n        // reset the scaler for consistency\n        uint8 _decimals = oracle.decimals(); // 9\n        require(_decimals <= MAX_DECIMALS, \"GAS: too many decimals\");\n        uint256 scaler = uint256(10**(MAX_DECIMALS - _decimals));\n        return raw * scaler;\n    }\n\n    function setGasOracle(address _gasOracle) public onlyOwner {\n        require(_gasOracle != address(0), \"address(0) given\");\n        gasOracle = IChainlinkOracle(_gasOracle);\n    }\n\n    function setPriceOracle(address _priceOracle) public onlyOwner {\n        require(_priceOracle != address(0), \"address(0) given\");\n        priceOracle = IChainlinkOracle(_priceOracle);\n    }\n\n    function setDecimals(uint8 _decimals) external {\n        decimals = _decimals;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-06-tracer#h-06-wrong-price-scale-for-gasoracle",
                "Location": "    constructor(address _priceOracle, address _gasOracle) {\n        gasOracle = IChainlinkOracle(_gasOracle); /* Gas cost oracle */\n        priceOracle = IChainlinkOracle(_priceOracle); /* Quote/ETH oracle */\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The GasOracle uses two chainlink oracles (GAS in ETH with some decimals, USD per ETH with some decimals) and multiplies their raw return values to get the gas price in USD. However, the scaling depends on the underlying decimals of the two oracles and could be anything. But the code assumes it\ufffd\ufffds in 18 decimals. \ufffd\ufffdReturned value is USD/Gas * 10^18 for compatibility with rest of calculations\ufffd\ufffd There is a toWad function that seems to involve scaling but it is never used. The impact is that, If the scale is wrong, the gas price can be heavily inflated or under-reported. Recommend checking chainlink.decimals() to know the decimals of the oracle answers and scale the answers to 18 decimals such that no matter the decimals of the underlying oracles, the latestAnswer function always returns the answer in 18 decimals.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "   function setCap(\n        address _vault,\n        address _strategy,\n        uint256 _cap,\n        address _convert\n    )\n        external\n        notHalted\n        onlyStrategist\n        onlyStrategy(_strategy)\n    {\n        _vaultDetails[_vault].caps[_strategy] = _cap;\n        uint256 _balance = IStrategy(_strategy).balanceOf();\n        // send excess funds (over cap) back to the vault\n        if (_balance > _cap && _cap != 0) {\n            uint256 _diff = _balance.sub(_cap);\n            IStrategy(_strategy).withdraw(_diff);\n            updateBalance(_vault, _strategy);\n            _balance = IStrategy(_strategy).balanceOf();\n            _vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_diff);\n            address _want = IStrategy(_strategy).want();\n            _balance = IERC20(_want).balanceOf(address(this));\n            if (_convert != address(0)) {\n                IConverter _converter = IConverter(_vaultDetails[_vault].converter);\n                IERC20(_want).safeTransfer(address(_converter), _balance);\n                _balance = _converter.convert(_want, _convert, _balance, 1);\n                IERC20(_convert).safeTransfer(_vault, _balance);\n            } else {\n                IERC20(_want).safeTransfer(_vault, _balance);\n            }\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-yaxis#h-01-controllersetcap-sets-wrong-vault-balance",
                "Location": "_vaultDetails[_vault].balance = _vaultDetails[_vault].balance.sub(_balance);",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The Controller.setCap function sets a cap for a strategy and withdraws any excess amounts (_diff). The vault balance is decreased by the entire strategy balance instead of by this _diff",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function balanceOfThis()\n        public\n        view\n        returns (uint256 _balance)\n    {\n        address[] memory _tokens = manager.getTokens(address(this));\n        for (uint8 i; i < _tokens.length; i++) {\n            address _token = _tokens[i];\n            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-yaxis#h-07-vaultbalance-mixes-normalized-and-standard-amounts",
                "Location": "for (uint8 i; i < _tokens.length; i++) {\n    address _token = _tokens[i];\n    // everything is padded to 18 decimals\n    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The Vault.balance function uses the balanceOfThis function which scales (\ufffd\ufffdnormalizes\ufffd\ufffd) all balances to 18 decimals. Note that balance()\ufffd\ufffds second term IController(manager.controllers(address(this))).balanceOf() is not normalized. The code is adding a non-normalized amount (for example 6 decimals only for USDC) to a normalized (18 decimals).",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function balanceOfThis()\n        public\n        view\n        returns (uint256 _balance)\n    {\n        address[] memory _tokens = manager.getTokens(address(this));\n        for (uint8 i; i < _tokens.length; i++) {\n            address _token = _tokens[i];\n            _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-yaxis#h-08-vaultwithdraw-mixes-normalized-and-standard-amounts",
                "Location": "// @audit compares unnormalzied output to normalized output\nif (_balance < _amount) {\n    IController _controller = IController(manager.controllers(address(this)));\n    // @audit cannot directly subtract unnormalized\n    uint256 _toWithdraw = _amount.sub(_balance);\n    if (_controller.strategies() > 0) {\n        _controller.withdraw(_output, _toWithdraw);\n    }\n    uint256 _after = IERC20(_output).balanceOf(address(this));\n    uint256 _diff = _after.sub(_balance);\n    if (_diff < _toWithdraw) {\n        _amount = _balance.add(_diff);\n    }\n}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. Note that balance()\ufffd\ufffds second term IController(manager.controllers(address(this))).balanceOf() is not normalized, but it must be. This leads to many issues through the contracts that use balance but don\ufffd\ufffdt treat these values as normalized values. For example, in Vault.withdraw, the computed _amount value is normalized (in 18 decimals). But the uint256 _balance = IERC20(_output).balanceOf(address(this)); value is not normalized but compared to the normalized _amount and even subtracted",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "   function manualRebalance(uint256 toLock) external whenNotPaused {\n        _onlyGovernance();\n        require(toLock <= MAX_BPS, \"Max is 100%\");\n\n        if (processLocksOnRebalance) {\n            // manualRebalance will revert if you have no expired locks\n            LOCKER.processExpiredLocks(false);\n        }\n\n        if (harvestOnRebalance) {\n            harvest();\n        }\n\n        // Token that is highly liquid\n        uint256 balanceOfWant =\n            IERC20Upgradeable(want).balanceOf(address(this));\n        // CVX uninvested we got from harvest and unlocks\n        uint256 balanceOfCVX = IERC20Upgradeable(CVX).balanceOf(address(this));\n        // Locked CVX in the locker\n        uint256 balanceInLock = LOCKER.balanceOf(address(this));\n        uint256 totalCVXBalance =\n            balanceOfCVX.add(balanceInLock).add(wantToCVX(balanceOfWant));\n\n        //Ratios\n        uint256 currentLockRatio =\n            balanceInLock.mul(10**18).div(totalCVXBalance);\n        // Amount we want to have in lock\n        uint256 newLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS);\n        // Amount we want to have in bCVX\n        uint256 toWantRatio =\n            totalCVXBalance.mul(MAX_BPS.sub(toLock)).div(MAX_BPS);\n\n        // We can't unlock enough, just deposit rest into bCVX\n        if (newLockRatio <= currentLockRatio) {\n            // Deposit into vault\n            uint256 toDeposit = IERC20Upgradeable(CVX).balanceOf(address(this));\n            if (toDeposit > 0) {\n                CVX_VAULT.deposit(toDeposit);\n            }\n\n            return;\n        }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-bvecvx#h-01-vecvxstrategymanualrebalance-has-wrong-logic",
                "Location": "if (newLockRatio <= currentLockRatio) {// ...}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The veCVXStrategy.manualRebalance function computes two ratios currentLockRatio and newLockRatio and compares them.\n\nHowever, these ratios compute different things and are not comparable:\n\ncurrentLockRatio = balanceInLock.mul(10**18).div(totalCVXBalance) is a percentage value with 18 decimals (i.e. 1e18 = 100%). Its max value can at most be 1e18.\nnewLockRatio = totalCVXBalance.mul(toLock).div(MAX_BPS) is a CVX token amount. It\ufffd\ufffds unbounded and just depends on the totalCVXBalance amount.\nThe comparison that follows does not make sense",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (int24 lower, int24 upper, uint128 amount, address recipient, bool unwrapBento) = abi.decode(\n            data,\n            (int24, int24, uint128, address, bool)\n        );\n\n        uint160 priceLower = TickMath.getSqrtRatioAtTick(lower);\n        uint160 priceUpper = TickMath.getSqrtRatioAtTick(upper);\n        uint160 currentPrice = price;\n\n        unchecked {\n            if (priceLower < currentPrice && currentPrice < priceUpper) liquidity -= amount;\n        }\n\n        (uint256 amount0, uint256 amount1) = _getAmountsForLiquidity(\n            uint256(priceLower),\n            uint256(priceUpper),\n            uint256(currentPrice),\n            uint256(amount)\n        );\n\n        (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount));\n\n        unchecked {\n            amount0 += amount0fees;\n            amount1 += amount1fees;\n        }\n\n        withdrawnAmounts = new TokenAmount[](2);\n        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});\n        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});\n\n        unchecked {\n            reserve0 -= uint128(amount0fees);\n            reserve1 -= uint128(amount1fees);\n        }\n\n        _transferBothTokens(recipient, amount0, amount1, unwrapBento);\n\n        nearestTick = Ticks.remove(ticks, lower, upper, amount, nearestTick);\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-sushitrident-2#h-08-wrong-inequality-when-addingremoving-liquidity-in-current-price-range",
                "Location": "unchecked { if (priceLower < currentPrice && currentPrice < priceUpper) liquidity += uint128(_liquidity);}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The ConcentratedLiquidityPool.mint/burn functions add/remove liquidity when (priceLower < currentPrice && currentPrice < priceUpper). it should  also be changed if priceLower == currentPrice",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function burn(bytes calldata data) public override lock returns (IPool.TokenAmount[] memory withdrawnAmounts) {\n        (int24 lower, int24 upper, uint128 amount, address recipient, bool unwrapBento) = abi.decode(\n            data,\n            (int24, int24, uint128, address, bool)\n        );\n\n        uint160 priceLower = TickMath.getSqrtRatioAtTick(lower);\n        uint160 priceUpper = TickMath.getSqrtRatioAtTick(upper);\n        uint160 currentPrice = price;\n\n        unchecked {\n            if (priceLower < currentPrice && currentPrice < priceUpper) liquidity -= amount;\n        }\n\n        (uint256 amount0, uint256 amount1) = _getAmountsForLiquidity(\n            uint256(priceLower),\n            uint256(priceUpper),\n            uint256(currentPrice),\n            uint256(amount)\n        );\n\n        (uint256 amount0fees, uint256 amount1fees) = _updatePosition(msg.sender, lower, upper, -int128(amount));\n\n        unchecked {\n            amount0 += amount0fees;\n            amount1 += amount1fees;\n        }\n\n        withdrawnAmounts = new TokenAmount[](2);\n        withdrawnAmounts[0] = TokenAmount({token: token0, amount: amount0});\n        withdrawnAmounts[1] = TokenAmount({token: token1, amount: amount1});\n\n        unchecked {\n            reserve0 -= uint128(amount0fees);\n            reserve1 -= uint128(amount1fees);\n        }\n\n        _transferBothTokens(recipient, amount0, amount1, unwrapBento);\n\n        nearestTick = Ticks.remove(ticks, lower, upper, amount, nearestTick);\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-sushitrident-2#h-10-concentratedliquiditypoolburn-wrong-implementation",
                "Location": "        unchecked {\n            reserve0 -= uint128(amount0fees);\n            reserve1 -= uint128(amount1fees);\n        }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers.The reserves should be updated once LP tokens are burned to match the actual total bento shares hold by the pool. However, the current implementation only updated reserves with the fees subtracted. Makes the reserve0 and reserve1 smaller than the current balance0 and balance1.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function cross(\n        mapping(int24 => Tick) storage ticks,\n        int24 nextTickToCross,\n        uint160 secondsPerLiquidity,\n        uint256 currentLiquidity,\n        uint256 feeGrowthGlobal,\n        bool zeroForOne\n    ) internal returns (uint256, int24) {\n        ticks[nextTickToCross].secondsPerLiquidityOutside = secondsPerLiquidity - ticks[nextTickToCross].secondsPerLiquidityOutside;\n        if (zeroForOne) {\n            // Moving forward through the linked list\n            if (nextTickToCross % 2 == 0) {\n                currentLiquidity -= ticks[nextTickToCross].liquidity;\n            } else {\n                currentLiquidity += ticks[nextTickToCross].liquidity;\n            }\n            nextTickToCross = ticks[nextTickToCross].previousTick;\n            ticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0;\n        } else {\n            // Moving backwards through the linked list\n            if (nextTickToCross % 2 == 0) {\n                currentLiquidity += ticks[nextTickToCross].liquidity;\n            } else {\n                currentLiquidity -= ticks[nextTickToCross].liquidity;\n            }\n            nextTickToCross = ticks[nextTickToCross].nextTick;\n            ticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1;\n        }\n\n        return (currentLiquidity, nextTickToCross);\n    }\n",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-09-sushitrident-2#h-11-concentratedliquiditypool-incorrect-feegrowthglobal-accounting-when-crossing-ticks",
                "Location": "if (zeroForOne) {\n...\nticks[nextTickToCross].feeGrowthOutside0 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside0;\n} else {\n...\nticks[nextTickToCross].feeGrowthOutside1 = feeGrowthGlobal - ticks[nextTickToCross].feeGrowthOutside1;\n}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. Swap fees are taken from the output. Hence, if swapping token0 for token1 (zeroForOne is true), then fees are taken in token1. We see this to be the case in the initialization of feeGrowthGlobal in the swap cache feeGrowthGlobal = zeroForOne ? feeGrowthGlobal1 : feeGrowthGlobal0; and in _updateFees(). However, looking at Ticks.cross(), the logic is the reverse, which causes wrong fee accounting.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function rampTargetPrice(\n        TargetPrice storage self,\n        uint256 futureTargetPrice_,\n        uint256 futureTime_\n    ) external returns (uint256) {\n        require(\n            block.timestamp >= self.initialTargetPriceTime.add(1 days),\n            \"Wait 1 day before starting ramp\"\n        );\n        require(\n            futureTime_ >= block.timestamp.add(MIN_RAMP_TIME),\n            \"Insufficient ramp time\"\n        );\n        require(\n            futureTargetPrice_ >= 0,\n            \"futureTargetPrice_ must be >= 0\"\n        );\n\n        uint256 initialTargetPricePrecise = _getTargetPricePrecise(self);\n        uint256 futureTargetPricePrecise = futureTargetPrice_.mul(TARGET_PRICE_PRECISION);\n\n        if (futureTargetPricePrecise < initialTargetPricePrecise) {\n            require(\n                futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT) >= initialTargetPricePrecise,\n                \"futureTargetPrice_ is too small\"\n            );\n        } else {\n            require(\n                futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT),\n                \"futureTargetPrice_ is too large\"\n            );\n        }\n\n        self.initialTargetPrice = initialTargetPricePrecise;\n        self.futureTargetPrice = futureTargetPricePrecise;\n        self.initialTargetPriceTime = block.timestamp;\n        self.futureTargetPriceTime = futureTime_;\n        \n        // console.log(\"executing rampTargetPrice() initalTargetPrice: %s\", self.initialTargetPrice);\n        // console.log(\"futureTargetPrice: %s\", self.futureTargetPrice);\n\n        emit RampTargetPrice(\n            initialTargetPricePrecise,\n            futureTargetPricePrecise,\n            block.timestamp,\n            futureTime_\n        );\n\n        // change token multiplier to reflect new target price\n        return self.originalPrecisionMultipliers[0].mul(initialTargetPricePrecise).div(WEI_UNIT);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-bootfinance#h-02-can-not-update-target-price",
                "Location": "        if (futureTargetPricePrecise < initialTargetPricePrecise) {\n            require(\n                futureTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT) >= initialTargetPricePrecise,\n                \"futureTargetPrice_ is too small\"\n            );\n        } else {\n            require(\n                futureTargetPricePrecise <= initialTargetPricePrecise.mul(MAX_RELATIVE_PRICE_CHANGE).div(WEI_UNIT),\n                \"futureTargetPrice_ is too large\"\n            );\n        }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The sanity checks in rampTargetPrice are broken. If futureTargetPricePrecise is smaller than initialTargetPricePrecise 0.01 of futureTargetPricePrecise would never larger than initialTargetPricePrecise.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function determineA(\n        Swap storage self, \n        uint256[] memory xp)\n        internal\n        view\n        returns(uint256)\n    {\n        // Determine the correct A by comparing xp[0] and xp[1].\n        // determine if currently in the A region or in the A2 region.\n        if( xp[0] < xp[1] ) {\n            return _getAPrecise(self);\n        } else {\n            return _getA2Precise(self);        \n        }\n    }     function getYC(\n        Swap storage self,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 x,\n        uint256[] memory xp\n    ) internal view returns (uint256) {\n        uint256 numTokens = self.pooledTokens.length;\n        require(\n            tokenIndexFrom != tokenIndexTo,\n            \"Can't compare token to itself\"\n        );\n        require(\n            tokenIndexFrom < numTokens && tokenIndexTo < numTokens,\n            \"Tokens must be in pool\"\n        );\n\n        // 1. Determine the correct A by comparing xp[0] and xp[1].\n        uint256 a = determineA(self, xp);\n\n        // 2. Calculate D of the initial position\n        uint256 d = getD(xp, a);\n\n        // 3. calculate y\n        uint256 y = getY(self, tokenIndexFrom, tokenIndexTo, x, xp, a, d);\n\n        // 4. Calculate A at the resulting position\n        uint256 aNew = _xpCalc(self, tokenIndexFrom, tokenIndexTo, x, y);\n\n        // 5. Check if we switched A's during the swap\n        if (aNew == a){     // We have used the correct A\n            return y;\n        } else {    // We have switched A's, do it again with the new A\n            return getY(self, tokenIndexFrom, tokenIndexTo, x, xp, aNew, d);\n        }\n\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-bootfinance#h-04-swaps-are-not-split-when-trade-crosses-target-price",
                "Location": "// 5. Check if we switched A's during the swap\nif (aNew == a){     // We have used the correct A\n    return y;\n} else {    // We have switched A's, do it again with the new A\n    return getY(self, tokenIndexFrom, tokenIndexTo, x, xp, aNew, d);\n}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The protocol uses two amplifier values A1 and A2 for the swap, depending on the target price, see SwapUtils.determineA. The swap curve is therefore a join of two different curves at the target price. When doing a trade that crosses the target price, it should first perform the trade partially with A1 up to the target price, and then the rest of the trade order with A2. However, the SwapUtils.swap / _calculateSwap function does not do this, it only uses the \ufffd\ufffdnew A\ufffd\ufffd, see getYC step 5.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function consult(address token) public view returns (uint256 result) {\n        uint256 pairCount = _pairs.length;\n        uint256 sumNative = 0;\n        uint256 sumUSD = 0;\n\n        for (uint256 i = 0; i < pairCount; i++) {\n            PairData memory pairData = _pairs[i];\n\n            if (token == pairData.token0) {\n                //\n                // TODO - Review:\n                //   Verify price1Average is amount of USDV against 1 unit of token1\n                //\n\n                sumNative += pairData.price1Average.mul(1).decode144(); // native asset amount\n                if (pairData.price1Average._x != 0) {\n                    require(sumNative != 0);\n                }\n\n                (\n                    uint80 roundID,\n                    int256 price,\n                    ,\n                    ,\n                    uint80 answeredInRound\n                ) = AggregatorV3Interface(_aggregators[pairData.token1])\n                        .latestRoundData();\n\n                require(\n                    answeredInRound >= roundID,\n                    \"TwapOracle::consult: stale chainlink price\"\n                );\n                require(\n                    price != 0,\n                    \"TwapOracle::consult: chainlink malfunction\"\n                );\n\n                sumUSD += uint256(price) * (10**10);\n            }\n        }\n        require(sumNative != 0, \"TwapOracle::consult: Sum of native is zero\");\n        result = ((sumUSD * IERC20Metadata(token).decimals()) / sumNative);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-vader#h-04-twaporacle-doesnt-calculate-vaderusdv-exchange-rate-correctly",
                "Location": "result = ((sumUSD * IERC20Metadata(token).decimals()) / sumNative); result = ((sumUSD * 18) / sumNative);",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.6.12;\n\nimport {Math} from \"@openzeppelin/contracts/math/Math.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {SafeMath} from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport {FixedPointMath} from \"../FixedPointMath.sol\";\nimport {IDetailedERC20} from \"../../interfaces/IDetailedERC20.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title CDP\n///\n/// @dev A library which provides the CDP data struct and associated functions.\nlibrary CDP {\n  using CDP for Data;\n  using FixedPointMath for FixedPointMath.FixedDecimal;\n  using SafeERC20 for IDetailedERC20;\n  using SafeMath for uint256;\n\n  struct Context {\n    FixedPointMath.FixedDecimal collateralizationLimit;\n    FixedPointMath.FixedDecimal accumulatedYieldWeight;\n  }\n\n  struct Data {\n    uint256 totalDeposited;\n    uint256 totalDebt;\n    uint256 totalCredit;\n    uint256 lastDeposit;\n    FixedPointMath.FixedDecimal lastAccumulatedYieldWeight;\n  }\n\n  function update(Data storage _self, Context storage _ctx) internal {\n    uint256 _earnedYield = _self.getEarnedYield(_ctx);\n    if (_earnedYield > _self.totalDebt) {\n      uint256 _currentTotalDebt = _self.totalDebt;\n      _self.totalDebt = 0;\n      _self.totalCredit = _earnedYield.sub(_currentTotalDebt);\n    } else {\n      _self.totalDebt = _self.totalDebt.sub(_earnedYield);\n    }\n    _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;\n  }\n\n  /// @dev Assures that the CDP is healthy.\n  ///\n  /// This function will revert if the CDP is unhealthy.\n  function checkHealth(Data storage _self, Context storage _ctx, string memory _msg) internal view {\n    require(_self.isHealthy(_ctx), _msg);\n  }\n\n  /// @dev Gets if the CDP is considered healthy.\n  ///\n  /// A CDP is healthy if its collateralization ratio is greater than the global collateralization limit.\n  ///\n  /// @return if the CDP is healthy.\n  function isHealthy(Data storage _self, Context storage _ctx) internal view returns (bool) {\n    return _ctx.collateralizationLimit.cmp(_self.getCollateralizationRatio(_ctx)) <= 0;\n  }\n\n  function getUpdatedTotalDebt(Data storage _self, Context storage _ctx) internal view returns (uint256) {\n    uint256 _unclaimedYield = _self.getEarnedYield(_ctx);\n    if (_unclaimedYield == 0) {\n      return _self.totalDebt;\n    }\n\n    uint256 _currentTotalDebt = _self.totalDebt;\n    if (_unclaimedYield >= _currentTotalDebt) {\n      return 0;\n    }\n\n    return _currentTotalDebt - _unclaimedYield;\n  }\n\n  function getUpdatedTotalCredit(Data storage _self, Context storage _ctx) internal view returns (uint256) {\n    uint256 _unclaimedYield = _self.getEarnedYield(_ctx);\n    if (_unclaimedYield == 0) {\n      return _self.totalCredit;\n    }\n\n    uint256 _currentTotalDebt = _self.totalDebt;\n    if (_unclaimedYield <= _currentTotalDebt) {\n      return 0;\n    }\n\n    return _self.totalCredit + (_unclaimedYield - _currentTotalDebt);\n  }\n\n  /// @dev Gets the amount of yield that a CDP has earned since the last time it was updated.\n  ///\n  /// @param _self the CDP to query.\n  /// @param _ctx  the CDP context.\n  ///\n  /// @return the amount of earned yield.\n  function getEarnedYield(Data storage _self, Context storage _ctx) internal view returns (uint256) {\n    FixedPointMath.FixedDecimal memory _currentAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;\n    FixedPointMath.FixedDecimal memory _lastAccumulatedYieldWeight = _self.lastAccumulatedYieldWeight;\n\n    if (_currentAccumulatedYieldWeight.cmp(_lastAccumulatedYieldWeight) == 0) {\n      return 0;\n    }\n\n    return _currentAccumulatedYieldWeight\n      .sub(_lastAccumulatedYieldWeight)\n      .mul(_self.totalDeposited)\n      .decode();\n  }\n\n  /// @dev Gets a CDPs collateralization ratio.\n  ///\n  /// The collateralization ratio is defined as the ratio of collateral to debt. If the CDP has zero debt then this\n  /// will return the maximum value of a fixed point integer.\n  ///\n  /// This function will use the updated total debt so an update before calling this function is not required.\n  ///\n  /// @param _self the CDP to query.\n  ///\n  /// @return a fixed point integer representing the collateralization ratio.\n  function getCollateralizationRatio(Data storage _self, Context storage _ctx)\n    internal view\n    returns (FixedPointMath.FixedDecimal memory)\n  {\n    uint256 _totalDebt = _self.getUpdatedTotalDebt(_ctx);\n    if (_totalDebt == 0) {\n      return FixedPointMath.maximumValue();\n    }\n    return FixedPointMath.fromU256(_self.totalDeposited).div(_totalDebt);\n  }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-yaxis#h-02-cdpsol-update-overwrites-users-credit-on-every-positive-increment",
                "Location": "  function update(Data storage _self, Context storage _ctx) internal {\n    uint256 _earnedYield = _self.getEarnedYield(_ctx);\n    if (_earnedYield > _self.totalDebt) {\n      uint256 _currentTotalDebt = _self.totalDebt;\n      _self.totalDebt = 0;\n      _self.totalCredit = _earnedYield.sub(_currentTotalDebt);\n    } else {\n      _self.totalDebt = _self.totalDebt.sub(_earnedYield);\n    }\n    _self.lastAccumulatedYieldWeight = _ctx.accumulatedYieldWeight;\n  }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. there is a function called update. This function slowly decreases the debt of a position as yield is earned, until the debt is fully paid off, and the idea is then that the credit should begin incrementing as more yield is accumulated. However, the current logic to increment the totalCredit is this line of code",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"../../utils/types/UFixed18.sol\";\n\n/// @dev OptimisticLedger type\nstruct OptimisticLedger {\n    /// @dev Individual account collateral balances\n    mapping(address => UFixed18) balances;\n\n    /// @dev Total ledger collateral balance\n    UFixed18 total;\n\n    /// @dev Total ledger collateral shortfall\n    UFixed18 shortfall;\n}\n\n/**\n * @title OptimisticLedgerLib\n * @notice Library that manages a global vs account ledger where the global ledger is settled separately,\n *         and ahead of, the user-level accounts.\n * @dev    Ensures that no more collateral leaves the ledger than goes it, while allowing user-level accounts\n *         to settle as a follow up step. Overdrafts on the user-level are accounted as \"shortall\". Shortfall\n *         in the system is the quantity of insolvency that can be optionally resolved by the ledger owner.\n *         Until the shortfall is resolved, collateral may be withdrawn from the ledger on a FCFS basis. However\n *         once the ledger total has been depleted, users will not be able to withdraw even if they have non-zero\n *         user level balances until the shortfall is resolved, recapitalizing the ledger.\n */\nlibrary OptimisticLedgerLib {\n    using UFixed18Lib for UFixed18;\n    using Fixed18Lib for Fixed18;\n\n    /**\n     * @notice Credits `account` with `amount` collateral\n     * @param self The struct to operate on\n     * @param account Account to credit collateral to\n     * @param amount Amount of collateral to credit\n     */\n    function creditAccount(OptimisticLedger storage self, address account, UFixed18 amount) internal {\n        self.balances[account] = self.balances[account].add(amount);\n        self.total = self.total.add(amount);\n    }\n\n    /**\n     * @notice Debits `account` `amount` collateral\n     * @param self The struct to operate on\n     * @param account Account to debit collateral from\n     * @param amount Amount of collateral to debit\n     */\n    function debitAccount(OptimisticLedger storage self, address account, UFixed18 amount) internal {\n        self.balances[account] = self.balances[account].sub(amount);\n        self.total = self.total.sub(amount);\n    }\n\n    /**\n     * @notice Credits `account` with `amount` collateral\n     * @dev Funds come from inside the product, not totals are updated\n     *      Shortfall is created if more funds are debited from an account than exist\n     * @param self The struct to operate on\n     * @param account Account to credit collateral to\n     * @param amount Amount of collateral to credit\n     */\n    function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)\n    internal returns (UFixed18 shortfall) {\n        Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);\n\n        if (newBalance.sign() == -1) {\n            shortfall = self.shortfall.add(newBalance.abs());\n            newBalance = Fixed18Lib.ZERO;\n        }\n\n        self.balances[account] = newBalance.abs();\n        self.shortfall = self.shortfall.add(shortfall);\n    }\n\n    /**\n     * @notice Debits ledger globally `amount` collateral\n     * @dev Removes balance from total that is accounted for elsewhere (e.g. product-level accumulators)\n     * @param self The struct to operate on\n     * @param amount Amount of collateral to debit\n     */\n    function debit(OptimisticLedger storage self, UFixed18 amount) internal {\n        self.total = self.total.sub(amount);\n    }\n\n    /**\n     * @notice Reduces the amount of collateral shortfall in the ledger\n     * @param self The struct to operate on\n     * @param amount Amount of shortfall to resolve\n     */\n    function resolve(OptimisticLedger storage self, UFixed18 amount) internal {\n        self.shortfall = self.shortfall.sub(amount);\n        self.total = self.total.add(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-perennial#h-01-wrong-shortfall-calculation",
                "Location": "    function settleAccount(OptimisticLedger storage self, address account, Fixed18 amount)\n    internal returns (UFixed18 shortfall) {\n        Fixed18 newBalance = Fixed18Lib.from(self.balances[account]).add(amount);\n\n        if (newBalance.sign() == -1) {\n            shortfall = self.shortfall.add(newBalance.abs());\n            newBalance = Fixed18Lib.ZERO;\n        }\n\n        self.balances[account] = newBalance.abs();\n        self.shortfall = self.shortfall.add(shortfall);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. ",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function _deposit(\n        bool _fromSavingsAccount,\n        bool _toSavingsAccount,\n        address _asset,\n        uint256 _amount,\n        address _poolSavingsStrategy,\n        address _depositFrom,\n        address _depositTo\n    ) internal returns (uint256 _sharesReceived) {\n        if (_fromSavingsAccount) {\n            _sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _poolSavingsStrategy,\n                true,\n                _toSavingsAccount\n            );\n        } else {\n            _sharesReceived = SavingsAccountUtil.directDeposit(\n                ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),\n                _depositFrom,\n                _depositTo,\n                _amount,\n                _asset,\n                _toSavingsAccount,\n                _poolSavingsStrategy\n            );\n        }\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-sublime#h-02-wrong-returns-of-savingsaccountutildepositfromsavingsaccount-can-cause-fund-loss",
                "Location": "_sharesReceived = SavingsAccountUtil.depositFromSavingsAccount(ISavingsAccount(IPoolFactory(poolFactory).savingsAccount()),",
                "Type": "Erroneous state updates",
                "Description": "Returning an unexpected value that deviates from the expected semantics specified for the contract. The function SavingsAccountUtil.depositFromSavingsAccount() is expected to return the number of equivalent shares for given _asset.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-streaming#h-03-reward-token-not-correctly-recovered",
                "Location": "    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The Streaming contract allows recovering the reward token by calling recoverTokens(rewardToken, recipient). However, the excess amount is computed incorrectly as ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount). Note that rewardTokenAmount only ever increases (when calling fundStream) but it never decreases when claiming the rewards through claimReward. However, claimReward transfers out the reward token. Therefore, the rewardTokenAmount never tracks the contract\ufffd\ufffds reward balance and the excess cannot be computed that way.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function recoverTokens(address token, address recipient) public lock {\n        // NOTE: it is the stream creators responsibility to save\n        // tokens on behalf of their users.\n        require(msg.sender == streamCreator, \"!creator\");\n        if (token == depositToken) {\n            require(block.timestamp > endDepositLock, \"time\");\n            // get the balance of this contract\n            // check what isnt claimable by either party\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);\n            // allow saving of the token\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n        \n        if (token == rewardToken) {\n            require(block.timestamp > endRewardLock, \"time\");\n            // check current balance vs internal balance\n            //\n            // NOTE: if a token rebases, i.e. changes balance out from under us,\n            // most of this contract breaks and rugs depositors. this isn't exclusive\n            // to this function but this function would in theory allow someone to rug\n            // and recover the excess (if it is worth anything)\n\n            // check what isnt claimable by depositors and governance\n            uint256 excess = ERC20(token).balanceOf(address(this)) - (rewardTokenAmount + rewardTokenFeeAmount);\n            ERC20(token).safeTransfer(recipient, excess);\n\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        if (incentives[token] > 0) {\n            require(block.timestamp >= endStream, \"stream\");\n            uint256 excess = ERC20(token).balanceOf(address(this)) - incentives[token];\n            ERC20(token).safeTransfer(recipient, excess);\n            emit RecoveredTokens(token, recipient, excess);\n            return;\n        }\n\n        // not reward token nor deposit nor incentivized token, free to transfer\n        uint256 bal = ERC20(token).balanceOf(address(this));\n        ERC20(token).safeTransfer(recipient, bal);\n        emit RecoveredTokens(token, recipient, bal);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-11-streaming#h-10-recovertokens-doesnt-work-when-issale-is-true",
                "Location": "uint256 excess = ERC20(token).balanceOf(address(this)) - (depositTokenAmount - redeemedDepositTokens);",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. This breaks in the case where isSale is true and the deposit tokens have already been claimed through the use of creatorClaimSoldTokens. In this case, redemeedDepositTokens will be zero, and depositTokenAmount will still be at its original value when the streaming ended. As a result, any attempts to recover deposit tokens from the contract would either revert or send less tokens than should be sent, since the logic above would still think that there are the full amount of deposit tokens in the contract. This breaks the functionality of the function completely in this case.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "   function _calculateUSDVPrice(\n        uint256[] memory liquidityWeights,\n        uint256 totalUSDVLiquidityWeight\n    ) internal view returns (uint256) {\n        uint256 totalUSD;\n        uint256 totalUSDV;\n        uint256 totalPairs = usdvPairs.length;\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n\n            totalUSDV +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n        }\n\n        // NOTE: Accuracy of VADER & USDV is 18 decimals == 1 ether\n        return (totalUSD * 1 ether) / totalUSDV;\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-vader#h-05-oracle-returns-an-improperly-scaled-usdvvader-price",
                "Location": "        for (uint256 i; i < totalPairs; ++i) {\n            IERC20 foreignAsset = usdvPairs[i];\n            ExchangePair storage pairData = twapData[address(foreignAsset)];\n\n            uint256 foreignPrice = getChainlinkPrice(address(foreignAsset));\n\n            totalUSD +=\n                (foreignPrice * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n\n            totalUSDV +=\n                (pairData\n                    .nativeTokenPriceAverage\n                    .mul(pairData.foreignUnit)\n                    .decode144() * liquidityWeights[i]) /\n                totalUSDVLiquidityWeight;\n        }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The LBT oracle does not properly scale values when calculating prices for VADER or USDV. ",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../shared/ProtocolConstants.sol\";\n\nimport \"../interfaces/reserve/IVaderReserve.sol\";\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\n\ncontract VaderReserve is IVaderReserve, ProtocolConstants, Ownable {\n    /* ========== LIBRARIES ========== */\n\n    // Used for safe VADER transfers\n    using SafeERC20 for IERC20;\n\n    /* ========== STATE VARIABLES ========== */\n\n    // The Vader token the reserve is handling\n    IERC20 public immutable vader;\n\n    // Router address for IL awards\n    address public router;\n\n    // Tracks last grant time for throttling\n    uint256 public lastGrant;\n\n    // LBT used for loss reimbursement\n    ILiquidityBasedTWAP public lbt;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(IERC20 _vader) {\n        require(\n            _vader != IERC20(_ZERO_ADDRESS),\n            \"VaderReserve::constructor: Incorrect Arguments\"\n        );\n        vader = _vader;\n    }\n\n    /* ========== VIEWS ========== */\n\n    function reserve() public view override returns (uint256) {\n        return vader.balanceOf(address(this));\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function grant(address recipient, uint256 amount)\n        external\n        override\n        onlyOwner\n        throttle\n    {\n        amount = _min(\n            (reserve() * _MAX_GRANT_BASIS_POINTS) / _MAX_BASIS_POINTS,\n            amount\n        );\n        vader.safeTransfer(recipient, amount);\n\n        emit GrantDistributed(recipient, amount);\n    }\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function initialize(\n        ILiquidityBasedTWAP _lbt,\n        address _router,\n        address _dao\n    ) external onlyOwner {\n        require(\n            _router != _ZERO_ADDRESS &&\n                _dao != _ZERO_ADDRESS &&\n                _lbt != ILiquidityBasedTWAP(_ZERO_ADDRESS),\n            \"VaderReserve::initialize: Incorrect Arguments\"\n        );\n        router = _router;\n        lbt = _lbt;\n        transferOwnership(_dao);\n    }\n\n    function reimburseImpermanentLoss(address recipient, uint256 amount)\n        external\n        override\n    {\n        require(\n            msg.sender == router,\n            \"VaderReserve::reimburseImpermanentLoss: Insufficient Priviledges\"\n        );\n\n        // NOTE: Loss is in USDV, reimbursed in VADER\n        // NOTE: If USDV LBT is working, prefer it otherwise use VADER price\n        if (lbt.previousPrices(uint256(ILiquidityBasedTWAP.Paths.USDV)) != 0) {\n            uint256 usdvPrice = lbt.getUSDVPrice();\n\n            amount = amount / usdvPrice;\n        } else {\n            uint256 vaderPrice = lbt.getVaderPrice();\n\n            amount = amount * vaderPrice;\n        }\n\n        uint256 actualAmount = _min(reserve(), amount);\n\n        vader.safeTransfer(recipient, actualAmount);\n\n        emit LossCovered(recipient, amount, actualAmount);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    /* ========== PRIVATE FUNCTIONS ========== */\n\n    /**\n     * @dev Calculates the minimum of the two values\n     */\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier throttle() {\n        require(\n            lastGrant + _GRANT_DELAY <= block.timestamp,\n            \"VaderReserve::throttle: Grant Too Fast\"\n        );\n        lastGrant = block.timestamp;\n        _;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-12-vader#h-08-reserve-does-not-properly-apply-prices-of-vader-and-usdv-tokens",
                "Location": "        if (lbt.previousPrices(uint256(ILiquidityBasedTWAP.Paths.USDV)) != 0) {\n            uint256 usdvPrice = lbt.getUSDVPrice();\n\n            amount = amount / usdvPrice;\n        } else {\n            uint256 vaderPrice = lbt.getVaderPrice();\n\n            amount = amount * vaderPrice;\n        }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. Here we multiply the IL experienced by the LP by a price for USDV or VADER as returned by the LBT. However the price from the oracle is a fixed point number (scaled up by 1e8 or 1e18 depending on the resolution of finding \ufffd\ufffdOracle returns an improperly scaled USDV/VADER price\ufffd\ufffd) and so a fixed scaling factor should be applied to convert back from a fixed point number to a standard integer. As it stands depending on the branch which is executed, the amount to be reimbursed will be 1e18 times too large or too small. Should the \ufffd\ufffdelse\ufffd\ufffd branch be executed the reserve will pay out much in terms of IL protection resulting in severe loss of funds. High severity.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../facades/TokenProxyLike.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n///@title Rebase Proxy\n///@author Justin Goro\n/**@notice expresses the balance changes of a rebase token as a fluctuating redeem rate, allowing for balanceOf stability. Useful for dapps which maintain their own balance values\n* Very large rebase down movement tokens are still discouraged as this could cause threshold instability.\n*/\n///@dev TokenProxyRegistry contract maps this token to a base token.\ncontract RebaseProxy is ERC20, TokenProxyLike {\n    constructor(\n        address _baseToken,\n        string memory name_,\n        string memory symbol_\n    ) TokenProxyLike(_baseToken) ERC20(name_, symbol_) {}\n\n    function redeemRate() public view returns (uint256) {\n        uint256 balanceOfBase = IERC20(baseToken).balanceOf(address(this));\n        if (totalSupply() == 0 || balanceOfBase == 0) return ONE;\n\n        return (balanceOfBase * ONE) / totalSupply();\n    }\n\n    function mint(address to, uint256 amount)\n        public\n        override\n        returns (uint256)\n    {\n        uint256 _redeemRate = redeemRate();\n        require(\n            IERC20(baseToken).transferFrom(msg.sender, address(this), amount)\n        );\n        uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));\n        uint256 proxy = (baseBalance * ONE) / _redeemRate;\n        _mint(to, proxy);\n    }\n\n    function redeem(address to, uint256 amount)\n        public\n        override\n        returns (uint256)\n    {\n        uint256 _redeemRate = redeemRate();\n        uint256 baseTokens = (_redeemRate * amount) / ONE;\n        _burn(msg.sender, amount);\n        IERC20(baseToken).transfer(to, baseTokens);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2022-01-behodler#h-02-wrong-minting-amount",
                "Location": "    function mint(address to, uint256 amount)\n        public\n        override\n        returns (uint256)\n    {\n        uint256 _redeemRate = redeemRate();\n        require(\n            IERC20(baseToken).transferFrom(msg.sender, address(this), amount)\n        );\n        uint256 baseBalance = IERC20(baseToken).balanceOf(address(this));\n        uint256 proxy = (baseBalance * ONE) / _redeemRate;\n        _mint(to, proxy);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. wrong minting amount",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function createPair() external isStopped(false) atPhase(Phase.PhaseThree) {\n        (address wavaxAddress, address tokenAddress) = (\n            address(WAVAX),\n            address(token)\n        );\n        require(\n            factory.getPair(wavaxAddress, tokenAddress) == address(0) ||\n                IJoePair(\n                    IJoeFactory(factory).getPair(wavaxAddress, tokenAddress)\n                ).totalSupply() ==\n                0,\n            \"LaunchEvent: liquid pair already exists\"\n        );\n        require(wavaxReserve > 0, \"LaunchEvent: no wavax balance\");\n\n        uint256 tokenAllocated = tokenReserve;\n\n        // Adjust the amount of tokens sent to the pool if floor price not met\n        if (\n            floorPrice > (wavaxReserve * 10**token.decimals()) / tokenAllocated\n        ) {\n            tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;\n            tokenIncentivesForUsers =\n                (tokenIncentivesForUsers * tokenAllocated) /\n                tokenReserve;\n            tokenIncentiveIssuerRefund =\n                tokenIncentivesBalance -\n                tokenIncentivesForUsers;\n        }\n\n        WAVAX.approve(address(router), wavaxReserve);\n        token.approve(address(router), tokenAllocated);\n\n        /// We can't trust the output cause of reflect tokens\n        (, , lpSupply) = router.addLiquidity(\n            wavaxAddress, // tokenA\n            tokenAddress, // tokenB\n            wavaxReserve, // amountADesired\n            tokenAllocated, // amountBDesired\n            wavaxReserve, // amountAMin\n            tokenAllocated, // amountBMin\n            address(this), // to\n            block.timestamp // deadline\n        );\n\n        pair = IJoePair(factory.getPair(tokenAddress, wavaxAddress));\n        wavaxAllocated = wavaxReserve;\n        wavaxReserve = 0;\n\n        tokenReserve -= tokenAllocated;\n\n        emit LiquidityPoolCreated(\n            address(pair),\n            tokenAddress,\n            wavaxAddress,\n            tokenAllocated,\n            wavaxAllocated\n        );\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2022-01-trader-joe#h-02-wrong-token-allocation-computation-for-token-decimals--18-if-floor-price-not-reached",
                "Location": "tokenAllocated = (wavaxReserve * 10**token.decimals()) / floorPrice;",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. In LaunchEvent.createPair, when the floor price is not reached (floorPrice > wavaxReserve * 1e18 / tokenAllocated), the tokens to be sent to the pool are lowered to match the raised WAVAX at the floor price. Note that the floorPrice is supposed to have a precision of 18: /// @param _floorPrice Price of each token in AVAX, scaled to 1e18 The floorPrice > (wavaxReserve * 1e18) / tokenAllocated check is correct but the tokenAllocated computation involves the token decimals",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function getAmountToTransfer(\n        uint256 initialGas,\n        address tokenAddress,\n        uint256 amount,\n        uint256 tokenGasPrice\n    ) internal returns (uint256 amountToTransfer) {\n        uint256 transferFeePerc = getTransferFee(tokenAddress, amount);\n        uint256 lpFee;\n        if (transferFeePerc > tokenManager.getTokensInfo(tokenAddress).equilibriumFee) {\n            // Here add some fee to incentive pool also\n            lpFee = (amount * tokenManager.getTokensInfo(tokenAddress).equilibriumFee) / BASE_DIVISOR;\n            incentivePool[tokenAddress] =\n                (incentivePool[tokenAddress] +\n                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /\n                BASE_DIVISOR;\n        } else {\n            lpFee = (amount * transferFeePerc) / BASE_DIVISOR;\n        }\n        uint256 transferFeeAmount = (amount * transferFeePerc) / BASE_DIVISOR;\n\n        liquidityProviders.addLPFee(tokenAddress, lpFee);\n\n        uint256 totalGasUsed = initialGas - gasleft();\n        totalGasUsed = totalGasUsed + tokenManager.getTokensInfo(tokenAddress).transferOverhead;\n        totalGasUsed = totalGasUsed + baseGas;\n\n        uint256 gasFee = totalGasUsed * tokenGasPrice;\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress] + gasFee;\n        gasFeeAccumulated[tokenAddress][_msgSender()] = gasFeeAccumulated[tokenAddress][_msgSender()] + gasFee;\n        amountToTransfer = amount - (transferFeeAmount + gasFee);\n\n        emit FeeDetails(lpFee, transferFeeAmount, gasFee);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2022-03-biconomy#h-03-wrong-formula-when-add-fee-incentivepool-can-lead-to-loss-of-funds",
                "Location": "            incentivePool[tokenAddress] =\n                (incentivePool[tokenAddress] +\n                    (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee))) /\n                BASE_DIVISOR;",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The getAmountToTransfer function of LiquidityPool updates incentivePool[tokenAddress] by adding some fee to it but the formula is wrong and the value of incentivePool[tokenAddress] will be divided by BASE_DIVISOR (10000000000) each time. After just a few time, the value of incentivePool[tokenAddress] will become zero and that amount of tokenAddress token will be locked in contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "function _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {\n  uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;\n  uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));\n  uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);\n  return _principalWithdrawable;\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2022-03-sublime#h-01-lenderpool-principal-withdrawable-is-incorrectly-calculated-if-start-is-invoked-with-non-zero-start-fee",
                "Location": "function _calculatePrincipalWithdrawable(uint256 _id, address _lender) internal view returns (uint256) {\n  uint256 _borrowedTokens = pooledCLConstants[_id].borrowLimit;\n  uint256 _totalLiquidityWithdrawable = _borrowedTokens.sub(POOLED_CREDIT_LINE.getPrincipal(_id));\n  uint256 _principalWithdrawable = _totalLiquidityWithdrawable.mul(balanceOf(_lender, _id)).div(_borrowedTokens);\n  return _principalWithdrawable;\n}",
                "Type": "Erroneous state updates",
                "Description": "Returning an unexpected value that deviates from the expected semantics specified for the contract. The _principalWithdrawable calculated will be more than expected if _start() is invoked with a non-zero start fee, because the borrow limit is reduced by the fee, resulting in totalSupply[id] not being 1:1 with the borrow limit.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iFACTORY.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Utils {\n\n    uint private one = 10**18;\n    uint private _10k = 10000;\n    uint private _year = 31536000; // One Year (in seconds)\n\n    bool private inited;\n\n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public POOLS;\n    address public FACTORY;\n\n    constructor () {}\n\n    function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {\n        require(inited == false,  \"inited\");\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        POOLS = _pools;\n        FACTORY = _factory;\n    }\n    //====================================SYSTEM FUNCTIONS====================================//\n    // VADER FeeOnTransfer\n    function getFeeOnTransfer(uint totalSupply, uint maxSupply) external pure returns(uint){\n        return calcShare(totalSupply, maxSupply, 100); // 0->100BP\n    }\n\n    function assetChecks(address collateralAsset, address debtAsset) external {\n        if(collateralAsset == VADER){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(collateralAsset == USDV){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Asset with VADER/ASSET-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAnchor(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAnchor(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        } else if(iPOOLS(POOLS).isSynth(collateralAsset) && iPOOLS(POOLS).isAsset(iSYNTH(collateralAsset).TOKEN())){\n            require(iPOOLS(POOLS).isAsset(debtAsset), \"Bad Combo\"); // Can borrow Anchor with VADER/ANCHOR-SYNTH\n        }\n    }\n\n    function isBase(address token) public view returns(bool base) {\n        if(token == VADER || token == USDV){\n            return true;\n        }\n    }\n    function isPool(address token) public view returns(bool pool) {\n        if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\n            pool = true;\n        }\n    }\n\n\n    //====================================CORE-MATH====================================//\n\n    function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){\n        if(P == 0){\n            return b;\n        } else {\n            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n            // P * (part1 + part2) / (part3) * slipAdjustment\n            uint slipAdjustment = getSlipAdustment(b, B, t, T);\n            uint part1 = (t * B);\n            uint part2 = (T * b);\n            uint part3 = (T * B) * 2;\n            uint _units = (((P * part1) + part2) / part3);\n            return (_units * slipAdjustment) / one;  // Divide by 10**18\n        }\n    }\n\n    function getSlipAdustment(uint b, uint B, uint t, uint T) public view returns (uint){\n        // slipAdjustment = (1 - ABS((B t - b T)/((2 b + B) (t + T))))\n        // 1 - ABS(part1 - part2)/(part3 * part4))\n        uint part1 = B * t;\n        uint part2 = b * T;\n        uint part3 = (b * 2) + B;\n        uint part4 = t + T;\n        uint numerator;\n        if(part1 > part2){\n            numerator = (part1 - part2);\n        } else {\n            numerator = (part2 - part1);\n        }\n        uint denominator = (part3 * part4);\n        return one - (numerator * one) / denominator; // Multiply by 10**18\n    }\n\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-04-vader#h-08-wrong-liquidity-units-calculation",
                "Location": "function calcLiquidityUnits(uint b, uint B, uint t, uint T, uint P) external view returns (uint){\n        if(P == 0){\n            return b;\n        } else {\n            // units = ((P (t B + T b))/(2 T B)) * slipAdjustment\n            // P * (part1 + part2) / (part3) * slipAdjustment\n            uint slipAdjustment = getSlipAdustment(b, B, t, T);\n            uint part1 = (t * B);\n            uint part2 = (T * b);\n            uint part3 = (T * B) * 2;\n            uint _units = (((P * part1) + part2) / part3);\n            return (_units * slipAdjustment) / one;  // Divide by 10**18\n        }\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The spec defines the number of LP units to be minted as units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments but the Utils.calcLiquidityUnits function computes ((P * part1) + part2) / part3 * slipAdjustments. The associativity on P * part1 is wrong, and part2 is not multiplied by P. The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iFACTORY.sol\";\n\ncontract Pools {\n\n    // Parameters\n    bool private inited;\n    uint public pooledVADER;\n    uint public pooledUSDV;\n    \n    address public VADER;\n    address public USDV;\n    address public ROUTER;\n    address public FACTORY;\n\n    mapping(address => bool) _isMember;\n    mapping(address => bool) _isAsset;\n    mapping(address => bool) _isAnchor;\n\n    mapping(address => uint) public mapToken_Units;\n    mapping(address => mapping(address => uint)) public mapTokenMember_Units;\n    mapping(address => uint) public mapToken_baseAmount;\n    mapping(address => uint) public mapToken_tokenAmount;\n\n    // Events\n    event AddLiquidity(address indexed member, address indexed base, uint baseAmount, address indexed token, uint tokenAmount, uint liquidityUnits);\n\n    //=====================================CREATION=========================================//\n    constructor() {}\n\n    function init(address _vader, address _usdv, address _router, address _factory) public {\n        require(inited == false);\n        inited = true;\n        VADER = _vader;\n        USDV = _usdv;\n        ROUTER = _router;\n        FACTORY = _factory;\n    }\n\n    //====================================LIQUIDITY=========================================//\n\n    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {\n        require(token != USDV && token != VADER); // Prohibited\n        uint _actualInputBase;\n        if(base == VADER){\n            if(!isAnchor(token)){               // If new Anchor\n                _isAnchor[token] = true;\n            }\n            _actualInputBase = getAddedAmount(VADER, token);\n        } else if (base == USDV) {\n            if(!isAsset(token)){               // If new Asset\n                _isAsset[token] = true;\n            }\n            _actualInputBase = getAddedAmount(USDV, token);\n        }\n        uint _actualInputToken = getAddedAmount(token, token);\n        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);\n        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member\n        mapToken_Units[token] += liquidityUnits;                // Add in total\n        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE\n        mapToken_tokenAmount[token] += _actualInputToken;       // Add token\n        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);\n    }\n\n    //======================================HELPERS=========================================//\n    // Safe adds\n    function getAddedAmount(address _token, address _pool) internal returns(uint addedAmount) {\n        uint _balance = iERC20(_token).balanceOf(address(this));\n        if(_token == VADER && _pool != VADER){  // Want to know added VADER\n            addedAmount = _balance - pooledVADER;\n            pooledVADER = pooledVADER + addedAmount;\n        } else if(_token == USDV) {             // Want to know added USDV\n            addedAmount = _balance - pooledUSDV;\n            pooledUSDV = pooledUSDV + addedAmount;\n        } else {                                // Want to know added Asset/Anchor\n            addedAmount = _balance - mapToken_tokenAmount[_pool];\n        }\n    }\n\n    function isAsset(address token) public view returns(bool) {\n        return _isAsset[token];\n    }\n    function isAnchor(address token) public view returns(bool) {\n        return _isAnchor[token];\n    }\n    function getSynth(address token) public view returns (address) {\n        return iFACTORY(FACTORY).getSynth(token);\n    }\n    function isSynth(address token) public view returns (bool) {\n        return iFACTORY(FACTORY).isSynth(token);\n    }\n    function UTILS() public view returns(address){\n        return iVADER(VADER).UTILS();\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-04-vader#h-12-getaddedamount-can-return-wrong-results",
                "Location": "The spec defines the number of LP units to be minted as units = (P (a B + A b))/(2 A B) * slipAdjustment = P * (part1 + part2) / part3 * slipAdjustments but the Utils.calcLiquidityUnits function computes ((P * part1) + part2) / part3 * slipAdjustments.\n\nThe associativity on P * part1 is wrong, and part2 is not multiplied by P.\n\nThe math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as redeeming the minted LP tokens does not result in the initial tokens anymore.    function addLiquidity(address base, address token, address member) external returns(uint liquidityUnits) {\n        require(token != USDV && token != VADER); // Prohibited\n        uint _actualInputBase;\n        if(base == VADER){\n            if(!isAnchor(token)){               // If new Anchor\n                _isAnchor[token] = true;\n            }\n            _actualInputBase = getAddedAmount(VADER, token);\n        } else if (base == USDV) {\n            if(!isAsset(token)){               // If new Asset\n                _isAsset[token] = true;\n            }\n            _actualInputBase = getAddedAmount(USDV, token);\n        }\n        uint _actualInputToken = getAddedAmount(token, token);\n        liquidityUnits = iUTILS(UTILS()).calcLiquidityUnits(_actualInputBase, mapToken_baseAmount[token], _actualInputToken, mapToken_tokenAmount[token], mapToken_Units[token]);\n        mapTokenMember_Units[token][member] += liquidityUnits;  // Add units to member\n        mapToken_Units[token] += liquidityUnits;                // Add in total\n        mapToken_baseAmount[token] += _actualInputBase;         // Add BASE\n        mapToken_tokenAmount[token] += _actualInputToken;       // Add token\n        emit AddLiquidity(member, base, _actualInputBase, token, _actualInputToken, liquidityUnits);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The getAddedAmount function only works correctly when called with (VADER/USDV, pool) or (pool, pool). However, when called with (token, pool) where token is neither VADER/USDV/pool, it returns the wrong results:\n\nIt gets the token balance\nAnd subtracts it from the stored mapToken_tokenAmount[_pool] amount which can be that of a completely different token\nAnyone can break individual pairs by calling sync(token1, token2) where the token1 balance is less than mapToken_tokenAmount[token2]. This will add the difference to mapToken_tokenAmount[token2] and break the accounting and result in a wrong swap logic.\n\nFurthermore, this can also be used to swap tokens without having to pay anthing with swap(token1, token2, member, toBase=false).\n\nRecommend adding a require statement in the else branch that checks that _token == _pool.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "function log_2(uint128 x)\n  internal pure returns(uint128) {\n    unchecked {\n      require(x != 0);\n\n      uint b = x;\n\n      uint l = 0xFE000000000000000000000000000000;\n\n      if(b < 0x10000000000000000) {l -= 0x80000000000000000000000000000000; b <<= 64;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) l |= 0x1; */\n\n      return uint128(l);\n    }\n  }",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-05-yield#h-03-yieldmathsol--log2--or--",
                "Location": "  function log_2(uint128 x)\n  internal pure returns(uint128) {\n    unchecked {\n      require(x != 0);\n\n      uint b = x;\n\n      uint l = 0xFE000000000000000000000000000000;\n\n      if(b < 0x10000000000000000) {l -= 0x80000000000000000000000000000000; b <<= 64;}\n      b = b * b >> 127; if(b > 0x100000000000000000000000000000000) l |= 0x1; */\n\n      return uint128(l);\n    }\n  }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. b > 0x100000000000000000000000000000000 may lead to compute error",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./interfaces/pooltogether/IProtocolYieldSource.sol\";\nimport \"./interfaces/idle/IIdleToken.sol\";\nimport \"./access/AssetManager.sol\";\n\ncontract IdleYieldSource is IProtocolYieldSource, Initializable, ReentrancyGuardUpgradeable, ERC20Upgradeable, AssetManager  {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public idleToken;\n    address public underlyingAsset;\n    uint256 public constant ONE_IDLE_TOKEN = 10**18;\n\n    event IdleYieldSourceInitialized(address indexed idleToken);\n\n    event RedeemedToken(\n        address indexed from,\n        uint256 shares,\n        uint256 amount\n    );\n\n    event SuppliedTokenTo(\n        address indexed from,\n        uint256 shares,\n        uint256 amount,\n        address indexed to\n    );\n\n    event Sponsored(\n        address indexed from,\n        uint256 amount\n    );\n\n    event TransferredERC20(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        address indexed token\n    );\n\n    function initialize(\n        address _idleToken\n    ) public initializer {\n\n        __Ownable_init();\n\n        idleToken = _idleToken;\n        underlyingAsset = IIdleToken(idleToken).token();\n\n        IERC20Upgradeable(underlyingAsset).safeApprove(idleToken, type(uint256).max);\n        emit IdleYieldSourceInitialized(idleToken);\n    }\n\n    function depositToken() external view override returns (address) {\n        return underlyingAsset;\n    }\n\n    function balanceOfToken(address addr) external view override returns (uint256) {\n        return _sharesToToken(balanceOf(addr));\n    }\n\n    function _totalShare() internal view returns(uint256) {\n        return IIdleToken(idleToken).balanceOf(address(this));\n    }\n\n    function _tokenToShares(uint256 tokens) internal view returns (uint256 shares) {\n        shares = (tokens * ONE_IDLE_TOKEN) / _price();\n    }\n\n    function _sharesToToken(uint256 shares) internal view returns (uint256 tokens) { \n        tokens = (shares * _price()) / ONE_IDLE_TOKEN;\n    }\n\n    function _price() internal view returns (uint256) {\n      return IIdleToken(idleToken).tokenPriceWithFee(address(this));\n    }\n\n    function _depositToIdle(uint256 mintAmount) internal returns (uint256) {\n        IERC20Upgradeable(underlyingAsset).safeTransferFrom(msg.sender, address(this), mintAmount);\n        return IIdleToken(idleToken).mintIdleToken(mintAmount, false, address(0));\n    }\n\n    function supplyTokenTo(uint256 mintAmount, address to) external nonReentrant override {\n        uint256 mintedTokenShares = _tokenToShares(mintAmount);\n        _depositToIdle(mintAmount);\n        _mint(to, mintedTokenShares);\n        emit SuppliedTokenTo(msg.sender, mintedTokenShares, mintAmount, to);\n    }\n\n    function redeemToken(uint256 redeemAmount) external override nonReentrant returns (uint256 redeemedUnderlyingAsset) {\n        uint256 redeemedShare = _tokenToShares(redeemAmount);\n        _burn(msg.sender, redeemedShare);\n        redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(redeemedShare);        \n        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);\n        emit RedeemedToken(msg.sender, redeemedShare, redeemAmount);\n    }\n\n    function transferERC20(address erc20Token, address to, uint256 amount) external override onlyOwnerOrAssetManager {\n        require(erc20Token != idleToken, \"IdleYieldSource/idleDai-transfer-not-allowed\");\n        IERC20Upgradeable(erc20Token).safeTransfer(to, amount);\n        emit TransferredERC20(msg.sender, to, amount, erc20Token);\n    }\n\n    function sponsor(uint256 amount) external override {\n        _depositToIdle(amount);\n        emit Sponsored(msg.sender, amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-06-pooltogether#h-01-user-could-lose-underlying-tokens-when-redeeming-from-the-idleyieldsource",
                "Location": "    function redeemToken(uint256 redeemAmount) external override nonReentrant returns (uint256 redeemedUnderlyingAsset) {\n        uint256 redeemedShare = _tokenToShares(redeemAmount);\n        _burn(msg.sender, redeemedShare);\n        redeemedUnderlyingAsset = IIdleToken(idleToken).redeemIdleToken(redeemedShare);        \n        IERC20Upgradeable(underlyingAsset).safeTransfer(msg.sender, redeemedUnderlyingAsset);\n        emit RedeemedToken(msg.sender, redeemedShare, redeemAmount);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. ",
                "Repair": "The redeemToken function in IdleYieldSource uses redeemedShare instead of redeemAmount as the input parameter when calling redeemIdleToken of the Idle yield source. As a result, users could get fewer underlying tokens than they should. When burning users\ufffd\ufffd shares, it is correct to use redeemedShare (line 130). However, when redeeming underlying tokens from Idle Finance, redeemAmount should be used instead of redeemedShare (line 131). Usually, the tokenPriceWithFee() is greater than ONE_IDLE_TOKEN, and thus redeemedShare is less than redeemAmount, causing users to get fewer underlying tokens than expected."
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./LibMath.sol\";\nimport \"../Interfaces/Types.sol\";\nimport \"prb-math/contracts/PRBMathSD59x18.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\nimport \"./LibPerpetuals.sol\";\n\nlibrary Balances {\n    using LibMath for int256;\n    using LibMath for uint256;\n    using PRBMathSD59x18 for int256;\n    using PRBMathUD60x18 for uint256;\n\n    uint256 public constant MAX_DECIMALS = 18;\n\n    struct Position {\n        int256 quote;\n        int256 base;\n    }\n\n    struct Trade {\n        uint256 price;\n        uint256 amount;\n        Perpetuals.Side side;\n    }\n\n    struct Account {\n        Position position;\n        uint256 totalLeveragedValue;\n        uint256 lastUpdatedIndex;\n        uint256 lastUpdatedGasPrice;\n    }\n\n    function applyTrade(\n        Position memory position,\n        Trade memory trade,\n        uint256 feeRate\n    ) internal pure returns (Position memory) {\n        int256 signedAmount = LibMath.toInt256(trade.amount);\n        int256 signedPrice = LibMath.toInt256(trade.price);\n        int256 quoteChange = PRBMathSD59x18.mul(signedAmount, signedPrice);\n        int256 fee = getFee(trade.amount, trade.price, feeRate);\n\n        int256 newQuote = 0;\n        int256 newBase = 0;\n\n        if (trade.side == Perpetuals.Side.Long) {\n            newBase = position.base + signedAmount;\n            newQuote = position.quote - quoteChange + fee;\n        } else if (trade.side == Perpetuals.Side.Short) {\n            newBase = position.base - signedAmount;\n            newQuote = position.quote + quoteChange - fee;\n        }\n\n        Position memory newPosition = Position(newQuote, newBase);\n\n        return newPosition;\n    }\n\n    function getFee(\n        uint256 amount,\n        uint256 executionPrice,\n        uint256 feeRate\n    ) internal pure returns (int256) {\n        uint256 quoteChange = PRBMathUD60x18.mul(amount, executionPrice);\n\n        int256 fee = PRBMathUD60x18.mul(quoteChange, feeRate).toInt256();\n        return fee;\n    }\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-06-tracer#h-04-logic-error-in-fee-subtraction",
                "Location": "    function applyTrade(\n        Position memory position,\n        Trade memory trade,\n        uint256 feeRate\n    ) internal pure returns (Position memory) {\n        int256 signedAmount = LibMath.toInt256(trade.amount);\n        int256 signedPrice = LibMath.toInt256(trade.price);\n        int256 quoteChange = PRBMathSD59x18.mul(signedAmount, signedPrice);\n        int256 fee = getFee(trade.amount, trade.price, feeRate);\n\n        int256 newQuote = 0;\n        int256 newBase = 0;\n\n        if (trade.side == Perpetuals.Side.Long) {\n            newBase = position.base + signedAmount;\n            newQuote = position.quote - quoteChange + fee;\n        } else if (trade.side == Perpetuals.Side.Short) {\n            newBase = position.base - signedAmount;\n            newQuote = position.quote + quoteChange - fee;\n        }\n\n        Position memory newPosition = Position(newQuote, newBase);\n\n        return newPosition;\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. In LibBalances.applyTrade(), we need to collect a fee from the trade. However, the current code subtracts a fee from the short position and adds it to the long. The correct implementation is to subtract a fee to both (see TracerPerpetualSwaps.sol L272). This issue causes withdrawals problems, since Tracer thinks it can withdraw the collect fees, leaving the users with an incorrect amount of quote tokens.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPLv3\npragma solidity >=0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport {FixedStablecoins} from \"contracts/common/FixedContracts.sol\";\nimport {ICurve3Pool} from \"contracts/interfaces/ICurve.sol\";\n\nimport \"contracts/common/Controllable.sol\";\n\nimport \"contracts/interfaces/IBuoy.sol\";\nimport \"contracts/interfaces/IChainPrice.sol\";\nimport \"contracts/interfaces/IChainlinkAggregator.sol\";\nimport \"contracts/interfaces/IERC20Detailed.sol\";\n\ncontract Buoy3Pool is FixedStablecoins, Controllable, IBuoy, IChainPrice {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 TIME_LIMIT = 3000;\n    uint256 public BASIS_POINTS = 20;\n    uint256 constant CHAIN_FACTOR = 100;\n\n    ICurve3Pool public immutable override curvePool;\n    IERC20 public immutable lpToken;\n\n    mapping(uint256 => uint256) lastRatio;\n\n    // Chianlink price feed\n    address public immutable daiUsdAgg;\n    address public immutable usdcUsdAgg;\n    address public immutable usdtUsdAgg;\n\n    mapping(address => mapping(address => uint256)) public tokenRatios;\n\n    event LogNewBasisPointLimit(uint256 oldLimit, uint256 newLimit);\n\n    constructor(\n        address _crv3pool,\n        address poolToken,\n        address[N_COINS] memory _tokens,\n        uint256[N_COINS] memory _decimals,\n        address[N_COINS] memory aggregators\n    ) public FixedStablecoins(_tokens, _decimals) {\n        curvePool = ICurve3Pool(_crv3pool);\n        lpToken = IERC20(poolToken);\n        daiUsdAgg = aggregators[0];\n        usdcUsdAgg = aggregators[1];\n        usdtUsdAgg = aggregators[2];\n    }\n\n\n    function safetyCheck() external view override returns (bool) {\n        for (uint256 i = 1; i < N_COINS; i++) {\n            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));\n            _ratio = abs(int256(_ratio - lastRatio[i]));\n            if (_ratio.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > BASIS_POINTS) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function abs(int256 x) private pure returns (uint256) {\n        return x >= 0 ? uint256(x) : uint256(-x);\n    }\n\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-06-gro#h-02-buoy3poolsafetycheck-is-not-precise-and-has-some-assumptions",
                "Location": "    function safetyCheck() external view override returns (bool) {\n        for (uint256 i = 1; i < N_COINS; i++) {\n            uint256 _ratio = curvePool.get_dy(int128(0), int128(i), getDecimal(0));\n            _ratio = abs(int256(_ratio - lastRatio[i]));\n            if (_ratio.mul(PERCENTAGE_DECIMAL_FACTOR).div(CURVE_RATIO_DECIMALS_FACTOR) > BASIS_POINTS) {\n                return false;\n            }\n        }\n        return true;\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The safetyCheck function has several issues that impact how precise the checks are: Only checks if the a/b and a/c ratios are within BASIS_POINTS. By transitivity, b/c is only within 2 * BASIS_POINTS if a/b and a/c are in range. For a more precise check whether both USDC and USDT are within range, b/c must be checked as well. If a/b is within range, this does not imply that b/a is within range. \ufffd\ufffdinverted ratios, a/b bs b/a, while producing different results should both reflect the same change in any one of the two underlying assets, but in opposite directions\ufffd\ufffd Example: lastRatio = 1.0 ratio: a = 1.0, b = 0.8 => a/b = 1.25, b/a = 0.8 If a/b was used with a 20% range, it\ufffd\ufffdd be out of range, but b/a is in range. The NatSpec for the function states that it checks Curve and an external oracle, but no external oracle calls are checked, both _ratio and lastRatio are only from Curve. Only _updateRatios checks the oracle. To address this issue, it is recommended to check if b/c is within BASIS_POINTS .",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\n// Copyright (c) 2021 0xdev0 - All rights reserved\n// https://twitter.com/0xdev0\n\npragma solidity ^0.8.0;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/ILPTokenMaster.sol';\nimport './interfaces/ILendingPair.sol';\nimport './interfaces/IController.sol';\nimport './interfaces/IRewardDistribution.sol';\nimport './interfaces/IInterestRateModel.sol';\n\nimport './external/Math.sol';\nimport './external/Ownable.sol';\nimport './external/Address.sol';\nimport './external/Clones.sol';\nimport './external/ERC20.sol';\n\nimport './TransferHelper.sol';\n\ncontract LendingPair is TransferHelper {\n\n  // Prevents division by zero and other undesirable behaviour\n  uint public constant MIN_RESERVE = 1000;\n\n  using Address for address;\n  using Clones for address;\n\n  mapping (address => mapping (address => uint)) public debtOf;\n  mapping (address => mapping (address => uint)) public accountInterestSnapshot;\n  mapping (address => uint) public cumulativeInterestRate; // 100e18 = 100%\n  mapping (address => uint) public totalDebt;\n  mapping (address => IERC20) public lpToken;\n\n  IController public controller;\n  address public tokenA;\n  address public tokenB;\n  uint public lastBlockAccrued;\n\n  event Liquidation(\n    address indexed account,\n    address indexed repayToken,\n    address indexed supplyToken,\n    uint repayAmount,\n    uint supplyAmount\n  );\n\n  receive() external payable {}\n\n  function accrueAccount(address _account) public {\n    _distributeReward(_account);\n    accrue();\n    _accrueAccountInterest(_account);\n\n    if (_account != feeRecipient()) {\n      _accrueAccountInterest(feeRecipient());\n    }\n  }\n\n  function _distributeReward(address _account) internal {\n    IRewardDistribution rewardDistribution = controller.rewardDistribution();\n\n    if (address(rewardDistribution) != address(0)) {\n      rewardDistribution.distributeReward(_account, tokenA);\n      rewardDistribution.distributeReward(_account, tokenB);\n    }\n  }\n\n  function accrue() public {\n    if (lastBlockAccrued < block.number) {\n      _accrueInterest(tokenA);\n      _accrueInterest(tokenB);\n      lastBlockAccrued = block.number;\n    }\n  }\n\n  function _accrueInterest(address _token) internal {\n    uint blocksElapsed = block.number - lastBlockAccrued;\n    uint newInterest = _borrowRatePerBlock(_token) * blocksElapsed;\n    cumulativeInterestRate[_token] += newInterest;\n  }\n\n  function _accrueAccountInterest(address _account) internal {\n    uint lpBalanceA = lpToken[tokenA].balanceOf(_account);\n    uint lpBalanceB = lpToken[tokenB].balanceOf(_account);\n\n    _accrueAccountSupply(tokenA, lpBalanceA, _account);\n    _accrueAccountSupply(tokenB, lpBalanceB, _account);\n    _accrueAccountDebt(tokenA, _account);\n    _accrueAccountDebt(tokenB, _account);\n\n    accountInterestSnapshot[tokenA][_account] = cumulativeInterestRate[tokenA];\n    accountInterestSnapshot[tokenB][_account] = cumulativeInterestRate[tokenB];\n  }\n\n  function feeRecipient() public view returns(address) {\n    return controller.feeRecipient();\n  }\n\n  function _accrueAccountSupply(address _token, uint _amount, address _account) internal {\n    if (_amount > 0) {\n      uint supplyInterest   = _newInterest(_amount, _token, _account);\n      uint newSupplyAccount = supplyInterest * _lpRate(_token) / 100e18;\n      uint newSupplySystem  = supplyInterest * _systemRate(_token) / 100e18;\n\n      _mintSupply(_token, _account, newSupplyAccount);\n      _mintSupply(_token, feeRecipient(), newSupplySystem);\n    }\n  }\n\n  function _accrueAccountDebt(address _token, address _account) internal {\n    if (debtOf[_token][_account] > 0) {\n      uint newDebt = _pendingBorrowInterest(_token, _account);\n      _mintDebt(_token, _account, newDebt);\n    }\n  }\n\n  function _borrowRatePerBlock(address _token) internal view returns(uint) {\n    return controller.interestRateModel().borrowRatePerBlock(ILendingPair(address(this)), _token);\n  }\n\n\n  function _mintSupply(address _token, address _account, uint _amount) internal {\n    if (_amount > 0) {\n      lpToken[_token].mint(_account, _amount);\n    }\n  }\n\n  function _mintDebt(address _token, address _account, uint _amount) internal {\n    debtOf[_token][_account] += _amount;\n    totalDebt[_token] += _amount;\n  }\n\n\n  function _pendingBorrowInterest(address _token, address _account) internal view returns(uint) {\n    return _newInterest(debtOf[_token][_account], _token, _account);\n  }\n\n\n  function _newInterest(uint _balance, address _token, address _account) internal view returns(uint) {\n    return _balance * (cumulativeInterestRate[_token] - accountInterestSnapshot[_token][_account]) / 100e18;\n  }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-07-wildcredit#h-01-reward-computation-is-wrong",
                "Location": "  function accrueAccount(address _account) public {\n    _distributeReward(_account);\n    accrue();\n    _accrueAccountInterest(_account);\n\n    if (_account != feeRecipient()) {\n      _accrueAccountInterest(feeRecipient());\n    }\n  }",
                "Type": "Erroneous state updates",
                "Description": "Incorrect calculating order. The LendingPair.accrueAccount function distributes rewards before updating the cumulative supply / borrow indexes as well as the index + balance for the user (by minting supply tokens / debt). This means the percentage of the user\ufffd\ufffds balance to the total is not correct as the total can be updated several times in between.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another\n    /// - i.e., the user gets a single token out by burning LP tokens.\n    function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {\n        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 _totalSupply = totalSupply;\n        uint256 liquidity = balanceOf[address(this)];\n\n        unchecked {\n            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);\n        }\n\n        uint256 amount0 = (liquidity * balance0) / _totalSupply;\n        uint256 amount1 = (liquidity * balance1) / _totalSupply;\n\n        _burn(address(this), liquidity);\n        unchecked {\n            if (tokenOut == token1) {\n                // @dev Swap `token0` for `token1`\n                // - calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.\n                amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1);\n                _transfer(token1, amount1, recipient, unwrapBento);\n                balance1 -= amount1;\n                amountOut = amount1;\n                amount0 = 0;\n            } else {\n                // @dev Swap `token1` for `token0`.\n                require(tokenOut == token0, \"INVALID_OUTPUT_TOKEN\");\n                amount0 += _getAmountOut(amount1, _reserve1 - amount1, _reserve0 - amount0);\n                _transfer(token0, amount0, recipient, unwrapBento);\n                balance0 -= amount0;\n                amountOut = amount0;\n                amount1 = 0;\n            }\n        }\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n        kLast = TridentMath.sqrt(balance0 * balance1);\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }\n\n    function _getReserves()\n        internal\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    {\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    }\n\n    function _mintFee(\n        uint112 _reserve0,\n        uint112 _reserve1,\n        uint256 _totalSupply\n    ) internal returns (uint256 liquidity) {\n        uint256 _kLast = kLast;\n        if (_kLast != 0) {\n            uint256 computed = TridentMath.sqrt(uint256(_reserve0) * _reserve1);\n            if (computed > _kLast) {\n                // @dev `barFee` % of increase in liquidity.\n                // It's going to be slightly less than `barFee` % in reality due to the math.\n                liquidity = (_totalSupply * (computed - _kLast) * barFee) / computed / MAX_FEE;\n                if (liquidity != 0) {\n                    _mint(barFeeTo, liquidity);\n                }\n            }\n        }\n    }\n    \n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveAmountIn,\n        uint256 reserveAmountOut\n    ) internal view returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * MAX_FEE_MINUS_SWAP_FEE;\n        amountOut = (amountInWithFee * reserveAmountOut) / (reserveAmountIn * MAX_FEE + amountInWithFee);\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-09-sushitrident#h-11-constantproductpoolburnsingle-swap-amount-computations-should-use-balance",
                "Location": "function burnSingle(bytes calldata data) public override lock returns (uint256 amountOut) {\n        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\n        (uint256 balance0, uint256 balance1) = _balance();\n        uint256 _totalSupply = totalSupply;\n        uint256 liquidity = balanceOf[address(this)];\n\n        unchecked {\n            _totalSupply += _mintFee(_reserve0, _reserve1, _totalSupply);\n        }\n\n        uint256 amount0 = (liquidity * balance0) / _totalSupply;\n        uint256 amount1 = (liquidity * balance1) / _totalSupply;\n\n        _burn(address(this), liquidity);\n        unchecked {\n            if (tokenOut == token1) {\n                // @dev Swap `token0` for `token1`\n                // - calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.\n                amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1);\n                _transfer(token1, amount1, recipient, unwrapBento);\n                balance1 -= amount1;\n                amountOut = amount1;\n                amount0 = 0;\n            } else {\n                // @dev Swap `token1` for `token0`.\n                require(tokenOut == token0, \"INVALID_OUTPUT_TOKEN\");\n                amount0 += _getAmountOut(amount1, _reserve1 - amount1, _reserve0 - amount0);\n                _transfer(token0, amount0, recipient, unwrapBento);\n                balance0 -= amount0;\n                amountOut = amount0;\n                amount1 = 0;\n            }\n        }\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\n        kLast = TridentMath.sqrt(balance0 * balance1);\n        emit Burn(msg.sender, amount0, amount1, recipient);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The ConstantProductPool.burnSingle function is basically a burn followed by a swap and must therefore act the same way as calling these two functions sequentially. The token amounts to redeem (amount0, amount1) are computed on the balance (not the reserve). However, the swap amount is then computed on the reserves and not the balance. The burn function would have updated the reserve to the balances and therefore balance should be used here:",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    uint256 internal constant BASE = 10**18;\n    uint256 internal constant MIN_TOKENS = 2;\n    uint256 internal constant MAX_TOKENS = 8;\n    uint256 internal constant MIN_FEE = BASE / 10**6;\n    uint256 internal constant MAX_FEE = BASE / 10;\n    uint256 internal constant MIN_WEIGHT = BASE;\n    uint256 internal constant MAX_WEIGHT = BASE * 50;\n    uint256 internal constant MAX_TOTAL_WEIGHT = BASE * 50;\n    uint256 internal constant MIN_BALANCE = BASE / 10**12;\n    uint256 internal constant INIT_POOL_SUPPLY = BASE * 100;\n    uint256 internal constant MIN_POW_BASE = 1;\n    uint256 internal constant MAX_POW_BASE = (2 * BASE) - 1;\n    uint256 internal constant POW_PRECISION = BASE / 10**10;\n    uint256 internal constant MAX_IN_RATIO = BASE / 2;\n    uint256 internal constant MAX_OUT_RATIO = (BASE / 3) + 1;    \n    \n    function _computeSingleOutGivenPoolIn(\n        uint256 tokenOutBalance,\n        uint256 tokenOutWeight,\n        uint256 _totalSupply,\n        uint256 _totalWeight,\n        uint256 toBurn,\n        uint256 _swapFee\n    ) internal pure returns (uint256 amountOut) {\n        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);\n        uint256 newPoolSupply = _totalSupply - toBurn;\n        uint256 poolRatio = _div(newPoolSupply, _totalSupply);\n        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));\n        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);\n        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;\n        uint256 zaz = (BASE - normalizedWeight) * _swapFee;\n        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));\n    }\n    \n        \n    function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {\n        uint256 c0 = a * BASE;\n        uint256 c1 = c0 + (b / 2);\n        c2 = c1 / b;\n    }\n    \n    function _pow(uint256 a, uint256 n) internal pure returns (uint256 output) {\n        output = n % 2 != 0 ? a : BASE;\n        for (n /= 2; n != 0; n /= 2) \n            a = a * a;\n            if (n % 2 != 0) output = output * a;\n    }\n        \n    function _mul(uint256 a, uint256 b) internal pure returns (uint256 c2) {\n        uint256 c0 = a * b;\n        uint256 c1 = c0 + (BASE / 2);\n        c2 = c1 / BASE;\n    }\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-09-sushitrident#h-14-incorrect-usage-of-_pow-in-_computesingleoutgivenpoolin-of-indexpool",
                "Location": "   function _computeSingleOutGivenPoolIn(\n        uint256 tokenOutBalance,\n        uint256 tokenOutWeight,\n        uint256 _totalSupply,\n        uint256 _totalWeight,\n        uint256 toBurn,\n        uint256 _swapFee\n    ) internal pure returns (uint256 amountOut) {\n        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);\n        uint256 newPoolSupply = _totalSupply - toBurn;\n        uint256 poolRatio = _div(newPoolSupply, _totalSupply);\n        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));\n        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);\n        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;\n        uint256 zaz = (BASE - normalizedWeight) * _swapFee;\n        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The _computeSingleOutGivenPoolIn function of IndexPool uses the _pow function to calculate tokenOutRatio with the exponent in WAD (i.e., in 18 decimals of precision). However, the _pow function assumes that the given exponent n is not in WAD. (for example, _pow(5, BASE) returns 5 ** (10 ** 18) instead of 5 ** 1). The misuse of the _pow function could causes an integer overflow in the _computeSingleOutGivenPoolIn function and thus prevent any function from calling it.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    uint256 internal constant BASE = 10**18;\n    uint256 internal constant MIN_TOKENS = 2;\n    uint256 internal constant MAX_TOKENS = 8;\n    uint256 internal constant MIN_FEE = BASE / 10**6;\n    uint256 internal constant MAX_FEE = BASE / 10;\n    uint256 internal constant MIN_WEIGHT = BASE;\n    uint256 internal constant MAX_WEIGHT = BASE * 50;\n    uint256 internal constant MAX_TOTAL_WEIGHT = BASE * 50;\n    uint256 internal constant MIN_BALANCE = BASE / 10**12;\n    uint256 internal constant INIT_POOL_SUPPLY = BASE * 100;\n    uint256 internal constant MIN_POW_BASE = 1;\n    uint256 internal constant MAX_POW_BASE = (2 * BASE) - 1;\n    uint256 internal constant POW_PRECISION = BASE / 10**10;\n    uint256 internal constant MAX_IN_RATIO = BASE / 2;\n    uint256 internal constant MAX_OUT_RATIO = (BASE / 3) + 1;\n\n    function _computeSingleOutGivenPoolIn(\n        uint256 tokenOutBalance,\n        uint256 tokenOutWeight,\n        uint256 _totalSupply,\n        uint256 _totalWeight,\n        uint256 toBurn,\n        uint256 _swapFee\n    ) internal pure returns (uint256 amountOut) {\n        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);\n        uint256 newPoolSupply = _totalSupply - toBurn;\n        uint256 poolRatio = _div(newPoolSupply, _totalSupply);\n        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));\n        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);\n        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;\n        uint256 zaz = (BASE - normalizedWeight) * _swapFee;\n        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));\n    }\n\n    function _mul(uint256 a, uint256 b) internal pure returns (uint256 c2) {\n        uint256 c0 = a * b;\n        uint256 c1 = c0 + (BASE / 2);\n        c2 = c1 / BASE;\n    }\n\n    function _div(uint256 a, uint256 b) internal pure returns (uint256 c2) {\n        uint256 c0 = a * BASE;\n        uint256 c1 = c0 + (b / 2);\n        c2 = c1 / b;\n    }\n\n\n    function _pow(uint256 a, uint256 n) internal pure returns (uint256 output) {\n        output = n % 2 != 0 ? a : BASE;\n        for (n /= 2; n != 0; n /= 2)\n            a = a * a;\n            if (n % 2 != 0) output = output * a;\n    }\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-09-sushitrident#h-15-incorrect-multiplication-in-_computesingleoutgivenpoolin-of-indexpool",
                "Location": "    function _computeSingleOutGivenPoolIn(\n        uint256 tokenOutBalance,\n        uint256 tokenOutWeight,\n        uint256 _totalSupply,\n        uint256 _totalWeight,\n        uint256 toBurn,\n        uint256 _swapFee\n    ) internal pure returns (uint256 amountOut) {\n        uint256 normalizedWeight = _div(tokenOutWeight, _totalWeight);\n        uint256 newPoolSupply = _totalSupply - toBurn;\n        uint256 poolRatio = _div(newPoolSupply, _totalSupply);\n        uint256 tokenOutRatio = _pow(poolRatio, _div(BASE, normalizedWeight));\n        uint256 newBalanceOut = _mul(tokenOutRatio, tokenOutBalance);\n        uint256 tokenAmountOutBeforeSwapFee = tokenOutBalance - newBalanceOut;\n        uint256 zaz = (BASE - normalizedWeight) * _swapFee;\n        amountOut = _mul(tokenAmountOutBeforeSwapFee, (BASE - zaz));\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The _computeSingleOutGivenPoolIn function of IndexPool uses the raw multiplication (i.e., *) to calculate the zaz variable. However, since both (BASE - normalizedWeight) and _swapFee are in WAD, the _mul function should be used instead to calculate the correct value of zaz. Otherwise, zaz would be 10 ** 18 times larger than the expected value and causes an integer underflow when calculating amountOut. The incorrect usage of multiplication prevents anyone from calling the function successfully.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "        function _calculatePrizeTierFraction(\n        IPrizeDistributionBuffer.PrizeDistribution memory _prizeDistribution,\n        uint256 _prizeTierIndex\n    ) internal pure returns (uint256) {\n         // get the prize fraction at that index\n        uint256 prizeFraction = _prizeDistribution.tiers[_prizeTierIndex];\n\n        // calculate number of prizes for that index\n        uint256 numberOfPrizesForIndex = _numberOfPrizesForIndex(\n            _prizeDistribution.bitRangeSize,\n            _prizeTierIndex\n        );\n\n        return prizeFraction / numberOfPrizesForIndex;\n    }\n\n\n    function _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 bitRangeDecimal = 2**uint256(_bitRangeSize);\n        uint256 numberOfPrizesForIndex = bitRangeDecimal**_prizeTierIndex;\n\n        while (_prizeTierIndex > 0) {\n            numberOfPrizesForIndex -= bitRangeDecimal**(_prizeTierIndex - 1);\n            _prizeTierIndex--;\n        }\n\n        return numberOfPrizesForIndex;\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-10-pooltogether#h-01-the-formula-of-number-of-prizes-for-a-degree-is-wrong",
                "Location": "function _numberOfPrizesForIndex(uint8 _bitRangeSize, uint256 _prizeTierIndex)\n    internal\n    pure\n    returns (uint256)\n{\n    uint256 bitRangeDecimal = 2**uint256(_bitRangeSize);\n    uint256 numberOfPrizesForIndex = bitRangeDecimal**_prizeTierIndex;\n    while (_prizeTierIndex > 0) {\n        numberOfPrizesForIndex -= bitRangeDecimal**(_prizeTierIndex - 1);\n        _prizeTierIndex--;\n    }\n    return numberOfPrizesForIndex;\n}",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. Due to the miscalculation of number of prizes for a degree, it will be smaller than expected, as a result, prize for a degree will be larger than expected. Making the protocol giving out more prizes than designed.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "  function exit(Hash.Order[] calldata o, uint256[] calldata a, Sig.Components[] calldata c) external returns (bool) {\n    for (uint256 i=0; i < o.length; i++) {\n      if (!o[i].exit) {\n          if (!o[i].vault) {\n            exitZcTokenFillingZcTokenInitiate(o[i], a[i], c[i]);\n          } else {\n            exitVaultFillingVaultInitiate(o[i], a[i], c[i]);\n          }\n      } else {\n        if (!o[i].vault) {\n          exitVaultFillingZcTokenExit(o[i], a[i], c[i]);\n        } else {\n          exitZcTokenFillingVaultExit(o[i], a[i], c[i]);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require(a <= (o.principal - filled[hash]), 'taker amount > available volume');\n\n    filled[hash] += a;\n\n    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;\n    uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;\n\n    Erc20 uToken = Erc20(o.underlying);\n    uToken.transferFrom(o.maker, msg.sender, premiumFilled - fee);\n\n    uToken.transferFrom(msg.sender, address(this), fee);\n\n    require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), 'vault exchange failed');\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n  function exitVaultFillingZcTokenExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require(a <= (o.principal - filled[hash]), 'taker amount > available volume');\n\n    filled[hash] += a;\n\n    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;\n    uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;\n\n    // redeem underlying on Compound and burn cTokens\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);\n    require((CErc20(cTokenAddr).redeemUnderlying(a) == 0), \"compound redemption error\");\n\n    Erc20 uToken = Erc20(o.underlying);\n    // transfer principal-premium  back to fixed exit party now that the interest coupon and zcb have been redeemed\n    uToken.transfer(o.maker, a - premiumFilled);\n    uToken.transfer(msg.sender, premiumFilled - fee);\n\n    require(mPlace.custodialExit(o.underlying, o.maturity, o.maker, msg.sender, a), 'custodial exit failed');\n\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }\n\n\n  function exitZcTokenFillingVaultExit(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require(a <= (o.premium - filled[hash]), 'taker amount > available volume');\n\n    filled[hash] += a;\n\n    uint256 principalFilled = (((a * 1e18) / o.premium) * o.principal) / 1e18;\n    uint256 fee = ((principalFilled * 1e18) / fenominator[1]) / 1e18;\n\n    MarketPlace mPlace = MarketPlace(marketPlace);\n    address cTokenAddr = mPlace.cTokenAddress(o.underlying, o.maturity);\n    require((CErc20(cTokenAddr).redeemUnderlying(principalFilled) == 0), \"compound redemption error\");\n\n    Erc20 uToken = Erc20(o.underlying);\n    uToken.transfer(msg.sender, principalFilled - a - fee);\n    uToken.transfer(o.maker, a);\n\n    require(mPlace.custodialExit(o.underlying, o.maturity, msg.sender, o.maker, principalFilled), 'custodial exit failed');\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, principalFilled);\n  }\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-09-swivel#h-02-swivel-taker-is-charged-fees-twice-in-exitvaultfillingvaultinitiate",
                "Location": "  function exitVaultFillingVaultInitiate(Hash.Order calldata o, uint256 a, Sig.Components calldata c) internal {\n    bytes32 hash = validOrderHash(o, c);\n\n    require(a <= (o.principal - filled[hash]), 'taker amount > available volume');\n    \n    filled[hash] += a;\n        \n    uint256 premiumFilled = (((a * 1e18) / o.principal) * o.premium) / 1e18;\n    uint256 fee = ((premiumFilled * 1e18) / fenominator[3]) / 1e18;\n\n    Erc20 uToken = Erc20(o.underlying);\n    // transfer premium minus fee from maker to sender\n    uToken.transferFrom(o.maker, msg.sender, premiumFilled - fee);\n\n    // transfer fee in underlying to swivel from sender\n    uToken.transferFrom(msg.sender, address(this), fee);\n\n    // transfer <a> vault.notional (nTokens) from sender to maker\n    require(MarketPlace(marketPlace).p2pVaultExchange(o.underlying, o.maturity, msg.sender, o.maker, a), 'vault exchange failed');\n\n    emit Exit(o.key, hash, o.maker, o.vault, o.exit, msg.sender, a, premiumFilled);\n  }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. Taker is charged fees twice in exitVaultFillingVaultInitiate() . Maker is transferring less than premiumFilled to taker and then taker is expected to pay fees i.e. taker\ufffd\ufffds net balance is premiumFilled - 2*fee",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: (c) Mochi.Fi, 2021\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@mochifi/library/contracts/CheapERC20.sol\";\nimport \"../interfaces/IERC3156FlashLender.sol\";\nimport \"../interfaces/IMochiVault.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\nimport \"../interfaces/IUSDM.sol\";\n\ncontract MochiVault is Initializable, IMochiVault, IERC3156FlashLender {\n    using Float for uint256;\n    using CheapERC20 for IERC20;\n\n    bytes32 public constant CALLBACK_SUCCESS =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    /// immutable variables\n    IMochiEngine public immutable engine;\n    IERC20 public override asset;\n\n    /// for accruing debt\n    uint256 public debtIndex;\n    uint256 public lastAccrued;\n\n    uint256 public override debts;\n    int256 public override claimable;\n\n    mapping(uint256 => Detail) public override details;\n\n    modifier updateDebt(uint256 _id) {\n        accrueDebt(_id);\n        _;\n    }\n    \n    function accrueDebt(uint256 _id) public {\n        // global debt for vault\n        // first, increase gloabal debt;\n        uint256 currentIndex = liveDebtIndex();\n        uint256 increased = (debts * currentIndex) / debtIndex - debts;\n        debts += increased;\n        claimable += int256(increased);\n        // update global debtIndex\n        debtIndex = currentIndex;\n        lastAccrued = block.timestamp;\n        // individual debt\n        if (_id != type(uint256).max && details[_id].debtIndex < debtIndex) {\n            require(details[_id].status != Status.Invalid, \"invalid\");\n            if (details[_id].debt != 0) {\n                uint256 increasedDebt = (details[_id].debt * debtIndex) /\n                    details[_id].debtIndex -\n                    details[_id].debt;\n                uint256 discountedDebt = increasedDebt.multiply(\n                    engine.discountProfile().discount(engine.nft().ownerOf(_id))\n                );\n                debts -= discountedDebt;\n                claimable -= int256(discountedDebt);\n                details[_id].debt += (increasedDebt - discountedDebt);\n            }\n            details[_id].debtIndex = debtIndex;\n        }\n    }\n\n    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-10-mochi#h-01-vault-fails-to-track-debt-correctly-that-leads-to-bad-debt",
                "Location": "    function borrow(\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) public override updateDebt(_id) {\n        // update prior to interaction\n        float memory price = engine.cssr().update(address(asset), _data);\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\n            address(asset)\n        );\n        uint256 maxMinted = details[_id].collateral.multiply(cf).multiply(\n            price\n        );\n        require(engine.nft().ownerOf(_id) == msg.sender, \"!approved\");\n        require(engine.nft().asset(_id) == address(asset), \"!asset\");\n        if(details[_id].debt + _amount > maxMinted) {\n            _amount = maxMinted - details[_id].debt;\n        }\n        if(engine.mochiProfile().creditCap(address(asset)) < debts + _amount) {\n            _amount = engine.mochiProfile().creditCap(address(asset)) - debts;\n        }\n        uint256 increasingDebt = (_amount * 1005) / 1000;\n        uint256 totalDebt = details[_id].debt + increasingDebt;\n        require(details[_id].debt + _amount >= engine.mochiProfile().minimumDebt(), \"<minimum\");\n        require(\n            !_liquidatable(details[_id].collateral, price, totalDebt),\n            \"!healthy\"\n        );\n        mintFeeToPool(increasingDebt - _amount, details[_id].referrer);\n        // this will ensure debtIndex will not increase on further `updateDebt` triggers\n        details[_id].debtIndex =\n            (details[_id].debtIndex * (totalDebt)) /\n            (details[_id].debt + _amount);\n        details[_id].debt = totalDebt;\n        details[_id].status = Status.Active;\n        debts += _amount;\n        engine.minter().mint(msg.sender, _amount);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The contract\ufffd\ufffds debt is inconsistent with the total sum of all users\ufffd\ufffd debt. The bias increases overtime and would break the vault at the end. For simplicity, we assume there\ufffd\ufffds only one user in the vault. Example: User deposits 1.2 M worth of BTC and borrows 1M USDM. The user\ufffd\ufffds debt (details[_id].debt) would be 1.005 M as there\ufffd\ufffds a .5 percent fee. The contract\ufffd\ufffds debt is 1M. BTC price decrease by 20 percent The liquidator tries to liquidate the position. The liquidator repays 1.005 M and the contract tries to sub the debt by 1.005 M The transaction is reverted as details[_id].debt -= _usdm; would raise exception. inaccurate accounting would lead to serious issues. I consider this a high-risk issue.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function _updateGlobalExchangeRate() internal {\n        uint128 currentBlock = uint128(block.number);\n        uint128 currentEpoch = currentBlock < endEpoch? currentBlock : endEpoch;\n        if (currentEpoch != lastUpdateEpoch){\n            // when no one has staked anything, do not update the rate\n            if(totalGlobalShares > 0)\n            {\n                unchecked { globalExchangeRate += uint128(uint256(allocatedTokensPerEpoch) * divider * uint256(currentEpoch - lastUpdateEpoch)/uint256(totalGlobalShares)) ; }\n            }\n            lastUpdateEpoch = currentEpoch;\n        }\n    }\n\n    function _updateValidator(Validator storage v) internal {\n        if(v.disabledEpoch == 0){\n            if (v.totalShares == 0){\n                v.exchangeRate = globalExchangeRate;\n            }\n            else {\n                uint128 rateDifference;\n                unchecked { rateDifference = globalExchangeRate - v.lastUpdateGlobalRate; }\n                uint128 tokensGivenToValidator = _sharesToTokens(v.globalShares, rateDifference);\n                uint128 commissionPaid = uint128(uint256(tokensGivenToValidator) * uint256(v.commissionRate) /  divider);\n                v.exchangeRate += uint128(uint256(tokensGivenToValidator - commissionPaid) * divider / v.totalShares);\n                unchecked { v.commissionAvailableToRedeem += commissionPaid; }\n            }\n            v.lastUpdateGlobalRate = globalExchangeRate;\n        }\n    }\n\n    function unstake(uint128 validatorId, uint128 amount) public {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = validators[validatorId];\n        Staking storage s = v.stakings[msg.sender];\n        require(s.staked >= amount, \"Staked < amount provided\");\n        bool isValidator = msg.sender == v._address;\n        _updateGlobalExchangeRate();\n        _updateValidator(v);disableValidator call and the rest does not matter anymore\n        uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);\n        require(validatorSharesRemove > 0, \"Unstake amount is too small\");\n        if (v.disabledEpoch == 0){\n            if (isValidator && endEpoch > block.number){\n                uint128 newValidatorStaked = s.staked - amount;\n                uint128 newValidatorMaxCap = newValidatorStaked * maxCapMultiplier;\n                uint128 delegated = v.delegated - s.staked;\n                require(delegated <= newValidatorMaxCap, \"Cannot unstake beyond max cap\");\n                require(newValidatorStaked >= validatorMinStakedRequired, \"Unstake > min staked required\");\n            }\n\n            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);\n            require(globalSharesRemove > 0, \"Unstake amount is too small\");\n            unchecked { totalGlobalShares -= globalSharesRemove;}\n            unchecked { v.globalShares -= globalSharesRemove; }\n\n            // update validator shares #\n            unchecked { v.totalShares -= validatorSharesRemove; }\n            unchecked { v.delegated -= amount; }\n        }\n        unchecked { s.shares -= validatorSharesRemove; }\n        unchecked { s.staked -= amount; }\n\n        // create unstaking instance\n        uint128 coolDownEnd = v.disabledEpoch != 0 ? v.disabledEpoch : uint128(block.number);\n        unchecked { coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown); }\n        v.unstakings[msg.sender].push(Unstaking( coolDownEnd, amount));\n        emit Unstaked(validatorId, msg.sender, amount);\n    }\n\n    function _tokensToShares(uint128 amount, uint128 rate) internal view returns(uint128){\n        return uint128(uint256(amount) * divider / uint256(rate));\n    }",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-10-covalent#h-02-unstake-should-update-exchange-rates-first",
                "Location": "    function unstake(uint128 validatorId, uint128 amount) public {\n        require(validatorId < validatorsN, \"Invalid validator\");\n        Validator storage v = validators[validatorId];\n        Staking storage s = v.stakings[msg.sender];\n        require(s.staked >= amount, \"Staked < amount provided\");\n        bool isValidator = msg.sender == v._address;\n        _updateGlobalExchangeRate();\n        _updateValidator(v);\n        // only update if the validator is enabled, otherwise the global shares were already excluded during disableValidator call and the rest does not matter anymore\n        uint128 validatorSharesRemove = _tokensToShares(amount, v.exchangeRate);\n        require(validatorSharesRemove > 0, \"Unstake amount is too small\");\n        if (v.disabledEpoch == 0){\n            // if validator is enabled and the program has not ended -> check for unstaking beyond max cap or min stake required\n            if (isValidator && endEpoch > block.number){\n                uint128 newValidatorStaked = s.staked - amount;\n                uint128 newValidatorMaxCap = newValidatorStaked * maxCapMultiplier;\n                uint128 delegated = v.delegated - s.staked;\n                require(delegated <= newValidatorMaxCap, \"Cannot unstake beyond max cap\");\n                require(newValidatorStaked >= validatorMinStakedRequired, \"Unstake > min staked required\");\n            }\n\n            // update global shares #\n            uint128 globalSharesRemove = _tokensToShares(amount, globalExchangeRate);\n            require(globalSharesRemove > 0, \"Unstake amount is too small\");\n            unchecked { totalGlobalShares -= globalSharesRemove;}\n            unchecked { v.globalShares -= globalSharesRemove; }\n\n            // update validator shares #\n            unchecked { v.totalShares -= validatorSharesRemove; }\n            unchecked { v.delegated -= amount; }\n        }\n        unchecked { s.shares -= validatorSharesRemove; }\n        unchecked { s.staked -= amount; }\n\n        // create unstaking instance\n        uint128 coolDownEnd = v.disabledEpoch != 0 ? v.disabledEpoch : uint128(block.number);\n        unchecked { coolDownEnd += (isValidator ? validatorCoolDown : delegatorCoolDown); }\n        v.unstakings[msg.sender].push(Unstaking( coolDownEnd, amount));\n        emit Unstaked(validatorId, msg.sender, amount);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Incorrect calculating order. The unstake function does not immediately update the exchange rates. It first computes the validatorSharesRemove = tokensToShares(amount, v.exchangeRate) with the old exchange rate.\n\nOnly afterwards, it updates the exchange rates (if the validator is not disabled)",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\nimport \"../governance/EmergencyPausable.sol\";\nimport \"../utils/Math.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract Swap is EmergencyPausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using Math for uint256;\n\n    address payable public feeRecipient;\n    uint256 public swapFee;\n    uint256 public constant SWAP_FEE_DIVISOR = 100_000;\n\n    event SwappedTokens(\n        address tokenSold,\n        address tokenBought,\n        uint256 amountSold,\n        uint256 amountBought,\n        uint256 amountBoughtFee\n    );\n\n    event NewSwapFee(\n        uint256 newSwapFee\n    );\n\n    event NewFeeRecipient(\n        address newFeeRecipient\n    );\n\n    event FeesSwept(\n        address token,\n        uint256 amount,\n        address recipient\n    );\n\n    constructor(address owner_, address payable feeRecipient_, uint256 swapFee_) {\n        require(owner_ != address(0), \"Swap::constructor: Owner must not be 0\");\n        transferOwnership(owner_);\n        feeRecipient = feeRecipient_;\n        emit NewFeeRecipient(feeRecipient);\n        swapFee = swapFee_;\n        emit NewSwapFee(swapFee);\n    }\n\n    function fillZrxQuote(\n        IERC20 zrxBuyTokenAddress,\n        address payable zrxTo,\n        bytes calldata zrxData,\n        uint256 ethAmount\n    ) internal returns (uint256, uint256) {\n        uint256 originalERC20Balance = 0;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n        }\n        uint256 originalETHBalance = address(this).balance;\n\n        (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n        require(success, \"Swap::fillZrxQuote: Failed to fill quote\");\n\n        uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);\n        uint256 erc20Delta;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);\n            require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n        } else {\n            require(ethDelta > 0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");\n        }\n\n        return (erc20Delta, ethDelta);\n    }\n\n    function signifiesETHOrZero(address tokenAddress) internal pure returns (bool) {\n        return (\n            tokenAddress == address(0) ||\n            tokenAddress == address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee)\n        );\n    }\n\n    function sweepFees(\n        address[] calldata tokens\n    ) external nonReentrant {\n        require(\n            feeRecipient != address(0),\n            \"Swap::withdrawAccruedFees: feeRecipient is not initialized\"\n        );\n        for (uint8 i = 0; i<tokens.length; i++) {\n            uint256 balance = IERC20(tokens[i]).balanceOf(address(this));\n            if (balance > 0) {\n                IERC20(tokens[i]).safeTransfer(feeRecipient, balance);\n                emit FeesSwept(tokens[i], balance, feeRecipient);\n            }\n        }\n        feeRecipient.transfer(address(this).balance);\n        emit FeesSwept(address(0), address(this).balance, feeRecipient);\n    }\n\n    fallback() external payable {}\n    receive() external payable {}\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-10-tally#h-02-wrong-calculation-of-erc20delta-and-ethdelta",
                "Location": "    function fillZrxQuote(\n        IERC20 zrxBuyTokenAddress,\n        address payable zrxTo,\n        bytes calldata zrxData,\n        uint256 ethAmount\n    ) internal returns (uint256, uint256) {\n        uint256 originalERC20Balance = 0;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n        }\n        uint256 originalETHBalance = address(this).balance;\n\n        (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n        require(success, \"Swap::fillZrxQuote: Failed to fill quote\");\n\n        uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);\n        uint256 erc20Delta;\n        if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n            erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);\n            require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n        } else {\n            require(ethDelta > 0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");\n        }\n\n        return (erc20Delta, ethDelta);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. When a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, at L215, ethDelta will always be 0.\n\nThat\ufffd\ufffds because originalETHBalance already includes the msg.value sent by the caller.\n\nLet\ufffd\ufffds say the ETH balance of the contract is 1 ETH before the swap.\n\nA user swaps 10 ETH to USDC;\noriginalETHBalance will be 11 ETH;\nIf there is 1 ETH of refund;\nethDelta will be 0 as the new balance is 2 ETH and subOrZero(2, 11) is 0.\nSimilarly, erc20Delta is also computed wrong.\n\nConsider a special case of a user trying to arbitrage from WBTC to WBTC, the originalERC20Balance already includes the input amount, erc20Delta will always be much lower than the actual delta amount.\n\nFor example, for an arb swap from 1 WBTC to 1.1 WBTC, the ethDelta will be 0.1 WBTC while it should be 1.1 WBTC.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../Controller.sol\";\nimport \"../interfaces/IUserManager.sol\";\nimport \"../interfaces/IAssetManager.sol\";\nimport \"../interfaces/IUErc20.sol\";\nimport \"../interfaces/IInterestRateModel.sol\";\n\ncontract UToken is Controller, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IUErc20;\n\n    bool public constant IS_UTOKEN = true;\n    uint256 public constant WAD = 1e18;\n\n    address public underlying;\n    IInterestRateModel public interestRateModel;\n    uint256 public borrowIndex;\n    uint256 public totalBorrows;\n    uint256 public totalReserves;\n    uint256 public overdueBlocks;\n    uint256 public originationFee;\n    uint256 public debtCeiling;\n    uint256 public maxBorrow;\n    uint256 public minBorrow;\n    address public assetManager;\n    address public userManager;\n    IUErc20 public uErc20;\n\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interest;\n        uint256 interestIndex;\n        uint256 lastRepay; //Calculate if it is overdue\n    }\n\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    event LogBorrow(address indexed account, uint256 amount, uint256 fee);\n\n    modifier onlyMember(address account) {\n        require(IUserManager(userManager).checkIsMember(account), \"UToken: caller is not a member\");\n        _;\n    }\n\n    function getRemainingLoanSize() public view returns (uint256) {\n        if (debtCeiling >= totalBorrows) {\n            return debtCeiling - totalBorrows;\n        } else {\n            return 0;\n        }\n    }\n\n    function calculatingFee(uint256 amount) public view returns (uint256) {\n        return (originationFee * amount) / WAD;\n    }\n\n    function borrowBalanceView(address account) public view returns (uint256) {\n        return accountBorrows[account].principal + calculatingInterest(account);\n    }\n\n    function checkIsOverdue(address account) public view returns (bool isOverdue) {\n        if (getBorrowed(account) == 0) {\n            isOverdue = false;\n        } else {\n            uint256 lastRepay = getLastRepay(account);\n            uint256 diff = getBlockNumber() - lastRepay;\n            isOverdue = (overdueBlocks < diff);\n        }\n    }\n\n    function borrow(uint256 amount) external onlyMember(msg.sender) whenNotPaused nonReentrant {\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n        require(amount >= minBorrow, \"UToken: amount less than loan size min\");\n\n        require(amount <= getRemainingLoanSize(), \"UToken: amount more than loan global size max\");\n\n        uint256 fee = calculatingFee(amount);\n        require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, \"UToken: amount large than borrow size max\");\n\n        require(!checkIsOverdue(msg.sender), \"UToken: Member has loans overdue\");\n\n        require(amount <= assetManagerContract.getLoanableAmount(underlying), \"UToken: Not enough to lend out\");\n        require(\n            uint256(_getCreditLimit(msg.sender)) >= amount + fee,\n            \"UToken: The loan amount plus fee is greater than credit limit\"\n        );\n\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n\n        uint256 borrowedAmount = borrowBalanceStoredInternal(msg.sender);\n\n        //Set lastRepay init data\n        if (accountBorrows[msg.sender].lastRepay == 0) {\n            accountBorrows[msg.sender].lastRepay = getBlockNumber();\n        }\n\n        uint256 accountBorrowsNew = borrowedAmount + amount + fee;\n        uint256 totalBorrowsNew = totalBorrows + amount + fee;\n        uint256 oldPrincipal = accountBorrows[msg.sender].principal;\n\n        accountBorrows[msg.sender].principal += amount + fee;\n        uint256 newPrincipal = accountBorrows[msg.sender].principal;\n        IUserManager(userManager).updateLockedData(msg.sender, newPrincipal - oldPrincipal, true);\n        accountBorrows[msg.sender].interest = accountBorrowsNew - accountBorrows[msg.sender].principal;\n        accountBorrows[msg.sender].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n        // The origination fees contribute to the reserve\n        totalReserves += fee;\n\n        require(assetManagerContract.withdraw(underlying, msg.sender, amount), \"UToken: Failed to withdraw\");\n\n        emit LogBorrow(msg.sender, amount, fee);\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-10-union#h-01-borrow-must-accrueinterest-first",
                "Location": "   function borrow(uint256 amount) external onlyMember(msg.sender) whenNotPaused nonReentrant {\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n        require(amount >= minBorrow, \"UToken: amount less than loan size min\");\n\n        require(amount <= getRemainingLoanSize(), \"UToken: amount more than loan global size max\");\n\n        uint256 fee = calculatingFee(amount);\n        require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, \"UToken: amount large than borrow size max\");\n\n        require(!checkIsOverdue(msg.sender), \"UToken: Member has loans overdue\");\n\n        require(amount <= assetManagerContract.getLoanableAmount(underlying), \"UToken: Not enough to lend out\");\n        require(\n            uint256(_getCreditLimit(msg.sender)) >= amount + fee,\n            \"UToken: The loan amount plus fee is greater than credit limit\"\n        );\n\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n\n        uint256 borrowedAmount = borrowBalanceStoredInternal(msg.sender);\n\n        //Set lastRepay init data\n        if (accountBorrows[msg.sender].lastRepay == 0) {\n            accountBorrows[msg.sender].lastRepay = getBlockNumber();\n        }\n\n        uint256 accountBorrowsNew = borrowedAmount + amount + fee;\n        uint256 totalBorrowsNew = totalBorrows + amount + fee;\n        uint256 oldPrincipal = accountBorrows[msg.sender].principal;\n\n        accountBorrows[msg.sender].principal += amount + fee;\n        uint256 newPrincipal = accountBorrows[msg.sender].principal;\n        IUserManager(userManager).updateLockedData(msg.sender, newPrincipal - oldPrincipal, true);\n        accountBorrows[msg.sender].interest = accountBorrowsNew - accountBorrows[msg.sender].principal;\n        accountBorrows[msg.sender].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n        // The origination fees contribute to the reserve\n        totalReserves += fee;\n\n        require(assetManagerContract.withdraw(underlying, msg.sender, amount), \"UToken: Failed to withdraw\");\n\n        emit LogBorrow(msg.sender, amount, fee);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Incorrect calculating order. The UToken.borrow function first checks the borrowed balance and the old credit limit before accruing the actual interest on the market. Thus the borrowed balance of the user does not include the latest interest as it uses the old global borrowIndex but the new borrowIndex is only set in accrueInterest.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../math/VaderMath.sol\";\n\nimport \"../../interfaces/reserve/IVaderReserve.sol\";\nimport \"../../interfaces/dex/router/IVaderRouter.sol\";\nimport \"../../interfaces/dex/pool/IVaderPoolFactory.sol\";\n\ncontract VaderRouter is IVaderRouter, ProtocolConstants, Ownable {\n    using SafeERC20 for IERC20;\n\n    IVaderPoolFactory public immutable factory;\n    IVaderReserve public reserve;\n\n    constructor(IVaderPoolFactory _factory) {\n        require(\n            _factory != IVaderPoolFactory(_ZERO_ADDRESS),\n            \"VaderRouter::constructor: Incorrect Arguments\"\n        );\n\n        factory = _factory;\n    }\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual override ensure(deadline) returns (uint256 amountOut) {\n        amountOut = _swap(amountIn, path, to);\n\n        require(\n            amountOut >= amountOutMin,\n            \"VaderRouter::swapExactTokensForTokens: Insufficient Trade Output\"\n        );\n    }\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external virtual ensure(deadline) returns (uint256 amountIn) {\n        amountIn = calculateInGivenOut(amountOut, path);\n\n        require(\n            amountInMax >= amountIn,\n            \"VaderRouter::swapTokensForExactTokens: Large Trade Input\"\n        );\n\n        _swap(amountIn, path, to);\n    }\n\n\n    function _swap(\n        uint256 amountIn,\n        address[] calldata path,\n        address to\n    ) private returns (uint256 amountOut) {\n        if (path.length == 3) {\n            require(\n                path[0] != path[1] &&\n                    path[1] == factory.nativeAsset() &&\n                    path[2] != path[1],\n                \"VaderRouter::_swap: Incorrect Path\"\n            );\n\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool0),\n                amountIn\n            );\n\n            return pool1.swap(0, pool0.swap(amountIn, 0, address(pool1)), to);\n        } else {\n            require(\n                path.length == 2,\n                \"VaderRouter::_swap: Incorrect Path Length\"\n            );\n            address nativeAsset = factory.nativeAsset();\n            require(path[0] != path[1], \"VaderRouter::_swap: Incorrect Path\");\n\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool),\n                amountIn\n            );\n            if (path[0] == nativeAsset) {\n                return pool.swap(amountIn, 0, to);\n            } else {\n                require(\n                    path[1] == nativeAsset,\n                    \"VaderRouter::_swap: Incorrect Path\"\n                );\n                return pool.swap(0, amountIn, to);\n            }\n        }\n    }\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"VaderRouter::ensure: Expired\");\n        _;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-11-vader#h-15-vaderrouter_swap-performs-wrong-swap",
                "Location": "  function _swap(\n        uint256 amountIn,\n        address[] calldata path,\n        address to\n    ) private returns (uint256 amountOut) {\n        if (path.length == 3) {\n            require(\n                path[0] != path[1] &&\n                    path[1] == factory.nativeAsset() &&\n                    path[2] != path[1],\n                \"VaderRouter::_swap: Incorrect Path\"\n            );\n\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool0),\n                amountIn\n            );\n\n            return pool1.swap(0, pool0.swap(amountIn, 0, address(pool1)), to);\n        } else {\n            require(\n                path.length == 2,\n                \"VaderRouter::_swap: Incorrect Path Length\"\n            );\n            address nativeAsset = factory.nativeAsset();\n            require(path[0] != path[1], \"VaderRouter::_swap: Incorrect Path\");\n\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            IERC20(path[0]).safeTransferFrom(\n                msg.sender,\n                address(pool),\n                amountIn\n            );\n            if (path[0] == nativeAsset) {\n                return pool.swap(amountIn, 0, to);\n            } else {\n                require(\n                    path[1] == nativeAsset,\n                    \"VaderRouter::_swap: Incorrect Path\"\n                );\n                return pool.swap(0, amountIn, to);\n            }\n        }\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The 3-path hop in VaderRouter._swap is supposed to first swap foreign assets to native assets, and then the received native assets to different foreign assets again.\n\nThe pool.swap(nativeAmountIn, foreignAmountIn) accepts the foreign amount as the second argument. The code however mixes these positional arguments up and tries to perform a pool0 foreign -> native swap by using the foreign amount as the native amount:",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../shared/ProtocolConstants.sol\";\n\nimport \"../math/VaderMath.sol\";\n\nimport \"../../interfaces/reserve/IVaderReserve.sol\";\nimport \"../../interfaces/dex/router/IVaderRouter.sol\";\nimport \"../../interfaces/dex/pool/IVaderPoolFactory.sol\";\n\ncontract VaderRouter is IVaderRouter, ProtocolConstants, Ownable {\n    using SafeERC20 for IERC20;\n\n    IVaderPoolFactory public immutable factory;\n    IVaderReserve public reserve;\n\n    constructor(IVaderPoolFactory _factory) {\n        require(\n            _factory != IVaderPoolFactory(_ZERO_ADDRESS),\n            \"VaderRouter::constructor: Incorrect Arguments\"\n        );\n\n        factory = _factory;\n    }\n\n\n    function initialize(IVaderReserve _reserve) external onlyOwner {\n        require(\n            _reserve != IVaderReserve(_ZERO_ADDRESS),\n            \"VaderRouter::initialize: Incorrect Reserve Specified\"\n        );\n\n        reserve = _reserve;\n\n        renounceOwnership();\n    }\n\n    function calculateOutGivenIn(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256 amountOut)\n    {\n        if (path.length == 2) {\n            address nativeAsset = factory.nativeAsset();\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            (uint256 nativeReserve, uint256 foreignReserve, ) = pool\n                .getReserves();\n            if (path[0] == nativeAsset) {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve,\n                        foreignReserve\n                    );\n            } else {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        foreignReserve,\n                        nativeReserve\n                    );\n            }\n        } else {\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0\n                .getReserves();\n            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1\n                .getReserves();\n\n            return\n                VaderMath.calculateSwap(\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve1,\n                        foreignReserve1\n                    ),\n                    foreignReserve0,\n                    nativeReserve0\n                );\n        }\n    }\n\n    modifier ensure(uint256 deadline) {\n        require(deadline >= block.timestamp, \"VaderRouter::ensure: Expired\");\n        _;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-11-vader#h-16-vaderroutercalculateoutgivenin-calculates-wrong-swap",
                "Location": "    function calculateOutGivenIn(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256 amountOut)\n    {\n        if (path.length == 2) {\n            address nativeAsset = factory.nativeAsset();\n            IVaderPool pool = factory.getPool(path[0], path[1]);\n            (uint256 nativeReserve, uint256 foreignReserve, ) = pool\n                .getReserves();\n            if (path[0] == nativeAsset) {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve,\n                        foreignReserve\n                    );\n            } else {\n                return\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        foreignReserve,\n                        nativeReserve\n                    );\n            }\n        } else {\n            IVaderPool pool0 = factory.getPool(path[0], path[1]);\n            IVaderPool pool1 = factory.getPool(path[1], path[2]);\n            (uint256 nativeReserve0, uint256 foreignReserve0, ) = pool0\n                .getReserves();\n            (uint256 nativeReserve1, uint256 foreignReserve1, ) = pool1\n                .getReserves();\n\n            return\n                VaderMath.calculateSwap(\n                    VaderMath.calculateSwap(\n                        amountIn,\n                        nativeReserve1,\n                        foreignReserve1\n                    ),\n                    foreignReserve0,\n                    nativeReserve0\n                );\n        }\n    }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The 3-path hop in VaderRouter.calculateOutGivenIn is supposed to first swap foreign assets to native assets in pool0, and then the received native assets to different foreign assets again in pool1. The first argument of VaderMath.calculateSwap(amountIn, reserveIn, reserveOut) must refer to the same token as the second argument reserveIn. The code however mixes these positions up and first performs a swap in pool1 instead of pool0",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nlibrary VaderMath {\n\n    uint256 public constant ONE = 1 ether;\n\n    function calculateLiquidityUnits(\n        uint256 vaderDeposited,\n        uint256 vaderBalance,\n        uint256 assetDeposited,\n        uint256 assetBalance,\n        uint256 totalPoolUnits\n    ) public pure returns (uint256) {\n        // slipAdjustment\n        uint256 slip = calculateSlipAdjustment(\n            vaderDeposited,\n            vaderBalance,\n            assetDeposited,\n            assetBalance\n        );\n\n        uint256 poolUnitFactor = (vaderBalance * assetDeposited) +\n            (vaderDeposited * assetBalance);\n\n        uint256 denominator = ONE * 2 * vaderBalance * assetBalance;\n\n        return ((totalPoolUnits * poolUnitFactor) / denominator) * slip;\n    }\n\n    function calculateSlipAdjustment(\n        uint256 vaderDeposited,\n        uint256 vaderBalance,\n        uint256 assetDeposited,\n        uint256 assetBalance\n    ) public pure returns (uint256) {\n        uint256 vaderAsset = vaderBalance * assetDeposited;\n\n        uint256 assetVader = assetBalance * vaderDeposited;\n\n        uint256 denominator = (vaderDeposited + vaderBalance) *\n            (assetDeposited + assetBalance);\n\n        return ONE - (delta(vaderAsset, assetVader) / denominator);\n    }\n\n    function calculateLoss(\n        uint256 originalVader,\n        uint256 originalAsset,\n        uint256 releasedVader,\n        uint256 releasedAsset\n    ) public pure returns (uint256 loss) {\n        uint256 originalValue = ((originalAsset * releasedVader) /\n            releasedAsset) + originalVader;\n\n        uint256 releasedValue = ((releasedAsset * releasedVader) /\n            releasedAsset) + releasedVader;\n\n        if (originalValue > releasedValue) loss = originalValue - releasedValue;\n    }\n\n    function calculateSwap(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure returns (uint256 amountOut) {\n        // x * Y * X\n        uint256 numerator = amountIn * reserveIn * reserveOut;\n\n        // (x + X) ^ 2\n        uint256 denominator = pow(amountIn + reserveIn);\n\n        amountOut = numerator / denominator;\n    }\n\n    function calculateSwapReverse(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure returns (uint256 amountIn) {\n        uint256 XY = reserveIn * reserveOut;\n\n        uint256 y2 = amountOut * 2;\n\n        uint256 y4 = y2 * 2;\n\n        require(\n            y4 < reserveOut,\n            \"VaderMath::calculateSwapReverse: Desired Output Exceeds Maximum Output Possible (1/4 of Liquidity Pool)\"\n        );\n\n        uint256 numeratorA = root(XY) * root(reserveIn * (reserveOut - y4));\n\n        uint256 numeratorB = y2 * reserveIn;\n        uint256 numeratorC = XY;\n\n        uint256 numerator = numeratorC - numeratorA - numeratorB;\n\n        // 2y\n        uint256 denominator = y2;\n\n        amountIn = numerator / denominator;\n    }\n\n\n    function delta(uint256 a, uint256 b) public pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n\n\n    function pow(uint256 a) public pure returns (uint256) {\n        return a * a;\n    }\n\n\n    function root(uint256 a) public pure returns (uint256 c) {\n        if (a > 3) {\n            c = a;\n            uint256 x = a / 2 + 1;\n            while (x < c) {\n                c = x;\n                x = (a / x + x) / 2;\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-11-vader#h-25-wrong-design-of-swap-results-in-unexpected-and-unfavorable-outputs",
                "Location": "    function calculateSwap(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) public pure returns (uint256 amountOut) {\n        // x * Y * X\n        uint256 numerator = amountIn * reserveIn * reserveOut;\n\n        // (x + X) ^ 2\n        uint256 denominator = pow(amountIn + reserveIn);\n\n        amountOut = numerator / denominator;\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. We believe the design (the formula) is wrong and it will result in unexpected and unfavorable outputs. Specifically, if the amountIn is larger than the reserveIn, the amountOut starts to decrease.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "    function _chargeFees(\n        uint256 thisNft,\n        uint256[] memory tvls,\n        uint256 supply,\n        uint256[] memory deltaTvls,\n        uint256 deltaSupply,\n        bool isWithdraw\n    ) internal {\n        ILpIssuerGovernance vg = ILpIssuerGovernance(address(_vaultGovernance));\n        uint256 elapsed = block.timestamp - lastFeeCharge;\n        if (elapsed < vg.delayedProtocolParams().managementFeeChargeDelay) {\n            return;\n        }\n        lastFeeCharge = block.timestamp;\n        uint256 baseSupply = supply;\n        if (isWithdraw) {\n            baseSupply = 0;\n            if (supply > deltaSupply) {\n                baseSupply = supply - deltaSupply;\n            }\n        }\n\n        if (baseSupply == 0) {\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] = (deltaTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / deltaSupply;\n            }\n            return;\n        }\n\n        uint256[] memory baseTvls = new uint256[](tvls.length);\n        for (uint256 i = 0; i < baseTvls.length; i++) {\n            if (isWithdraw) {\n                baseTvls[i] = tvls[i] - deltaTvls[i];\n            } else {\n                baseTvls[i] = tvls[i];\n            }\n        }\n\n        ILpIssuerGovernance.DelayedStrategyParams memory strategyParams = vg.delayedStrategyParams(thisNft);\n        if (strategyParams.managementFee > 0) {\n            uint256 toMint = (strategyParams.managementFee * baseSupply * elapsed) /\n                (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(strategyParams.strategyTreasury, toMint);\n            emit ManagementFeesCharged(strategyParams.strategyTreasury, strategyParams.managementFee, toMint);\n        }\n        uint256 protocolFee = vg.delayedProtocolPerVaultParams(thisNft).protocolFee;\n        if (protocolFee > 0) {\n            address treasury = vg.internalParams().protocolGovernance.protocolTreasury();\n            uint256 toMint = (protocolFee * baseSupply * elapsed) / (CommonLibrary.DENOMINATOR * CommonLibrary.YEAR);\n            _mint(treasury, toMint);\n            emit ProtocolFeesCharged(treasury, protocolFee, toMint);\n        }\n        uint256 performanceFee = strategyParams.performanceFee;\n        uint256[] memory hwms = _lpPriceHighWaterMarks;\n        if (performanceFee > 0) {\n            uint256 minLpPriceFactor = type(uint256).max;\n            for (uint256 i = 0; i < baseTvls.length; i++) {\n                uint256 hwm = hwms[i];\n                uint256 lpPrice = (baseTvls[i] * CommonLibrary.PRICE_DENOMINATOR) / baseSupply;\n                if (lpPrice > hwm) {\n                    uint256 delta = (lpPrice * CommonLibrary.DENOMINATOR) / hwm;\n                    if (delta < minLpPriceFactor) {\n                        minLpPriceFactor = delta;\n                    }\n                } else {\n                    // not eligible for performance fees\n                    return;\n                }\n            }\n            for (uint256 i = 0; i < tvls.length; i++) {\n                _lpPriceHighWaterMarks[i] += (hwms[i] * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            }\n            address treasury = strategyParams.strategyPerformanceTreasury;\n            uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            _mint(treasury, toMint);\n            emit PerformanceFeesCharged(treasury, performanceFee, toMint);\n        }\n    }\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-12-mellow#h-02-wrong-implementation-of-performancefee-can-cause-users-to-lose-50-to-100-of-their-funds",
                "Location": "address treasury = strategyParams.strategyPerformanceTreasury;\n            uint256 toMint = (baseSupply * minLpPriceFactor) / CommonLibrary.DENOMINATOR;\n            _mint(treasury, toMint);",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. A certain amount of lp tokens (shares of the vault) will be minted to the strategyPerformanceTreasury as performanceFee, the amount is calculated based on the minLpPriceFactor. However, the current formula for toMint is wrong, which issues more than 100% of the current totalSupply of the lp token to the strategyPerformanceTreasury each time. Causing users to lose 50% to 100% of their funds after a few times.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./interfaces/IStabilizerNode.sol\";\nimport \"./Auction.sol\";\nimport \"./Permissions.sol\";\n\n\ncontract AuctionBurnReserveSkew is Initializable, Permissions {\n  using SafeMath for uint256;\n\n  uint256[] public pegObservations;\n  uint256 public auctionAverageLookback = 10;\n\n  IStabilizerNode public stabilizerNode;\n  IAuction public auction;\n\n  // This is the total number of stabilization observation we have seen\n  uint256 public count;\n\n  event SetAuctionAverageLookback(uint256 lookback);\n  event SetStabilizerNode(address stabilizerNode);\n  event SetAuction(address auction);\n  event AbovePegObservation(uint256 amount);\n  event BelowPegObservation(uint256 amount);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _stabilizerNode,\n    address _auction,\n    uint256 _period\n  ) external initializer {\n    _adminSetup(_timelock);\n    _setupRole(STABILIZER_NODE_ROLE, _stabilizerNode);\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    stabilizerNode = IStabilizerNode(_stabilizerNode);\n    auction = IAuction(_auction);\n    auctionAverageLookback = _period;\n\n    for (uint i = 0; i < _period; i++) {\n      pegObservations.push(0);\n    }\n  }\n\n  function consult(uint256 excess) public view returns (uint256) {\n    uint256 frequency = getPegDeltaFrequency();\n    uint256 participation = getAverageParticipation();\n\n    // Weight participation higher than frequency\n    uint256 skew = (frequency + (participation * 2)) / 3;\n\n    return excess.mul(skew).div(10000);\n  }\n\n  function getRealBurnBudget(\n    uint256 maxBurnSpend,\n    uint256 premiumExcess\n  ) public view returns(uint256) {\n\n    if (premiumExcess > maxBurnSpend) {\n      return premiumExcess;\n    }\n\n    uint256 usableExcess = maxBurnSpend.sub(premiumExcess);\n\n    if (usableExcess == 0) {\n      return premiumExcess;\n    }\n\n    uint256 burnable = consult(usableExcess);\n\n    return premiumExcess + burnable;\n  }\n\n  function getAverageParticipation() public view returns (uint256) {\n    uint256 initialAuction = 0;\n    uint256 currentAuctionId = auction.currentAuctionId();\n\n    if (currentAuctionId > auctionAverageLookback) {\n      initialAuction = currentAuctionId - auctionAverageLookback;\n    }\n\n    AuctionData memory aggregate;\n\n    for (uint256 i = initialAuction; i < currentAuctionId; ++i) {\n      (uint256 commitments, uint256 maxCommitments) = auction.getAuctionCommitments(i);\n      aggregate.maxCommitments = aggregate.maxCommitments + maxCommitments;\n      aggregate.commitments = aggregate.commitments + commitments;\n    }\n\n    uint256 participation = 0;\n    if (aggregate.maxCommitments > 0) {\n      participation = aggregate.commitments.mul(10000).div(aggregate.maxCommitments);\n    }\n\n    return participation;\n  }\n\n  function getPegDeltaFrequency() public view returns (uint256) {\n    uint256 initialIndex = 0;\n    uint256 index;\n\n    if (count > auctionAverageLookback) {\n      initialIndex = count - auctionAverageLookback;\n    }\n\n    uint256 total = 0;\n\n    for (uint256 i = initialIndex; i < count; ++i) {\n      index = _getIndexOfObservation(i);\n      total = total + pegObservations[index];\n    }\n\n    return total * 10000 / auctionAverageLookback;\n  }\n\n  function _getIndexOfObservation(uint _index) internal view returns (uint index) {\n    return _index % auctionAverageLookback;\n  }\n\n\n  function setAuctionAverageLookback(uint256 _lookback)\n    external\n    onlyRole(ADMIN_ROLE, \"Must have admin role\")\n  {\n    require(_lookback > 0, \"Cannot have zero lookback period\");\n\n    if (_lookback > auctionAverageLookback) {\n      for (uint i = auctionAverageLookback; i < _lookback; i++) {\n        pegObservations.push(0);\n      }\n    }\n\n    auctionAverageLookback = _lookback;\n    emit SetAuctionAverageLookback(_lookback);\n  }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-11-malt#h-04-auctionburnreserveskewgetpegdeltafrequency-wrong-implementation-can-result-in-an-improper-amount-of-excess-liquidity-extension-balance-to-be-used-at-the-end-of-an-auction-",
                "Location": "  function getPegDeltaFrequency() public view returns (uint256) {\n    uint256 initialIndex = 0;\n    uint256 index;\n\n    if (count > auctionAverageLookback) {\n      initialIndex = count - auctionAverageLookback;\n    }\n\n    uint256 total = 0;\n\n    for (uint256 i = initialIndex; i < count; ++i) {\n      index = _getIndexOfObservation(i);\n      total = total + pegObservations[index];\n    }\n\n    return total * 10000 / auctionAverageLookback;\n  }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. When count < auctionAverageLookback, at L131, it should be return total * 10000 / count;. The current implementation will return a smaller value than expected. The result of getPegDeltaFrequency() will be used for calculating realBurnBudget for auctions. With the result of getPegDeltaFrequency() being inaccurate, can result in an improper amount of excess Liquidity Extension balance to be used at the end of an auction.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"./BoringCrypto/BoringMath.sol\";\nimport \"./BoringCrypto/BoringERC20.sol\";\nimport \"./BoringCrypto/Domain.sol\";\nimport \"./BoringCrypto/ERC20.sol\";\nimport \"./BoringCrypto/IERC20.sol\";\nimport \"./BoringCrypto/BoringOwnable.sol\";\nimport \"./IsYETIRouter.sol\";\n\n\ninterface IYETIToken is IERC20 {\n    function sendToSYETI(address _sender, uint256 _amount) external;\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\n\ncontract sYETIToken is IERC20, Domain, BoringOwnable {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using BoringERC20 for IERC20;\n\n    string public constant symbol = \"sYETI\";\n    string public constant name = \"Staked YETI Tokens\";\n    uint8 public constant decimals = 18;\n    uint256 public override totalSupply;\n    uint256 private constant LOCK_TIME = 69 hours;\n    uint256 public effectiveYetiTokenBalance;\n    uint256 public lastBuybackTime;\n    uint256 public lastBuybackPrice;\n    uint256 public lastRebaseTime;\n    uint256 public transferRatio; // 100% = 1e18. Amount to transfer over each rebase. \n    IYETIToken public yetiToken;\n    IERC20 public yusdToken;\n    bool private addressesSet;\n\n\n    mapping(address => bool) public validRouters;\n\n    struct User {\n        uint128 balance;\n        uint128 lockedUntil;\n    }\n\n    mapping(address => User) public users;\n    mapping(address => mapping(address => uint256)) public override allowance;\n    mapping(address => uint256) public nonces;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event BuyBackExecuted(uint YUSDToSell, uint amounts0, uint amounts1);\n    event Rebase(uint additionalYetiTokenBalance);\n\n    function balanceOf(address user) public view override returns (uint256) {\n        return users[user].balance;\n    }\n\n    function setAddresses(IYETIToken _yeti, IERC20 _yusd) external onlyOwner {\n        require(!addressesSet, \"addresses already set\");\n        yetiToken = _yeti;\n        yusdToken = _yusd;\n        addressesSet = true;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        User memory fromUser = users[from];\n        require(block.timestamp >= fromUser.lockedUntil, \"Locked\");\n        if (shares != 0) {\n            require(fromUser.balance >= shares, \"Low balance\");\n            if (from != to) {\n                require(to != address(0), \"Zero address\"); // Moved down so other failed calls safe some gas\n                User memory toUser = users[to];\n                uint128 shares128 = shares.to128();\n                users[from].balance = fromUser.balance - shares128; // Underflow is checked\n                users[to].balance = toUser.balance + shares128; // Can't overflow because totalSupply would be greater than 2^128-1;\n            }\n        }\n        emit Transfer(from, to, shares);\n    }\n\n\n    function rebase() external {\n        require(block.timestamp >= lastRebaseTime + 8 hours, \"Can only rebase every 8 hours\");\n\n        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));\n        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance);\n        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance);\n        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18);\n        if (amountYetiToRebase > adjustedYetiTokenBalance) {\n            amountYetiToRebase = adjustedYetiTokenBalance;\n        }\n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);\n        lastRebaseTime = block.timestamp;\n        emit Rebase(amountYetiToRebase);\n    }\n\n\n    function _getValueOfContract(uint _adjustedYetiTokenBalance) internal view returns (uint256) {\n        uint256 yusdTokenBalance = yusdToken.balanceOf(address(this));\n        return div(yusdTokenBalance.mul(1e18), lastBuybackPrice).add(_adjustedYetiTokenBalance);\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        require(b != 0, \"BoringMath: Div By 0\");\n        return a / b;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-12-yetifinance#h-02-yeti-token-rebase-checks-the-additional-token-amount-incorrectly",
                "Location": "    function rebase() external {\n        require(block.timestamp >= lastRebaseTime + 8 hours, \"Can only rebase every 8 hours\");\n        // Use last buyback price to transfer some of the actual YETI Tokens that this contract owns \n        // to the effective yeti token balance. Transfer a portion of the value over to the effective balance\n\n        // raw balance of the contract\n        uint256 yetiTokenBalance = yetiToken.balanceOf(address(this));  \n        // amount of YETI free / available to give out\n        uint256 adjustedYetiTokenBalance = yetiTokenBalance.sub(effectiveYetiTokenBalance); \n        // in YETI, amount that should be eligible to give out.\n        uint256 valueOfContract = _getValueOfContract(adjustedYetiTokenBalance); \n        // in YETI, amount to rebase\n        uint256 amountYetiToRebase = div(valueOfContract.mul(transferRatio), 1e18); \n        // Ensure that the amount of YETI tokens effectively added is >= the amount we have repurchased. \n        // Amount available = adjustdYetiTokenBalance, amount to distribute is amountYetiToRebase\n        if (amountYetiToRebase > adjustedYetiTokenBalance) {\n            amountYetiToRebase = adjustedYetiTokenBalance;\n        }\n        // rebase amount joins the effective supply. \n        effectiveYetiTokenBalance = effectiveYetiTokenBalance.add(amountYetiToRebase);\n        // update rebase time\n        lastRebaseTime = block.timestamp;\n        emit Rebase(amountYetiToRebase);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The condition isn't checked now as the whole balance is used instead of the Yeti tokens bought back from the market. As it's not checked, the amount added to effectiveYetiTokenBalance during rebase can exceed the actual amount of the Yeti tokens owned by the contract. As the before check amount is calculated as the contract net worth, it can be fixed by immediate buy back, but it will not be the case. The deficit of Yeti tokens can materialize in net worth terms as well if Yeti tokens price will raise compared to the last used one. In this case users will be cumulatively accounted with the amount of tokens that cannot be actually withdrawn from the contract, as its net holdings will be less then total users' claims. In other words, the contract will be in default if enough users claim after that.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"../external/libraries/UniswapV2OracleLibrary.sol\";\n\nimport \"../interfaces/external/chainlink/IAggregatorV3.sol\";\nimport \"../interfaces/external/uniswap/IUniswapV2Pair.sol\";\n\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\nimport \"../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\n\ncontract LiquidityBasedTWAP is ILiquidityBasedTWAP, Ownable {\n    using FixedPoint for FixedPoint.uq112x112;\n    using FixedPoint for FixedPoint.uq144x112;\n\n\n    address public immutable vader;\n    IVaderPoolV2 public immutable vaderPool;\n\n    IUniswapV2Pair[] public vaderPairs;\n    IERC20[] public usdvPairs;\n\n    uint256 public override maxUpdateWindow;\n    uint256[2] public totalLiquidityWeight;\n    uint256[2] public override previousPrices;\n    mapping(address => ExchangePair) public twapData;\n    mapping(address => IAggregatorV3) public oracles;\n\n\n    constructor(address _vader, IVaderPoolV2 _vaderPool) {\n        require(\n            _vader != address(0) && _vaderPool != IVaderPoolV2(address(0)),\n            \"LBTWAP::construction: Zero Address\"\n        );\n        vader = _vader;\n        vaderPool = _vaderPool;\n    }\n\n    function syncVaderPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = vaderPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateVaderPrice(\n                pair,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;\n    }\n\n\n    function _updateVaderPrice(\n        IUniswapV2Pair pair,\n        ExchangePair storage pairData,\n        uint256 timeElapsed\n    ) internal returns (uint256 currentLiquidityEvaluation) {\n        bool isFirst = pair.token0() == vader;\n\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n\n        (uint256 reserveNative, uint256 reserveForeign) = isFirst\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n\n        (\n            uint256 price0Cumulative,\n            uint256 price1Cumulative,\n            uint256 currentMeasurement\n        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));\n\n        uint256 nativeTokenPriceCumulative = isFirst\n            ? price0Cumulative\n            : price1Cumulative;\n\n        unchecked {\n            pairData.nativeTokenPriceAverage = FixedPoint.uq112x112(\n                uint224(\n                    (nativeTokenPriceCumulative -\n                        pairData.nativeTokenPriceCumulative) / timeElapsed\n                )\n            );\n        }\n\n        pairData.nativeTokenPriceCumulative = nativeTokenPriceCumulative;\n\n        pairData.lastMeasurement = currentMeasurement;\n\n        currentLiquidityEvaluation =\n            (reserveNative * previousPrices[uint256(Paths.VADER)]) +\n            (reserveForeign * getChainlinkPrice(pairData.foreignAsset));\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-12-vader#h-04-vader-twap-averages-wrong",
                "Location": "    function syncVaderPrice()\n        public\n        override\n        returns (\n            uint256[] memory pastLiquidityWeights,\n            uint256 pastTotalLiquidityWeight\n        )\n    {\n        uint256 _totalLiquidityWeight;\n        uint256 totalPairs = vaderPairs.length;\n        pastLiquidityWeights = new uint256[](totalPairs);\n        pastTotalLiquidityWeight = totalLiquidityWeight[uint256(Paths.VADER)];\n\n        for (uint256 i; i < totalPairs; ++i) {\n            IUniswapV2Pair pair = vaderPairs[i];\n            ExchangePair storage pairData = twapData[address(pair)];\n            uint256 timeElapsed = block.timestamp - pairData.lastMeasurement;\n\n            if (timeElapsed < pairData.updatePeriod) continue;\n\n            uint256 pastLiquidityEvaluation = pairData.pastLiquidityEvaluation;\n            uint256 currentLiquidityEvaluation = _updateVaderPrice(\n                pair,\n                pairData,\n                timeElapsed\n            );\n\n            pastLiquidityWeights[i] = pastLiquidityEvaluation;\n\n            pairData.pastLiquidityEvaluation = currentLiquidityEvaluation;\n\n            _totalLiquidityWeight += currentLiquidityEvaluation;\n        }\n\n        totalLiquidityWeight[uint256(Paths.VADER)] = _totalLiquidityWeight;\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The vader price in LiquidityBasedTWAP.getVaderPrice is computed using the pastLiquidityWeights and pastTotalLiquidityWeight return values of the syncVaderPrice. The syncVaderPrice function does not initialize all weights and the total liquidity weight does not equal the sum of the individual weights because it skips initializing the pair with the previous data if the TWAP update window has not been reached yet",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\n\npragma solidity =0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../shared/ProtocolConstants.sol\";\n\nimport \"../interfaces/shared/IERC20Extended.sol\";\nimport \"../interfaces/tokens/IUSDV.sol\";\nimport \"../interfaces/reserve/IVaderReserve.sol\";\nimport \"../interfaces/lbt/ILiquidityBasedTWAP.sol\";\n\n// TBD\ncontract USDV is IUSDV, ProtocolConstants, ERC20, Ownable {\n\n    using SafeERC20 for IERC20Extended;\n\n    IERC20Extended public immutable vader;\n\n    ILiquidityBasedTWAP public lbt;\n\n    uint256 public exchangeFee;\n\n    uint256 public dailyLimit = type(uint256).max;\n\n    uint256 public cycleTimestamp;\n\n    uint256 public cycleMints;\n\n    mapping(address => Lock[]) public locks;\n\n    address public guardian;\n\n    bool private isLocked;\n\n    constructor(IERC20Extended _vader) ERC20(\"Vader USD\", \"USDV\") {\n        require(\n            _vader != IERC20Extended(_ZERO_ADDRESS),\n            \"USDV::constructor: Improper Configuration\"\n        );\n        vader = _vader;\n    }\n\n\n    function mint(uint256 vAmount)\n        external\n        onlyWhenNotLocked\n        returns (uint256 uAmount)\n    {\n        uint256 vPrice = lbt.getVaderPrice();\n\n        vader.transferFrom(msg.sender, address(this), vAmount);\n        vader.burn(vAmount);\n\n        uAmount = (vPrice * vAmount) / 1e18;\n\n        if (cycleTimestamp <= block.timestamp) {\n            cycleTimestamp = block.timestamp + 24 hours;\n            cycleMints = uAmount;\n        } else {\n            cycleMints += uAmount;\n            require(\n                cycleMints <= dailyLimit,\n                \"USDV::mint: 24 Hour Limit Reached\"\n            );\n        }\n\n        if (exchangeFee != 0) {\n            uint256 fee = (uAmount * exchangeFee) / _MAX_BASIS_POINTS;\n            uAmount = uAmount - fee;\n            _mint(owner(), fee);\n        }\n\n        _mint(address(this), uAmount);\n\n        _createLock(LockTypes.USDV, uAmount);\n    }\n\n    function burn(uint256 uAmount)\n        external\n        onlyWhenNotLocked\n        returns (uint256 vAmount)\n    {\n        uint256 uPrice = lbt.getUSDVPrice();\n\n        _burn(msg.sender, uAmount);\n\n        vAmount = (uPrice * uAmount) / 1e18;\n\n        if (exchangeFee != 0) {\n            uint256 fee = (vAmount * exchangeFee) / _MAX_BASIS_POINTS;\n            vAmount = vAmount - fee;\n            vader.mint(owner(), fee);\n        }\n\n        vader.mint(address(this), vAmount);\n\n        _createLock(LockTypes.VADER, vAmount);\n    }\n\n    function claim(uint256 i) external onlyWhenNotLocked returns (uint256) {\n        Lock[] storage userLocks = locks[msg.sender];\n        Lock memory lock = userLocks[i];\n\n        require(lock.release <= block.timestamp, \"USDV::claim: Vesting\");\n\n        uint256 last = userLocks.length - 1;\n        if (i != last) {\n            userLocks[i] = userLocks[last];\n        }\n\n        userLocks.pop();\n\n        if (lock.token == LockTypes.USDV)\n            _transfer(address(this), msg.sender, lock.amount);\n        else vader.transfer(msg.sender, lock.amount);\n\n        emit LockClaimed(msg.sender, lock.token, lock.amount, lock.release);\n\n        return lock.amount;\n    }\n\n    function _createLock(LockTypes lockType, uint256 amount) private {\n        uint256 release = block.timestamp + lbt.maxUpdateWindow();\n\n        locks[msg.sender].push(Lock(lockType, amount, release));\n\n        emit LockCreated(msg.sender, lockType, amount, release);\n    }\n\n    modifier onlyWhenNotLocked() {\n        require(!isLocked);\n        _;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-12-vader#h-09-usdvsol-mint-and-burn-amounts-are-incorrect",
                "Location": "    function mint(uint256 vAmount)\n        external\n        onlyWhenNotLocked\n        returns (uint256 uAmount)\n    {\n        uint256 vPrice = lbt.getVaderPrice();\n\n        vader.transferFrom(msg.sender, address(this), vAmount);\n        vader.burn(vAmount);\n\n        uAmount = (vPrice * vAmount) / 1e18;\n\n        if (cycleTimestamp <= block.timestamp) {\n            cycleTimestamp = block.timestamp + 24 hours;\n            cycleMints = uAmount;\n        } else {\n            cycleMints += uAmount;\n            require(\n                cycleMints <= dailyLimit,\n                \"USDV::mint: 24 Hour Limit Reached\"\n            );\n        }\n\n        if (exchangeFee != 0) {\n            uint256 fee = (uAmount * exchangeFee) / _MAX_BASIS_POINTS;\n            uAmount = uAmount - fee;\n            _mint(owner(), fee);\n        }\n\n        _mint(address(this), uAmount);\n\n        _createLock(LockTypes.USDV, uAmount);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The USDV.mint function queries the price of Vader from the LiquidityBasedTwap contract. The calculation to determine uAmount in mint is actually performed incorrectly. uAmount = (vPrice * vAmount) / 1e18; will return the USD amount for the provided Vader as vPrice is denominated in USD/Vader. This uAmount is subsequently used when minting tokens for the user (locked for a period of time) and fee to the contract owner.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract MasterChef is Ownable, ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed _user, uint indexed _pid, uint _amount);\n    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);\n    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);\n\n    struct UserInfo {\n        uint128 amount;\n        uint128 rewardDebt;\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 depositToken;\n        uint allocPoint;\n        uint lastRewardBlock;\n        uint accConcurPerShare;\n        uint16 depositFeeBP;\n    }\n\n    PoolInfo[] public poolInfo;\n    mapping(uint => mapping(address => UserInfo)) public userInfo;\n    mapping(address => bool) public isDepositor;\n    mapping(address => uint256) public pid;\n    uint public concurPerBlock = 100000 gwei;\n    uint public totalAllocPoint = 0;\n    uint public startBlock;\n    uint public endBlock;\n    IERC20 public concur;\n\n    uint private _concurShareMultiplier = 1e18;\n    uint private _perMille = 1000; // 100%\n\n    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n        concur = _concur;\n        poolInfo.push(\n            PoolInfo({\n            depositToken: IERC20(address(0)),\n            allocPoint : 0,\n            lastRewardBlock : _startBlock,\n            accConcurPerShare : 0,\n            depositFeeBP : 0\n        }));\n    }\n\n    modifier onlyDepositor() {\n        require(isDepositor[msg.sender], \"!depositor\");\n        _;\n    }\n\n    function getMultiplier(uint _from, uint _to) public pure returns (uint) {\n        return _to.sub(_from);\n    }\n\n    function updatePool(uint _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (lpSupply == 0 || pool.allocPoint == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        if(block.number >= endBlock) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }        \n\n        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        pool.lastRewardBlock = block.number;\n    }\n\n    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        updatePool(_pid);\n       \n        if(user.amount > 0) {  \n            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n            if (pending > 0) {\n                safeConcurTransfer(_recipient, pending);\n            }\n        }\n\n        if (_amount > 0) {\n            if (pool.depositFeeBP > 0) {\n                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);\n                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);\n            } else {\n                user.amount = SafeCast.toUint128(user.amount + _amount);\n            }\n        }     \n\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Deposit(_recipient, _pid, _amount);\n    }\n\n    function safeConcurTransfer(address _to, uint _amount) private {\n        uint concurBalance = concur.balanceOf(address(this));\n        bool transferSuccess = false;\n        if (_amount > concurBalance) {\n            transferSuccess = concur.transfer(_to, concurBalance);\n        } else {\n            transferSuccess = concur.transfer(_to, _amount);\n        }\n        require(transferSuccess, \"safeConcurTransfer: transfer failed\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-02-concur#h-02-masterchef-improper-handling-of-deposit-fee",
                "Location": "            if (pool.depositFeeBP > 0) {\n                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);\n                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);",
                "Type": "Erroneous state updates",
                "Description": "Incorrect calculating order. If a pool\ufffd\ufffds deposit fee is non-zero, it is subtracted from the amount to be credited to the user. However, the deposit fee is not credited to anyone, leading to permanent lockups of deposit fees in the relevant depositor contracts (StakingRewards and ConvexStakingWrapper for now).",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    event Deposit(address indexed from, address indexed to, uint256 amount, uint256 shares);\n\n    event Withdraw(address indexed from, address indexed to, uint256 amount, uint256 shares);\n\n    ERC20 public immutable asset;\n\n    uint256 internal immutable ONE;\n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, _asset.decimals()) {\n        asset = _asset;\n\n        unchecked {\n            ONE = 10**decimals;\n        }\n    }\n\n    function deposit(uint256 amount, address to) public virtual returns (uint256 shares) {\n        require((shares = previewDeposit(amount)) != 0, \"ZERO_SHARES\");\n\n        asset.safeTransferFrom(msg.sender, address(this), amount);\n\n        _mint(to, shares);\n\n        emit Deposit(msg.sender, to, amount, shares);\n\n        afterDeposit(amount, shares);\n    }\n\n    function mint(uint256 shares, address to) public virtual returns (uint256 amount) {\n        amount = previewMint(shares);\n\n        asset.safeTransferFrom(msg.sender, address(this), amount);\n\n        _mint(to, amount);\n\n        emit Deposit(msg.sender, to, amount, shares);\n\n        afterDeposit(amount, shares);\n    }\n\n    function withdraw(\n        uint256 amount,\n        address to,\n        address from\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(amount);\n\n        if (msg.sender != from) {\n            uint256 allowed = allowance[from][msg.sender];\n\n            if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(amount, shares);\n\n        _burn(from, shares);\n\n        emit Withdraw(from, to, amount, shares);\n\n        asset.safeTransfer(to, amount);\n    }\n\n    function redeem(\n        uint256 shares,\n        address to,\n        address from\n    ) public virtual returns (uint256 amount) {\n        uint256 allowed = allowance[from][msg.sender];\n\n        if (msg.sender != from && allowed != type(uint256).max) allowance[from][msg.sender] = allowed - shares;\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((amount = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(amount, shares);\n\n        _burn(from, shares);\n\n        emit Withdraw(from, to, amount, shares);\n\n        asset.safeTransfer(to, amount);\n    }\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function assetsOf(address user) public view virtual returns (uint256) {\n        return previewRedeem(balanceOf[user]);\n    }\n\n    function assetsPerShare() public view virtual returns (uint256) {\n        return previewRedeem(ONE);\n    }\n\n    function previewDeposit(uint256 amount) public view virtual returns (uint256) {\n        uint256 supply = totalSupply;\n\n        return supply == 0 ? amount : amount.mulDivDown(supply, totalAssets());\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply;\n\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 amount) public view virtual returns (uint256) {\n        uint256 supply = totalSupply;\n\n        return supply == 0 ? amount : amount.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply;\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function maxDeposit(address) public virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function beforeWithdraw(uint256 amount, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 amount, uint256 shares) internal virtual {}\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-02-tribe-turbo#h-01-erc4626-mint-uses-wrong-amount",
                "Location": "function mint(uint256 shares, address to) public virtual returns (uint256 amount) {\n    amount = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n    // Need to transfer before minting or ERC777s could reenter.\n    asset.safeTransferFrom(msg.sender, address(this), amount);\n    _mint(to, amount);\n    emit Deposit(msg.sender, to, amount, shares);\n    afterDeposit(amount, shares);\n}",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The ERC4626.mint function mints amount instead of shares. This will lead to issues when the asset <> shares are not 1-to-1 as will be the case for most vaults over time. Usually, the asset amount is larger than the share amount as vaults receive asset yield. Therefore, when minting, shares should be less than amount. Users receive a larger share amount here which can be exploited to drain the vault assets.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/ICreditLimitModel.sol\";\n\ncontract CreditLimitByMedian is Ownable, ICreditLimitModel {\n using Math for uint256;\n\n bool public constant override isCreditLimitModel = true;\n uint256 public override effectiveNumber;\n\n constructor(uint256 effectiveNumber_) {\n  effectiveNumber = effectiveNumber_;\n }\n\n function getCreditLimit(uint256[] memory vouchs) public view override returns (uint256) {\n  if (vouchs.length >= effectiveNumber) {\nreturn _findMedian(vouchs);\n  } else {\nreturn 0;\n  }\n }\n\n function getLockedAmount(\n  LockedInfo[] memory array,\n  address account,\n  uint256 amount,\n  bool isIncrease\n ) public pure override returns (uint256) {\n  if (array.length == 0) return 0;\n\n  uint256 newLockedAmount;\n  if (isIncrease) {\nfor (uint256 i = 0; i < array.length; i++) {\n uint256 remainingVouchingAmount;\n if (array[i].vouchingAmount > array[i].lockedAmount) {\n  remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;\n } else {\n  remainingVouchingAmount = 0;\n }\n\n if (remainingVouchingAmount > array[i].availableStakingAmount) {\n  if (array[i].availableStakingAmount > amount) {\nnewLockedAmount = array[i].lockedAmount + amount;\n  } else {\nnewLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;\n  }\n } else {\n  if (remainingVouchingAmount > amount) {\nnewLockedAmount = array[i].lockedAmount + amount;\n  } else {\nnewLockedAmount = array[i].lockedAmount + remainingVouchingAmount;\n  }\n }\n\n if (account == array[i].staker) {\n  return newLockedAmount;\n }\n}\n  } else {\nfor (uint256 i = 0; i < array.length; i++) {\n if (array[i].lockedAmount > amount) {\n  newLockedAmount = array[i].lockedAmount - 1;\n } else {\n  newLockedAmount = 0;\n }\n\n if (account == array[i].staker) {\n  return newLockedAmount;\n }\n}\n  }\n\n  return 0;\n }\n\n function setEffectNumber(uint256 number) external onlyOwner {\n  effectiveNumber = number;\n }\n\n /**\n  *  @dev Find median from uint array\n  *  @param array array\n  *  @return uint256\n  */\n function _findMedian(uint256[] memory array) private pure returns (uint256) {\n  uint256[] memory arr = _sortArray(array);\n  if (arr.length == 0) return 0;\n\n  if (arr.length % 2 == 0) {\nuint256 num1 = arr[arr.length >> 1];\nuint256 num2 = arr[(arr.length >> 1) - 1];\nreturn num1.average(num2);\n  } else {\nreturn arr[arr.length >> 1];\n  }\n }\n\n /**\n  *  @dev Sort uint array\n  *  @param arr array\n  *  @return uint256 array\n  */\n function _sortArray(uint256[] memory arr) private pure returns (uint256[] memory) {\n  uint256 length = arr.length;\n\n  for (uint256 i = 0; i < length; i++) {\nfor (uint256 j = i + 1; j < length; j++) {\n if (arr[i] < arr[j]) {\n  uint256 temp = arr[j];\n  arr[j] = arr[i];\n  arr[i] = temp;\n }\n}\n  }\n\n  return arr;\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-10-union#h-02-wrong-implementation-of-creditlimitbymediansolgetlockedamount-makes-it-unable-to-unlock-lockedamount-in-creditlimitbymedian-model",
                "Location": "    function getLockedAmount(\n        LockedInfo[] memory array,\n        address account,\n        uint256 amount,\n        bool isIncrease\n    ) public pure override returns (uint256) {\n        if (array.length == 0) return 0;\n\n        uint256 newLockedAmount;\n        if (isIncrease) {\n            for (uint256 i = 0; i < array.length; i++) {\n                uint256 remainingVouchingAmount;\n                if (array[i].vouchingAmount > array[i].lockedAmount) {\n                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;\n                } else {\n                    remainingVouchingAmount = 0;\n                }\n\n                if (remainingVouchingAmount > array[i].availableStakingAmount) {\n                    if (array[i].availableStakingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;\n                    }\n                } else {\n                    if (remainingVouchingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;\n                    }\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        } else {\n            for (uint256 i = 0; i < array.length; i++) {\n                if (array[i].lockedAmount > amount) {\n                    newLockedAmount = array[i].lockedAmount - 1;\n                } else {\n                    newLockedAmount = 0;\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        }\n\n        return 0;\n    }",
                "Type": "Erroneous state updates",
                "Description": "Incorrect calculating order. getLockedAmount() is used by UserManager.sol#updateLockedData() to update locked amounts. Based on the context, at L66, newLockedAmount = array[i].lockedAmount - 1; should be newLockedAmount = array[i].lockedAmount - amount;. The current implementation is wrong and makes it impossible to unlock lockedAmount in CreditLimitByMedian model.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Fund.sol\";\nimport \"./Lending.sol\";\nimport \"./RoleAware.sol\";\nimport \"./MarginRouter.sol\";\nimport \"./PriceAware.sol\";\n\nstruct CrossMarginAccount {\n uint256 lastDepositBlock;\n address[] borrowTokens;\n mapping(address => uint256) borrowed;\n mapping(address => uint256) borrowedYieldQuotientsFP;\n address[] holdingTokens;\n mapping(address => uint256) holdings;\n mapping(address => bool) holdsToken;\n}\n\nabstract contract CrossMarginAccounts is RoleAware, PriceAware {\n uint256 public leveragePercent;\n\n uint256 public liquidationThresholdPercent;\n\n mapping(address => CrossMarginAccount) internal marginAccounts;\n mapping(address => uint256) public tokenCaps;\n mapping(address => uint256) public totalShort;\n mapping(address => uint256) public totalLong;\n uint256 public coolingOffPeriod;\n\n function addHolding(\n  CrossMarginAccount storage account,\n  address token,\n  uint256 depositAmount\n ) internal {\n  if (!hasHoldingToken(account, token)) {\naccount.holdingTokens.push(token);\n  }\n\n  account.holdings[token] += depositAmount;\n }\n\n function borrow(\n  CrossMarginAccount storage account,\n  address borrowToken,\n  uint256 borrowAmount\n ) internal {\n  if (!hasBorrowedToken(account, borrowToken)) {\naccount.borrowTokens.push(borrowToken);\n  } else {\naccount.borrowed[borrowToken] = Lending(lending())\n .applyBorrowInterest(\n account.borrowed[borrowToken],\n borrowToken,\n account.borrowedYieldQuotientsFP[borrowToken]\n);\n  }\n  account.borrowedYieldQuotientsFP[borrowToken] = Lending(lending())\n.viewBorrowingYieldFP(borrowToken);\n\n  account.borrowed[borrowToken] += borrowAmount;\n  addHolding(account, borrowToken, borrowAmount);\n\n  require(positiveBalance(account), \"Can't borrow: insufficient balance\");\n }\n\n function positiveBalance(CrossMarginAccount storage account)\n  internal\n  returns (bool)\n {\n  uint256 loan = loanInPeg(account, false);\n  uint256 holdings = holdingsInPeg(account, false);\n  return holdings * (leveragePercent - 100) >= loan * leveragePercent;\n }\n\n function hasHoldingToken(CrossMarginAccount storage account, address token)\n  internal\n  view\n  returns (bool)\n {\n  return account.holdsToken[token];\n }\n\n function hasBorrowedToken(CrossMarginAccount storage account, address token)\n  internal\n  view\n  returns (bool)\n {\n  return account.borrowedYieldQuotientsFP[token] > 0;\n }\n\n function loanInPeg(CrossMarginAccount storage account, bool forceCurBlock)\n  internal\n  returns (uint256)\n {\n  return\nsumTokensInPegWithYield(\n account.borrowTokens,\n account.borrowed,\n account.borrowedYieldQuotientsFP,\n forceCurBlock\n);\n }\n\n function holdingsInPeg(\n  CrossMarginAccount storage account,\n  bool forceCurBlock\n ) internal returns (uint256) {\n  return\nsumTokensInPeg(\n account.holdingTokens,\n account.holdings,\n forceCurBlock\n);\n }\n \n function belowMaintenanceThreshold(CrossMarginAccount storage account)\n  internal\n  returns (bool)\n {\n  uint256 loan = loanInPeg(account, true);\n  uint256 holdings = holdingsInPeg(account, true);\n  return 100 * holdings >= liquidationThresholdPercent * loan;\n }\n\n function sumTokensInPeg(\n  address[] storage tokens,\n  mapping(address => uint256) storage amounts,\n  bool forceCurBlock\n ) internal returns (uint256 totalPeg) {\n  uint256 len = tokens.length;\n  for (uint256 tokenId; tokenId < len; tokenId++) {\naddress token = tokens[tokenId];\ntotalPeg += PriceAware.getCurrentPriceInPeg(\n token,\n amounts[token],\n forceCurBlock\n);\n  }\n }\n \n\n function sumTokensInPegWithYield(\n  address[] storage tokens,\n  mapping(address => uint256) storage amounts,\n  mapping(address => uint256) storage yieldQuotientsFP,\n  bool forceCurBlock\n ) internal returns (uint256 totalPeg) {\n  uint256 len = tokens.length;\n  for (uint256 tokenId; tokenId < len; tokenId++) {\naddress token = tokens[tokenId];\ntotalPeg += yieldTokenInPeg(\n token,\n amounts[token],\n yieldQuotientsFP,\n forceCurBlock\n);\n  }\n }\n\n function yieldTokenInPeg(\n  address token,\n  uint256 amount,\n  mapping(address => uint256) storage yieldQuotientsFP,\n  bool forceCurBlock\n ) internal returns (uint256) {\n  uint256 yieldFP = Lending(lending()).viewBorrowingYieldFP(token);\n  uint256 amountInToken = (amount * yieldFP) / yieldQuotientsFP[token];\n  return\nPriceAware.getCurrentPriceInPeg(\n token,\n amountInToken,\n forceCurBlock\n);\n }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-04-marginswap#h-05-wrong-liquidation-logic",
                "Location": "    function belowMaintenanceThreshold(CrossMarginAccount storage account)\n        internal\n        returns (bool)\n    {\n        uint256 loan = loanInPeg(account, true);\n        uint256 holdings = holdingsInPeg(account, true);\n        // The following should hold:\n        // holdings / loan >= 1.1\n        // => holdings >= loan * 1.1\n        return 100 * holdings >= liquidationThresholdPercent * loan;\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The inequality in the last equation is wrong because it says the higher the holdings (margin + loan) compared to the loan, the higher the chance of being liquidated. The inverse equality was probably intended return 100 * holdings <= liquidationThresholdPercent * loan;. Users that shouldn\ufffd\ufffdt be liquidated can be liquidated, and users that should be liquidated cannot get liquidated.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n// Interfaces\nimport \"./interfaces/iERC20.sol\";\nimport \"./interfaces/iVADER.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iPOOLS.sol\";\nimport \"./interfaces/iFACTORY.sol\";\nimport \"./interfaces/iSYNTH.sol\";\n\nimport \"hardhat/console.sol\";\n\ncontract Utils {\n\n uint private one = 10**18;\n uint private _10k = 10000;\n uint private _year = 31536000; // One Year (in seconds)\n\n bool private inited;\n\n address public VADER;\n address public USDV;\n address public ROUTER;\n address public POOLS;\n address public FACTORY;\n\n constructor () {}\n\n function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {\n  require(inited == false,  \"inited\");\n  inited = true;\n  VADER = _vader;\n  USDV = _usdv;\n  ROUTER = _router;\n  POOLS = _pools;\n  FACTORY = _factory;\n }\n //====================================SYSTEM FUNCTIONS====================================//\n function isBase(address token) public view returns(bool base) {\n  if(token == VADER || token == USDV){\nreturn true;\n  }\n }\n function isPool(address token) public view returns(bool pool) {\n  if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\npool = true;\n  }\n }\n\n //====================================PRICING====================================//\n\n function calcSwapValueInBase(address token, uint amount) public view returns (uint){\n  (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n  return calcSwapOutput(amount, _tokenAmt, _baseAmt);\n }\n function calcSwapValueInToken(address token, uint amount) public view returns (uint){\n  (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n  return calcSwapOutput(amount, _baseAmt, _tokenAmt);\n }\n //==================================== LENDING ====================================//\n\n function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {\n  uint _collateralAdjusted = (collateral * 6666) / 10000; // 150% collateral Ratio\n  if(isBase(collateralAsset)){\nbaseValue = _collateralAdjusted;\n  }else if(isPool(collateralAsset)){\nbaseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); // calc units to BASE\n  }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){\nbaseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); // Calc swap value\n  }\n  debt = calcSwapValueInToken(debtAsset, baseValue);  // get debt output\n  return (debt, baseValue);\n }\n\n //====================================CORE-MATH====================================//\n\n\n function calcShare(uint part, uint total, uint amount) public pure returns (uint share){\n  // share = amount * part/total\n  if(part > total){\npart = total;\n  }\n  if(total > 0){\nshare = (amount * part) / total;\n  }\n }\n\n function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){\n  // y = (x * X * Y )/(x + X)^2\n  uint numerator = (x * X * Y);\n  uint denominator = (x + X) * (x + X);\n  return (numerator / denominator);\n }\n\n function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){\n  // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3\n  // (part1 * (part2 - part3 + part4)) / part5\n  uint part1 = (u * A);\n  uint part2 = ((U * U) * 2);\n  uint part3 = ((U * u) * 2);\n  uint part4 = (u * u);\n  uint numerator = ((part1 * part2) - part3) + part4;\n  uint part5 = ((U * U) * U);\n  return (numerator / part5);\n }\n function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){\n  if(B0 > 0 && T1 > 0){\nuint _depositValue = B0 + (T0 * B1) / T1; // B0+(T0*B1/T1)\nuint _redemptionValue = B1 + (T1 * B1) / T1; // B1+(T1*B1/T1)\nif(_redemptionValue <= _depositValue){\n coverage = (_depositValue - _redemptionValue);\n}\n  }\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-04-vader#h-07-wrong-calcasymmetricshare-calculation",
                "Location": "    function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){\n        // share = (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3\n        // (part1 * (part2 - part3 + part4)) / part5\n        uint part1 = (u * A);\n        uint part2 = ((U * U) * 2);\n        uint part3 = ((U * u) * 2);\n        uint part4 = (u * u);\n        uint numerator = ((part1 * part2) - part3) + part4;\n        uint part5 = ((U * U) * U);\n        return (numerator / part5);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The inline-comment defines the number of asymmetric shares as (u * U * (2 * A^2 - 2 * U * u + U^2))/U^3 but the Utils.calcAsymmetricShare function computes (uA * 2U^2 - 2uU + u^2) / U^3 which is not equivalent as can be seen from the A^2 term in the first term which does not occur in the second one. The associativity on P * part1 is wrong, and part2 is not multiplied by P. The math from the spec is not correctly implemented and could lead to the protocol being economically exploited, as the asymmetric share (which is used to determine the collateral value in base tokens) could be wrong. For example, it might be possible to borrow more than the collateral put up. Recommend clarifying if the comment or the code is correct and fix them if not.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\nimport \"./interface/INFTXVaultFactory.sol\";\nimport \"./interface/INFTXEligibility.sol\";\nimport \"./interface/INFTXEligibilityManager.sol\";\nimport \"./interface/INFTXLPStaking.sol\";\nimport \"./interface/INFTXFeeDistributor.sol\";\nimport \"./interface/IPrevNftxContract.sol\";\nimport \"./interface/IRewardDistributionToken.sol\";\nimport \"./token/ERC20BurnableUpgradeable.sol\";\nimport \"./token/ERC20FlashMintUpgradeable.sol\";\nimport \"./token/ERC721HolderUpgradeable.sol\";\nimport \"./token/ERC1155HolderUpgradeable.sol\";\nimport \"./token/IERC721Upgradeable.sol\";\nimport \"./token/IERC1155Upgradeable.sol\";\nimport \"./util/PausableUpgradeable.sol\";\nimport \"./util/SafeMathUpgradeable.sol\";\nimport \"./util/ReentrancyGuardUpgradeable.sol\";\nimport \"./util/EnumerableSetUpgradeable.sol\";\nimport \"hardhat/console.sol\";\n\ncontract NFTXVaultUpgradeable is\n PausableUpgradeable,\n ERC20BurnableUpgradeable,\n ERC20FlashMintUpgradeable,\n ReentrancyGuardUpgradeable,\n ERC721HolderUpgradeable,\n ERC1155HolderUpgradeable\n{\n using SafeMathUpgradeable for uint256;\n using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n uint256 constant base = 10**18;\n uint256 public vaultId;\n address public assetAddress;\n INFTXVaultFactory public vaultFactory;\n\n uint256 randNonce;\n uint256 public redeemFee;\n uint256 public directRedeemFee;\n\n // Purposely putting these on a new slot to make sure they're together.\n bool public is1155;\n bool public enableRedeem;\n bool public enableDirectRedeem;\n\n EnumerableSetUpgradeable.UintSet holdings;\n mapping(uint256 => uint256) quantity1155;\n\n event Redeemed(uint256[] nftIds, address sender);\n constructor() public {\n  __Pausable_init();\n  __ERC20_init(\"\", \"\");\n  __ERC20Burnable_init_unchained();\n  __ERC20FlashMint_init();\n }\n\n function redeem(uint256 amount, uint256[] calldata specificIds)\n  external\n  virtual\n  returns (uint256[] memory)\n {\n  return redeemTo(amount, specificIds, msg.sender);\n }\n\n\n function redeemTo(uint256 amount, uint256[] memory specificIds, address to)\n  public\n  virtual\n  nonReentrant\n returns (uint256[] memory)\n {\n  onlyOwnerIfPaused(2);\n  requireenableRedeem, \"Redeeming not enabled\");\n\n  require(\nspecificIds.length == 0 ||enableDirectRedeem,\n\"Direct redeem not enabled\"\n  )\n\n  uint256 fee = directRedeemFee.mul(specificIds.length).add(\nredeemFee.mul(amount.sub(specificIds.length))\n  );\n  // We burn all from sender and mint to fee receiver to reduce costs.\n  _burnFrom(msg.sender, base.mul(amount).add(fee));\n  _distributeFees(fee);\n\n  uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);\n  afterRedeemHook(redeemedIds);\n\n  emit Redeemed(redemedIds, to);\n  return redeemedIds;\n }\n\n\n function withdrawNFTsTo(\n  uint256 amount,\n  uint256[] memory specificIds,\n  address to\n ) internal virtual returns (uint256[] memory) {\n  bool _is1155 = is1155;\n  address _assetAddress = assetAddress;\n  uint256[] memory redeemedIds = new uint256[](amount);\n\n  for (uint256 i = 0; i < amount; i++) {\nuint256 tokenId = i < specificIds.length\n ? specificIds[i]\n : getRandomTokenIdFromFund();\nredeemedIds[i] = tokenId;\nif (_is1155) {\n IERC1155Upgradeable(_assetAddress).safeTransferFrom(\n  address(this),\n  to,\n  tokenId,\n  1,\n  \"\"\n );\n quantity1155[tokenId] = quantity1155[tokenId].sub(1);\n if (quantity1155[tokenId] == 0) {\n  holdings.remove(tokenId);\n }\n} else {\n IERC721Upgradeable(_assetAddress).safeTransferFrom(\n  address(this),\n  to,\n  tokenId\n );\n holdings.remove(tokenId);\n}\n  }\n  return redeemedIds;\n }\n\n function _distributeFees(uint256 amount) internal virtual {\n  // Mint fees directly to the distributor and distribute.\n  if (amount > 0) {\naddress feeReceiver = vaultFactory.feeReceiver();\n_mint(feeReceiver, amount);\nINFTXFeeDistributor(feeReceiver).distribute(vaultId);\n  }\n }\n\n function getRandomTokenIdFromFund() internal virtual returns (uint256) {\n  uint256 randomIndex = getPseudoRand(holdings.length());\n  return holdings.at(randomIndex);\n }\n\n function getPseudoRand(uint256 modulus) internal virtual returns (uint256) {\n  randNonce += 1;\n  return\nuint256(\n keccak256(\n  abi.encodePacked(blockhash(block.number - 1), randNonce)\n )\n) %\nmodulus;\n }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-05-nftx#h-03-getrandomtokenidfromfund-yields-wrong-probabilities-for-erc1155",
                "Location": "function getRandomTokenIdFromFund() internal virtual returns (uint256) {\n        uint256 randomIndex = getPseudoRand(holdings.length());\n        return holdings.at(randomIndex);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. NFTXVaultUpgradeable.getRandomTokenIdFromFund does not work with ERC1155 as it does not take the deposited quantity1155 into account. Assume tokenId0 has a count of 100, and tokenId1 has a count of 1. Then getRandomId would have a pseudo-random 1:1 chance for token 0 and 1 when in reality it should be 100:1. This might make it easier for an attacker to redeem more valuable NFTs as the probabilities are off. Recommend taking the quantities of each token into account (quantity1155) which probably requires a design change as it is currently hard to do without iterating over all tokens.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.1;\n\nimport \"../../utils/access/AccessControl.sol\";\nimport \"../../interfaces/vault/IOracle.sol\";\nimport \"../../math/CastBytes32Bytes6.sol\";\n\ncontract CompositeMultiOracle is IOracle, AccessControl {\n using CastBytes32Bytes6 for bytes32;\n\n uint8 public constant override decimals = 18;// All prices are converted to 18 decimals\n\n event SourceSet(bytes6 indexed baseId, bytes6 indexed quoteId, address indexed source);\n event PathSet(bytes6 indexed baseId, bytes6 indexed quoteId, bytes6[] indexed path);\n\n struct Source {\n  address source;\n  uint8 decimals;\n }\n\n mapping(bytes6 => mapping(bytes6 => Source)) public sources;\n mapping(bytes6 => mapping(bytes6 => bytes6[])) public paths;\n\n function setSource(bytes6 base, bytes6 quote, address source) external auth {\n  _setSource(base, quote, source);\n }\n\n\n function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) external auth {\n  require(\nbases.length == quotes.length && \nbases.length == sources_.length,\n\"Mismatched inputs\"\n  );\n  for (uint256 i = 0; i < bases.length; i++) {\n_setSource(bases[i], quotes[i], sources_[i]);\n  }\n }\n\n function setPath(bytes6 base, bytes6 quote, bytes6[] memory path) external auth {\n  _setPath(base, quote, path);\n }\n\n function setPaths(bytes6[] memory bases, bytes6[] memory quotes, bytes6[][] memory paths_) external auth {\n  require(\nbases.length == quotes.length && \nbases.length == paths_.length,\n\"Mismatched inputs\"\n  );\n  for (uint256 i = 0; i < bases.length; i++) {\n_setPath(bases[i], quotes[i], paths_[i]);\n  }\n }\n\n function peek(bytes32 base, bytes32 quote, uint256 amount)\n  external view virtual override\n  returns (uint256 value, uint256 updateTime)\n {\n  uint256 price = 1e18;\n  bytes6 base_ = base.b6();\n  bytes6 quote_ = quote.b6();\n  bytes6[] memory path = paths[base_][quote_];\n  for (uint256 p = 0; p < path.length; p++) {\n(price, updateTime) = _peek(base_, path[p], price, updateTime);\nbase_ = path[p];\n  }\n  (price, updateTime) = _peek(base_, quote_, price, updateTime);\n  value = price * amount / 1e18;\n }\n\n function get(bytes32 base, bytes32 quote, uint256 amount)\n  external virtual override\n  returns (uint256 value, uint256 updateTime)\n {\n  uint256 price = 1e18;\n  bytes6 base_ = base.b6();\n  bytes6 quote_ = quote.b6();\n  bytes6[] memory path = paths[base_][quote_];\n  for (uint256 p = 0; p < path.length; p++) {\n(price, updateTime) = _get(base_, path[p], price, updateTime);\nbase_ = path[p];\n  }\n  (price, updateTime) = _get(base_, quote_, price, updateTime);\n  value = price * amount / 1e18;\n }\n\n function _peek(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)\n  private view returns (uint priceOut, uint updateTimeOut)\n {\n  Source memory source = sources[base][quote];\n  require (source.source != address(0), \"Source not found\");\n  (priceOut, updateTimeOut) = IOracle(source.source).peek(base, quote, 10 ** source.decimals);// Get price for one unit\n  priceOut = priceIn * priceOut / (10 ** source.decimals);// Fixed point according to decimals\n  updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;  // Take the oldest update time\n }\n\n function _get(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)\n  private returns (uint priceOut, uint updateTimeOut)\n {\n  Source memory source = sources[base][quote];\n  require (source.source != address(0), \"Source not found\");\n  (priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals); // Get price for one unit\n  priceOut = priceIn * priceOut / (10 ** source.decimals);// Fixed point according to decimals\n  updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;  // Take the oldest update time\n }\n\n function _setSource(bytes6 base, bytes6 quote, address source) internal {\n  uint8 decimals_ = IOracle(source).decimals();\n  require (decimals_ <= 18, \"Unsupported decimals\");\n  sources[base][quote] = Source({\nsource: source,\ndecimals: decimals_\n  });\n  emit SourceSet(base, quote, source);\n }\n\n function _setPath(bytes6 base, bytes6 quote, bytes6[] memory path) internal {\n  bytes6 base_ = base;\n  for (uint256 p = 0; p < path.length; p++) {\nrequire (sources[base_][path[p]].source != address(0), \"Source not found\");\nbase_ = path[p];\n  }\n  paths[base][quote] = path;\n  emit PathSet(base, quote, path);\n }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-08-yield#h-01-compositemultioracle-returns-wrong-decimals-for-prices",
                "Location": "function _peek(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)\n        private view returns (uint priceOut, uint updateTimeOut)\n    {\n        Source memory source = sources[base][quote];\n        require (source.source != address(0), \"Source not found\");\n        (priceOut, updateTimeOut) = IOracle(source.source).peek(base, quote, 10 ** source.decimals);   // Get price for one unit\n        priceOut = priceIn * priceOut / (10 ** source.decimals);                                       // Fixed point according to decimals\n        updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;                 // Take the oldest update time\n    }",
                "Type": "Erroneous state updates",
                "Description": "Other accounting errors. The CompositeMultiOracle.peek/get functions seem to return wrong prices. It\ufffd\ufffds unclear what decimals source.decimals refers to in this case.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"./libraries/FixedPoint.sol\";\nimport \"./libraries/UniswapV3OracleLibrary/UniswapV3OracleLibraryV2.sol\";\nimport \"./interfaces/IUniswapV3Pool.sol\";\nimport \"./market/OverlayV1Market.sol\";\nimport \"./libraries/UniswapV3OracleLibrary/TickMath.sol\";\n\ncontract OverlayV1UniswapV3Market is OverlayV1Market {\n\nusing FixedPoint for uint256;\n\nuint256 internal X96 = 0x1000000000000000000000000;\n\nuint256 public immutable macroWindow; // window size for main TWAP\nuint256 public immutable microWindow; // window size for bid/ask TWAP\n\naddress public immutable marketFeed;\naddress public immutable ovlFeed;\naddress public immutable base;\naddress public immutable quote;\nuint128 internal immutable baseAmount;\n\naddress internal immutable eth;\nbool internal immutable ethIs0;\n\nconstructor(\naddress _mothership,\naddress _ovlFeed,\naddress _marketFeed,\naddress _quote,\naddress _eth,\nuint128 _baseAmount,\nuint256 _macroWindow,\nuint256 _microWindow,\nuint256 _priceFrameCap\n) OverlayV1Market (\n_mothership\n) OverlayV1Comptroller (\n_microWindow\n) OverlayV1OI (\n_microWindow\n) OverlayV1PricePoint (\n_priceFrameCap\n) {\n// immutables\neth = _eth;\nethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;\novlFeed = _ovlFeed;\nmarketFeed = _marketFeed;\nbaseAmount = _baseAmount;\nmacroWindow = _macroWindow;\nmicroWindow = _microWindow;\n\naddress _token0 = IUniswapV3Pool(_marketFeed).token0();\naddress _token1 = IUniswapV3Pool(_marketFeed).token1();\n\nbase = _token0 != _quote ? _token0 : _token1;\nquote = _token0 == _quote ? _token0 : _token1;\n\nint24 _tick = OracleLibraryV2.consult(\n_marketFeed,\nuint32(_macroWindow),\nuint32(0)\n);\n_pricePoints.push(PricePoint(\n_tick, \n_tick, \n0\n));\nuint _price = OracleLibraryV2.getQuoteAtTick(\n_tick,\nuint128(_baseAmount),\n_token0 != _quote ? _token0 : _token1,\n_token0 == _quote ? _token0 : _token1\n);\nemit NewPricePoint(_price, _price, 0);\n}\n\nfunction fetchPricePoint () public view override returns (\nPricePoint memory price_\n) {\nint56[] memory _ticks;\nuint160[] memory _liqs;\nuint _ovlPrice;\nuint _marketLiquidity;\nint24 _microTick;\nint24 _macroTick;\n{\nuint32[] memory _secondsAgo = new uint32[](3);\n_secondsAgo[2] = uint32(macroWindow);\n_secondsAgo[1] = uint32(microWindow);\n( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo);\n_macroTick = int24(( _ticks[0] - _ticks[2]) / int56(int32(int(macroWindow))));\n_microTick = int24((_ticks[0] - _ticks[1]) / int56(int32(int(microWindow))));\nuint _sqrtPrice = TickMath.getSqrtRatioAtTick(_microTick);\nuint _liquidity = (uint160(microWindow) << 128) / ( _liqs[0] - _liqs[1] );\n_marketLiquidity = ethIs0\n? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n: FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n}\n{\nuint32[] memory _secondsAgo = new uint32[](2);\n_secondsAgo[1] = uint32(macroWindow);\n( _ticks, ) = IUniswapV3Pool(ovlFeed).observe(_secondsAgo);\n_ovlPrice = OracleLibraryV2.getQuoteAtTick(\nint24((_ticks[0] - _ticks[1]) / int56(int32(int(macroWindow)))),\n1e18,\novl,\neth\n);\n\n}\nprice_ = PricePoint(\n_microTick, \n_macroTick, \ncomputeDepth(_marketLiquidity, _ovlPrice)\n);\n}\n\nfunction computeDepth (\nuint _marketLiquidity,\nuint _ovlPrice\n) public override view returns (\nuint depth_\n) {\ndepth_ = ((_marketLiquidity * 1e18) / _ovlPrice)\n.mulUp(lmbda)\n.divDown(2e18);\n}\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-11-overlay#h-01-overlayv1uniswapv3market-computes-wrong-market-liquidity",
                "Location": "    function fetchPricePoint () public view override returns (\n        PricePoint memory price_\n    ) {\n\n        int56[] memory _ticks;\n        uint160[] memory _liqs;\n\n        uint _ovlPrice;\n        uint _marketLiquidity;\n\n        int24 _microTick;\n        int24 _macroTick;\n\n        {\n\n            uint32[] memory _secondsAgo = new uint32[](3);\n            _secondsAgo[2] = uint32(macroWindow);\n            _secondsAgo[1] = uint32(microWindow);\n\n            ( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo);\n\n            _macroTick = int24(( _ticks[0] - _ticks[2]) / int56(int32(int(macroWindow))));\n\n            _microTick = int24((_ticks[0] - _ticks[1]) / int56(int32(int(microWindow))));\n\n            uint _sqrtPrice = TickMath.getSqrtRatioAtTick(_microTick);\n\n            uint _liquidity = (uint160(microWindow) << 128) / ( _liqs[0] - _liqs[1] );\n\n            _marketLiquidity = ethIs0\n                ? ( uint256(_liquidity) << 96 ) / _sqrtPrice\n                : FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n\n        }",
                "Type": "Erroneous state updates",
                "Description": "Calculations performed with incorrect numbers. The OverlayV1UniswapV3Market.fetchPricePoint tries to compute the market depth in OVL terms as marketLiquidity (in ETH) / ovlPrice (in ETH per OVL). To get the market liquidity in ETH (and not the other token pair), it uses the ethIs0 boolean. However, ethIs0 boolean refers to the ovlFeed, whereas the _liquidity refers to the marketFeed, and therefore the ethIs0 boolean has nothing to do with the market feed where the liquidity is taken from",
                "Repair": ""
            }
        ]
    }
]