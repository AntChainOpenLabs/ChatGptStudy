[
    {
	    "Code":"// SPDX-License-Identifier: UNLICENSED \npragma solidity 0.8.3; \nimport \"./interfaces/iBEP20.sol\"; \nimport \"./interfaces/iUTILS.sol\"; \nimport \"./interfaces/iDAO.sol\"; \nimport \"./interfaces/iBASE.sol\"; \nimport \"./interfaces/iDAOVAULT.sol\"; \nimport \"./interfaces/iROUTER.sol\"; \nimport \"./interfaces/iSYNTH.sol\";  \nimport \"./interfaces/iSYNTHFACTORY.sol\";  \nimport \"./interfaces/iBEP677.sol\";  \n \ncontract Pool is iBEP20 {   \n    address public BASE; \n    address public TOKEN; \n    address public DEPLOYER; \n \n    string _name; string _symbol; \n    uint8 public override decimals; uint256 public override totalSupply; \n    mapping(address => uint) private _balances; \n    mapping(address => mapping(address => uint)) private _allowances; \n \n    uint256 public baseAmount; // SPARTA amount that should be in the pool \n    uint256 public tokenAmount; // TOKEN amount that should be in the pool \n \n    uint private lastMonth; // Timestamp of the start of current metric period (For UI) \n    uint public genesis; // Timestamp from when the pool was first deployed (For UI) \n \n    uint256 public map30DPoolRevenue; // Tally of revenue during current incomplete metric period (for UI) \n    uint256 public mapPast30DPoolRevenue; // Tally of revenue from last full metric period (for UI) \n    uint256 [] public revenueArray; // Array of the last two metric periods (For UI) \n \n    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued); \n    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed); \n    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee); \n    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount); \n    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount); \n \n    function _DAO() internal view returns(iDAO) { \n        return iBASE(BASE).DAO(); \n    } \n \n    constructor (address _base, address _token) { \n        BASE = _base; \n        TOKEN = _token; \n        string memory poolName = \"-SpartanProtocolPool\"; \n        string memory poolSymbol = \"-SPP\"; \n        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName)); \n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol)); \n        decimals = 18; \n        genesis = block.timestamp; \n        DEPLOYER = msg.sender; \n        lastMonth = 0; \n    } \n \n    //========================================iBEP20=========================================// \n \n    function name() external view override returns (string memory) { \n        return _name; \n    } \n \n    function symbol() external view override returns (string memory) { \n        return _symbol; \n    } \n \n    function balanceOf(address account) public view override returns (uint256) { \n        return _balances[account]; \n    } \n \n    function allowance(address owner, address spender) public view virtual override returns (uint256) { \n        return _allowances[owner][spender]; \n    } \n \n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) { \n        _transfer(msg.sender, recipient, amount); \n        return true; \n    } \n \n    function approve(address spender, uint256 amount) external virtual override returns (bool) { \n        _approve(msg.sender, spender, amount); \n        return true; \n    } \n \n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) { \n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue)); \n        return true; \n    } \n \n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) { \n        uint256 currentAllowance = _allowances[msg.sender][spender]; \n        require(currentAllowance >= subtractedValue, \"!approval\"); \n        _approve(msg.sender, spender, currentAllowance - subtractedValue); \n        return true; \n    } \n \n    function _approve(address owner, address spender, uint256 amount) internal virtual { \n        require(owner != address(0), \"!owner\"); \n        require(spender != address(0), \"!spender\"); \n        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max \n            _allowances[owner][spender] = amount; \n            emit Approval(owner, spender, amount); \n        } \n    } \n \n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) { \n        _transfer(sender, recipient, amount); \n        // Max approval (saves an SSTORE) \n        if (_allowances[sender][msg.sender] < type(uint256).max) { \n            uint256 currentAllowance = _allowances[sender][msg.sender]; \n            require(currentAllowance >= amount, \"!approval\"); \n            _approve(sender, msg.sender, currentAllowance - amount); \n        } \n        return true; \n    } \n \n    //iBEP677 approveAndCall \n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) { \n      _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval \n      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient \n      return true; \n    } \n \n    //iBEP677 transferAndCall \n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) { \n      _transfer(msg.sender, recipient, amount); \n      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient  \n      return true; \n    } \n \n    function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n        require(sender != address(0), \"!sender\"); \n        uint256 senderBalance = _balances[sender]; \n        require(senderBalance >= amount, \"!balance\"); \n        _balances[sender] -= amount; \n        _balances[recipient] += amount; \n        emit Transfer(sender, recipient, amount); \n    } \n \n    function _mint(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"!account\"); \n        totalSupply += amount; \n        _balances[account] += amount; \n        emit Transfer(address(0), account, amount); \n    } \n \n    function burn(uint256 amount) external virtual override { \n        _burn(msg.sender, amount); \n    } \n \n    function burnFrom(address account, uint256 amount) external virtual {   \n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount); \n        _approve(account, msg.sender, decreasedAllowance);  \n        _burn(account, amount); \n    } \n \n    function _burn(address account, uint256 amount) internal virtual { \n        require(account != address(0), \"!account\"); \n        require(_balances[account] >= amount, \"!balance\"); \n        _balances[account] -= amount; \n        totalSupply -= amount; \n        emit Transfer(account, address(0), amount); \n    } \n \n    //====================================POOL FUNCTIONS =================================// \n \n    // User adds liquidity to the pool \n    function add() external returns(uint liquidityUnits){ \n        liquidityUnits = addForMember(msg.sender); \n        return liquidityUnits; \n    } \n \n    // Contract adds liquidity for user  \n    function addForMember(address member) public returns(uint liquidityUnits){ \n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get the received SPARTA amount \n        uint256 _actualInputToken = _getAddedTokenAmount(); // Get the received TOKEN amount \n        if(baseAmount == 0 || tokenAmount == 0){ \n        require(_actualInputBase != 0 && _actualInputToken != 0, \"!Balanced\"); \n        } \n        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP \ntokens to mint \n        _incrementPoolBalances(_actualInputBase, _actualInputToken); // Update recorded BASE and TOKEN amounts \n        _mint(member, liquidityUnits); // Mint the LP tokens directly to the user \n        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits); \n        return liquidityUnits; \n    } \n     \n    // User removes liquidity from the pool  \n    function remove() external returns (uint outputBase, uint outputToken) { \n        return removeForMember(msg.sender); \n    }  \n \n    // Contract removes liquidity for the user \n    function removeForMember(address member) public returns (uint outputBase, uint outputToken) { \n        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount \n        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units \n        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units \n        _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts \n        _burn(address(this), _actualInputUnits); // Burn the LP tokens \n        iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user \n        iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user \n        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits); \n        return (outputBase, outputToken); \n    } \n \n    // Caller swaps tokens \n    function swap(address token) external returns (uint outputAmount, uint fee){ \n        (outputAmount, fee) = swapTo(token, msg.sender); \n        return (outputAmount, fee); \n    } \n \n    // Contract swaps tokens for the member \n    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) { \n        require((token == BASE || token == TOKEN), \"!BASE||TOKEN\"); // Must be SPARTA or the pool's relevant TOKEN \n        address _fromToken; uint _amount; \n        if(token == BASE){ \n            _fromToken = TOKEN; // If SPARTA is selected; swap from TOKEN \n            _amount = _getAddedTokenAmount(); // Get the received TOKEN amount \n            (outputAmount, fee) = _swapTokenToBase(_amount); // Calculate the SPARTA output from the swap \n        } else { \n            _fromToken = BASE; // If TOKEN is selected; swap from SPARTA \n            _amount = _getAddedBaseAmount(); // Get the received SPARTA amount \n            (outputAmount, fee) = _swapBaseToToken(_amount); // Calculate the TOKEN output from the swap \n        } \n        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee); \n        iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user \n        return (outputAmount, fee); \n    } \n \n    // Swap SPARTA for Synths \n    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) { \n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth \n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount \n        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant \nunderlying TOKEN \n        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted \n        _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount \n        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN \n        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA \n        _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold \n        iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user \n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics \n        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount); \n      return (output, fee); \n    } \n     \n    // Swap Synths for SPARTA \n    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) { \n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, \"!synth\"); // Must be a valid Synth \n        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount \n        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying \nTOKEN to SPARTA \n        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA \n        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract \n        iSYNTH(synthIN).burnSynth(); // Burn the SYNTH units \n        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount \n        iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user \n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics \n        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth); \n      return (outputBase, fee); \n    } \n \n    //=======================================INTERNAL MATHS======================================// \n \n    // Check the SPARTA amount received by this Pool \n    function _getAddedBaseAmount() internal view returns(uint256 _actual){ \n        uint _baseBalance = iBEP20(BASE).balanceOf(address(this));  \n        if(_baseBalance > baseAmount){ \n            _actual = _baseBalance-(baseAmount); \n        } else { \n            _actual = 0; \n        } \n        return _actual; \n    } \n   \n    // Check the TOKEN amount received by this Pool \n    function _getAddedTokenAmount() internal view returns(uint256 _actual){ \n        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this));  \n        if(_tokenBalance > tokenAmount){ \n            _actual = _tokenBalance-(tokenAmount); \n        } else { \n            _actual = 0; \n        } \n        return _actual; \n    } \n \n    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts \n    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){ \n        uint256 _X = baseAmount; \n        uint256 _Y = tokenAmount; \n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output \n        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc TOKEN fee \n        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee); // Convert TOKEN fee to SPARTA \n        _setPoolAmounts(_X + _x, _Y - _y); // Update recorded BASE and TOKEN amounts \n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics \n        return (_y, _fee); \n    } \n \n    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts \n    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){ \n        uint256 _X = tokenAmount; \n        uint256 _Y = baseAmount; \n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc SPARTA output \n        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc SPARTA fee \n        _setPoolAmounts(_Y - _y, _X + _x); // Update recorded BASE and TOKEN amounts \n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics \n        return (_y, _fee); \n    } \n \n    //=======================================BALANCES=========================================// \n \n    // Sync internal balances to actual \n    function sync() external { \n        baseAmount = iBEP20(BASE).balanceOf(address(this)); \n        tokenAmount = iBEP20(TOKEN).balanceOf(address(this)); \n    } \n \n    // Increment internal balances \n    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  { \n        baseAmount += _baseAmount; \n        tokenAmount += _tokenAmount; \n    } \n \n    // Set internal balances \n    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  { \n        baseAmount = _baseAmount; \n        tokenAmount = _tokenAmount;  \n    } \n \n    // Decrement internal balances \n    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  { \n        baseAmount -= _baseAmount; \n        tokenAmount -= _tokenAmount;  \n    } \n \n    //===========================================POOL FEE ROI=================================// \n \n    function _addPoolMetrics(uint256 _fee) internal { \n        if(lastMonth == 0){ \n            lastMonth = block.timestamp; \n        } \n        if(block.timestamp <= lastMonth + 2592000){ // 30Days \n            map30DPoolRevenue = map30DPoolRevenue+(_fee); \n        } else { \n            lastMonth = block.timestamp; \n            mapPast30DPoolRevenue = map30DPoolRevenue; \n            addRevenue(mapPast30DPoolRevenue); \n            map30DPoolRevenue = 0; \n            map30DPoolRevenue = map30DPoolRevenue+(_fee); \n        } \n    } \n \n    function addRevenue(uint _totalRev) internal { \n        if(!(revenueArray.length == 2)){ \n            revenueArray.push(_totalRev); \n        } else { \n            addFee(_totalRev); \n        } \n    } \n \n    function addFee(uint _rev) internal { \n        uint _n = revenueArray.length; // 2 \n        for (uint i = _n - 1; i > 0; i--) { \n            revenueArray[i] = revenueArray[i - 1]; \n        } \n        revenueArray[0] = _rev; \n    } \n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-04-vader#h-11-swap-token-can-be-traded-as-fake-base-token",
	            "Location":"_actualInput = getAddedAmount(base, token); and calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount in swap function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Swap token can be traded as fake base token,The Pools.swap function does not check if base is one of the base tokens. One can transfer tokens to the pool and set base=token and call swap(token, token, member, toBase=false) The _actualInput = getAddedAmount(base, token); will return the token amount added but use the ratio compared to the base reserve calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount which yields a wrong swap result. It breaks the accounting for the pool as tokens are transferred in, but the base balance is increased (and token balance decreased). LPs cannot correctly withdraw again, and others cannot correctly swap again. Another example scenario is that the token pool amount can be stolen. Send tokenIn=baseAmount of tokens to the pool and call swap(base=token, token, member, toBase=false). Depending on the price of token relative to base this could be cheaper than trading with the base tokens.",
	            "Repair":""
            },
            {
                "Name":"https://code4rena.com/reports/2021-04-vader#h-13-4-synths-can-be-minted-with-fake-base-token",
	            "Location":"_actualInput = getAddedAmount(base, token); and calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount in mintSynth function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.4 Synths can be minted with fake base token,The Pools.mintSynth function does not check if base is one of the base tokens. One can transfer tokens to the pool and set base=token and call mintSynth(token, token, member). The _actualInput = getAddedAmount(base, token); will return the token amount added but use the ratio compared to the base reserve calcSwapOutput(_actualInput=tokenInput, mapToken_baseAmount[token], mapToken_tokenAmount[token]); = tokenIn / baseAmount * tokenAmount which yields a wrong swap result. It breaks the accounting for the pool as tokens are transferred in, but the base balance is increased. The amount that is minted could also be inflated (cheaper than sending the actual base tokens), especially if token is a high-precision token or worth less than base.",
	            "Repair":""
            }
            
        ]
    },
    {
	    "Code":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\nimport \"./interfaces/iBEP20.sol\";\nimport \"./interfaces/iUTILS.sol\";\nimport \"./interfaces/iDAO.sol\";\nimport \"./interfaces/iBASE.sol\";\nimport \"./interfaces/iDAOVAULT.sol\";\nimport \"./interfaces/iROUTER.sol\";\nimport \"./interfaces/iSYNTH.sol\"; \nimport \"./interfaces/iSYNTHFACTORY.sol\"; \nimport \"./interfaces/iBEP677.sol\"; \n\ncontract Pool is iBEP20 {  \n    address public BASE;\n    address public TOKEN;\n    address public DEPLOYER;\n\n    string _name; string _symbol;\n    uint8 public override decimals; uint256 public override totalSupply;\n    mapping(address => uint) private _balances;\n    mapping(address => mapping(address => uint)) private _allowances;\n\n    uint256 public baseAmount; // SPARTA amount that should be in the pool\n    uint256 public tokenAmount; // TOKEN amount that should be in the pool\n\n    uint private lastMonth; // Timestamp of the start of current metric period (For UI)\n    uint public genesis; // Timestamp from when the pool was first deployed (For UI)\n\n    uint256 public map30DPoolRevenue; // Tally of revenue during current incomplete metric period (for UI)\n    uint256 public mapPast30DPoolRevenue; // Tally of revenue from last full metric period (for UI)\n    uint256 [] public revenueArray; // Array of the last two metric periods (For UI)\n\n    event AddLiquidity(address indexed member, uint inputBase, uint inputToken, uint unitsIssued);\n    event RemoveLiquidity(address indexed member, uint outputBase, uint outputToken, uint unitsClaimed);\n    event Swapped(address indexed tokenFrom, address indexed tokenTo, address indexed recipient, uint inputAmount, uint outputAmount, uint fee);\n    event MintSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n    event BurnSynth(address indexed member, address indexed base, uint256 baseAmount, address indexed token, uint256 synthAmount);\n\n    function _DAO() internal view returns(iDAO) {\n        return iBASE(BASE).DAO();\n    }\n\n    constructor (address _base, address _token) {\n        BASE = _base;\n        TOKEN = _token;\n        string memory poolName = \"-SpartanProtocolPool\";\n        string memory poolSymbol = \"-SPP\";\n        _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));\n        _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));\n        decimals = 18;\n        genesis = block.timestamp;\n        DEPLOYER = msg.sender;\n        lastMonth = 0;\n    }\n\n    //========================================iBEP20=========================================//\n\n    function name() external view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view override returns (string memory) {\n        return _symbol;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"!approval\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"!owner\");\n        require(spender != address(0), \"!spender\");\n        if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max\n            _allowances[owner][spender] = amount;\n            emit Approval(owner, spender, amount);\n        }\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        // Max approval (saves an SSTORE)\n        if (_allowances[sender][msg.sender] < type(uint256).max) {\n            uint256 currentAllowance = _allowances[sender][msg.sender];\n            require(currentAllowance >= amount, \"!approval\");\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    //iBEP677 approveAndCall\n    function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval\n      iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient\n      return true;\n    }\n\n    //iBEP677 transferAndCall\n    function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n      _transfer(msg.sender, recipient, amount);\n      iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient \n      return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"!sender\");\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"!balance\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function burn(uint256 amount) external virtual override {\n        _burn(msg.sender, amount);\n    }\n\n    function burnFrom(address account, uint256 amount) external virtual {  \n        uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\n        _approve(account, msg.sender, decreasedAllowance); \n        _burn(account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"!account\");\n        require(_balances[account] >= amount, \"!balance\");\n        _balances[account] -= amount;\n        totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    //====================================POOL FUNCTIONS =================================//\n\n    // User adds liquidity to the pool\n    function add() external returns(uint liquidityUnits){\n        liquidityUnits = addForMember(msg.sender);\n        return liquidityUnits;\n    }\n\n    // Contract adds liquidity for user \n    function addForMember(address member) public returns(uint liquidityUnits){\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get the received SPARTA amount\n        uint256 _actualInputToken = _getAddedTokenAmount(); // Get the received TOKEN amount\n        if(baseAmount == 0 || tokenAmount == 0){\n        require(_actualInputBase != 0 && _actualInputToken != 0, \"!Balanced\");\n        }\n        liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); // Calculate LP tokens to mint\n        _incrementPoolBalances(_actualInputBase, _actualInputToken); // Update recorded BASE and TOKEN amounts\n        _mint(member, liquidityUnits); // Mint the LP tokens directly to the user\n        emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);\n        return liquidityUnits;\n    }\n    \n    // User removes liquidity from the pool \n    function remove() external returns (uint outputBase, uint outputToken) {\n        return removeForMember(msg.sender);\n    } \n\n    // Contract removes liquidity for the user\n    function removeForMember(address member) public returns (uint outputBase, uint outputToken) {\n        uint256 _actualInputUnits = balanceOf(address(this)); // Get the received LP units amount\n        outputBase = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, BASE, address(this)); // Get the SPARTA value of LP units\n        outputToken = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(_actualInputUnits, TOKEN, address(this)); // Get the TOKEN value of LP units\n        _decrementPoolBalances(outputBase, outputToken); // Update recorded BASE and TOKEN amounts\n        _burn(address(this), _actualInputUnits); // Burn the LP tokens\n        iBEP20(BASE).transfer(member, outputBase); // Transfer the SPARTA to user\n        iBEP20(TOKEN).transfer(member, outputToken); // Transfer the TOKENs to user\n        emit RemoveLiquidity(member, outputBase, outputToken, _actualInputUnits);\n        return (outputBase, outputToken);\n    }\n\n    // Caller swaps tokens\n    function swap(address token) external returns (uint outputAmount, uint fee){\n        (outputAmount, fee) = swapTo(token, msg.sender);\n        return (outputAmount, fee);\n    }\n\n    // Contract swaps tokens for the member\n    function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {\n        require((token == BASE || token == TOKEN), \"!BASE||TOKEN\"); // Must be SPARTA or the pool's relevant TOKEN\n        address _fromToken; uint _amount;\n        if(token == BASE){\n            _fromToken = TOKEN; // If SPARTA is selected; swap from TOKEN\n            _amount = _getAddedTokenAmount(); // Get the received TOKEN amount\n            (outputAmount, fee) = _swapTokenToBase(_amount); // Calculate the SPARTA output from the swap\n        } else {\n            _fromToken = BASE; // If TOKEN is selected; swap from SPARTA\n            _amount = _getAddedBaseAmount(); // Get the received SPARTA amount\n            (outputAmount, fee) = _swapBaseToToken(_amount); // Calculate the TOKEN output from the swap\n        }\n        emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);\n        iBEP20(token).transfer(member, outputAmount); // Transfer the swap output to the selected user\n        return (outputAmount, fee);\n    }\n\n    // Swap SPARTA for Synths\n    function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); // Must be a valid Synth\n        uint256 _actualInputBase = _getAddedBaseAmount(); // Get received SPARTA amount\n        uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount); // Calculate value of swapping SPARTA to the relevant underlying TOKEN\n        uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); // Calculate LP tokens to be minted\n        _incrementPoolBalances(_actualInputBase, 0); // Update recorded SPARTA amount\n        uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); // Calc slip fee in TOKEN\n        fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee); // Convert TOKEN fee to SPARTA\n        _mint(synthOut, _liquidityUnits); // Mint the LP tokens directly to the Synth contract to hold\n        iSYNTH(synthOut).mintSynth(member, output); // Mint the Synth tokens directly to the user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\n      return (output, fee);\n    }\n    \n    // Swap Synths for SPARTA\n    function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {\n        require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, \"!synth\"); // Must be a valid Synth\n        uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); // Get received SYNTH amount\n        uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); // Calculate value of swapping relevant underlying TOKEN to SPARTA\n        fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount); // Calc slip fee in SPARTA\n        iBEP20(synthIN).transfer(synthIN, _actualInputSynth); // Transfer SYNTH to relevant synth contract\n        iSYNTH(synthIN).burnSynth(); // Burn the SYNTH units\n        _decrementPoolBalances(outputBase, 0); // Update recorded SPARTA amount\n        iBEP20(BASE).transfer(member, outputBase); // Transfer SPARTA to user\n        _addPoolMetrics(fee); // Add slip fee to the revenue metrics\n        emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);\n      return (outputBase, fee);\n    }\n\n    //=======================================INTERNAL MATHS======================================//\n\n    // Check the SPARTA amount received by this Pool\n    function _getAddedBaseAmount() internal view returns(uint256 _actual){\n        uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); \n        if(_baseBalance > baseAmount){\n            _actual = _baseBalance-(baseAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n  \n    // Check the TOKEN amount received by this Pool\n    function _getAddedTokenAmount() internal view returns(uint256 _actual){\n        uint _tokenBalance = iBEP20(TOKEN).balanceOf(address(this)); \n        if(_tokenBalance > tokenAmount){\n            _actual = _tokenBalance-(tokenAmount);\n        } else {\n            _actual = 0;\n        }\n        return _actual;\n    }\n\n    // Calculate output of swapping SPARTA for TOKEN & update recorded amounts\n    function _swapBaseToToken(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = baseAmount;\n        uint256 _Y = tokenAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc TOKEN output\n        uint fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc TOKEN fee\n        _fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, fee); // Convert TOKEN fee to SPARTA\n        _setPoolAmounts(_X + _x, _Y - _y); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    // Calculate output of swapping TOKEN for SPARTA & update recorded amounts\n    function _swapTokenToBase(uint256 _x) internal returns (uint256 _y, uint256 _fee){\n        uint256 _X = tokenAmount;\n        uint256 _Y = baseAmount;\n        _y =  iUTILS(_DAO().UTILS()).calcSwapOutput(_x, _X, _Y); // Calc SPARTA output\n        _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_x, _X, _Y); // Calc SPARTA fee\n        _setPoolAmounts(_Y - _y, _X + _x); // Update recorded BASE and TOKEN amounts\n        _addPoolMetrics(_fee); // Add slip fee to the revenue metrics\n        return (_y, _fee);\n    }\n\n    //=======================================BALANCES=========================================//\n\n    // Sync internal balances to actual\n    function sync() external {\n        baseAmount = iBEP20(BASE).balanceOf(address(this));\n        tokenAmount = iBEP20(TOKEN).balanceOf(address(this));\n    }\n\n    // Increment internal balances\n    function _incrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount += _baseAmount;\n        tokenAmount += _tokenAmount;\n    }\n\n    // Set internal balances\n    function _setPoolAmounts(uint256 _baseAmount, uint256 _tokenAmount) internal  {\n        baseAmount = _baseAmount;\n        tokenAmount = _tokenAmount; \n    }\n\n    // Decrement internal balances\n    function _decrementPoolBalances(uint _baseAmount, uint _tokenAmount) internal  {\n        baseAmount -= _baseAmount;\n        tokenAmount -= _tokenAmount; \n    }\n\n    //===========================================POOL FEE ROI=================================//\n\n    function _addPoolMetrics(uint256 _fee) internal {\n        if(lastMonth == 0){\n            lastMonth = block.timestamp;\n        }\n        if(block.timestamp <= lastMonth + 2592000){ // 30Days\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        } else {\n            lastMonth = block.timestamp;\n            mapPast30DPoolRevenue = map30DPoolRevenue;\n            addRevenue(mapPast30DPoolRevenue);\n            map30DPoolRevenue = 0;\n            map30DPoolRevenue = map30DPoolRevenue+(_fee);\n        }\n    }\n\n    function addRevenue(uint _totalRev) internal {\n        if(!(revenueArray.length == 2)){\n            revenueArray.push(_totalRev);\n        } else {\n            addFee(_totalRev);\n        }\n    }\n\n    function addFee(uint _rev) internal {\n        uint _n = revenueArray.length; // 2\n        for (uint i = _n - 1; i > 0; i--) {\n            revenueArray[i] = revenueArray[i - 1];\n        }\n        revenueArray[0] = _rev;\n    }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-07-spartan#h-09-arbitrary-synth-mintburn-from-pool",
	            "Location":"mintSynth function",
	            "Type":"ID-related violations",
	            "Description":"Shared resource (e.g., token) without proper locks.arbitrary synth mint/burn from pool,Pool can mint arbitrary Synth provided as long as it’s a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"// SPDX-License-Identifier: UNLICENSED\n pragma solidity 0.8.3;\n import \"./Pool.sol\";  \n import \"./interfaces/iPOOLFACTORY.sol\";\n \n contract Synth is iBEP20 {\n     address public BASE;\n     address public LayerONE; // Underlying relevant layer1 token\n     uint public genesis;\n     address public DEPLOYER;\n \n     string _name; string _symbol;\n     uint8 public override decimals; uint256 public override totalSupply;\n \n     mapping(address => uint) private _balances;\n     mapping(address => mapping(address => uint)) private _allowances;\n     mapping(address => uint) public mapSynth_LPBalance;\n     mapping(address => uint) public mapSynth_LPDebt;\n    \n     function _DAO() internal view returns(iDAO) {\n         return iBASE(BASE).DAO();\n     }\n     \n     // Restrict access\n     modifier onlyDAO() {\n         require(msg.sender == DEPLOYER, \"!DAO\");\n         _;\n     }\n \n     // Restrict access\n     modifier onlyPool() {\n         require(iPOOLFACTORY(_DAO().POOLFACTORY()).isCuratedPool(msg.sender) == true, \"!curated\");\n         _;\n     }\n     \n     constructor (address _base, address _token) {\n         BASE = _base;\n         LayerONE = _token;\n         string memory synthName = \"-SpartanProtocolSynthetic\";\n         string memory synthSymbol = \"-SPS\";\n         _name = string(abi.encodePacked(iBEP20(_token).name(), synthName));\n         _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), synthSymbol));\n         decimals = iBEP20(_token).decimals();\n         DEPLOYER = msg.sender;\n         genesis = block.timestamp;\n     }\n \n     //========================================iBEP20=========================================//\n \n     function name() external view override returns (string memory) {\n         return _name;\n     }\n \n     function symbol() external view override returns (string memory) {\n         return _symbol;\n     }\n \n     function balanceOf(address account) public view override returns (uint256) {\n         return _balances[account];\n     }\n \n     function allowance(address owner, address spender) public view virtual override returns (uint256) {\n         return _allowances[owner][spender];\n     }\n \n     // iBEP20 Transfer function\n     function transfer(address recipient, uint256 amount) external virtual override returns (bool) {\n         _transfer(msg.sender, recipient, amount);\n         return true;\n     }\n \n     // iBEP20 Approve, change allowance functions\n     function approve(address spender, uint256 amount) external virtual override returns (bool) {\n         _approve(msg.sender, spender, amount);\n         return true;\n     }\n \n     function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\n         _approve(msg.sender, spender, _allowances[msg.sender][spender]+(addedValue));\n         return true;\n     }\n \n     function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\n         uint256 currentAllowance = _allowances[msg.sender][spender];\n         require(currentAllowance >= subtractedValue, \"!approval\");\n         _approve(msg.sender, spender, currentAllowance - subtractedValue);\n         return true;\n     }\n \n     function _approve(address owner, address spender, uint256 amount) internal virtual {\n         require(owner != address(0), \"!owner\");\n         require(spender != address(0), \"!spender\");\n         if (_allowances[owner][spender] < type(uint256).max) { // No need to re-approve if already max\n             _allowances[owner][spender] = amount;\n             emit Approval(owner, spender, amount);\n         }\n     }\n     \n     // iBEP20 TransferFrom function\n     function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool) {\n         _transfer(sender, recipient, amount);\n         // Unlimited approval (saves an SSTORE)\n         if (_allowances[sender][msg.sender] < type(uint256).max) {\n             uint256 currentAllowance = _allowances[sender][msg.sender];\n             require(currentAllowance >= amount, \"!approval\");\n             _approve(sender, msg.sender, currentAllowance - amount);\n         }\n         return true;\n     }\n \n     //iBEP677 approveAndCall\n     function approveAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n         _approve(msg.sender, recipient, type(uint256).max); // Give recipient max approval\n         iBEP677(recipient).onTokenApproval(address(this), amount, msg.sender, data); // Amount is passed thru to recipient\n         return true;\n     }\n \n     //iBEP677 transferAndCall\n     function transferAndCall(address recipient, uint amount, bytes calldata data) external returns (bool) {\n         _transfer(msg.sender, recipient, amount);\n         iBEP677(recipient).onTokenTransfer(address(this), amount, msg.sender, data); // Amount is passed thru to recipient \n         return true;\n     }\n \n     // Internal transfer function\n     function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n         require(sender != address(0), \"!sender\");\n         uint256 senderBalance = _balances[sender];\n         require(senderBalance >= amount, \"!balance\");\n         _balances[sender] -= amount;\n         _balances[recipient] += amount;\n         emit Transfer(sender, recipient, amount);\n     }\n \n     // Internal mint (upgrading and daily emissions)\n     function _mint(address account, uint256 amount) internal virtual {\n         require(account != address(0), \"!account\");\n         totalSupply += amount;\n         _balances[account] += amount;\n         emit Transfer(address(0), account, amount);\n     }\n \n     // Burn supply\n     function burn(uint256 amount) external virtual override {\n         _burn(msg.sender, amount);\n     }\n \n     function burnFrom(address account, uint256 amount) external virtual {  \n         uint256 decreasedAllowance = allowance(account, msg.sender) - (amount);\n         _approve(account, msg.sender, decreasedAllowance); \n         _burn(account, amount);\n     }\n \n     function _burn(address account, uint256 amount) internal virtual {\n         require(account != address(0), \"!account\");\n         require(_balances[account] >= amount, \"!balance\");\n         _balances[account] -= amount;\n         totalSupply -= amount;\n         emit Transfer(account, address(0), amount);\n     }\n \n     //==================================== SYNTH FUNCTIONS =================================//\n \n     // Handle received LP tokens and mint Synths\n     function mintSynth(address member, uint amount) external onlyPool returns (uint syntheticAmount){\n         uint lpUnits = _getAddedLPAmount(msg.sender); // Get the received LP units\n         mapSynth_LPDebt[msg.sender] += amount; // Increase debt by synth amount\n         mapSynth_LPBalance[msg.sender] += lpUnits; // Increase lp balance by LPs received\n         _mint(member, amount); // Mint the synths & tsf to user\n         return amount;\n     }\n     \n     // Handle received Synths and burn the LPs and Synths\n     function burnSynth() external returns (bool){\n         uint _syntheticAmount = balanceOf(address(this)); // Get the received synth units\n         uint _amountUnits = (_syntheticAmount * mapSynth_LPBalance[msg.sender]) / mapSynth_LPDebt[msg.sender]; // share = amount * part/total\n         mapSynth_LPBalance[msg.sender] -= _amountUnits; // Reduce lp balance\n         mapSynth_LPDebt[msg.sender] -= _syntheticAmount; // Reduce debt by synths being burnt\n         if(_amountUnits > 0){\n             _burn(address(this), _syntheticAmount); // Burn the synths\n             Pool(msg.sender).burn(_amountUnits); // Burn the LP tokens\n         }\n         return true;\n     }\n \n     // Burn LPs to if their value outweights the synths supply value (Ensures incentives are funnelled to existing LPers)\n     function realise(address pool) external {\n         uint baseValueLP = iUTILS(_DAO().UTILS()).calcLiquidityHoldings(mapSynth_LPBalance[pool], BASE, pool); // Get the SPARTA value of the LP tokens\n         uint baseValueSynth = iUTILS(_DAO().UTILS()).calcActualSynthUnits(mapSynth_LPDebt[pool], address(this)); // Get the SPARTA value of the synths\n         if(baseValueLP > baseValueSynth){\n             uint premium = baseValueLP - baseValueSynth; // Get the premium between the two values\n             if(premium > 10**18){\n                 uint premiumLP = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(premium, pool); // Get the LP value of the premium\n                 mapSynth_LPBalance[pool] -= premiumLP; // Reduce the LP balance\n                 Pool(pool).burn(premiumLP); // Burn the premium of the LP tokens\n             }\n         }\n     }\n \n     // Check the received token amount\n     function _handleTransferIn(address _token, uint256 _amount) internal returns(uint256 _actual){\n         if(_amount > 0) {\n             uint startBal = iBEP20(_token).balanceOf(address(this)); // Get existing balance\n             iBEP20(_token).transferFrom(msg.sender, address(this), _amount); // Transfer tokens in\n             _actual = iBEP20(_token).balanceOf(address(this)) - startBal; // Calculate received amount\n         }\n         return _actual;\n     }\n \n     // Check the received LP tokens amount\n     function _getAddedLPAmount(address _pool) internal view returns(uint256 _actual){\n         uint _lpCollateralBalance = iBEP20(_pool).balanceOf(address(this)); // Get total balance held\n         if(_lpCollateralBalance > mapSynth_LPBalance[_pool]){\n             _actual = _lpCollateralBalance - mapSynth_LPBalance[_pool]; // Get received amount\n         } else {\n             _actual = 0;\n         }\n         return _actual;\n     }\n \n     function getmapAddress_LPBalance(address pool) external view returns (uint){\n         return mapSynth_LPBalance[pool];\n     }\n \n     function getmapAddress_LPDebt(address pool) external view returns (uint){\n         return mapSynth_LPDebt[pool];\n     }\n }",
        "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-07-spartan#h-09-arbitrary-synth-mintburn-from-pool",
	            "Location":"mintSynth function",
	            "Type":"ID-related violations",
	            "Description":"Shared resource (e.g., token) without proper locks.arbitrary synth mint/burn from pool,Pool can mint arbitrary Synth provided as long as it’s a valid synth. When there are multiple curated pools and synth (which the protocol is designed for), hackers can mint expensive synthetics from a cheaper AMM pool. The hacker can burn the minted synth at the expensive pool and get profit. The arbitrage profit can be amplified with flash loan services and break all the pegs.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity 0.8.3;\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\nimport \"./interfaces/IFloatToken.sol\";\nimport \"./interfaces/ILongShort.sol\";\nimport \"./interfaces/IStaker.sol\";\nimport \"./interfaces/ISyntheticToken.sol\";\n\ncontract Staker is IStaker, Initializable {\n\n  uint256 public constant FLOAT_ISSUANCE_FIXED_DECIMAL = 1e42;\n  uint256 public constant safeExponentBitShifting = 52;\n\n\n  address public admin;\n  address public floatCapital;\n  address public floatTreasury;\n  uint256 public floatPercentage;\n\n  address public longShort;\n  address public floatToken;\n\n\n  mapping(uint32 => uint256) public marketLaunchIncentive_period; // seconds\n  mapping(uint32 => uint256) public marketLaunchIncentive_multipliers; // e18 scale\n  mapping(uint32 => uint256) public marketUnstakeFee_e18;\n  mapping(uint32 => uint256) public balanceIncentiveCurve_exponent;\n  mapping(uint32 => int256) public balanceIncentiveCurve_equilibriumOffset;\n\n  mapping(uint32 => mapping(bool => address)) public syntheticTokens;\n\n  mapping(address => uint32) public marketIndexOfToken;\n\n\n  mapping(uint32 => uint256) public latestRewardIndex;\n  mapping(uint32 => mapping(uint256 => AccumulativeIssuancePerStakedSynthSnapshot))\n    public accumulativeFloatPerSyntheticTokenSnapshots;\n  struct AccumulativeIssuancePerStakedSynthSnapshot {\n    uint256 timestamp;\n    uint256 accumulativeFloatPerSyntheticToken_long;\n    uint256 accumulativeFloatPerSyntheticToken_short;\n  }\n\n  /* ══════ User specific ══════ */\n  mapping(uint32 => mapping(address => uint256)) public userIndexOfLastClaimedReward;\n  mapping(address => mapping(address => uint256)) public userAmountStaked;\n  mapping(uint32 => uint256) public batched_stakerNextTokenShiftIndex;\n  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping;\n  mapping(uint256 => uint256) public stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping;\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_stakedSyntheticTokenShiftIndex;\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long;\n  mapping(uint32 => mapping(address => uint256)) public userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short;\n  event StakerV1(\n    address admin,\n    address floatTreasury,\n    address floatCapital,\n    address floatToken,\n    uint256 floatPercentage\n  );\n\n  event MarketAddedToStaker(\n    uint32 marketIndex,\n    uint256 exitFee_e18,\n    uint256 period,\n    uint256 multiplier,\n    uint256 balanceIncentiveExponent,\n    int256 balanceIncentiveEquilibriumOffset\n  );\n\n  event AccumulativeIssuancePerStakedSynthSnapshotCreated(\n    uint32 marketIndex,\n    uint256 accumulativeFloatIssuanceSnapshotIndex,\n    uint256 accumulativeLong,\n    uint256 accumulativeShort\n  );\n  event StakeAdded(address user, address token, uint256 amount, uint256 lastMintIndex);\n  event StakeWithdrawn(address user, address token, uint256 amount);\n  event FloatMinted(address user, uint32 marketIndex, uint256 amountFloatMinted);\n  event MarketLaunchIncentiveParametersChanges(uint32 marketIndex, uint256 period, uint256 multiplier);\n  event StakeWithdrawalFeeUpdated(uint32 marketIndex, uint256 stakeWithdralFee);\n  event BalanceIncentiveExponentUpdated(uint32 marketIndex, uint256 balanceIncentiveExponent);\n  event BalanceIncentiveEquilibriumOffsetUpdated(uint32 marketIndex, int256 balanceIncentiveEquilibriumOffset);\n  event FloatPercentageUpdated(uint256 floatPercentage);\n  event SyntheticTokensShifted();\n  event ChangeAdmin(address newAdmin);\n  function onlyAdminModifierLogic() internal virtual {\n    require(msg.sender == admin, \"not admin\");\n  }\n\n  modifier onlyAdmin() {\n    onlyAdminModifierLogic();\n    _;\n  }\n\n  function onlyValidSyntheticModifierLogic(address _synth) internal virtual {\n    require(marketIndexOfToken[_synth] != 0, \"not valid synth\");\n  }\n\n  modifier onlyValidSynthetic(address _synth) {\n    onlyValidSyntheticModifierLogic(_synth);\n    _;\n  }\n\n  function onlyValidMarketModifierLogic(uint32 marketIndex) internal virtual {\n    require(address(syntheticTokens[marketIndex][true]) != address(0), \"not valid market\");\n  }\n\n  modifier onlyValidMarket(uint32 marketIndex) {\n    onlyValidMarketModifierLogic(marketIndex);\n    _;\n  }\n\n  function onlyLongShortModifierLogic() internal virtual {\n    require(msg.sender == address(longShort), \"not long short\");\n  }\n\n  modifier onlyLongShort() {\n    onlyLongShortModifierLogic();\n    _;\n  }\n  function initialize(\n    address _admin,\n    address _longShort,\n    address _floatToken,\n    address _floatTreasury,\n    address _floatCapital,\n    uint256 _floatPercentage\n  ) external virtual initializer {\n    admin = _admin;\n    floatCapital = _floatCapital;\n    floatTreasury = _floatTreasury;\n    longShort = _longShort;\n    floatToken = _floatToken;\n\n    _changeFloatPercentage(_floatPercentage);\n\n    emit StakerV1(_admin, _floatTreasury, _floatCapital, _floatToken, _floatPercentage);\n  }\n  function changeAdmin(address _admin) external onlyAdmin {\n    admin = _admin;\n    emit ChangeAdmin(_admin);\n  }\n\n  /// @dev Logic for changeFloatPercentage\n  function _changeFloatPercentage(uint256 newFloatPercentage) internal virtual {\n    require(newFloatPercentage <= 1e18 && newFloatPercentage > 0); // less than or equal to 100% and greater than 0%\n    floatPercentage = newFloatPercentage;\n  }\n  function changeFloatPercentage(uint256 newFloatPercentage) external onlyAdmin {\n    _changeFloatPercentage(newFloatPercentage);\n    emit FloatPercentageUpdated(newFloatPercentage);\n  }\n  function _changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) internal virtual {\n    require(newMarketUnstakeFee_e18 <= 5e16); // Explicitely stating 5% fee as the max fee possible.\n    marketUnstakeFee_e18[marketIndex] = newMarketUnstakeFee_e18;\n  }\n  function changeUnstakeFee(uint32 marketIndex, uint256 newMarketUnstakeFee_e18) external onlyAdmin {\n    _changeUnstakeFee(marketIndex, newMarketUnstakeFee_e18);\n    emit StakeWithdrawalFeeUpdated(marketIndex, newMarketUnstakeFee_e18);\n  }\n  function _changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) internal virtual {\n    require(initialMultiplier >= 1e18, \"marketLaunchIncentiveMultiplier must be >= 1e18\");\n\n    marketLaunchIncentive_period[marketIndex] = period;\n    marketLaunchIncentive_multipliers[marketIndex] = initialMultiplier;\n  }\n  function changeMarketLaunchIncentiveParameters(\n    uint32 marketIndex,\n    uint256 period,\n    uint256 initialMultiplier\n  ) external onlyAdmin {\n    _changeMarketLaunchIncentiveParameters(marketIndex, period, initialMultiplier);\n\n    emit MarketLaunchIncentiveParametersChanges(marketIndex, period, initialMultiplier);\n  }\n  function _changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    internal\n    virtual\n  {\n    require(\n      // The exponent has to be less than 5 in these versions of the contracts.\n      _balanceIncentiveCurve_exponent > 0 && _balanceIncentiveCurve_exponent < 6,\n      \"balanceIncentiveCurve_exponent out of bounds\"\n    );\n\n    balanceIncentiveCurve_exponent[marketIndex] = _balanceIncentiveCurve_exponent;\n  }\n  function changeBalanceIncentiveExponent(uint32 marketIndex, uint256 _balanceIncentiveCurve_exponent)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n\n    emit BalanceIncentiveExponentUpdated(marketIndex, _balanceIncentiveCurve_exponent);\n  }\n  function _changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    internal\n    virtual\n  {\n    // Unreasonable that we would ever shift this more than 90% either way\n    require(\n      _balanceIncentiveCurve_equilibriumOffset > -9e17 && _balanceIncentiveCurve_equilibriumOffset < 9e17,\n      \"balanceIncentiveCurve_equilibriumOffset out of bounds\"\n    );\n\n    balanceIncentiveCurve_equilibriumOffset[marketIndex] = _balanceIncentiveCurve_equilibriumOffset;\n  }\n  function changeBalanceIncentiveEquilibriumOffset(uint32 marketIndex, int256 _balanceIncentiveCurve_equilibriumOffset)\n    external\n    onlyAdmin\n  {\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n\n    emit BalanceIncentiveEquilibriumOffsetUpdated(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n  }\n  function addNewStakingFund(\n    uint32 marketIndex,\n    address longToken,\n    address shortToken,\n    uint256 kInitialMultiplier,\n    uint256 kPeriod,\n    uint256 unstakeFee_e18,\n    uint256 _balanceIncentiveCurve_exponent,\n    int256 _balanceIncentiveCurve_equilibriumOffset\n  ) external override onlyLongShort {\n    marketIndexOfToken[longToken] = marketIndex;\n    marketIndexOfToken[shortToken] = marketIndex;\n\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp = block.timestamp;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_long = 0;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].accumulativeFloatPerSyntheticToken_short = 0;\n\n    syntheticTokens[marketIndex][true] = longToken;\n    syntheticTokens[marketIndex][false] = shortToken;\n\n    _changeBalanceIncentiveExponent(marketIndex, _balanceIncentiveCurve_exponent);\n    _changeBalanceIncentiveEquilibriumOffset(marketIndex, _balanceIncentiveCurve_equilibriumOffset);\n    _changeMarketLaunchIncentiveParameters(marketIndex, kPeriod, kInitialMultiplier);\n\n    _changeUnstakeFee(marketIndex, unstakeFee_e18);\n    batched_stakerNextTokenShiftIndex[marketIndex] = 1;\n\n    emit MarketAddedToStaker(\n      marketIndex,\n      unstakeFee_e18,\n      kPeriod,\n      kInitialMultiplier,\n      _balanceIncentiveCurve_exponent,\n      _balanceIncentiveCurve_equilibriumOffset\n    );\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(marketIndex, 0, 0, 0);\n  }\n  function _getMarketLaunchIncentiveParameters(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256 period, uint256 multiplier)\n  {\n    period = marketLaunchIncentive_period[marketIndex];\n    multiplier = marketLaunchIncentive_multipliers[marketIndex];\n\n    if (multiplier < 1e18) {\n      multiplier = 1e18; // multiplier of 1 by default\n    }\n  }\n  function _getKValue(uint32 marketIndex) internal view virtual returns (uint256) {\n    // Parameters controlling the float issuance multiplier.\n    (uint256 kPeriod, uint256 kInitialMultiplier) = _getMarketLaunchIncentiveParameters(marketIndex);\n\n    // Sanity check - under normal circumstances, the multipliers should\n    // *never* be set to a value < 1e18, as there are guards against this.\n    assert(kInitialMultiplier >= 1e18);\n\n    uint256 initialTimestamp = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][0].timestamp;\n\n    if (block.timestamp - initialTimestamp <= kPeriod) {\n      return kInitialMultiplier - (((kInitialMultiplier - 1e18) * (block.timestamp - initialTimestamp)) / kPeriod);\n    } else {\n      return 1e18;\n    }\n  }\n  function _calculateFloatPerSecond(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) {\n    uint256 k = _getKValue(marketIndex);\n\n    uint256 totalLocked = (longValue + shortValue);\n\n    int256 equilibriumOffsetMarketScaled = (balanceIncentiveCurve_equilibriumOffset[marketIndex] *\n      int256(totalLocked)) / 2e18;\n\n    uint256 denominator = ((totalLocked >> safeExponentBitShifting)**balanceIncentiveCurve_exponent[marketIndex]);\n    if (int256(shortValue) - equilibriumOffsetMarketScaled < int256(longValue)) {\n      if (equilibriumOffsetMarketScaled >= int256(shortValue)) {\n        return (0, 1e18 * k * shortPrice);\n      }\n\n      uint256 numerator = (uint256(int256(shortValue) - equilibriumOffsetMarketScaled) >>\n        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];\n\n      uint256 longRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 shortRewardUnscaled = 1e18 - longRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    } else {\n      if (-equilibriumOffsetMarketScaled >= int256(longValue)) {\n        // edge case: imbalanced far past the equilibrium offset - full rewards go to long token\n        //            extremeley unlikely to happen in practice\n        return (1e18 * k * longPrice, 0);\n      }\n\n      uint256 numerator = (uint256(int256(longValue) + equilibriumOffsetMarketScaled) >>\n        (safeExponentBitShifting - 1))**balanceIncentiveCurve_exponent[marketIndex];\n\n      // NOTE: `x * 5e17` == `(x * 10e18) / 2`\n      uint256 shortRewardUnscaled = (numerator * 5e17) / denominator;\n      uint256 longRewardUnscaled = 1e18 - shortRewardUnscaled;\n\n      return ((longRewardUnscaled * k * longPrice) / 1e18, (shortRewardUnscaled * k * shortPrice) / 1e18);\n    }\n  }\n  function _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(uint32 marketIndex)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    return\n      block.timestamp -\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]].timestamp;\n  }\n  function _calculateNewCumulativeIssuancePerStakedSynth(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal view virtual returns (uint256 longCumulativeRates, uint256 shortCumulativeRates) {\n    // Compute the current 'r' value for float issuance per second.\n    (uint256 longFloatPerSecond, uint256 shortFloatPerSecond) = _calculateFloatPerSecond(\n      marketIndex,\n      longPrice,\n      shortPrice,\n      longValue,\n      shortValue\n    );\n\n    // Compute time since last accumulativeIssuancePerStakedSynthSnapshot for the given token.\n    uint256 timeDelta = _calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex);\n\n    // Compute new cumulative 'r' value total.\n    return (\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_long + (timeDelta * longFloatPerSecond),\n      accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][latestRewardIndex[marketIndex]]\n      .accumulativeFloatPerSyntheticToken_short + (timeDelta * shortFloatPerSecond)\n    );\n  }\n  function _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue\n  ) internal virtual {\n    (\n      uint256 newLongAccumulativeValue,\n      uint256 newShortAccumulativeValue\n    ) = _calculateNewCumulativeIssuancePerStakedSynth(marketIndex, longPrice, shortPrice, longValue, shortValue);\n\n    uint256 newIndex = latestRewardIndex[marketIndex] + 1;\n\n    // Set cumulative 'r' value on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_long = newLongAccumulativeValue;\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex]\n    .accumulativeFloatPerSyntheticToken_short = newShortAccumulativeValue;\n\n    // Set timestamp on new accumulativeIssuancePerStakedSynthSnapshot.\n    accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][newIndex].timestamp = block.timestamp;\n\n    // Update latest index to point to new accumulativeIssuancePerStakedSynthSnapshot.\n    latestRewardIndex[marketIndex] = newIndex;\n\n    emit AccumulativeIssuancePerStakedSynthSnapshotCreated(\n      marketIndex,\n      newIndex,\n      newLongAccumulativeValue,\n      newShortAccumulativeValue\n    );\n  }\n  function pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations(\n    uint32 marketIndex,\n    uint256 longPrice,\n    uint256 shortPrice,\n    uint256 longValue,\n    uint256 shortValue,\n    uint256 stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted // This value should be ALWAYS be zero if no shift occured\n  ) external override onlyLongShort {\n    if (stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted > 0) {\n      stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;\n      stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[\n        batched_stakerNextTokenShiftIndex[marketIndex]\n      ] = latestRewardIndex[marketIndex] + 1;\n      batched_stakerNextTokenShiftIndex[marketIndex] += 1;\n\n      emit SyntheticTokensShifted();\n    }\n\n    // Time delta is fetched twice in below code, can pass through? Which is less gas?\n    if (_calculateTimeDeltaFromLastAccumulativeIssuancePerStakedSynthSnapshot(marketIndex) > 0) {\n      _setCurrentAccumulativeIssuancePerStakeStakedSynthSnapshot(\n        marketIndex,\n        longPrice,\n        shortPrice,\n        longValue,\n        shortValue\n      );\n    }\n  }\n  function _calculateAccumulatedFloatInRange(\n    uint32 marketIndex,\n    uint256 amountStakedLong,\n    uint256 amountStakedShort,\n    uint256 rewardIndexFrom,\n    uint256 rewardIndexTo\n  ) internal view virtual returns (uint256 floatReward) {\n    if (amountStakedLong > 0) {\n      uint256 accumDeltaLong = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_long -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_long;\n      floatReward += (accumDeltaLong * amountStakedLong) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n\n    if (amountStakedShort > 0) {\n      uint256 accumDeltaShort = accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexTo]\n      .accumulativeFloatPerSyntheticToken_short -\n        accumulativeFloatPerSyntheticTokenSnapshots[marketIndex][rewardIndexFrom]\n        .accumulativeFloatPerSyntheticToken_short;\n      floatReward += (accumDeltaShort * amountStakedShort) / FLOAT_ISSUANCE_FIXED_DECIMAL;\n    }\n  }\n  function _calculateAccumulatedFloat(uint32 marketIndex, address user) internal virtual returns (uint256 floatReward) {\n    address longToken = syntheticTokens[marketIndex][true];\n    address shortToken = syntheticTokens[marketIndex][false];\n\n    uint256 amountStakedLong = userAmountStaked[longToken][user];\n    uint256 amountStakedShort = userAmountStaked[shortToken][user];\n\n    uint256 usersLastRewardIndex = userIndexOfLastClaimedReward[marketIndex][user];\n    if (usersLastRewardIndex == latestRewardIndex[marketIndex]) {\n      return 0;\n    }\n\n    uint256 usersShiftIndex = userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user];\n    // if there is a change in the users tokens held due to a token shift (or possibly another action in the future)\n    if (usersShiftIndex > 0 && usersShiftIndex < batched_stakerNextTokenShiftIndex[marketIndex]) {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex]\n      );\n\n      // Update the users balances\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] > 0) {\n        amountStakedShort += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user],\n          true,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedLong -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][user] = 0;\n      }\n\n      if (userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] > 0) {\n        amountStakedLong += ILongShort(longShort).getAmountSyntheticTokenToMintOnTargetSide(\n          marketIndex,\n          userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user],\n          false,\n          stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[usersShiftIndex]\n        );\n\n        amountStakedShort -= userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user];\n        userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][user] = 0;\n      }\n\n      // Save the users updated staked amounts\n      userAmountStaked[longToken][user] = amountStakedLong;\n      userAmountStaked[shortToken][user] = amountStakedShort;\n\n      floatReward += _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[usersShiftIndex],\n        latestRewardIndex[marketIndex]\n      );\n\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][user] = 0;\n    } else {\n      floatReward = _calculateAccumulatedFloatInRange(\n        marketIndex,\n        amountStakedLong,\n        amountStakedShort,\n        usersLastRewardIndex,\n        latestRewardIndex[marketIndex]\n      );\n    }\n  }\n  function _mintFloat(address user, uint256 floatToMint) internal virtual {\n    IFloatToken(floatToken).mint(user, floatToMint);\n    IFloatToken(floatToken).mint(floatCapital, (floatToMint * floatPercentage) / 1e18);\n  }\n  function _mintAccumulatedFloat(uint32 marketIndex, address user) internal virtual {\n    uint256 floatToMint = _calculateAccumulatedFloat(marketIndex, user);\n\n    if (floatToMint > 0) {\n      // Set the user has claimed up until now, stops them setting this forward\n      userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n      _mintFloat(user, floatToMint);\n      emit FloatMinted(user, marketIndex, floatToMint);\n    }\n  }\n  function _mintAccumulatedFloatMulti(uint32[] calldata marketIndexes, address user) internal virtual {\n    uint256 floatTotal = 0;\n    for (uint256 i = 0; i < marketIndexes.length; i++) {\n      uint256 floatToMint = _calculateAccumulatedFloat(marketIndexes[i], user);\n\n      if (floatToMint > 0) {\n        // Set the user has claimed up until now, stops them setting this forward\n        userIndexOfLastClaimedReward[marketIndexes[i]][user] = latestRewardIndex[marketIndexes[i]];\n\n        floatTotal += floatToMint;\n\n        emit FloatMinted(user, marketIndexes[i], floatToMint);\n      }\n    }\n    if (floatTotal > 0) {\n      _mintFloat(user, floatTotal);\n    }\n  }\n  function claimFloatCustom(uint32[] calldata marketIndexes) external {\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, msg.sender);\n  }\n\n  /**\n  @notice Mints outstanding float on behalf of another user.\n  @param marketIndexes Identifiers for the markets for which to mint float.\n  @param user The address of the user.\n   */\n  function claimFloatCustomFor(uint32[] calldata marketIndexes, address user) external {\n    // Unbounded loop - users are responsible for paying their own gas costs on these and it doesn't effect the rest of the system.\n    // No need to impose limit.\n    ILongShort(longShort).updateSystemStateMulti(marketIndexes);\n    _mintAccumulatedFloatMulti(marketIndexes, user);\n  }\n  function stakeFromUser(address from, uint256 amount) public virtual override onlyValidSynthetic((msg.sender)) {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[(msg.sender)]);\n    _stake((msg.sender), amount, from);\n  }\n  function _stake(\n    address token,\n    uint256 amount,\n    address user\n  ) internal virtual {\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    // If they already have staked and have rewards due, mint these.\n    if (\n      userIndexOfLastClaimedReward[marketIndex][user] != 0 &&\n      userIndexOfLastClaimedReward[marketIndex][user] < latestRewardIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, user);\n    }\n\n    userAmountStaked[token][user] = userAmountStaked[token][user] + amount;\n\n    userIndexOfLastClaimedReward[marketIndex][user] = latestRewardIndex[marketIndex];\n\n    emit StakeAdded(user, address(token), amount, userIndexOfLastClaimedReward[marketIndex][user]);\n  }\n  function shiftTokens(\n    uint256 amountSyntheticTokensToShift,\n    uint32 marketIndex,\n    bool isShiftFromLong\n  ) external virtual {\n    address token = syntheticTokens[marketIndex][isShiftFromLong];\n    require(userAmountStaked[token][msg.sender] >= amountSyntheticTokensToShift, \"Not enough tokens to shift\");\n\n    // If the user has outstanding token shift that have already been confirmed in the LongShort\n    // contract, execute them first.\n    if (\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] != 0 &&\n      userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] <\n      batched_stakerNextTokenShiftIndex[marketIndex]\n    ) {\n      _mintAccumulatedFloat(marketIndex, msg.sender);\n    }\n\n    if (isShiftFromLong) {\n      ILongShort(longShort).shiftPositionFromLongNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    } else {\n      ILongShort(longShort).shiftPositionFromShortNextPrice(marketIndex, amountSyntheticTokensToShift);\n      userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][\n        msg.sender\n      ] += amountSyntheticTokensToShift;\n    }\n\n    userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] = batched_stakerNextTokenShiftIndex[\n      marketIndex\n    ];\n  }\n  function _withdraw(\n    uint32 marketIndex,\n    address token,\n    uint256 amount\n  ) internal virtual {\n    require(userAmountStaked[token][msg.sender] > 0, \"nothing to withdraw\");\n    _mintAccumulatedFloat(marketIndex, msg.sender);\n\n    userAmountStaked[token][msg.sender] = userAmountStaked[token][msg.sender] - amount;\n\n    uint256 amountFees = (amount * marketUnstakeFee_e18[marketIndex]) / 1e18;\n\n    IERC20(token).transfer(floatTreasury, amountFees);\n    IERC20(token).transfer(msg.sender, amount - amountFees);\n\n    emit StakeWithdrawn(msg.sender, token, amount);\n  }\n  function withdraw(address token, uint256 amount) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    _withdraw(marketIndex, token, amount);\n\n    if (userNextPrice_stakedSyntheticTokenShiftIndex[marketIndex][msg.sender] > 0) {\n      // If they still have outstanding shifts after minting float, then check\n      // that they don't withdraw more than their shifts allow.\n      uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n        ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n        : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n      require(\n        userAmountStaked[token][msg.sender] >= amountToShiftForThisToken,\n        \"Outstanding next price stake shifts too great\"\n      );\n    }\n  }\n  function withdrawAll(address token) external {\n    ILongShort(longShort).updateSystemState(marketIndexOfToken[token]);\n\n    uint32 marketIndex = marketIndexOfToken[token];\n\n    uint256 amountToShiftForThisToken = syntheticTokens[marketIndex][true] == token\n      ? userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_long[marketIndex][msg.sender]\n      : userNextPrice_amountStakedSyntheticToken_toShiftAwayFrom_short[marketIndex][msg.sender];\n\n    _withdraw(marketIndex, token, userAmountStaked[token][msg.sender] - amountToShiftForThisToken);\n  }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-08-floatcapital#h-02-2-variables-not-indexed-by-marketindex",
	            "Location":"stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping[ batched_stakerNextTokenShiftIndex[marketIndex]  ] = stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mappingIfShiftExecuted;stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping[  batched_stakerNextTokenShiftIndex[marketIndex]  ] = latestRewardIndex[marketIndex] + 1;batched_stakerNextTokenShiftIndex[marketIndex] += 1; in pushUpdatedMarketPricesToUpdateFloatIssuanceCalculations fuction",
	            "Type":"ID-related violations",
	            "Description":"ID uniqueness violation (i.e., an ID should be unique but it is not).2 variables not indexed by marketIndex,In the token contract: batched_stakerNextTokenShiftIndex is indexed by marketIndex, so it can have separate (or the same) values for each different marketIndex.stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping are not indexed by marketIndex. So the values of stakerTokenShiftIndex_to_longShortMarketPriceSnapshotIndex_mapping and stakerTokenShiftIndex_to_accumulativeFloatIssuanceSnapshotIndex_mapping can be overwritten by a different market, if batched_stakerNextTokenShiftIndex[market1]==batched_stakerNextTokenShiftIndex[market2] This will lead to weird results in_calculateAccumulatedFloat, allocating too much or too little float.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"interfaces/compound/CTokenInterface.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract CompoundToNotionalV2 {\n    NotionalProxy public immutable NotionalV2;\n    address public owner;\n\n    constructor(NotionalProxy notionalV2_) {\n        NotionalV2 = notionalV2_;\n        owner = msg.sender;\n    }\n\n    function enableToken(address token, address spender) external {\n        require(msg.sender == owner, \"Unauthorized\");\n        CTokenInterface(token).approve(spender, type(uint256).max);\n    }\n\n    function migrateBorrowFromCompound(\n        address cTokenBorrow,\n        uint256 cTokenRepayAmount,\n        uint16[] memory notionalV2CollateralIds,\n        uint256[] memory notionalV2CollateralAmounts,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        uint256 borrowBalance = CTokenInterface(cTokenBorrow).borrowBalanceCurrent(msg.sender);\n        if (cTokenRepayAmount == 0) {\n            // Set the entire borrow balance if it is not set\n            cTokenRepayAmount = borrowBalance;\n        } else {\n            // Check that the cToken repayment amount is not more than required\n            require(cTokenRepayAmount <= borrowBalance, \"Invalid repayment amount\");\n        }\n\n        bytes memory encodedData = abi.encode(\n            cTokenBorrow,\n            cTokenRepayAmount,\n            notionalV2CollateralIds,\n            notionalV2CollateralAmounts\n        );\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function notionalCallback(\n        address sender,\n        address account,\n        bytes calldata callbackData\n    ) external returns (uint256) {\n        require(sender == address(this), \"Unauthorized callback\");\n\n        (\n            address cTokenBorrow,\n            uint256 cTokenRepayAmount,\n            uint16[] memory notionalV2CollateralIds,\n            uint256[] memory notionalV2CollateralAmounts\n        ) = abi.decode(callbackData, (address, uint256, uint16[], uint256[]));\n        address underlyingToken = CTokenInterface(cTokenBorrow).underlying();\n        bool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\n        require(success, \"Transfer of repayment failed\");\n        uint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n        require(code == 0, \"Repay borrow behalf failed\");\n\n        for (uint256 i; i < notionalV2CollateralIds.length; i++) {\n            (Token memory assetToken, /* */) = NotionalV2.getCurrency(notionalV2CollateralIds[i]);\n            success = CTokenInterface(assetToken.tokenAddress).transferFrom(account, address(this), notionalV2CollateralAmounts[i]);\n            require(success, \"cToken transfer failed\");\n            NotionalV2.depositAssetToken(account, notionalV2CollateralIds[i], notionalV2CollateralAmounts[i]);\n        }\n    }\n\n    receive() external payable {\n        revert(\"Cannot transfer ETH\");\n    }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-08-notional#h-04-access-restrictions-on-compoundtonotionalv2notionalcallback-can-be-bypassed",
	            "Location":"function notionalCallback(    address sender,address account,   bytes calldata callbackData) external returns (uint256) {require(sender == address(this), \"Unauthorized callback\"); in notionalCallback function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Access restrictions on CompoundToNotionalV2.notionalCallback can be bypassed,The CompoundToNotionalV2.notionalCallback is supposed to only be called from the verified contract that calls this callback. But, the access restrictions can be circumvented by simply providing sender = this, as sender is a parameter of the function that can be chosen by the attacker.An attacker can call the function passing in an arbitrary account whose tokens are then transferred to the contract. The account first has to approve this contract but this can happen with accounts that legitimately want to call the outer function and have to send a first transaction to approve the contract, but then an attacker front-runs the actual transaction.It’s at least a griefing attack: I can pass in a malicious cTokenBorrow that returns any token of my choice (through the .underlying() call) but whose repayBorrowBehalf is a no-op.This will lead to any of the victim’s approved tokens becoming stuck in the contract, essentially burning them",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"../../global/Types.sol\";\nimport \"interfaces/notional/NotionalProxy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface WETH9 {\n    function withdraw(uint256 wad) external;\n\n    function transfer(address dst, uint256 wad) external returns (bool);\n}\n\ninterface IEscrow {\n    function getBalances(address account) external view returns (int256[] memory);\n}\n\ninterface INotionalV1Erc1155 {\n    /** Notional V1 Types */\n    struct Deposit {\n        // Currency Id to deposit\n        uint16 currencyId;\n        // Amount of tokens to deposit\n        uint128 amount;\n    }\n    struct Withdraw {\n        // Destination of the address to withdraw to\n        address to;\n        // Currency Id to withdraw\n        uint16 currencyId;\n        // Amount of tokens to withdraw\n        uint128 amount;\n    }\n\n    enum TradeType {TakeCurrentCash, TakefCash, AddLiquidity, RemoveLiquidity}\n\n    /**\n     * Used to describe a trade in ERC1155.batchOperation\n     */\n    struct Trade {\n        TradeType tradeType;\n        uint8 cashGroup;\n        uint32 maturity;\n        uint128 amount;\n        bytes slippageData;\n    }\n\n    function batchOperationWithdraw(\n        address account,\n        uint32 maxTime,\n        Deposit[] memory deposits,\n        Trade[] memory trades,\n        Withdraw[] memory withdraws\n    ) external payable;\n}\n\ncontract NotionalV1ToNotionalV2 {\n    IEscrow public immutable Escrow;\n    NotionalProxy public immutable NotionalV2;\n    INotionalV1Erc1155 public immutable NotionalV1Erc1155;\n    WETH9 public immutable WETH;\n    IERC20 public immutable WBTC;\n\n    uint16 internal constant V1_ETH = 0;\n    uint16 internal constant V1_DAI = 1;\n    uint16 internal constant V1_USDC = 2;\n    uint16 internal constant V1_WBTC = 3;\n\n    uint16 public constant V2_ETH = 1;\n    uint16 public immutable V2_DAI;\n    uint16 public immutable V2_USDC;\n    uint16 public immutable V2_WBTC;\n\n    constructor(\n        IEscrow escrow_,\n        NotionalProxy notionalV2_,\n        INotionalV1Erc1155 erc1155_,\n        WETH9 weth_,\n        IERC20 wbtc_,\n        uint16 v2Dai_,\n        uint16 v2USDC_,\n        uint16 v2WBTC_\n    ) {\n        Escrow = escrow_;\n        NotionalV2 = notionalV2_;\n        NotionalV1Erc1155 = erc1155_;\n        WETH = weth_;\n        WBTC = wbtc_;\n        V2_DAI = v2Dai_;\n        V2_USDC = v2USDC_;\n        V2_WBTC = v2WBTC_;\n    }\n\n    function enableWBTC() external {\n        WBTC.approve(address(NotionalV2), type(uint256).max);\n    }\n\n    function migrateDaiEther(\n        uint128 v1RepayAmount,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        bytes memory encodedData = abi.encode(V1_DAI, v1RepayAmount, V1_ETH, V2_ETH);\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function migrateUSDCEther(\n        uint128 v1RepayAmount,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        bytes memory encodedData = abi.encode(V1_USDC, v1RepayAmount, V1_ETH, V2_ETH);\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function migrateDaiWBTC(\n        uint128 v1RepayAmount,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        bytes memory encodedData = abi.encode(V1_DAI, v1RepayAmount, V1_WBTC, V2_WBTC);\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function migrateUSDCWBTC(\n        uint128 v1RepayAmount,\n        BalanceActionWithTrades[] calldata borrowAction\n    ) external {\n        bytes memory encodedData = abi.encode(V1_USDC, v1RepayAmount, V1_WBTC, V2_WBTC);\n        NotionalV2.batchBalanceAndTradeActionWithCallback(msg.sender, borrowAction, encodedData);\n    }\n\n    function notionalCallback(\n        address sender,\n        address account,\n        bytes calldata callbackData\n    ) external returns (uint256) {\n        require(sender == address(this), \"Unauthorized callback\");\n        (\n            uint16 v1DebtCurrencyId,\n            uint128 v1RepayAmount,\n            uint16 v1CollateralId,\n            uint16 v2CollateralId\n        ) = abi.decode(callbackData, (uint16, uint128, uint16, uint16));\n\n        int256[] memory balances = Escrow.getBalances(account);\n        int256 collateralBalance =\n            (v1CollateralId == V1_ETH ? balances[V1_ETH] : balances[V1_WBTC]);\n        require(collateralBalance > 0);\n\n        {\n            INotionalV1Erc1155.Deposit[] memory deposits = new INotionalV1Erc1155.Deposit[](1);\n            INotionalV1Erc1155.Trade[] memory trades = new INotionalV1Erc1155.Trade[](0);\n            INotionalV1Erc1155.Withdraw[] memory withdraws = new INotionalV1Erc1155.Withdraw[](1);\n\n            // This will deposit what was borrowed from the account's wallet\n            deposits[0].currencyId = v1DebtCurrencyId;\n            deposits[0].amount = v1RepayAmount;\n\n            // This will withdraw to the current contract the collateral to repay the flash loan\n            withdraws[0].currencyId = v1CollateralId;\n            withdraws[0].to = address(this);\n            withdraws[0].amount = uint128(collateralBalance);\n\n            NotionalV1Erc1155.batchOperationWithdraw(\n                account,\n                uint32(block.timestamp),\n                deposits,\n                trades,\n                withdraws\n            );\n        }\n\n        // Overflow checked above, cannot be negative\n        uint256 v2CollateralBalance = uint256(collateralBalance);\n        if (v2CollateralId == V2_ETH) {\n            // Notional V1 uses WETH, but V2 uses ETH\n            WETH.withdraw(v2CollateralBalance);\n            NotionalV2.depositUnderlyingToken{value: v2CollateralBalance}(\n                account,\n                v2CollateralId,\n                v2CollateralBalance\n            );\n        } else {\n            NotionalV2.depositUnderlyingToken(account, v2CollateralId, v2CollateralBalance);\n        }\n\n        // When this exits it will do a free collateral check\n    }\n\n    receive() external payable {}\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-08-notional#h-05-access-restrictions-on-notionalv1tonotionalv2notionalcallback-can-be-bypassed",
	            "Location":"function notionalCallback(address sender,address account,bytes calldata callbackData) external returns (uint256) {require(sender == address(this), \"Unauthorized callback\");} in notionalCallback function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Access restrictions on NotionalV1ToNotionalV2.notionalCallback can be bypassed,The NotionalV1ToNotionalV2.notionalCallback is supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providing sender = this as sender is a parameter of the function that can be chosen by the attacker.An attacker can call the function passing in an arbitrary account whose tokens can then be stolen. The account first has to approve this contract but this can happen with accounts that legitimately want to migrate their tokens and therefore have to send a first transaction to approve the contract, but then an attacker frontruns the actual migration transaction.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity ^0.8.0;\nimport \"../interfaces/IMochiProfile.sol\";\nimport \"../interfaces/IMochiEngine.sol\";\n\n///@notice this is where policies including some math is registered will be able to swap the profile when current profile is not suitable\n///@dev this profile is built with https://docs.google.com/spreadsheets/d/1T2WKpwj5QmueR7O8R9AXNbnHLc-rJ_-8DLdRI2eJZqA\ncontract MochiProfileV0 is IMochiProfile {\n    using Float for float;\n    using Float for uint256;\n    IMochiEngine public immutable engine;\n\n    uint256 public override liquidityRequirement;\n\n    uint256 public override minimumDebt;\n\n    mapping(address => AssetClass) internal _assetClass;\n\n    mapping(address => uint256) public override creditCap;\n\n    uint256 public immutable secPerYear;\n\n    uint256 public override delay;\n\n    constructor(address _engine) {\n        secPerYear = 31536000;\n        engine = IMochiEngine(_engine);\n\n        liquidityRequirement = 1000000e18; // 1million dollar\n        minimumDebt = 1000e18;\n        delay = 3 minutes;\n    }\n\n    modifier onlyGov() {\n        require(msg.sender == engine.governance(), \"!gov\");\n        _;\n    }\n\n    function assetClass(address _asset)\n        public\n        view\n        override\n        returns (AssetClass)\n    {\n        return _assetClass[_asset];\n    }\n\n    function changeLiquidityRequirement(uint256 _requirement)\n        external\n        override\n        onlyGov\n    {\n        liquidityRequirement = _requirement;\n    }\n\n    function registerAsset(address _asset) external {\n        uint256 liq = engine.cssr().getLiquidity(_asset);\n        require(liq >= liquidityRequirement, \"<liquidity\");\n        _register(_asset, AssetClass.Sigma);\n    }\n\n    function registerAssetByGov(\n        address[] calldata _asset,\n        AssetClass[] calldata _classes\n    ) external onlyGov {\n        for (uint256 i = 0; i < _asset.length; i++) {\n            _register(_asset[i], _classes[i]);\n            engine.vaultFactory().deployVault(_asset[i]);\n        }\n    }\n\n    function _register(address _asset, AssetClass _class) internal {\n        _assetClass[_asset] = _class;\n    }\n\n    function changeMinimumDebt(uint256 _debt) external override onlyGov {\n        minimumDebt = _debt;\n    }\n\n    function changeAssetClass(\n        address[] calldata _assets,\n        AssetClass[] calldata _classes\n    ) external override onlyGov {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            _assetClass[_assets[i]] = _classes[i];\n        }\n    }\n\n    function changeCreditCap(\n        address[] calldata _assets,\n        uint256[] calldata _caps\n    ) external onlyGov {\n        for (uint256 i = 0; i < _assets.length; i++) {\n            creditCap[_assets[i]] = _caps[i];\n        }\n    }\n\n    function setDelay(uint256 _delay) external onlyGov {\n        delay = _delay;\n    }\n\n    ///@notice The Collateral Factor at which the users vault will be liquidated\n    function liquidationFactor(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 95, denominator: 100});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 85, denominator: 100});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 80, denominator: 100});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 75, denominator: 100});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 65, denominator: 100});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 40, denominator: 100});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function riskFactor(address _asset) public view returns (uint256) {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return 1;\n        } else if (class == AssetClass.Alpha) {\n            return 2;\n        } else if (class == AssetClass.Gamma) {\n            return 3;\n        } else if (class == AssetClass.Delta) {\n            return 4;\n        } else if (class == AssetClass.Zeta) {\n            return 5;\n        } else if (class == AssetClass.Sigma) {\n            return 6;\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function maxCollateralFactor(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 90, denominator: 100});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 80, denominator: 100});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 75, denominator: 100});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 65, denominator: 100});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 55, denominator: 100});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 45, denominator: 100});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function baseFee() public pure returns (float memory) {\n        return float({numerator: 5, denominator: 1000});\n    }\n\n    function liquidationFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 45, denominator: 1000});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 100, denominator: 1000});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 125, denominator: 1000});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 150, denominator: 1000});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 175, denominator: 1000});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 200, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function keeperFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        AssetClass class = assetClass(_asset);\n        if (class == AssetClass.Stable) {\n            return float({numerator: 5, denominator: 1000});\n        } else if (class == AssetClass.Alpha) {\n            return float({numerator: 10, denominator: 1000});\n        } else if (class == AssetClass.Gamma) {\n            return float({numerator: 15, denominator: 1000});\n        } else if (class == AssetClass.Delta) {\n            return float({numerator: 20, denominator: 1000});\n        } else if (class == AssetClass.Zeta) {\n            return float({numerator: 25, denominator: 1000});\n        } else if (class == AssetClass.Sigma) {\n            return float({numerator: 30, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function maxFee(AssetClass _class) public pure returns (float memory) {\n        if (_class == AssetClass.Stable) {\n            return float({numerator: 10, denominator: 1000});\n        } else if (_class == AssetClass.Alpha) {\n            return float({numerator: 15, denominator: 1000});\n        } else if (_class == AssetClass.Gamma) {\n            return float({numerator: 20, denominator: 1000});\n        } else if (_class == AssetClass.Delta) {\n            return float({numerator: 21, denominator: 1000});\n        } else if (_class == AssetClass.Zeta) {\n            return float({numerator: 22, denominator: 1000});\n        } else if (_class == AssetClass.Sigma) {\n            return float({numerator: 23, denominator: 1000});\n        } else {\n            revert(\"invalid\");\n        }\n    }\n\n    function stabilityFee(address _asset)\n        public\n        view\n        override\n        returns (float memory)\n    {\n        float memory base = baseFee();\n        AssetClass class = assetClass(_asset);\n        float memory max = maxFee(class);\n        float memory u = utilizationRatio(_asset);\n        if (u.gt(float({numerator: 1, denominator: 1}))) {\n            return max;\n        }\n        return base.add(max.sub(base).mul(u));\n    }\n\n    function calculateFeeIndex(\n        address _asset,\n        uint256 _currentIndex,\n        uint256 _lastAccrued\n    ) external view override returns (uint256) {\n        float memory feePerYear = stabilityFee(_asset);\n        uint256 timePassed = block.timestamp - _lastAccrued;\n        float memory feeAccumulated = feePerYear.mul(\n            float({numerator: timePassed, denominator: secPerYear})\n        );\n        return _currentIndex + _currentIndex.multiply(feeAccumulated);\n    }\n\n    ///@dev returns utilization ratio scaled with 1e18\n    function utilizationRatio(address _asset)\n        public\n        view\n        override\n        returns (float memory ratio)\n    {\n        IMochiVault vault = engine.vaultFactory().getVault(_asset);\n        uint256 debts = vault.debts();\n        uint256 cap = creditCap[_asset];\n        return float({numerator: debts, denominator: cap});\n    }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-10-mochi#h-04-registerasset-can-overwrite-_assetclass-value",
	            "Location":"function registerAsset(address _asset) external { uint256 liq = engine.cssr().getLiquidity(_asset); require(liq >= liquidityRequirement, \"<liquidity\"); _register(_asset, AssetClass.Sigma);} in registerAsset function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.registerAsset() can overwrite _assetClass value,Everyone can call the function registerAsset() of MochiProfileV0.sol Assuming the liquidity for the asset is sufficient, registerAsset() will reset the _assetClass of an already registered asset to AssetClass.Sigma.When the _assetClass is changed to AssetClass.Sigma then liquidationFactor(), riskFactor(), maxCollateralFactor(), liquidationFee() keeperFee() maxFee() will also return a different value. Then the entire vault will behave differently. The threshold for liquidation will also be different, possibly leading to a liquidation that isn’t supposed to happen.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity ^0.8.4;\ncontract Vesting is Ownable, Pausable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    IERC20 public vestingToken;\n    address public multiSig;\n    uint256 public totalVestedAmount;\n    uint256 public totalClaimedAmount;\n    uint256 private unixYear = 52 * 7 * 24 * 60 * 60;\n\n    struct Timelock {\n        uint256 amount;\n        uint256 releaseTimestamp;\n    }\n\n    mapping(address => Timelock[]) public timelocks;\n    mapping(address => uint256) public benClaimed;  \n    mapping(address => uint256[2]) public benVested; \n    mapping(address => uint256) public benTotal;     \n    mapping(address => uint256) public benVestingIndex; \n    mapping(address => bool[2]) public benRevocable;         \n    event TokenVested(address indexed sender, uint256 amount, uint256 releaseTimestamp, uint256 currentTimestamp);\n    event TokenClaimed(address indexed beneficiary, uint256 amount, uint256 currentTimestamp);\n    event TokenRevoked(address indexed beneficiary, uint256 amount, uint256 currentTimestamp);\n    event Revoke(address indexed account, uint256 currentTimestamp);\n    constructor(\n        IERC20 _token,\n        address _multiSig\n    ) {\n        require(address(_token) != address(0) && address(_multiSig) != address(0), \"Invalid address\");\n        vestingToken = _token;\n        multiSig = _multiSig;\n\n        totalVestedAmount = 0;\n        totalClaimedAmount = 0;\n    }\n    function vest(address _beneficiary, uint256 _amount, uint256 _isRevocable) external payable whenNotPaused {\n        require(_beneficiary != address(0), \"Invalid address\");\n        require( _amount > 0, \"amount must be positive\");\n     \n        require(_isRevocable == 0 || _isRevocable == 1, \"revocable must be 0 or 1\");\n        uint256 _unlockTimestamp = block.timestamp.add(unixYear);\n\n        Timelock memory newVesting = Timelock(_amount, _unlockTimestamp);\n        timelocks[_beneficiary].push(newVesting);\n\n        if(_isRevocable == 0){\n            benRevocable[_beneficiary] = [false,false];\n        }\n        else if(_isRevocable == 1){\n            benRevocable[_beneficiary] = [true,false];\n        }\n\n        totalVestedAmount = totalVestedAmount.add(_amount);\n        benTotal[_beneficiary] = benTotal[_beneficiary].add(_amount);\n        vestingToken.transferFrom(msg.sender, address(this), _amount);\n\n        emit TokenVested(_beneficiary, _amount, _unlockTimestamp, block.timestamp);\n    }\n    function revoke(address _addr) public onlyOwner whenNotPaused {\n        require(benRevocable[_addr][0] == true && benRevocable[_addr][1] == false);\n\n        uint256 amount = _claimableAmount(_addr).sub(benClaimed[_addr]);\n        assert(amount <= benTotal[_addr]);\n    \n        benClaimed[_addr] = benClaimed[_addr].add(amount);\n        totalClaimedAmount = totalClaimedAmount.add(amount);\n\n        emit TokenClaimed(_addr, amount, block.timestamp);\n\n        uint256 locked = 0;\n        for (uint256 i = 0; i < timelocks[_addr].length; i++) {\n            locked = locked.add(timelocks[_addr][i].amount);\n        }\n        delete timelocks[_addr];\n\n        uint256 bal = locked.sub(benClaimed[_addr]);\n        benRevocable[_addr][1] = true;\n        emit Revoke(_addr, block.timestamp);\n        \n        //clean slate\n        benClaimed[_addr] = 0;\n        benVested[_addr] = [0, 0];\n        benTotal[_addr] = 0;\n        benVestingIndex[_addr] = 0;\n        \n        vestingToken.safeTransfer(_addr, amount); \n\n        if (bal > 0) {\n            vestingToken.safeTransfer(multiSig, bal); \n            emit TokenRevoked(_addr, bal, block.timestamp);\n        }\n    }\n    function calcClaimableAmount(address _addr) public view returns (uint256) {\n        uint256 sum = 0;\n        for (uint256 i = 0; i < timelocks[_addr].length; i++) {\n            if (block.timestamp >= timelocks[_addr][i].releaseTimestamp) {\n                sum = sum.add(timelocks[_addr][i].amount);\n            }\n            else {\n                uint256 iTimeStamp = timelocks[_addr][i].releaseTimestamp.sub(unixYear);\n                uint256 claimable = block.timestamp.sub(iTimeStamp).mul(timelocks[_addr][i].amount).div(unixYear);\n                sum = sum.add(claimable);\n            }\n        }\n        return sum;\n    }\n    function _claimableAmount(address _addr) private returns (uint256) {\n        uint256 completely_vested = 0;\n        uint256 partial_sum = 0;\n        uint256 inc = 0;\n\n        for (uint256 i = benVestingIndex[_addr]; i < timelocks[_addr].length; i++) {\n            if (block.timestamp >= timelocks[_addr][i].releaseTimestamp) {\n                inc += 1;\n                completely_vested = completely_vested.add(timelocks[_addr][i].amount);\n            }\n            else {\n                uint256 iTimeStamp = timelocks[_addr][i].releaseTimestamp.sub(unixYear);\n                uint256 claimable = block.timestamp.sub(iTimeStamp).mul(timelocks[_addr][i].amount).div(unixYear);\n                partial_sum = partial_sum.add(claimable);\n            }\n        }\n\n        benVestingIndex[_addr] +=inc;\n        benVested[_addr][0] = benVested[_addr][0].add(completely_vested);\n        benVested[_addr][1] = partial_sum;\n        uint256 s = benVested[_addr][0].add(partial_sum);\n        assert(s <= benTotal[_addr]);\n        return s;\n    }\n    function claim() external whenNotPaused nonReentrant {\n        require(benRevocable[msg.sender][1] == false);\n        uint256 amount = _claimableAmount(msg.sender).sub(benClaimed[msg.sender]);\n        require(amount > 0, \"Claimable amount must be positive\");\n        require(amount <= benTotal[msg.sender], \"Cannot withdraw more than total vested amount\");\n        benClaimed[msg.sender] = benClaimed[msg.sender].add(amount);\n        totalClaimedAmount = totalClaimedAmount.add(amount);\n        vestingToken.safeTransfer(msg.sender, amount);\n\n        emit TokenClaimed(msg.sender, amount, block.timestamp);\n    }\n\n    function pause() public onlyOwner whenNotPaused {\n        _pause();\n    }\n    function unpause() public onlyOwner whenPaused {\n        _unpause();\n    }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-11-bootfinance#h-08-unable-to-claim-vesting-due-to-unbounded-timelock-loop",
	            "Location":"timelocks[_beneficiary].push(newVesting); in vest function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Unable to claim vesting due to unbounded timelock loop,The timelocks for any beneficiary are unbounded, and can be vested by someone who is not the beneficiary. When the array becomes significantly big enough, the vestments will no longer be claimable for the beneficiary.The vest() function in Vesting.sol does not check the beneficiary, hence anyone can vest for anyone else, pushing a new timelock to the timelocks[_beneficiary]. The _claimableAmount() function (used by claim() function), then loops through the timelocks[_beneficiary] to determine the amount to be claimed. A malicious actor can easy repeatedly call the vest() function with minute amounts to make the array large enough, such that when it comes to claiming, it will exceed the gas limit and revert, rendering the vestment for the beneficiary unclaimable. The malicious actor could do this to each beneficiary, locking up all the vestments.",
	            "Repair":""
            },
            {
                "Name":"https://code4rena.com/reports/2021-11-bootfinance#h-08-unable-to-claim-vesting-due-to-unbounded-timelock-loop",
	            "Location":"uint256 amount = _claimableAmount(msg.sender).sub(benClaimed[msg.sender]); in claim function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Unable to claim vesting due to unbounded timelock loop,The timelocks for any beneficiary are unbounded, and can be vested by someone who is not the beneficiary. When the array becomes significantly big enough, the vestments will no longer be claimable for the beneficiary.The vest() function in Vesting.sol does not check the beneficiary, hence anyone can vest for anyone else, pushing a new timelock to the timelocks[_beneficiary]. The _claimableAmount() function (used by claim() function), then loops through the timelocks[_beneficiary] to determine the amount to be claimed. A malicious actor can easy repeatedly call the vest() function with minute amounts to make the array large enough, such that when it comes to claiming, it will exceed the gas limit and revert, rendering the vestment for the beneficiary unclaimable. The malicious actor could do this to each beneficiary, locking up all the vestments.",
	            "Repair":""
            },
            {
                "Name":"https://code4rena.com/reports/2021-11-bootfinance#h-08-unable-to-claim-vesting-due-to-unbounded-timelock-loop",
	            "Location":"for (uint256 i = 0; i < timelocks[_addr].length; i++)  in calcClaimableAmount function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Unable to claim vesting due to unbounded timelock loop,The timelocks for any beneficiary are unbounded, and can be vested by someone who is not the beneficiary. When the array becomes significantly big enough, the vestments will no longer be claimable for the beneficiary.The vest() function in Vesting.sol does not check the beneficiary, hence anyone can vest for anyone else, pushing a new timelock to the timelocks[_beneficiary]. The _claimableAmount() function (used by claim() function), then loops through the timelocks[_beneficiary] to determine the amount to be claimed. A malicious actor can easy repeatedly call the vest() function with minute amounts to make the array large enough, such that when it comes to claiming, it will exceed the gas limit and revert, rendering the vestment for the beneficiary unclaimable. The malicious actor could do this to each beneficiary, locking up all the vestments.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity =0.8.9;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BasePoolV2.sol\";\nimport \"../../interfaces/shared/IERC20Extended.sol\";\nimport \"../../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\nimport \"../../interfaces/dex-v2/wrapper/ILPWrapper.sol\";\nimport \"../../interfaces/dex-v2/synth/ISynthFactory.sol\";\n\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\n    using SafeERC20 for IERC20;\n    ILPWrapper public wrapper;\n    ISynthFactory public synthFactory;\n    bool public queueActive;\n\n\n\n    constructor(bool _queueActive, IERC20 _nativeAsset)\n        BasePoolV2(_nativeAsset)\n    {\n        queueActive = _queueActive;\n    }\n\n    function cumulativePrices(IERC20 foreignAsset)\n        public\n        view\n        returns (\n            uint256 price0CumulativeLast,\n            uint256 price1CumulativeLast,\n            uint32 blockTimestampLast\n        )\n    {\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\n            .priceCumulative;\n        price0CumulativeLast = priceCumulative.nativeLast;\n        price1CumulativeLast = priceCumulative.foreignLast;\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\n    }\n\n    function initialize(\n        ILPWrapper _wrapper,\n        ISynthFactory _synthFactory,\n        address _router\n    ) external onlyOwner {\n        require(\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Already initialized\"\n        );\n        require(\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\n        );\n        require(\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\n        );\n        require(\n            _router != _ZERO_ADDRESS,\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\n        );\n        wrapper = _wrapper;\n        synthFactory = _synthFactory;\n        router = _router;\n    }\n    function mintSynth(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        address from,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        supportedToken(foreignAsset)\n        returns (uint256 amountSynth)\n    {\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        if (synth == ISynth(_ZERO_ADDRESS))\n            synth = synthFactory.createSynth(\n                IERC20Extended(address(foreignAsset))\n            );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountSynth = VaderMath.calculateSwap(\n            nativeDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        synth.mint(to, amountSynth);\n    }\n\n    function burnSynth(\n        IERC20 foreignAsset,\n        uint256 synthAmount,\n        address to\n    ) external override nonReentrant returns (uint256 amountNative) {\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        require(\n            synth != ISynth(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\n        );\n\n        require(\n            synthAmount > 0,\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\n        );\n\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\n        synth.burn(synthAmount);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountNative = VaderMath.calculateSwap(\n            synthAmount,\n            reserveForeign,\n            reserveNative\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        nativeAsset.safeTransfer(to, amountNative);\n    }\n    function burn(uint256 id, address to)\n        external\n        override\n        onlyRouter\n        returns (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        )\n    {\n        (amountNative, amountForeign) = _burn(id, to);\n\n        Position storage position = positions[id];\n\n        uint256 creation = position.creation;\n        uint256 originalNative = position.originalNative;\n        uint256 originalForeign = position.originalForeign;\n\n        delete positions[id];\n\n        uint256 loss = VaderMath.calculateLoss(\n            originalNative,\n            originalForeign,\n            amountNative,\n            amountForeign\n        );\n\n        coveredLoss =\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /\n            _ONE_YEAR;\n    }\n\n    function mintFungible(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) external override nonReentrant returns (uint256 liquidity) {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 totalLiquidityUnits = pair.totalSupply;\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\n        );\n\n        pair.totalSupply = totalLiquidityUnits + liquidity;\n\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign + foreignDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        lp.mint(to, liquidity);\n\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\n    }\n\n    function burnFungible(\n        IERC20 foreignAsset,\n        uint256 liquidity,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\n        );\n\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\n        lp.burn(liquidity);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 _totalSupply = pair.totalSupply;\n        amountNative = (liquidity * reserveNative) / _totalSupply;\n        amountForeign = (liquidity * reserveForeign) / _totalSupply;\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\n        );\n\n        pair.totalSupply = _totalSupply - liquidity;\n\n        nativeAsset.safeTransfer(to, amountNative);\n        foreignAsset.safeTransfer(to, amountForeign);\n\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign - amountForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    function toggleQueue() external override onlyOwner {\n        bool _queueActive = !queueActive;\n        queueActive = _queueActive;\n        emit QueueActive(_queueActive);\n    }\n\n    function setTokenSupport(IERC20 foreignAsset, bool support)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            supported[foreignAsset] != support,\n            \"VaderPoolV2::supportToken: Already At Desired State\"\n        );\n        supported[foreignAsset] = support;\n    }\n\n    function setFungibleTokenSupport(IERC20 foreignAsset)\n        external\n        override\n        onlyOwner\n    {\n        wrapper.createWrapper(foreignAsset);\n    }\n\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-11-vader#h-21-lack-of-access-control-allow-attacker-to-mintfungible-and-mintsynth-with-other-users-wallet-balance",
	            "Location":"mintFungible function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Lack of access control allow attacker to mintFungible() and mintSynth() with other user’s wallet balance,This issue allows anyone to call mintFungible() and mintSynth() and steal almost all their wallet balances for all the users who have approved the contract before.",
	            "Repair":""
            }
            
        ]
    },
    {
	    "Code":"pragma solidity =0.8.9;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BasePoolV2.sol\";\nimport \"../../interfaces/shared/IERC20Extended.sol\";\nimport \"../../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\nimport \"../../interfaces/dex-v2/wrapper/ILPWrapper.sol\";\nimport \"../../interfaces/dex-v2/synth/ISynthFactory.sol\";\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\n\n    using SafeERC20 for IERC20;\n\n    ILPWrapper public wrapper;\n\n\n    ISynthFactory public synthFactory;\n\n    bool public queueActive;\n\n\n    constructor(bool _queueActive, IERC20 _nativeAsset)\n        BasePoolV2(_nativeAsset)\n    {\n        queueActive = _queueActive;\n    }\n    function cumulativePrices(IERC20 foreignAsset)\n        public\n        view\n        returns (\n            uint256 price0CumulativeLast,\n            uint256 price1CumulativeLast,\n            uint32 blockTimestampLast\n        )\n    {\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\n            .priceCumulative;\n        price0CumulativeLast = priceCumulative.nativeLast;\n        price1CumulativeLast = priceCumulative.foreignLast;\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\n    }\n    function initialize(\n        ILPWrapper _wrapper,\n        ISynthFactory _synthFactory,\n        address _router\n    ) external onlyOwner {\n        require(\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Already initialized\"\n        );\n        require(\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\n        );\n        require(\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\n        );\n        require(\n            _router != _ZERO_ADDRESS,\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\n        );\n        wrapper = _wrapper;\n        synthFactory = _synthFactory;\n        router = _router;\n    }\n    function mintSynth(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        address from,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        supportedToken(foreignAsset)\n        returns (uint256 amountSynth)\n    {\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        if (synth == ISynth(_ZERO_ADDRESS))\n            synth = synthFactory.createSynth(\n                IERC20Extended(address(foreignAsset))\n            );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountSynth = VaderMath.calculateSwap(\n            nativeDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        synth.mint(to, amountSynth);\n    }\n    function burnSynth(\n        IERC20 foreignAsset,\n        uint256 synthAmount,\n        address to\n    ) external override nonReentrant returns (uint256 amountNative) {\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        require(\n            synth != ISynth(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\n        );\n\n        require(\n            synthAmount > 0,\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\n        );\n\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\n        synth.burn(synthAmount);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountNative = VaderMath.calculateSwap(\n            synthAmount,\n            reserveForeign,\n            reserveNative\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        nativeAsset.safeTransfer(to, amountNative);\n    }\n    function burn(uint256 id, address to)\n        external\n        override\n        onlyRouter\n        returns (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        )\n    {\n        (amountNative, amountForeign) = _burn(id, to);\n\n        Position storage position = positions[id];\n\n        uint256 creation = position.creation;\n        uint256 originalNative = position.originalNative;\n        uint256 originalForeign = position.originalForeign;\n\n        delete positions[id];\n        uint256 loss = VaderMath.calculateLoss(\n            originalNative,\n            originalForeign,\n            amountNative,\n            amountForeign\n        );\n\n        // TODO: Original Implementation Applied 100 Days\n        coveredLoss =\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /\n            _ONE_YEAR;\n    }\n    function mintFungible(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) external override nonReentrant returns (uint256 liquidity) {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 totalLiquidityUnits = pair.totalSupply;\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\n        );\n\n        pair.totalSupply = totalLiquidityUnits + liquidity;\n\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign + foreignDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        lp.mint(to, liquidity);\n\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\n    }\n    function burnFungible(\n        IERC20 foreignAsset,\n        uint256 liquidity,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\n        );\n\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\n        lp.burn(liquidity);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 _totalSupply = pair.totalSupply;\n        amountNative = (liquidity * reserveNative) / _totalSupply;\n        amountForeign = (liquidity * reserveForeign) / _totalSupply;\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\n        );\n\n        pair.totalSupply = _totalSupply - liquidity;\n\n        nativeAsset.safeTransfer(to, amountNative);\n        foreignAsset.safeTransfer(to, amountForeign);\n\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign - amountForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n\n    function toggleQueue() external override onlyOwner {\n        bool _queueActive = !queueActive;\n        queueActive = _queueActive;\n        emit QueueActive(_queueActive);\n    }\n    function setTokenSupport(IERC20 foreignAsset, bool support)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            supported[foreignAsset] != support,\n            \"VaderPoolV2::supportToken: Already At Desired State\"\n        );\n        supported[foreignAsset] = support;\n    }\n\n    function setFungibleTokenSupport(IERC20 foreignAsset)\n        external\n        override\n        onlyOwner\n    {\n        wrapper.createWrapper(foreignAsset);\n    }\n\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-11-vader#h-21-lack-of-access-control-allow-attacker-to-mintfungible-and-mintsynth-with-other-users-wallet-balance",
	            "Location":"mintFungible function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Lack of access control allow attacker to mintFungible() and mintSynth() with other user’s wallet balance,This issue allows anyone to call mintFungible() and mintSynth() and steal almost all their wallet balances for all the users who have approved the contract before.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity =0.8.9;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./BasePoolV2.sol\";\nimport \"../../interfaces/shared/IERC20Extended.sol\";\nimport \"../../interfaces/dex-v2/pool/IVaderPoolV2.sol\";\nimport \"../../interfaces/dex-v2/wrapper/ILPWrapper.sol\";\nimport \"../../interfaces/dex-v2/synth/ISynthFactory.sol\";\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\n\n    using SafeERC20 for IERC20;\n    ILPWrapper public wrapper;\n    ISynthFactory public synthFactory;\n    bool public queueActive;\n\n    constructor(bool _queueActive, IERC20 _nativeAsset)\n        BasePoolV2(_nativeAsset)\n    {\n        queueActive = _queueActive;\n    }\n    function cumulativePrices(IERC20 foreignAsset)\n        public\n        view\n        returns (\n            uint256 price0CumulativeLast,\n            uint256 price1CumulativeLast,\n            uint32 blockTimestampLast\n        )\n    {\n        PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\n            .priceCumulative;\n        price0CumulativeLast = priceCumulative.nativeLast;\n        price1CumulativeLast = priceCumulative.foreignLast;\n        blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\n    }\n\n\n    function initialize(\n        ILPWrapper _wrapper,\n        ISynthFactory _synthFactory,\n        address _router\n    ) external onlyOwner {\n        require(\n            wrapper == ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Already initialized\"\n        );\n        require(\n            _wrapper != ILPWrapper(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\n        );\n        require(\n            _synthFactory != ISynthFactory(_ZERO_ADDRESS),\n            \"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\n        );\n        require(\n            _router != _ZERO_ADDRESS,\n            \"VaderPoolV2::initialize: Incorrect Router Specified\"\n        );\n        wrapper = _wrapper;\n        synthFactory = _synthFactory;\n        router = _router;\n    }\n\n    function mintSynth(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        address from,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        supportedToken(foreignAsset)\n        returns (uint256 amountSynth)\n    {\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        if (synth == ISynth(_ZERO_ADDRESS))\n            synth = synthFactory.createSynth(\n                IERC20Extended(address(foreignAsset))\n            );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); \n\n        amountSynth = VaderMath.calculateSwap(\n            nativeDeposit,\n            reserveNative,\n            reserveForeign\n        );\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        synth.mint(to, amountSynth);\n    }\n\n    function burnSynth(\n        IERC20 foreignAsset,\n        uint256 synthAmount,\n        address to\n    ) external override nonReentrant returns (uint256 amountNative) {\n        ISynth synth = synthFactory.synths(foreignAsset);\n\n        require(\n            synth != ISynth(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnSynth: Inexistent Synth\"\n        );\n\n        require(\n            synthAmount > 0,\n            \"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\n        );\n\n        IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\n        synth.burn(synthAmount);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        amountNative = VaderMath.calculateSwap(\n            synthAmount,\n            reserveForeign,\n            reserveNative\n        );\n\n        // TODO: Clarify\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        nativeAsset.safeTransfer(to, amountNative);\n    }\n\n    function burn(uint256 id, address to)\n        external\n        override\n        onlyRouter\n        returns (\n            uint256 amountNative,\n            uint256 amountForeign,\n            uint256 coveredLoss\n        )\n    {\n        (amountNative, amountForeign) = _burn(id, to);\n\n        Position storage position = positions[id];\n\n        uint256 creation = position.creation;\n        uint256 originalNative = position.originalNative;\n        uint256 originalForeign = position.originalForeign;\n\n        delete positions[id];\n\n        uint256 loss = VaderMath.calculateLoss(\n            originalNative,\n            originalForeign,\n            amountNative,\n            amountForeign\n        );\n        coveredLoss =\n            (loss * _min(block.timestamp - creation, _ONE_YEAR)) /\n            _ONE_YEAR;\n    }\n    function mintFungible(\n        IERC20 foreignAsset,\n        uint256 nativeDeposit,\n        uint256 foreignDeposit,\n        address from,\n        address to\n    ) external override nonReentrant returns (uint256 liquidity) {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::mintFungible: Unsupported Token\"\n        );\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n        foreignAsset.safeTransferFrom(from, address(this), foreignDeposit);\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 totalLiquidityUnits = pair.totalSupply;\n        if (totalLiquidityUnits == 0) liquidity = nativeDeposit;\n        else\n            liquidity = VaderMath.calculateLiquidityUnits(\n                nativeDeposit,\n                reserveNative,\n                foreignDeposit,\n                reserveForeign,\n                totalLiquidityUnits\n            );\n\n        require(\n            liquidity > 0,\n            \"VaderPoolV2::mintFungible: Insufficient Liquidity Provided\"\n        );\n\n        pair.totalSupply = totalLiquidityUnits + liquidity;\n\n        _update(\n            foreignAsset,\n            reserveNative + nativeDeposit,\n            reserveForeign + foreignDeposit,\n            reserveNative,\n            reserveForeign\n        );\n\n        lp.mint(to, liquidity);\n\n        emit Mint(from, to, nativeDeposit, foreignDeposit);\n    }\n    function burnFungible(\n        IERC20 foreignAsset,\n        uint256 liquidity,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 amountNative, uint256 amountForeign)\n    {\n        IERC20Extended lp = wrapper.tokens(foreignAsset);\n\n        require(\n            lp != IERC20Extended(_ZERO_ADDRESS),\n            \"VaderPoolV2::burnFungible: Unsupported Token\"\n        );\n\n        IERC20(lp).safeTransferFrom(msg.sender, address(this), liquidity);\n        lp.burn(liquidity);\n\n        (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\n            foreignAsset\n        ); // gas savings\n\n        PairInfo storage pair = pairInfo[foreignAsset];\n        uint256 _totalSupply = pair.totalSupply;\n        amountNative = (liquidity * reserveNative) / _totalSupply;\n        amountForeign = (liquidity * reserveForeign) / _totalSupply;\n\n        require(\n            amountNative > 0 && amountForeign > 0,\n            \"VaderPoolV2::burnFungible: Insufficient Liquidity Burned\"\n        );\n\n        pair.totalSupply = _totalSupply - liquidity;\n\n        nativeAsset.safeTransfer(to, amountNative);\n        foreignAsset.safeTransfer(to, amountForeign);\n\n        _update(\n            foreignAsset,\n            reserveNative - amountNative,\n            reserveForeign - amountForeign,\n            reserveNative,\n            reserveForeign\n        );\n\n        emit Burn(msg.sender, amountNative, amountForeign, to);\n    }\n    function toggleQueue() external override onlyOwner {\n        bool _queueActive = !queueActive;\n        queueActive = _queueActive;\n        emit QueueActive(_queueActive);\n    }\n    function setTokenSupport(IERC20 foreignAsset, bool support)\n        external\n        override\n        onlyOwner\n    {\n        require(\n            supported[foreignAsset] != support,\n            \"VaderPoolV2::supportToken: Already At Desired State\"\n        );\n        supported[foreignAsset] = support;\n    }\n    function setFungibleTokenSupport(IERC20 foreignAsset)\n        external\n        override\n        onlyOwner\n    {\n        wrapper.createWrapper(foreignAsset);\n    }\n\n    function _min(uint256 a, uint256 b) private pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-11-vader#h-26-all-user-assets-which-are-approved-to-vaderpoolv2-may-be-stolen",
	            "Location":"function mintFungible(IERC20 foreignAsset,uint256 nativeDeposit,uint256 foreignDeposit,address from,address to) external override nonReentrant returns (uint256 liquidity) in mintFungible function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.All user assets which are approved to VaderPoolV2 may be stolen,Total loss of funds which have been approved on VaderPoolV2",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity 0.8.6;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./libraries/ExtendedSafeCastLib.sol\";\nimport \"./libraries/TwabLib.sol\";\nimport \"./interfaces/ITicket.sol\";\nimport \"./ControlledToken.sol\";\n\n\ncontract Ticket is ControlledToken, ITicket {\n    using SafeERC20 for IERC20;\n    using ExtendedSafeCastLib for uint256;\n\n    \n    bytes32 private immutable _DELEGATE_TYPEHASH =\n        keccak256(\"Delegate(address user,address delegate,uint256 nonce,uint256 deadline)\");\n\n    mapping(address => TwabLib.Account) internal userTwabs;\n    TwabLib.Account internal totalSupplyTwab;\n    mapping(address => address) internal delegates;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 decimals_,\n        address _controller\n    ) ControlledToken(_name, _symbol, decimals_, _controller) {}\n\n    function getAccountDetails(address _user)\n        external\n        view\n        override\n        returns (TwabLib.AccountDetails memory)\n    {\n        return userTwabs[_user].details;\n    }\n    function getTwab(address _user, uint16 _index)\n        external\n        view\n        override\n        returns (ObservationLib.Observation memory)\n    {\n        return userTwabs[_user].twabs[_index];\n    }\n    function getBalanceAt(address _user, uint64 _target) external view override returns (uint256) {\n        TwabLib.Account storage account = userTwabs[_user];\n\n        return\n            TwabLib.getBalanceAt(\n                account.twabs,\n                account.details,\n                uint32(_target),\n                uint32(block.timestamp)\n            );\n    }\n    function getAverageBalancesBetween(\n        address _user,\n        uint64[] calldata _startTimes,\n        uint64[] calldata _endTimes\n    ) external view override returns (uint256[] memory) {\n        return _getAverageBalancesBetween(userTwabs[_user], _startTimes, _endTimes);\n    }\n    function getAverageTotalSuppliesBetween(\n        uint64[] calldata _startTimes,\n        uint64[] calldata _endTimes\n    ) external view override returns (uint256[] memory) {\n        return _getAverageBalancesBetween(totalSupplyTwab, _startTimes, _endTimes);\n    }\n    function getAverageBalanceBetween(\n        address _user,\n        uint64 _startTime,\n        uint64 _endTime\n    ) external view override returns (uint256) {\n        TwabLib.Account storage account = userTwabs[_user];\n\n        return\n            TwabLib.getAverageBalanceBetween(\n                account.twabs,\n                account.details,\n                uint32(_startTime),\n                uint32(_endTime),\n                uint32(block.timestamp)\n            );\n    }\n    function getBalancesAt(address _user, uint64[] calldata _targets)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256 length = _targets.length;\n        uint256[] memory _balances = new uint256[](length);\n\n        TwabLib.Account storage twabContext = userTwabs[_user];\n        TwabLib.AccountDetails memory details = twabContext.details;\n\n        for (uint256 i = 0; i < length; i++) {\n            _balances[i] = TwabLib.getBalanceAt(\n                twabContext.twabs,\n                details,\n                uint32(_targets[i]),\n                uint32(block.timestamp)\n            );\n        }\n\n        return _balances;\n    }\n    function getTotalSupplyAt(uint64 _target) external view override returns (uint256) {\n        return\n            TwabLib.getBalanceAt(\n                totalSupplyTwab.twabs,\n                totalSupplyTwab.details,\n                uint32(_target),\n                uint32(block.timestamp)\n            );\n    }\n    function getTotalSuppliesAt(uint64[] calldata _targets)\n        external\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256 length = _targets.length;\n        uint256[] memory totalSupplies = new uint256[](length);\n\n        TwabLib.AccountDetails memory details = totalSupplyTwab.details;\n\n        for (uint256 i = 0; i < length; i++) {\n            totalSupplies[i] = TwabLib.getBalanceAt(\n                totalSupplyTwab.twabs,\n                details,\n                uint32(_targets[i]),\n                uint32(block.timestamp)\n            );\n        }\n\n        return totalSupplies;\n    }\n\n    /// @inheritdoc ITicket\n    function delegateOf(address _user) external view override returns (address) {\n        return delegates[_user];\n    }\n\n    /// @inheritdoc ITicket\n    function controllerDelegateFor(address _user, address _to) external override onlyController {\n        _delegate(_user, _to);\n    }\n\n    /// @inheritdoc ITicket\n    function delegateWithSignature(\n        address _user,\n        address _newDelegate,\n        uint256 _deadline,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) external virtual override {\n        require(block.timestamp <= _deadline, \"Ticket/delegate-expired-deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_DELEGATE_TYPEHASH, _user, _newDelegate, _useNonce(_user), _deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, _v, _r, _s);\n        require(signer == _user, \"Ticket/delegate-invalid-signature\");\n\n        _delegate(_user, _newDelegate);\n    }\n\n    /// @inheritdoc ITicket\n    function delegate(address _to) external virtual override {\n        _delegate(msg.sender, _to);\n    }\n\n    function _delegate(address _user, address _to) internal {\n        uint256 balance = balanceOf(_user);\n        address currentDelegate = delegates[_user];\n\n        if (currentDelegate == _to) {\n            return;\n        }\n\n        delegates[_user] = _to;\n\n        _transferTwab(currentDelegate, _to, balance);\n\n        emit Delegated(_user, _to);\n    }\n\n    function _getAverageBalancesBetween(\n        TwabLib.Account storage _account,\n        uint64[] calldata _startTimes,\n        uint64[] calldata _endTimes\n    ) internal view returns (uint256[] memory) {\n        uint256 startTimesLength = _startTimes.length;\n        require(startTimesLength == _endTimes.length, \"Ticket/start-end-times-length-match\");\n\n        TwabLib.AccountDetails memory accountDetails = _account.details;\n\n        uint256[] memory averageBalances = new uint256[](startTimesLength);\n        uint32 currentTimestamp = uint32(block.timestamp);\n\n        for (uint256 i = 0; i < startTimesLength; i++) {\n            averageBalances[i] = TwabLib.getAverageBalanceBetween(\n                _account.twabs,\n                accountDetails,\n                uint32(_startTimes[i]),\n                uint32(_endTimes[i]),\n                currentTimestamp\n            );\n        }\n\n        return averageBalances;\n    }\n\n    // @inheritdoc ERC20\n    function _beforeTokenTransfer(address _from, address _to, uint256 _amount) internal override {\n        if (_from == _to) {\n            return;\n        }\n\n        address _fromDelegate;\n        if (_from != address(0)) {\n            _fromDelegate = delegates[_from];\n        }\n\n        address _toDelegate;\n        if (_to != address(0)) {\n            _toDelegate = delegates[_to];\n        }\n\n        _transferTwab(_fromDelegate, _toDelegate, _amount);\n    }\n\n    function _transferTwab(address _from, address _to, uint256 _amount) internal {\n        // If we are transferring tokens from a delegated account to an undelegated account\n        if (_from != address(0)) {\n            _decreaseUserTwab(_from, _amount);\n\n            if (_to == address(0)) {\n                _decreaseTotalSupplyTwab(_amount);\n            }\n        }\n\n        // If we are transferring tokens from an undelegated account to a delegated account\n        if (_to != address(0)) {\n            _increaseUserTwab(_to, _amount);\n\n            if (_from == address(0)) {\n                _increaseTotalSupplyTwab(_amount);\n            }\n        }\n    }\n\n    function _increaseUserTwab(\n        address _to,\n        uint256 _amount\n    ) internal {\n        if (_amount == 0) {\n            return;\n        }\n\n        TwabLib.Account storage _account = userTwabs[_to];\n\n        (\n            TwabLib.AccountDetails memory accountDetails,\n            ObservationLib.Observation memory twab,\n            bool isNew\n        ) = TwabLib.increaseBalance(_account, _amount.toUint208(), uint32(block.timestamp));\n\n        _account.details = accountDetails;\n\n        if (isNew) {\n            emit NewUserTwab(_to, twab);\n        }\n    }\n\n    function _decreaseUserTwab(\n        address _to,\n        uint256 _amount\n    ) internal {\n        if (_amount == 0) {\n            return;\n        }\n\n        TwabLib.Account storage _account = userTwabs[_to];\n\n        (\n            TwabLib.AccountDetails memory accountDetails,\n            ObservationLib.Observation memory twab,\n            bool isNew\n        ) = TwabLib.decreaseBalance(\n                _account,\n                _amount.toUint208(),\n                \"Ticket/twab-burn-lt-balance\",\n                uint32(block.timestamp)\n            );\n\n        _account.details = accountDetails;\n\n        if (isNew) {\n            emit NewUserTwab(_to, twab);\n        }\n    }\n\n    function _decreaseTotalSupplyTwab(uint256 _amount) internal {\n        if (_amount == 0) {\n            return;\n        }\n\n        (\n            TwabLib.AccountDetails memory accountDetails,\n            ObservationLib.Observation memory tsTwab,\n            bool tsIsNew\n        ) = TwabLib.decreaseBalance(\n                totalSupplyTwab,\n                _amount.toUint208(),\n                \"Ticket/burn-amount-exceeds-total-supply-twab\",\n                uint32(block.timestamp)\n            );\n\n        totalSupplyTwab.details = accountDetails;\n\n        if (tsIsNew) {\n            emit NewTotalSupplyTwab(tsTwab);\n        }\n    }\n\n\n    function _increaseTotalSupplyTwab(uint256 _amount) internal {\n        if (_amount == 0) {\n            return;\n        }\n\n        (\n            TwabLib.AccountDetails memory accountDetails,\n            ObservationLib.Observation memory _totalSupply,\n            bool tsIsNew\n        ) = TwabLib.increaseBalance(totalSupplyTwab, _amount.toUint208(), uint32(block.timestamp));\n\n        totalSupplyTwab.details = accountDetails;\n\n        if (tsIsNew) {\n            emit NewTotalSupplyTwab(_totalSupply);\n        }\n    }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2021-12-pooltogether#h-05-malicious-tickets-can-lead-to-the-loss-of-all-tokens",
	            "Location":"function getAverageTotalSuppliesBetween(    uint64[] calldata _startTimes,   uint64[] calldata _endTimes) external view override returns (uint256[] memory) {uint256[] memory _balances = new uint256[](1); _balances[0] = uint256(1);return _balances;} in getAverageTotalSuppliesBetween function",
	            "Type":"ID-related violations",
	            "Description":"Shared resource (e.g., token) without proper locks.Malicious tickets can lead to the loss of all tokens,It allows an attacker to retrieve all the tokens of each promotions.",
	            "Repair":""
            },
            {
                "Name":"https://code4rena.com/reports/2021-12-pooltogether#h-05-malicious-tickets-can-lead-to-the-loss-of-all-tokens",
	            "Location":"function getAverageBalanceBetween(address _user,uint64 _startTime,uint64 _endTimea) external view override returns (uint256) {return 1337;} in getAverageBalanceBetween function",
	            "Type":"ID-related violations",
	            "Description":"Shared resource (e.g., token) without proper locks.Malicious tickets can lead to the loss of all tokens,It allows an attacker to retrieve all the tokens of each promotions.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity 0.8.7;\nimport \"./interfaces/IOwnership.sol\";\nimport \"./interfaces/IUniversalMarket.sol\";\nimport \"./interfaces/IRegistry.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Factory is IFactory {\n    event MarketCreated(\n        address indexed market,\n        address indexed template,\n        string _metaData,\n        uint256[] conditions,\n        address[] references\n    );\n    event TemplateApproval(\n        IUniversalMarket indexed template,\n        bool approval,\n        bool isOpen,\n        bool duplicate\n    );\n    event ReferenceApproval(\n        IUniversalMarket indexed template,\n        uint256 indexed slot,\n        address target,\n        bool approval\n    );\n    event ConditionApproval(\n        IUniversalMarket indexed template,\n        uint256 indexed slot,\n        uint256 target\n    );\n\n    address[] public markets;\n\n    struct Template {\n        bool isOpen;\n        bool approval; \n        bool allowDuplicate; \n    }\n    mapping(address => Template) public templates;\n    mapping(address => mapping(uint256 => mapping(address => bool)))\n        public reflist;\n    mapping(address => mapping(uint256 => uint256)) public conditionlist;\n    address public registry;\n    IOwnership public ownership;\n\n    modifier onlyOwner() {\n        require(\n            ownership.owner() == msg.sender,\n            \"Restricted: caller is not allowed to operate\"\n        );\n        _;\n    }\n\n    constructor(address _registry, address _ownership) {\n        registry = _registry;\n        ownership = IOwnership(_ownership);\n    }\n    function approveTemplate(\n        IUniversalMarket _template,\n        bool _approval,\n        bool _isOpen,\n        bool _duplicate\n    ) external override onlyOwner {\n        require(address(_template) != address(0));\n        templates[address(_template)].approval = _approval;\n        templates[address(_template)].isOpen = _isOpen;\n        templates[address(_template)].allowDuplicate = _duplicate;\n        emit TemplateApproval(_template, _approval, _isOpen, _duplicate);\n    }\n    function approveReference(\n        IUniversalMarket _template,\n        uint256 _slot,\n        address _target,\n        bool _approval\n    ) external override onlyOwner {\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        reflist[address(_template)][_slot][_target] = _approval;\n        emit ReferenceApproval(_template, _slot, _target, _approval);\n    \n\n    function setCondition(\n        IUniversalMarket _template,\n        uint256 _slot,\n        uint256 _target\n    ) external override onlyOwner {\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        conditionlist[address(_template)][_slot] = _target;\n        emit ConditionApproval(_template, _slot, _target);\n    }\n    function createMarket(\n        IUniversalMarket _template,\n        string memory _metaData,\n        uint256[] memory _conditions,\n        address[] memory _references\n    ) public override returns (address) {\n        //check eligibility\n        require(\n            templates[address(_template)].approval == true,\n            \"ERROR: UNAUTHORIZED_TEMPLATE\"\n        );\n        if (templates[address(_template)].isOpen == false) {\n            require(\n                ownership.owner() == msg.sender,\n                \"ERROR: UNAUTHORIZED_SENDER\"\n            );\n        }\n        if (_references.length > 0) {\n            for (uint256 i = 0; i < _references.length; i++) {\n                require(\n                    reflist[address(_template)][i][_references[i]] == true ||\n                        reflist[address(_template)][i][address(0)] == true,\n                    \"ERROR: UNAUTHORIZED_REFERENCE\"\n                );\n            }\n        }\n\n        if (_conditions.length > 0) {\n            for (uint256 i = 0; i < _conditions.length; i++) {\n                if (conditionlist[address(_template)][i] > 0) {\n                    _conditions[i] = conditionlist[address(_template)][i];\n                }\n            }\n        }\n\n        if (\n            IRegistry(registry).confirmExistence(\n                address(_template),\n                _references[0]\n            ) == false\n        ) {\n            IRegistry(registry).setExistence(\n                address(_template),\n                _references[0]\n            );\n        } else {\n            if (templates[address(_template)].allowDuplicate == false) {\n                revert(\"ERROR: DUPLICATE_MARKET\");\n            }\n        }\n\n        //create market\n        IUniversalMarket market = IUniversalMarket(\n            _createClone(address(_template))\n        );\n\n        IRegistry(registry).supportMarket(address(market));\n        \n        markets.push(address(market));\n\n\n        //initialize\n        market.initialize(_metaData, _conditions, _references);\n\n        emit MarketCreated(\n            address(market),\n            address(_template),\n            _metaData,\n            _conditions,\n            _references\n        );\n\n        return address(market);\n    }\n\n    function _createClone(address target) internal returns (address result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(\n                clone,\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\n            )\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            result := create(0, clone, 0x37)\n        }\n    }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-01-insure#h-03-malicious-market-creators-can-steal-tokens-from-unsuspecting-approved-reference-accounts",
	            "Location":"createMarket function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Malicious Market Creators Can Steal Tokens From Unsuspecting Approved Reference Accounts,The current method of market creation involves calling Factory.createMarket() with a list of approved _conditions and _references accounts. If a registered template address has templates[address(_template)].isOpen == true, then any user is able to call createMarket() using this template. If the template points to PoolTemplate.sol, then a malicious market creator can abuse PoolTemplate.initialize() as it makes a vault deposit from an account that they control. The vulnerable internal function, _depositFrom(), makes a vault deposit from the _references[4] address (arbitrarily set to an approved reference address upon market creation).Hence, if approved _references accounts have set an unlimited approval amount for Vault.sol before deploying their market, a malicious user can frontrun market creation and cause these tokens to be transferred to the incorrect market.This issue can cause honest market creators to have their tokens transferred to an incorrectly configured market, leading to unrecoverable funds. If their approval to Vault.sol was set to the unlimited amount, malicious users will also be able to force honest market creators to transfer more tokens than they would normally want to allow.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity 0.8.7;\nimport "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";\nimport "./InsureDAOERC20.sol";\nimport "./interfaces/IPoolTemplate.sol";\nimport "./interfaces/IUniversalMarket.sol";\nimport "./interfaces/IParameters.sol";\nimport "./interfaces/IVault.sol";\nimport "./interfaces/IRegistry.sol";\nimport "./interfaces/IIndexTemplate.sol";\ncontract PoolTemplate is InsureDAOERC20, IPoolTemplate, IUniversalMarket {\n\n    event Deposit(address indexed depositor, uint256 amount, uint256 mint);\n    event WithdrawRequested(\n        address indexed withdrawer,\n        uint256 amount,\n        uint256 time\n    );\n    event Withdraw(address indexed withdrawer, uint256 amount, uint256 retVal);\n    event Unlocked(uint256 indexed id, uint256 amount);\n    event Insured(\n        uint256 indexed id,\n        uint256 amount,\n        bytes32 target,\n        uint256 startTime,\n        uint256 endTime,\n        address insured,\n        uint256 premium\n    );\n    event Redeemed(\n        uint256 indexed id,\n        address insured,\n        bytes32 target,\n        uint256 amount,\n        uint256 payout\n    );\n    event CoverApplied(\n        uint256 pending,\n        uint256 payoutNumerator,\n        uint256 payoutDenominator,\n        uint256 incidentTimestamp,\n        bytes32 merkleRoot,\n        string rawdata,\n        string memo\n    );\n    event TransferInsurance(uint256 indexed id, address from, address to);\n    event CreditIncrease(address indexed depositor, uint256 credit);\n    event CreditDecrease(address indexed withdrawer, uint256 credit);\n    event MarketStatusChanged(MarketStatus statusValue);\n    event Paused(bool paused);\n    event MetadataChanged(string metadata);\n\n    bool public initialized;\n    bool public override paused;\n    string public metadata;\n\n    IParameters public parameters;\n    IRegistry public registry;\n    IVault public vault;\n\n    uint256 public attributionDebt; \n    uint256 public override lockedAmount; \n    uint256 public override totalCredit; \n    uint256 public rewardPerCredit; \n    uint256 public pendingEnd; \n    struct IndexInfo {\n        uint256 credit;\n        uint256 rewardDebt;\n        bool exist; \n    }\n\n    mapping(address => IndexInfo) public indicies;\n    address[] public indexList;\n    enum MarketStatus {\n        Trading,\n        Payingout\n    }\n    MarketStatus public marketStatus;\n\n    struct Withdrawal {\n        uint256 timestamp;\n        uint256 amount;\n    }\n    mapping(address => Withdrawal) public withdrawalReq;\n\n    struct Insurance {\n        uint256 id; \n        uint256 startTime; \n        uint256 endTime; \n        uint256 amount; \n        bytes32 target; \n        address insured; \n        bool status; \n    }\n    mapping(uint256 => Insurance) public insurances;\n    uint256 public allInsuranceCount;\n    struct Incident {\n        uint256 payoutNumerator;\n        uint256 payoutDenominator;\n        uint256 incidentTimestamp;\n        bytes32 merkleRoot;\n    }\n    Incident public incident;\n\n    uint256 public constant MAGIC_SCALE_1E6 = 1e6; \n    modifier onlyOwner() {\n        require(\n            msg.sender == parameters.getOwner(),\n            "Restricted: caller is not allowed to operate"\n        );\n        _;\n    }\n\n    constructor() {\n        initialized = true;\n    }\n    function initialize(\n        string calldata _metaData,\n        uint256[] calldata _conditions,\n        address[] calldata _references\n    ) external override {\n        require(\n            initialized == false &&\n                bytes(_metaData).length > 0 &&\n                _references[0] != address(0) &&\n                _references[1] != address(0) &&\n                _references[2] != address(0) &&\n                _references[3] != address(0) &&\n                _references[4] != address(0) &&\n                _conditions[0] <= _conditions[1],\n            "ERROR: INITIALIZATION_BAD_CONDITIONS"\n        );\n        initialized = true;\n\n        string memory _name = string(\n            abi.encodePacked(\n                "InsureDAO-",\n                IERC20Metadata(_references[1]).name(),\n                "-PoolInsurance"\n            )\n        );\n        string memory _symbol = string(\n            abi.encodePacked("i-", IERC20Metadata(_references[1]).symbol())\n        );\n        uint8 _decimals = IERC20Metadata(_references[0]).decimals();\n\n        initializeToken(_name, _symbol, _decimals);\n\n        registry = IRegistry(_references[2]);\n        parameters = IParameters(_references[3]);\n        vault = IVault(parameters.getVault(_references[1]));\n\n        metadata = _metaData;\n\n        marketStatus = MarketStatus.Trading;\n\n        if (_conditions[1] > 0) {\n            _depositFrom(_conditions[1], _references[4]);\n        }\n    }\n    function deposit(uint256 _amount) public returns (uint256 _mintAmount) {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            "ERROR: DEPOSIT_DISABLED"\n        );\n        require(_amount > 0, "ERROR: DEPOSIT_ZERO");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, msg.sender, address(this));\n\n        emit Deposit(msg.sender, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(msg.sender, _mintAmount);\n    }\n    function _depositFrom(uint256 _amount, address _from)\n        internal\n        returns (uint256 _mintAmount)\n    {\n        require(\n            marketStatus == MarketStatus.Trading && paused == false,\n            "ERROR: DEPOSIT_DISABLED"\n        );\n        require(_amount > 0, "ERROR: DEPOSIT_ZERO");\n\n        _mintAmount = worth(_amount);\n\n        vault.addValue(_amount, _from, address(this));\n\n        emit Deposit(_from, _amount, _mintAmount);\n\n        //mint iToken\n        _mint(_from, _mintAmount);\n    }\n    function requestWithdraw(uint256 _amount) external {\n        uint256 _balance = balanceOf(msg.sender);\n        require(_balance >= _amount, "ERROR: REQUEST_EXCEED_BALANCE");\n        require(_amount > 0, "ERROR: REQUEST_ZERO");\n        withdrawalReq[msg.sender].timestamp = block.timestamp;\n        withdrawalReq[msg.sender].amount = _amount;\n        emit WithdrawRequested(msg.sender, _amount, block.timestamp);\n    }\n    function withdraw(uint256 _amount) external returns (uint256 _retVal) {\n        uint256 _supply = totalSupply();\n        require(_supply != 0, "ERROR: NO_AVAILABLE_LIQUIDITY");\n\n        uint256 _liquidity = originalLiquidity();\n        _retVal = (_amount * _liquidity) / _supply;\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            "ERROR: WITHDRAWAL_PENDING"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) <\n                block.timestamp,\n            "ERROR: WITHDRAWAL_QUEUE"\n        );\n        require(\n            withdrawalReq[msg.sender].timestamp +\n                parameters.getLockup(msg.sender) +\n                parameters.getWithdrawable(msg.sender) >\n                block.timestamp,\n            "ERROR: WITHDRAWAL_NO_ACTIVE_REQUEST"\n        );\n        require(\n            withdrawalReq[msg.sender].amount >= _amount,\n            "ERROR: WITHDRAWAL_EXCEEDED_REQUEST"\n        );\n        require(_amount > 0, "ERROR: WITHDRAWAL_ZERO");\n        require(\n            _retVal <= availableBalance(),\n            "ERROR: WITHDRAW_INSUFFICIENT_LIQUIDITY"\n        );\n        withdrawalReq[msg.sender].amount -= _amount;\n        _burn(msg.sender, _amount);\n        vault.withdrawValue(_retVal, msg.sender);\n\n        emit Withdraw(msg.sender, _amount, _retVal);\n    }\n    function unlockBatch(uint256[] calldata _ids) external {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            unlock(_ids[i]);\n        }\n    }\n    function unlock(uint256 _id) public {\n        require(\n            insurances[_id].status == true &&\n                marketStatus == MarketStatus.Trading &&\n                insurances[_id].endTime + parameters.getGrace(msg.sender) <\n                block.timestamp,\n            "ERROR: UNLOCK_BAD_COINDITIONS"\n        );\n        insurances[_id].status == false;\n\n        lockedAmount = lockedAmount - insurances[_id].amount;\n\n        emit Unlocked(_id, insurances[_id].amount);\n    }\n\n    function allocateCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        require(\n            IRegistry(registry).isListed(msg.sender),\n            "ERROR: ALLOCATE_CREDIT_BAD_CONDITIONS"\n        );\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        if (_index.exist == false) {\n            _index.exist = true;\n            indexList.push(msg.sender);\n        } else if (_index.credit > 0) {\n            _pending = _sub(\n                (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n                _index.rewardDebt\n            );\n            if (_pending > 0) {\n                vault.transferAttribution(_pending, msg.sender);\n                attributionDebt -= _pending;\n            }\n        }\n        if (_credit > 0) {\n            totalCredit += _credit;\n            _index.credit += _credit;\n            emit CreditIncrease(msg.sender, _credit);\n        }\n        _index.rewardDebt =\n            (_index.credit * _rewardPerCredit) /\n            MAGIC_SCALE_1E6;\n    }\n    function withdrawCredit(uint256 _credit)\n        external\n        override\n        returns (uint256 _pending)\n    {\n        IndexInfo storage _index = indicies[msg.sender];\n        uint256 _rewardPerCredit = rewardPerCredit;\n        require(\n            IRegistry(registry).isListed(msg.sender) &&\n                _index.credit >= _credit &&\n                _credit <= availableBalance(),\n            "ERROR: WITHDRAW_CREDIT_BAD_CONDITIONS"\n        );\n\n        //calculate acrrued premium\n        _pending = _sub(\n            (_index.credit * _rewardPerCredit) / MAGIC_SCALE_1E6,\n            _index.rewardDebt\n        );\n\n        //Withdraw liquidity\n        if (_credit > 0) {\n            totalCredit -= _credit;\n            _index.credit -= _credit;\n            emit CreditDecrease(msg.sender, _credit);\n        }\n\n        //withdraw acrrued premium\n        if (_pending > 0) {\n            vault.transferAttribution(_pending, msg.sender);\n            attributionDebt -= _pending;\n            _index.rewardDebt =\n                (_index.credit * _rewardPerCredit) /\n                MAGIC_SCALE_1E6;\n        }\n    }\n    function insure(\n        uint256 _amount,\n        uint256 _maxCost,\n        uint256 _span,\n        bytes32 _target\n    ) external returns (uint256) {\n        //Distribute premium and fee\n        uint256 _endTime = _span + block.timestamp;\n        uint256 _premium = getPremium(_amount, _span);\n        uint256 _fee = parameters.getFeeRate(msg.sender);\n\n        require(\n            _amount <= availableBalance(),\n            "ERROR: INSURE_EXCEEDED_AVAILABLE_BALANCE"\n        );\n        require(_premium <= _maxCost, "ERROR: INSURE_EXCEEDED_MAX_COST");\n        require(_span <= 365 days, "ERROR: INSURE_EXCEEDED_MAX_SPAN");\n        require(\n            parameters.getMinDate(msg.sender) <= _span,\n            "ERROR: INSURE_SPAN_BELOW_MIN"\n        );\n\n        require(\n            marketStatus == MarketStatus.Trading,\n            "ERROR: INSURE_MARKET_PENDING"\n        );\n        require(paused == false, "ERROR: INSURE_MARKET_PAUSED");\n        uint256 _liquidity = totalLiquidity();\n        uint256 _totalCredit = totalCredit;\n        uint256[2] memory _newAttribution = vault.addValueBatch(\n            _premium,\n            msg.sender,\n            [address(this), parameters.getOwner()],\n            [MAGIC_SCALE_1E6 - _fee, _fee]\n        );\n        uint256 _id = allInsuranceCount;\n        lockedAmount += _amount;\n        Insurance memory _insurance = Insurance(\n            _id,\n            block.timestamp,\n            _endTime,\n            _amount,\n            _target,\n            msg.sender,\n            true\n        );\n        insurances[_id] = _insurance;\n        allInsuranceCount += 1;\n        if (_totalCredit > 0) {\n            uint256 _attributionForIndex = (_newAttribution[0] * _totalCredit) /\n                _liquidity;\n            attributionDebt += _attributionForIndex;\n            rewardPerCredit += ((_attributionForIndex * MAGIC_SCALE_1E6) /\n                _totalCredit);\n        }\n\n        emit Insured(\n            _id,\n            _amount,\n            _target,\n            block.timestamp,\n            _endTime,\n            msg.sender,\n            _premium\n        );\n\n        return _id;\n    }\n    function redeem(uint256 _id, bytes32[] calldata _merkleProof) external {\n        Insurance storage _insurance = insurances[_id];\n        require(_insurance.status == true, "ERROR: INSURANCE_NOT_ACTIVE");\n\n        uint256 _payoutNumerator = incident.payoutNumerator;\n        uint256 _payoutDenominator = incident.payoutDenominator;\n        uint256 _incidentTimestamp = incident.incidentTimestamp;\n        bytes32 _targets = incident.merkleRoot;\n\n        require(\n            marketStatus == MarketStatus.Payingout,\n            "ERROR: NO_APPLICABLE_INCIDENT"\n        );\n        require(_insurance.insured == msg.sender, "ERROR: NOT_YOUR_INSURANCE");\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                _insurance.startTime <= _incidentTimestamp &&\n                _insurance.endTime >= _incidentTimestamp,\n            "ERROR: INSURANCE_NOT_APPLICABLE"\n        );\n        require(\n            MerkleProof.verify(\n                _merkleProof,\n                _targets,\n                keccak256(\n                    abi.encodePacked(_insurance.target, _insurance.insured)\n                )\n            ) ||\n                MerkleProof.verify(\n                    _merkleProof,\n                    _targets,\n                    keccak256(abi.encodePacked(_insurance.target, address(0)))\n                ),\n            "ERROR: INSURANCE_EXEMPTED"\n        );\n        _insurance.status = false;\n        lockedAmount -= _insurance.amount;\n\n        uint256 _payoutAmount = (_insurance.amount * _payoutNumerator) /\n            _payoutDenominator;\n\n        vault.borrowValue(_payoutAmount, msg.sender);\n\n        emit Redeemed(\n            _id,\n            msg.sender,\n            _insurance.target,\n            _insurance.amount,\n            _payoutAmount\n        );\n    }\n    function transferInsurance(uint256 _id, address _to) external {\n        Insurance storage insurance = insurances[_id];\n\n        require(\n            _to != address(0) &&\n                insurance.insured == msg.sender &&\n                insurance.endTime >= block.timestamp &&\n                insurance.status == true,\n            "ERROR: INSURANCE_TRANSFER_BAD_CONDITIONS"\n        );\n\n        insurance.insured = _to;\n        emit TransferInsurance(_id, msg.sender, _to);\n    }\n    function getPremium(uint256 _amount, uint256 _span)\n        public\n        view\n        returns (uint256 premium)\n    {\n        return\n            parameters.getPremium(\n                _amount,\n                _span,\n                totalLiquidity(),\n                lockedAmount,\n                address(this)\n            );\n    }\n    function applyCover(\n        uint256 _pending,\n        uint256 _payoutNumerator,\n        uint256 _payoutDenominator,\n        uint256 _incidentTimestamp,\n        bytes32 _merkleRoot,\n        string calldata _rawdata,\n        string calldata _memo\n    ) external override onlyOwner {\n        require(paused == false, "ERROR: UNABLE_TO_APPLY");\n        incident.payoutNumerator = _payoutNumerator;\n        incident.payoutDenominator = _payoutDenominator;\n        incident.incidentTimestamp = _incidentTimestamp;\n        incident.merkleRoot = _merkleRoot;\n        marketStatus = MarketStatus.Payingout;\n        pendingEnd = block.timestamp + _pending;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            if (indicies[indexList[i]].credit > 0) {\n                IIndexTemplate(indexList[i]).lock();\n            }\n        }\n        emit CoverApplied(\n            _pending,\n            _payoutNumerator,\n            _payoutDenominator,\n            _incidentTimestamp,\n            _merkleRoot,\n            _rawdata,\n            _memo\n        );\n        emit MarketStatusChanged(marketStatus);\n    }\n    function resume() external {\n        require(\n            marketStatus == MarketStatus.Payingout &&\n                pendingEnd < block.timestamp,\n            "ERROR: UNABLE_TO_RESUME"\n        );\n\n        uint256 _debt = vault.debts(address(this));\n        uint256 _totalCredit = totalCredit;\n        uint256 _deductionFromIndex = (_debt * _totalCredit * MAGIC_SCALE_1E6) /\n            totalLiquidity();\n        uint256 _actualDeduction;\n        for (uint256 i = 0; i < indexList.length; i++) {\n            address _index = indexList[i];\n            uint256 _credit = indicies[_index].credit;\n            if (_credit > 0) {\n                uint256 _shareOfIndex = (_credit * MAGIC_SCALE_1E6) /\n                    _totalCredit;\n                uint256 _redeemAmount = _divCeil(\n                    _deductionFromIndex,\n                    _shareOfIndex\n                );\n                _actualDeduction += IIndexTemplate(_index).compensate(\n                    _redeemAmount\n                );\n            }\n        }\n\n        uint256 _deductionFromPool = _debt -\n            _deductionFromIndex /\n            MAGIC_SCALE_1E6;\n        uint256 _shortage = _deductionFromIndex /\n            MAGIC_SCALE_1E6 -\n            _actualDeduction;\n\n        if (_deductionFromPool > 0) {\n            vault.offsetDebt(_deductionFromPool, address(this));\n        }\n\n        vault.transferDebt(_shortage);\n\n        marketStatus = MarketStatus.Trading;\n        emit MarketStatusChanged(MarketStatus.Trading);\n    }\n    function rate() external view returns (uint256) {\n        if (totalSupply() > 0) {\n            return (originalLiquidity() * MAGIC_SCALE_1E6) / totalSupply();\n        } else {\n            return 0;\n        }\n    }\n    function valueOfUnderlying(address _owner)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _balance = balanceOf(_owner);\n        if (_balance == 0) {\n            return 0;\n        } else {\n            return (_balance * originalLiquidity()) / totalSupply();\n        }\n    }\n    function pendingPremium(address _index)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        uint256 _credit = indicies[_index].credit;\n        if (_credit == 0) {\n            return 0;\n        } else {\n            return\n                _sub(\n                    (_credit * rewardPerCredit) / MAGIC_SCALE_1E6,\n                    indicies[_index].rewardDebt\n                );\n        }\n    }\n    function worth(uint256 _value) public view returns (uint256 _amount) {\n        uint256 _supply = totalSupply();\n        uint256 _originalLiquidity = originalLiquidity();\n        if (_supply > 0 && _originalLiquidity > 0) {\n            _amount = (_value * _supply) / _originalLiquidity;\n        } else if (_supply > 0 && _originalLiquidity == 0) {\n            _amount = _value * _supply;\n        } else {\n            _amount = _value;\n        }\n    }\n    function allocatedCredit(address _index)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return indicies[_index].credit;\n    }\n    function availableBalance()\n        public\n        view\n        override\n        returns (uint256 _balance)\n    {\n        if (totalLiquidity() > 0) {\n            return totalLiquidity() - lockedAmount;\n        } else {\n            return 0;\n        }\n    }\n    function utilizationRate() public view override returns (uint256 _rate) {\n        if (lockedAmount > 0) {\n            return (lockedAmount * MAGIC_SCALE_1E6) / totalLiquidity();\n        } else {\n            return 0;\n        }\n    }\n    function totalLiquidity() public view override returns (uint256 _balance) {\n        return originalLiquidity() + totalCredit;\n    }\n\n    function originalLiquidity() public view returns (uint256 _balance) {\n        return\n            vault.underlyingValue(address(this)) -\n            vault.attributionValue(attributionDebt);\n    }\n    function setPaused(bool _state) external override onlyOwner {\n        if (paused != _state) {\n            paused = _state;\n            emit Paused(_state);\n        }\n    }\n    function changeMetadata(string calldata _metadata)\n        external\n        override\n        onlyOwner\n    {\n        metadata = _metadata;\n        emit MetadataChanged(_metadata);\n    }\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0)) {\n            uint256 _after = balanceOf(from) - amount;\n            if (_after < withdrawalReq[from].amount) {\n                withdrawalReq[from].amount = _after;\n            }\n        }\n    }\n    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0);\n        uint256 c = a / b;\n        if (a % b != 0) c = c + 1;\n        return c;\n    }\n    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a < b) {\n            return 0;\n        } else {\n            return a - b;\n        }\n    }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-01-insure#h-03-malicious-market-creators-can-steal-tokens-from-unsuspecting-approved-reference-accounts",
	            "Location":"initialize function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Malicious Market Creators Can Steal Tokens From Unsuspecting Approved Reference Accounts,The current method of market creation involves calling Factory.createMarket() with a list of approved _conditions and _references accounts. If a registered template address has templates[address(_template)].isOpen == true, then any user is able to call createMarket() using this template. If the template points to PoolTemplate.sol, then a malicious market creator can abuse PoolTemplate.initialize() as it makes a vault deposit from an account that they control. The vulnerable internal function, _depositFrom(), makes a vault deposit from the _references[4] address (arbitrarily set to an approved reference address upon market creation).Hence, if approved _references accounts have set an unlimited approval amount for Vault.sol before deploying their market, a malicious user can frontrun market creation and cause these tokens to be transferred to the incorrect market.This issue can cause honest market creators to have their tokens transferred to an incorrectly configured market, leading to unrecoverable funds. If their approval to Vault.sol was set to the unlimited amount, malicious users will also be able to force honest market creators to transfer more tokens than they would normally want to allow.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity =0.7.6;\npragma abicoder v2;\nimport \"@openzeppelin-0.7/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin-0.7/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./ActionGuards.sol\";\nimport \"./math/SafeInt256.sol\";\nimport \"./stubs/BalanceHandler.sol\";\nimport \"./stubs/TokenHandler.sol\";\nimport \"./global/StorageLayoutV2.sol\";\nimport \"./global/Constants.sol\";\nimport \"interfaces/notional/NotionalTreasury.sol\";\nimport \"interfaces/compound/ComptrollerInterface.sol\";\nimport \"interfaces/compound/CErc20Interface.sol\";\nimport {WETH9_07 as WETH9} from \"interfaces/WETH9_07.sol\";\ncontract TreasuryAction is StorageLayoutV2, ActionGuards, NotionalTreasury {\n    using SafeMath for uint256;\n    using SafeInt256 for int256;\n    using SafeERC20 for IERC20;\n    using TokenHandler for Token;\n\n    IERC20 public immutable COMP;\n    Comptroller public immutable COMPTROLLER;\n    WETH9 public immutable WETH;\n    event TreasuryManagerChanged(address indexed previousManager, address indexed newManager);\n    event ReserveBufferUpdated(uint16 currencyId, uint256 bufferAmount);\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n    modifier onlyManagerContract() {\n        require(treasuryManagerContract == msg.sender, \"Caller is not the treasury manager\");\n        _;\n    }\n    function _checkValidCurrency(uint16 currencyId) internal view {\n        require(0 < currencyId && currencyId <= maxCurrencyId, \"Invalid currency id\");\n    }\n\n    constructor(Comptroller _comptroller, WETH9 _weth) {\n        COMPTROLLER = _comptroller;\n        COMP = IERC20(_comptroller.getCompAddress());\n        WETH = _weth;\n    }\n    function setTreasuryManager(address manager) external override onlyOwner {\n        emit TreasuryManagerChanged(treasuryManagerContract, manager);\n        treasuryManagerContract = manager;\n    }\n    function setReserveBuffer(uint16 currencyId, uint256 bufferAmount)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        reserveBuffer[currencyId] = bufferAmount;\n        emit ReserveBufferUpdated(currencyId, bufferAmount);\n    }\n    function setReserveCashBalance(uint16 currencyId, int256 newBalance)\n        external\n        override\n        onlyOwner\n    {\n        _checkValidCurrency(currencyId);\n        (int256 reserveBalance) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n        require(newBalance < reserveBalance, \"cannot increase reserve balance\");\n\n        BalanceHandler.setReserveCashBalance(currencyId, newBalance);\n    }\n    function claimCOMPAndTransfer(address[] calldata cTokens)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256)\n    {\n        uint256 balanceBefore = COMP.balanceOf(address(this));\n        COMPTROLLER.claimComp(address(this), cTokens);\n        uint256 balanceAfter = COMP.balanceOf(address(this));\n        uint256 amountClaimed = balanceAfter.sub(balanceBefore);\n        COMP.safeTransfer(treasuryManagerContract, amountClaimed);\n        return amountClaimed;\n    }\n    function _redeemAndTransfer(\n        uint16 currencyId,\n        Token memory asset,\n        int256 assetInternalRedeemAmount\n    ) private returns (uint256) {\n        Token memory underlying = TokenHandler.getUnderlyingToken(currencyId);\n        int256 assetExternalRedeemAmount = asset.convertToExternal(assetInternalRedeemAmount);\n        uint256 redeemedExternalUnderlying = asset\n            .redeem(underlying, assetExternalRedeemAmount.toUint())\n            .toUint();\n        if (underlying.tokenAddress == address(0)) {\n            WETH9(WETH).deposit{value: address(this).balance}();\n        }\n\n        address underlyingAddress = underlying.tokenAddress == address(0)\n            ? address(WETH)\n            : underlying.tokenAddress;\n        IERC20(underlyingAddress).safeTransfer(treasuryManagerContract, redeemedExternalUnderlying);\n\n        return redeemedExternalUnderlying;\n    }\n    function transferReserveToTreasury(uint16[] calldata currencies)\n        external\n        override\n        onlyManagerContract\n        nonReentrant\n        returns (uint256[] memory)\n    {\n        uint256[] memory amountsTransferred = new uint256[](currencies.length);\n\n        for (uint256 i; i < currencies.length; i++) {\n            if (i > 0) require(currencies[i] > currencies[i - 1], \"IDs must be sorted\");\n\n            uint16 currencyId = currencies[i];\n\n            _checkValidCurrency(currencyId);\n            int256 bufferInternal = SafeInt256.toInt(reserveBuffer[currencyId]);\n            if (bufferInternal == 0) continue;\n            (int256 reserveInternal, , , ) = BalanceHandler.getBalanceStorage(Constants.RESERVE, currencyId);\n\n            if (reserveInternal <= bufferInternal) continue;\n\n            Token memory asset = TokenHandler.getAssetToken(currencyId);\n\n            int256 assetInternalRedeemAmount = reserveInternal.subNoNeg(bufferInternal);\n\n            amountsTransferred[i] = _redeemAndTransfer(\n                currencyId,\n                asset,\n                assetInternalRedeemAmount\n            );\n            BalanceHandler.harvestExcessReserveBalance(\n                currencyId,\n                reserveInternal,\n                assetInternalRedeemAmount\n            );\n        }\n        return amountsTransferred;\n    }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-01-notional#h-01-treasury-cannot-claim-comp-tokens--comp-tokens-are-stuck",
	            "Location":"claimCOMPAndTransfer function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Treasury cannot claim COMP tokens & COMP tokens are stuck,The TreasuryAction.claimCOMPAndTransfer function uses pre- and post-balances of the COMP token to check which ones to transfer.Note that anyone can claim COMP tokens on behalf of any address (see Comptroller.claimComp). An attacker can claim COMP tokens on behalf of the contract and it’ll never be able to claim any compound itself. The COMP claimed by the attacker are stuck in the contract and cannot be retrieved. (One can eventually get back the stuck COMP by creating a cCOMP market and then transferring it through transferReserveToTreasury.)",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity ^0.8.11;\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"./external/ConvexInterfaces.sol\";\nimport \"./interfaces/IConcurRewardClaim.sol\";\nimport \"./interfaces/IShelterClient.sol\";\nimport \"./interfaces/IShelter.sol\";\nimport \"./MasterChef.sol\";\n\ncontract ConvexStakingWrapper is Ownable, ReentrancyGuard, Pausable, IShelterClient {\n    using SafeERC20 for IERC20;\n\n    struct RewardType {\n        address token;\n        address pool;\n        uint128 integral;\n        uint128 remaining;\n    }\n\n    struct Reward {\n        uint128 integral;\n    }\n    address public constant convexBooster =\n        address(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n    address public constant crv =\n        address(0xD533a949740bb3306d119CC777fa900bA034cd52);\n    address public constant cvx =\n        address(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);\n\n    uint256 public constant CRV_INDEX = 0;\n    uint256 public constant CVX_INDEX = 1;\n    uint256 public constant VOTECYCLE_START = 1645002000; //Feb 16 2022 09:00:00 GMT+0000\n    MasterChef public immutable masterChef;\n\n    //convex rewards\n    mapping(uint256 => address) public convexPool;\n    mapping(uint256 => RewardType[]) public rewards;\n    mapping(uint256 => mapping(uint256 => mapping(address => Reward)))\n        public userReward;\n    mapping(uint256 => mapping(address => uint256)) public registeredRewards;\n    mapping(IERC20 => uint256) public amountInShelter;\n\n    //management\n    address public treasury;\n    IShelter public shelter;\n    IConcurRewardClaim public claimContract;\n\n    struct Deposit {\n        uint64 epoch;\n        uint192 amount;\n    }\n\n    struct WithdrawRequest {\n        uint64 epoch;\n        uint192 amount;\n    }\n\n    mapping(address => uint256) public pids;\n    mapping(uint256 => mapping(address => Deposit)) public deposits;\n    mapping(uint256 => mapping(address => WithdrawRequest)) public withdrawRequest;\n\n    event Deposited(address indexed _user, uint256 _amount);\n    event Withdrawn(address indexed _user, uint256 _amount);\n\n    modifier whenNotInShelter(uint256 _pid) {\n        IERC20 lpToken = IERC20(\n            IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n        );\n        require(shelter.activated(lpToken) == 0, \"shelter activated\");\n        _;\n    }\n\n    constructor(address _treasury, MasterChef _masterChef) {\n        treasury = _treasury;\n        masterChef = _masterChef;\n    }\n\n    function setShelter(IShelter _shelter) external onlyOwner {\n        require(address(shelter) == address(0), \"shelter cannot be changed\");\n        shelter = _shelter;\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function changeTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n    }\n\n    function setRewardPool(address _claimContract) external onlyOwner {\n        claimContract = IConcurRewardClaim(_claimContract);\n    }\n\n    function enterShelter(uint256[] calldata _pids) external onlyOwner {\n        for(uint256 i = 0; i<_pids.length; i++){\n            IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);\n            uint256 amount = pool.balanceOf(address(this));\n            pool.withdrawAndUnwrap(amount, false);\n            IERC20 lpToken = IERC20(\n                pool.poolInfo(_pids[i]).lptoken\n            );\n            amountInShelter[lpToken] = amount;\n            lpToken.safeTransfer(address(shelter), amount);\n            shelter.activate(lpToken);\n        }\n    }\n\n    function exitShelter(uint256[] calldata _pids) external onlyOwner {\n        for(uint256 i = 0; i<_pids.length; i++){\n            IRewardStaking pool = IRewardStaking(convexPool[_pids[i]]);\n            IERC20 lpToken = IERC20(\n                pool.poolInfo(_pids[i]).lptoken\n            );\n            amountInShelter[lpToken] = 0;\n            shelter.deactivate(lpToken);\n        }\n    }\n\n    function totalShare(IERC20 _token) external view override returns(uint256) {\n        // this will be zero if shelter is not activated\n        return amountInShelter[_token];\n    }\n\n    function shareOf(IERC20 _token, address _user) external view override returns(uint256) {\n        uint256 pid = pids[address(_token)];\n        return uint256(deposits[pid][_user].amount);\n    }\n    function addRewards(uint256 _pid) public {\n        address mainPool = IRewardStaking(convexBooster)\n            .poolInfo(_pid)\n            .crvRewards;\n        if (rewards[_pid].length == 0) {\n            pids[IRewardStaking(convexBooster).poolInfo(_pid).lptoken] = _pid;\n            convexPool[_pid] = mainPool;\n            rewards[_pid].push(\n                RewardType({\n                    token: crv,\n                    pool: mainPool,\n                    integral: 0,\n                    remaining: 0\n                })\n            );\n            rewards[_pid].push(\n                RewardType({\n                    token: cvx,\n                    pool: address(0),\n                    integral: 0,\n                    remaining: 0\n                })\n            );\n            registeredRewards[_pid][crv] = CRV_INDEX + 1; //mark registered at index+1\n            registeredRewards[_pid][cvx] = CVX_INDEX + 1; //mark registered at index+1\n        }\n\n        uint256 extraCount = IRewardStaking(mainPool).extraRewardsLength();\n        for (uint256 i = 0; i < extraCount; i++) {\n            address extraPool = IRewardStaking(mainPool).extraRewards(i);\n            address extraToken = IRewardStaking(extraPool).rewardToken();\n            if (extraToken == cvx) {\n                //no-op for cvx, crv rewards\n                rewards[_pid][CVX_INDEX].pool = extraPool;\n            } else if (registeredRewards[_pid][extraToken] == 0) {\n                //add new token to list\n                rewards[_pid].push(\n                    RewardType({\n                        token: IRewardStaking(extraPool).rewardToken(),\n                        pool: extraPool,\n                        integral: 0,\n                        remaining: 0\n                    })\n                );\n                registeredRewards[_pid][extraToken] = rewards[_pid].length; //mark registered at index+1\n            }\n        }\n    }\n\n    function rewardLength(uint256 _pid) external view returns (uint256) {\n        return rewards[_pid].length;\n    }\n\n    function _getDepositedBalance(uint256 _pid, address _account)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return deposits[_pid][_account].amount;\n    }\n\n    function _getTotalSupply(uint256 _pid)\n        internal\n        view\n        virtual\n        returns (uint256)\n    {\n        return IRewardStaking(convexPool[_pid]).balanceOf(address(this));\n    }\n\n    function _calcRewardIntegral(\n        uint256 _pid,\n        uint256 _index,\n        address _account,\n        uint256 _balance,\n        uint256 _supply\n    ) internal {\n        RewardType memory reward = rewards[_pid][_index];\n        uint256 bal = IERC20(reward.token).balanceOf(address(this));\n        uint256 d_reward = bal - reward.remaining;\n        // send 20 % of cvx / crv reward to treasury\n        if (reward.token == cvx || reward.token == crv) {\n            IERC20(reward.token).transfer(treasury, d_reward / 5);\n            d_reward = (d_reward * 4) / 5;\n        }\n        IERC20(reward.token).transfer(address(claimContract), d_reward);\n\n        if (_supply > 0 && d_reward > 0) {\n            reward.integral =\n                reward.integral +\n                uint128((d_reward * 1e20) / _supply);\n        }\n        uint256 userI = userReward[_pid][_index][_account].integral;\n        if (userI < reward.integral) {\n            userReward[_pid][_index][_account].integral = reward.integral;\n            claimContract.pushReward(\n                _account,\n                reward.token,\n                (_balance * (reward.integral - userI)) / 1e20\n            );\n        }\n        if (bal != reward.remaining) {\n            reward.remaining = uint128(bal);\n        }\n\n        rewards[_pid][_index] = reward;\n    }\n\n    function _checkpoint(uint256 _pid, address _account) internal {\n        if (paused()) return;\n\n        uint256 supply = _getTotalSupply(_pid);\n        uint256 depositedBalance = _getDepositedBalance(_pid, _account);\n\n        IRewardStaking(convexPool[_pid]).getReward(address(this), true);\n\n        uint256 rewardCount = rewards[_pid].length;\n        for (uint256 i = 0; i < rewardCount; i++) {\n            _calcRewardIntegral(_pid, i, _account, depositedBalance, supply);\n        }\n    }\n    function deposit(uint256 _pid, uint256 _amount)\n        external\n        whenNotPaused\n        whenNotInShelter(_pid)\n        nonReentrant\n    {\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].epoch = currentEpoch();\n        deposits[_pid][msg.sender].amount += uint192(_amount);\n        if (_amount > 0) {\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n\n            lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n            lpToken.safeApprove(convexBooster, _amount);\n            IConvexDeposits(convexBooster).deposit(_pid, _amount, true);\n            lpToken.safeApprove(convexBooster, 0);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.deposit(msg.sender, pid, _amount);\n        }\n\n        emit Deposited(msg.sender, _amount);\n    }\n    function withdraw(uint256 _pid, uint256 _amount)\n        external\n        nonReentrant\n        whenNotInShelter(_pid)\n    {\n        WithdrawRequest memory request = withdrawRequest[_pid][msg.sender];\n        require(request.epoch < currentEpoch() && deposits[_pid][msg.sender].epoch + 1 < currentEpoch(), \"wait\");\n        require(request.amount >= _amount, \"too much\");\n        _checkpoint(_pid, msg.sender);\n        deposits[_pid][msg.sender].amount -= uint192(_amount);\n        if (_amount > 0) {\n            IRewardStaking(convexPool[_pid]).withdrawAndUnwrap(_amount, false);\n            IERC20 lpToken = IERC20(\n                IRewardStaking(convexPool[_pid]).poolInfo(_pid).lptoken\n            );\n            lpToken.safeTransfer(msg.sender, _amount);\n            uint256 pid = masterChef.pid(address(lpToken));\n            masterChef.withdraw(msg.sender, pid, _amount);\n        }\n        delete withdrawRequest[_pid][msg.sender];\n        //events\n        emit Withdrawn(msg.sender, _amount);\n    }\n    function currentEpoch() public view returns(uint64) {\n        return uint64((block.timestamp - VOTECYCLE_START) / 2 weeks) + 1;\n    }\n    function requestWithdraw(uint256 _pid, uint256 _amount) external {\n        require(_amount <= uint256(deposits[_pid][msg.sender].amount), \"too much\");\n        withdrawRequest[_pid][msg.sender] = WithdrawRequest({\n            epoch : currentEpoch(),\n            amount : uint192(_amount)\n        });\n    }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-02-concur#h-11-convexstakingwrapper_calcrewardintegral-can-be-manipulated-to-steal-tokens-from-other-pools",
	            "Location":"_calcRewardIntegral function",
	            "Type":"ID-related violations",
	            "Description":"Shared resource (e.g., token) without proper locks.ConvexStakingWrapper._calcRewardIntegral() Can Be Manipulated To Steal Tokens From Other Pools,The ConvexStakingWrapper.sol implementation makes several modifications to the original design. One of the key changes is the ability to add multiple pools into the wrapper contract, where each pool is represented by a unique _pid. By doing this, we are able to aggregate pools and their LP tokens to simplify the token distribution process.However, the interdependence between pools introduces new problems. Because the original implementation uses the contract’s reward token balance to track newly claimed tokens, it is possible for a malicious user to abuse the unguarded getReward function to maximise the profit they are able to generate. By calling getReward on multiple pools with the same reward token (i.e. cvx), users are able to siphon rewards from other pools. This inevitably leads to certain loss of rewards for users who have deposited LP tokens into these victim pools. As crv and cvx are reward tokens by default, it is very likely that someone will want to exploit this issue.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../libraries/AccountMigrationLibrary.sol\";\nimport \"./Constants.sol\";\nimport \"./FoundationTreasuryNode.sol\";\nimport \"./NFTMarketAuction.sol\";\nimport \"./NFTMarketCore.sol\";\nimport \"./NFTMarketFees.sol\";\nimport \"./SendValueWithFallbackWithdraw.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\n\nerror NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(uint256 minAmount);\nerror NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();\n\nerror NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(uint256 reservePrice);\n\nerror NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(uint256 endTime);\nerror NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();\nerror NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();\nerror NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();\n\nerror NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(uint256 endTime);\n\nerror NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(address seller);\nerror NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();\nerror NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\n\nerror NFTMarketReserveAuction_Exceeds_Max_Duration(uint256 maxDuration);\n\nerror NFTMarketReserveAuction_Less_Than_Extension_Duration(uint256 extensionDuration);\nerror NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();\n\nerror NFTMarketReserveAuction_Not_Matching_Seller(address seller);\n\nerror NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(address owner);\nerror NFTMarketReserveAuction_Too_Much_Value_Provided();\n\n\nabstract contract NFTMarketReserveAuction is\n  Constants,\n  FoundationTreasuryNode,\n  NFTMarketCore,\n  ReentrancyGuardUpgradeable,\n  SendValueWithFallbackWithdraw,\n  NFTMarketFees,\n  NFTMarketAuction\n{\n  using AccountMigrationLibrary for address;\n\n  struct ReserveAuction {\n\n    address nftContract;\n\n    uint256 tokenId;\n\n    address payable seller;\n\n    uint256 duration;\n\n    uint256 extensionDuration;\n\n    uint256 endTime;\n\n    address payable bidder;\n\n    uint256 amount;\n  }\n\n  mapping(address => mapping(uint256 => uint256)) private nftContractToTokenIdToAuctionId;\n\n  mapping(uint256 => ReserveAuction) private auctionIdToAuction;\n\n  uint256[5] private __gap_was_config;\n\n\n  uint256 private immutable DURATION;\n\n  uint256 private constant EXTENSION_DURATION = 15 minutes;\n\n  uint256 private constant MAX_MAX_DURATION = 1000 days;\n\n  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);\n\n  event ReserveAuctionCanceled(uint256 indexed auctionId);\n\n  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);\n\n  event ReserveAuctionCreated(\n    address indexed seller,\n    address indexed nftContract,\n    uint256 indexed tokenId,\n    uint256 duration,\n    uint256 extensionDuration,\n    uint256 reservePrice,\n    uint256 auctionId\n  );\n\n  event ReserveAuctionFinalized(\n    uint256 indexed auctionId,\n    address indexed seller,\n    address indexed bidder,\n    uint256 f8nFee,\n    uint256 creatorFee,\n    uint256 ownerRev\n  );\n\n  event ReserveAuctionInvalidated(uint256 indexed auctionId);\n\n  event ReserveAuctionSellerMigrated(\n    uint256 indexed auctionId,\n    address indexed originalSellerAddress,\n    address indexed newSellerAddress\n  );\n  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);\n\n  /// @notice Confirms that the reserve price is not zero.\n  modifier onlyValidAuctionConfig(uint256 reservePrice) {\n    if (reservePrice == 0) {\n      revert NFTMarketReserveAuction_Must_Set_Non_Zero_Reserve_Price();\n    }\n    _;\n  }\n  constructor(uint256 duration) {\n    if (duration > MAX_MAX_DURATION) {\n      // This ensures that math in this file will not overflow due to a huge duration.\n      revert NFTMarketReserveAuction_Exceeds_Max_Duration(MAX_MAX_DURATION);\n    }\n    if (duration < EXTENSION_DURATION) {\n      // The auction duration configuration must be greater than the extension window of 15 minutes\n      revert NFTMarketReserveAuction_Less_Than_Extension_Duration(EXTENSION_DURATION);\n    }\n    DURATION = duration;\n  }\n  function adminCancelReserveAuction(uint256 auctionId, string calldata reason)\n    external\n    onlyFoundationAdmin\n    nonReentrant\n  {\n    if (bytes(reason).length == 0) {\n      revert NFTMarketReserveAuction_Cannot_Admin_Cancel_Without_Reason();\n    }\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\n    if (auction.amount == 0) {\n      revert NFTMarketReserveAuction_Cannot_Cancel_Nonexistent_Auction();\n    }\n\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\n    delete auctionIdToAuction[auctionId];\n\n    // Return the NFT to the owner.\n    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);\n\n    if (auction.bidder != address(0)) {\n      // Refund the highest bidder if any bids were placed in this auction.\n      _sendValueWithFallbackWithdraw(auction.bidder, auction.amount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n    }\n\n    emit ReserveAuctionCanceledByAdmin(auctionId, reason);\n  }\n  function adminAccountMigration(\n    uint256[] calldata listedAuctionIds,\n    address originalAddress,\n    address payable newAddress,\n    bytes memory signature\n  ) external onlyFoundationOperator {\n\n    originalAddress.requireAuthorizedAccountMigration(newAddress, signature);\n\n    unchecked {\n      for (uint256 i = 0; i < listedAuctionIds.length; ++i) {\n        uint256 auctionId = listedAuctionIds[i];\n        ReserveAuction storage auction = auctionIdToAuction[auctionId];\n        if (auction.seller != address(0)) {\n\n          if (auction.seller != originalAddress) {\n            revert NFTMarketReserveAuction_Cannot_Migrate_Non_Matching_Seller(auction.seller);\n          }\n\n          auction.seller = newAddress;\n\n          emit ReserveAuctionSellerMigrated(auctionId, originalAddress, newAddress);\n        }\n      }\n    }\n  }\n  function cancelReserveAuction(uint256 auctionId) external nonReentrant {\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\n    if (auction.seller != msg.sender) {\n      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);\n    }\n    if (auction.endTime != 0) {\n      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\n    }\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\n    delete auctionIdToAuction[auctionId];\n    _transferFromEscrowIfAvailable(auction.nftContract, auction.tokenId, auction.seller);\n\n    emit ReserveAuctionCanceled(auctionId);\n  }\n  function createReserveAuction(\n    address nftContract,\n    uint256 tokenId,\n    uint256 reservePrice\n  ) external nonReentrant onlyValidAuctionConfig(reservePrice) {\n    uint256 auctionId = _getNextAndIncrementAuctionId();\n\n    // If the `msg.sender` is not the owner of the NFT, transferring into escrow should fail.\n    _transferToEscrow(nftContract, tokenId);\n\n    // Store the auction details\n    nftContractToTokenIdToAuctionId[nftContract][tokenId] = auctionId;\n    auctionIdToAuction[auctionId] = ReserveAuction(\n      nftContract,\n      tokenId,\n      payable(msg.sender),\n      DURATION,\n      EXTENSION_DURATION,\n      0, // endTime is only known once the reserve price is met\n      payable(0), // bidder is only known once a bid has been placed\n      reservePrice\n    );\n\n    emit ReserveAuctionCreated(msg.sender, nftContract, tokenId, DURATION, EXTENSION_DURATION, reservePrice, auctionId);\n  }\n  function finalizeReserveAuction(uint256 auctionId) external nonReentrant {\n    if (auctionIdToAuction[auctionId].endTime == 0) {\n      revert NFTMarketReserveAuction_Cannot_Finalize_Already_Settled_Auction();\n    }\n    _finalizeReserveAuction(auctionId, false);\n  }\n  function placeBid(uint256 auctionId) external payable {\n    placeBidOf(auctionId, msg.value);\n  }\n  function placeBidOf(uint256 auctionId, uint256 amount) public payable nonReentrant {\n    if (amount < msg.value) {\n      revert NFTMarketReserveAuction_Too_Much_Value_Provided();\n    } else if (amount > msg.value) {\n      unchecked {\n        uint256 delta = amount - msg.value;\n        feth.marketWithdrawFrom(msg.sender, delta);\n      }\n    }\n\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n\n    if (auction.amount == 0) {\n      revert NFTMarketReserveAuction_Cannot_Bid_On_Nonexistent_Auction();\n    }\n\n    if (auction.endTime == 0) {\n\n      if (auction.amount > amount) {\n\n        revert NFTMarketReserveAuction_Cannot_Bid_Lower_Than_Reserve_Price(auction.amount);\n      }\n      _afterAuctionStarted(auction.nftContract, auction.tokenId);\n      auction.amount = amount;\n      auction.bidder = payable(msg.sender);\n      unchecked {\n        auction.endTime = block.timestamp + auction.duration;\n      }\n    } else {\n      if (auction.endTime < block.timestamp) {\n        revert NFTMarketReserveAuction_Cannot_Bid_On_Ended_Auction(auction.endTime);\n      } else if (auction.bidder == msg.sender) {\n        revert NFTMarketReserveAuction_Cannot_Rebid_Over_Outstanding_Bid();\n      } else if (amount < _getMinIncrement(auction.amount)) {\n        revert NFTMarketReserveAuction_Bid_Must_Be_At_Least_Min_Amount(_getMinIncrement(auction.amount));\n      }\n      uint256 originalAmount = auction.amount;\n      address payable originalBidder = auction.bidder;\n      auction.amount = amount;\n      auction.bidder = payable(msg.sender);\n\n      unchecked {\n        if (auction.endTime - block.timestamp < auction.extensionDuration) {\n          auction.endTime = block.timestamp + auction.extensionDuration;\n        }\n      }\n      _sendValueWithFallbackWithdraw(originalBidder, originalAmount, SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT);\n    }\n\n    emit ReserveAuctionBidPlaced(auctionId, msg.sender, amount, auction.endTime);\n  }\n  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) external onlyValidAuctionConfig(reservePrice) {\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n    if (auction.seller != msg.sender) {\n      revert NFTMarketReserveAuction_Only_Owner_Can_Update_Auction(auction.seller);\n    } else if (auction.endTime != 0) {\n      revert NFTMarketReserveAuction_Cannot_Update_Auction_In_Progress();\n    }\n\n    auction.amount = reservePrice;\n\n    emit ReserveAuctionUpdated(auctionId, reservePrice);\n  }\n  function _finalizeReserveAuction(uint256 auctionId, bool keepInEscrow) private {\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\n\n    if (auction.endTime >= block.timestamp) {\n      revert NFTMarketReserveAuction_Cannot_Finalize_Auction_In_Progress(auction.endTime);\n    }\n    delete nftContractToTokenIdToAuctionId[auction.nftContract][auction.tokenId];\n    delete auctionIdToAuction[auctionId];\n\n    if (!keepInEscrow) {\n      NFTMarketCore._transferFromEscrow(auction.nftContract, auction.tokenId, auction.bidder, address(0));\n    }\n    (uint256 f8nFee, uint256 creatorFee, uint256 ownerRev) = _distributeFunds(\n      auction.nftContract,\n      auction.tokenId,\n      auction.seller,\n      auction.amount\n    );\n\n    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, f8nFee, creatorFee, ownerRev);\n  }\n  function _transferFromEscrow(\n    address nftContract,\n    uint256 tokenId,\n    address recipient,\n    address seller\n  ) internal virtual override {\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\n    if (auctionId != 0) {\n      ReserveAuction storage auction = auctionIdToAuction[auctionId];\n      if (auction.endTime == 0) {\n        if (auction.seller != seller) {\n          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);\n        }\n        delete nftContractToTokenIdToAuctionId[nftContract][tokenId];\n        delete auctionIdToAuction[auctionId];\n\n        emit ReserveAuctionInvalidated(auctionId);\n      } else {\n        if (auction.bidder != seller) {\n          revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);\n        }\n        _finalizeReserveAuction(auctionId, false);\n        return;\n      }\n    }\n\n    super._transferFromEscrow(nftContract, tokenId, recipient, seller);\n  }\n  function _transferFromEscrowIfAvailable(\n    address nftContract,\n    uint256 tokenId,\n    address recipient\n  ) internal virtual override {\n    if (nftContractToTokenIdToAuctionId[nftContract][tokenId] == 0) {\n      super._transferFromEscrowIfAvailable(nftContract, tokenId, recipient);\n    }\n  }\n  function _transferToEscrow(address nftContract, uint256 tokenId) internal virtual override {\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\n    if (auctionId == 0) {\n      super._transferToEscrow(nftContract, tokenId);\n      return;\n    }\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n    if (auction.endTime == 0) {\n      if (auction.seller != msg.sender) {\n        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);\n      }\n    } else {\n      if (auction.bidder != msg.sender) {\n        revert NFTMarketReserveAuction_Not_Matching_Seller(auction.bidder);\n      }\n      _finalizeReserveAuction(auctionId, true);\n    }\n  }\n  function getMinBidAmount(uint256 auctionId) external view returns (uint256 minimum) {\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\n    if (auction.endTime == 0) {\n      return auction.amount;\n    }\n    return _getMinIncrement(auction.amount);\n  }\n  function getReserveAuction(uint256 auctionId) external view returns (ReserveAuction memory auction) {\n    return auctionIdToAuction[auctionId];\n  }\n  function getReserveAuctionIdFor(address nftContract, uint256 tokenId) external view returns (uint256 auctionId) {\n    return nftContractToTokenIdToAuctionId[nftContract][tokenId];\n  }\n  function _getSellerFor(address nftContract, uint256 tokenId)\n    internal\n    view\n    virtual\n    override\n    returns (address payable seller)\n  {\n    seller = auctionIdToAuction[nftContractToTokenIdToAuctionId[nftContract][tokenId]].seller;\n    if (seller == address(0)) {\n      seller = super._getSellerFor(nftContract, tokenId);\n    }\n  }\n  function _isInActiveAuction(address nftContract, uint256 tokenId) internal view override returns (bool) {\n    uint256 auctionId = nftContractToTokenIdToAuctionId[nftContract][tokenId];\n    return auctionId != 0 && auctionIdToAuction[auctionId].endTime >= block.timestamp;\n  }\n  uint256[1000] private __gap;\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-02-foundation#h-01-nft-owner-can-create-multiple-auctions",
	            "Location":"createReserveAuction function",
	            "Type":"ID-related violations",
	            "Description":"Shared resource (e.g., token) without proper locks.NFT owner can create multiple auctions,NFT owner can permanently lock funds of bidders.",
	            "Repair":""
            },
            {
                "Name":"https://code4rena.com/reports/2022-02-foundation#h-01-nft-owner-can-create-multiple-auctions",
	            "Location":"  if (auction.seller != msg.sender) {revert NFTMarketReserveAuction_Not_Matching_Seller(auction.seller);} in _transferToEscrow function",
	            "Type":"ID-related violations",
	            "Description":"Shared resource (e.g., token) without proper locks.NFT owner can create multiple auctions,NFT owner can permanently lock funds of bidders.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity ^0.8.7;\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport \"./Swapper.sol\";\n\ncontract GenericSwapFacet is ILiFi, Swapper {\n    function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {\n        uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\n\n        LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-03-lifinance#h-01-reliance-on-lifidatareceivingassetid-can-cause-loss-of-funds",
	            "Location":"uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n _executeSwaps(_lifiData, _swapData);\n uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\n LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance); in swapTokensGeneric function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Reliance on lifiData.receivingAssetId can cause loss of funds,In the swapTokensGeneric() function, an arbitrary number of swaps can be performed from and to various tokens. However, the final balance that is sent to the user relies on _lifiData.receivingAssetId which has no use in the swapping functionality. LifiData is claimed to be used purely for analytical reasons per the comments to this function. If this value is input incorrectly, the swapped tokens will simply sit in the contract and be lost to the user.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../interfaces/IAggregatorV3Interface.sol\";\nimport \"../interfaces/IStableCoin.sol\";\nimport \"../interfaces/IJPEGLock.sol\";\n\ncontract NFTVault is AccessControlUpgradeable, ReentrancyGuardUpgradeable {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n\n    event PositionOpened(address indexed owner, uint256 indexed index);\n    event Borrowed(\n        address indexed owner,\n        uint256 indexed index,\n        uint256 amount\n    );\n    event Repaid(address indexed owner, uint256 indexed index, uint256 amount);\n    event PositionClosed(address indexed owner, uint256 indexed index);\n    event Liquidated(\n        address indexed liquidator,\n        address indexed owner,\n        uint256 indexed index,\n        bool insured\n    );\n    event Repurchased(address indexed owner, uint256 indexed index);\n    event InsuranceExpired(address indexed owner, uint256 indexed index);\n\n    enum BorrowType {\n        NOT_CONFIRMED,\n        NON_INSURANCE,\n        USE_INSURANCE\n    }\n\n    struct Position {\n        BorrowType borrowType;\n        uint256 debtPrincipal;\n        uint256 debtPortion;\n        uint256 debtAmountForRepurchase;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    struct VaultSettings {\n        Rate debtInterestApr;\n        Rate creditLimitRate;\n        Rate liquidationLimitRate;\n        Rate valueIncreaseLockRate;\n        Rate organizationFeeRate;\n        Rate insurancePurchaseRate;\n        Rate insuranceLiquidationPenaltyRate;\n        uint256 insuraceRepurchaseTimeLimit;\n        uint256 borrowAmountCap;\n    }\n\n    bytes32 public constant DAO_ROLE = keccak256(\"DAO_ROLE\");\n    bytes32 public constant LIQUIDATOR_ROLE = keccak256(\"LIQUIDATOR_ROLE\");\n\n    bytes32 public constant CUSTOM_NFT_HASH = keccak256(\"CUSTOM\");\n\n    IStableCoin public stablecoin;\n    IAggregatorV3Interface public ethAggregator;\n    IAggregatorV3Interface public jpegAggregator;\n    IAggregatorV3Interface public floorOracle;\n    IAggregatorV3Interface public fallbackOracle;\n    IJPEGLock public jpegLocker;\n    IERC721Upgradeable public nftContract;\n    bool public daoFloorOverride;\n\n    bool public useFallbackOracle;\n\n    uint256 public totalDebtAmount;\n\n    uint256 public totalDebtAccruedAt;\n    uint256 public totalFeeCollected;\n    uint256 internal totalDebtPortion;\n\n    VaultSettings public settings;\n\n    EnumerableSetUpgradeable.UintSet private positionIndexes;\n\n    mapping(uint256 => Position) private positions;\n    mapping(uint256 => address) public positionOwner;\n    mapping(bytes32 => uint256) public nftTypeValueETH;\n    mapping(uint256 => uint256) public nftValueETH;\n\n    mapping(uint256 => bytes32) public nftTypes;\n    mapping(uint256 => uint256) public pendingNFTValueETH;\n\n\n    modifier validNFTIndex(uint256 nftIndex) {\n\n        require(nftContract.ownerOf(nftIndex) != address(0), \"invalid_nft\");\n        _;\n    }\n\n    struct NFTCategoryInitializer {\n        bytes32 hash;\n        uint256 valueETH;\n        uint256[] nfts;\n    }\n    function initialize(\n        IStableCoin _stablecoin,\n        IERC721Upgradeable _nftContract,\n        IAggregatorV3Interface _ethAggregator,\n        IAggregatorV3Interface _jpegAggregator,\n        IAggregatorV3Interface _floorOracle,\n        IAggregatorV3Interface _fallbackOracle,\n        NFTCategoryInitializer[] memory _typeInitializers,\n        IJPEGLock _jpegLocker,\n        VaultSettings memory _settings\n    ) external initializer {\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n\n        _setupRole(DAO_ROLE, msg.sender);\n        _setRoleAdmin(LIQUIDATOR_ROLE, DAO_ROLE);\n        _setRoleAdmin(DAO_ROLE, DAO_ROLE);\n\n        _validateRate(_settings.debtInterestApr);\n        _validateRate(_settings.creditLimitRate);\n        _validateRate(_settings.liquidationLimitRate);\n        _validateRate(_settings.valueIncreaseLockRate);\n        _validateRate(_settings.organizationFeeRate);\n        _validateRate(_settings.insurancePurchaseRate);\n        _validateRate(_settings.insuranceLiquidationPenaltyRate);\n\n        _validateCreditLimitAndLiquidationRate(\n            _settings.creditLimitRate,\n            _settings.liquidationLimitRate\n        );\n\n        stablecoin = _stablecoin;\n        jpegLocker = _jpegLocker;\n        ethAggregator = _ethAggregator;\n        jpegAggregator = _jpegAggregator;\n        floorOracle = _floorOracle;\n        fallbackOracle = _fallbackOracle;\n        nftContract = _nftContract;\n\n        settings = _settings;\n\n        //initializing the categories\n        for (uint256 i = 0; i < _typeInitializers.length; i++) {\n            NFTCategoryInitializer memory initializer = _typeInitializers[i];\n            nftTypeValueETH[initializer.hash] = initializer.valueETH;\n            for (uint256 j = 0; j < initializer.nfts.length; j++) {\n                nftTypes[initializer.nfts[j]] = initializer.hash;\n            }\n        }\n    }\n\n    function accrue() public {\n        uint256 additionalInterest = _calculateAdditionalInterest();\n\n        totalDebtAccruedAt = block.timestamp;\n\n        totalDebtAmount += additionalInterest;\n        totalFeeCollected += additionalInterest;\n    }\n\n    function setBorrowAmountCap(uint256 _borrowAmountCap)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        settings.borrowAmountCap = _borrowAmountCap;\n    }\n\n    function setDebtInterestApr(Rate memory _debtInterestApr)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_debtInterestApr);\n        settings.debtInterestApr = _debtInterestApr;\n    }\n\n\n    function setValueIncreaseLockRate(Rate memory _valueIncreaseLockRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_valueIncreaseLockRate);\n        settings.valueIncreaseLockRate = _valueIncreaseLockRate;\n    }\n\n    function setCreditLimitRate(Rate memory _creditLimitRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_creditLimitRate);\n        _validateCreditLimitAndLiquidationRate(\n            _creditLimitRate,\n            settings.liquidationLimitRate\n        );\n\n        settings.creditLimitRate = _creditLimitRate;\n    }\n\n    function setLiquidationLimitRate(Rate memory _liquidationLimitRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_liquidationLimitRate);\n        _validateCreditLimitAndLiquidationRate(\n            settings.creditLimitRate,\n            _liquidationLimitRate\n        );\n\n        settings.liquidationLimitRate = _liquidationLimitRate;\n    }\n\n    function toggleFallbackOracle(bool _useFallback)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        useFallbackOracle = _useFallback;\n    }\n\n    function setJPEGLockTime(uint256 _newLockTime) external onlyRole(DAO_ROLE) {\n        jpegLocker.setLockTime(_newLockTime);\n    }\n\n    function overrideFloor(uint256 _newFloor) external onlyRole(DAO_ROLE) {\n        require(_newFloor > 0, \"Invalid floor\");\n        nftTypeValueETH[bytes32(0)] = _newFloor;\n        daoFloorOverride = true;\n    }\n\n    function disableFloorOverride() external onlyRole(DAO_ROLE) {\n        daoFloorOverride = false;\n    }\n\n    function setOrganizationFeeRate(Rate memory _organizationFeeRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_organizationFeeRate);\n        settings.organizationFeeRate = _organizationFeeRate;\n    }\n\n    function setInsurancePurchaseRate(Rate memory _insurancePurchaseRate)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        _validateRate(_insurancePurchaseRate);\n        settings.insurancePurchaseRate = _insurancePurchaseRate;\n    }\n\n    function setInsuranceLiquidationPenaltyRate(\n        Rate memory _insuranceLiquidationPenaltyRate\n    ) external onlyRole(DAO_ROLE) {\n        _validateRate(_insuranceLiquidationPenaltyRate);\n        settings\n            .insuranceLiquidationPenaltyRate = _insuranceLiquidationPenaltyRate;\n    }\n    function setNFTType(uint256 _nftIndex, bytes32 _type)\n        external\n        validNFTIndex(_nftIndex)\n        onlyRole(DAO_ROLE)\n    {\n        require(\n            _type == bytes32(0) || nftTypeValueETH[_type] > 0,\n            \"invalid_nftType\"\n        );\n        nftTypes[_nftIndex] = _type;\n    }\n    function setNFTTypeValueETH(bytes32 _type, uint256 _amountETH)\n        external\n        onlyRole(DAO_ROLE)\n    {\n        nftTypeValueETH[_type] = _amountETH;\n    }\n    function setPendingNFTValueETH(uint256 _nftIndex, uint256 _amountETH)\n        external\n        validNFTIndex(_nftIndex)\n        onlyRole(DAO_ROLE)\n    {\n        pendingNFTValueETH[_nftIndex] = _amountETH;\n    }\n    function finalizePendingNFTValueETH(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        uint256 pendingValue = pendingNFTValueETH[_nftIndex];\n        require(pendingValue > 0, \"no_pending_value\");\n        uint256 toLockJpeg = (((pendingValue *\n            _ethPriceUSD() *\n            settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator) *\n            settings.valueIncreaseLockRate.numerator) /\n            settings.valueIncreaseLockRate.denominator /\n            _jpegPriceUSD();\n\n        //lock JPEG using JPEGLock\n        jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg);\n\n        nftTypes[_nftIndex] = CUSTOM_NFT_HASH;\n        nftValueETH[_nftIndex] = pendingValue;\n        //clear pending value\n        pendingNFTValueETH[_nftIndex] = 0;\n    }\n    function _validateCreditLimitAndLiquidationRate(\n        Rate memory _creditLimitRate,\n        Rate memory _liquidationLimitRate\n    ) internal pure {\n        require(\n            _liquidationLimitRate.numerator * _creditLimitRate.denominator >\n                _creditLimitRate.numerator * _liquidationLimitRate.denominator,\n            \"credit_rate_exceeds_or_equals_liquidation_rate\"\n        );\n    }\n\n    function _validateRate(Rate memory rate) internal pure {\n        require(\n            rate.denominator > 0 && rate.denominator >= rate.numerator,\n            \"invalid_rate\"\n        );\n    }\n\n    function _getNFTValueETH(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        bytes32 nftType = nftTypes[_nftIndex];\n\n        if (nftType == bytes32(0) && !daoFloorOverride) {\n            return\n                _normalizeAggregatorAnswer(\n                    useFallbackOracle ? fallbackOracle : floorOracle\n                );\n        } else if (nftType == CUSTOM_NFT_HASH) return nftValueETH[_nftIndex];\n\n        return nftTypeValueETH[nftType];\n    }\n    function _getNFTValueUSD(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 nft_value = _getNFTValueETH(_nftIndex);\n        return (nft_value * _ethPriceUSD()) / 1 ether;\n    }\n\n    function _ethPriceUSD() internal view returns (uint256) {\n        return _normalizeAggregatorAnswer(ethAggregator);\n    }\n\n    function _jpegPriceUSD() internal view returns (uint256) {\n        return _normalizeAggregatorAnswer(jpegAggregator);\n    }\n    function _normalizeAggregatorAnswer(IAggregatorV3Interface aggregator)\n        internal\n        view\n        returns (uint256)\n    {\n        int256 answer = aggregator.latestAnswer();\n        uint8 decimals = aggregator.decimals();\n\n        require(answer > 0, \"invalid_oracle_answer\");\n        return\n            decimals > 18\n                ? uint256(answer) / 10**(decimals - 18)\n                : uint256(answer) * 10**(18 - decimals);\n    }\n\n    struct NFTInfo {\n        uint256 index;\n        bytes32 nftType;\n        address owner;\n        uint256 nftValueETH;\n        uint256 nftValueUSD;\n    }\n    function getNFTInfo(uint256 _nftIndex)\n        external\n        view\n        returns (NFTInfo memory nftInfo)\n    {\n        nftInfo = NFTInfo(\n            _nftIndex,\n            nftTypes[_nftIndex],\n            nftContract.ownerOf(_nftIndex),\n            _getNFTValueETH(_nftIndex),\n            _getNFTValueUSD(_nftIndex)\n        );\n    }\n    function _getCreditLimit(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 asset_value = _getNFTValueUSD(_nftIndex);\n        return\n            (asset_value * settings.creditLimitRate.numerator) /\n            settings.creditLimitRate.denominator;\n    }\n\n    function _getLiquidationLimit(uint256 _nftIndex)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 asset_value = _getNFTValueUSD(_nftIndex);\n        return\n            (asset_value * settings.liquidationLimitRate.numerator) /\n            settings.liquidationLimitRate.denominator;\n    }\n\n    function _getDebtAmount(uint256 _nftIndex) internal view returns (uint256) {\n        uint256 calculatedDebt = _calculateDebt(\n            totalDebtAmount,\n            positions[_nftIndex].debtPortion,\n            totalDebtPortion\n        );\n\n        uint256 principal = positions[_nftIndex].debtPrincipal;\n\n        return principal > calculatedDebt ? principal : calculatedDebt;\n    }\n    function _calculateDebt(\n        uint256 total,\n        uint256 userPortion,\n        uint256 totalPortion\n    ) internal pure returns (uint256) {\n        return totalPortion == 0 ? 0 : (total * userPortion) / totalPortion;\n    }\n    function _openPosition(address _owner, uint256 _nftIndex) internal {\n        nftContract.transferFrom(_owner, address(this), _nftIndex);\n\n        positions[_nftIndex] = Position({\n            borrowType: BorrowType.NOT_CONFIRMED,\n            debtPrincipal: 0,\n            debtPortion: 0,\n            debtAmountForRepurchase: 0,\n            liquidatedAt: 0,\n            liquidator: address(0)\n        });\n        positionOwner[_nftIndex] = _owner;\n        positionIndexes.add(_nftIndex);\n\n        emit PositionOpened(_owner, _nftIndex);\n    }\n\n    function _calculateAdditionalInterest() internal view returns (uint256) {\n        uint256 elapsedTime = block.timestamp - totalDebtAccruedAt;\n        if (elapsedTime == 0) {\n            return 0;\n        }\n\n        if (totalDebtAmount == 0) {\n            return 0;\n        }\n\n        uint256 interestPerYear = (totalDebtAmount *\n            settings.debtInterestApr.numerator) /\n            settings.debtInterestApr.denominator;\n        uint256 interestPerSec = interestPerYear / 365 days;\n\n        return elapsedTime * interestPerSec;\n    }\n\n    function totalPositions() external view returns (uint256) {\n        return positionIndexes.length();\n    }\n\n    function openPositionsIndexes() external view returns (uint256[] memory) {\n        return positionIndexes.values();\n    }\n\n    struct PositionPreview {\n        address owner;\n        uint256 nftIndex;\n        bytes32 nftType;\n        uint256 nftValueUSD;\n        VaultSettings vaultSettings;\n        uint256 creditLimit;\n        uint256 debtPrincipal;\n        uint256 debtInterest;\n        BorrowType borrowType;\n        bool liquidatable;\n        uint256 liquidatedAt;\n        address liquidator;\n    }\n\n    function showPosition(uint256 _nftIndex)\n        external\n        view\n        validNFTIndex(_nftIndex)\n        returns (PositionPreview memory preview)\n    {\n        address posOwner = positionOwner[_nftIndex];\n\n        uint256 debtPrincipal = positions[_nftIndex].debtPrincipal;\n        uint256 debtAmount = positions[_nftIndex].liquidatedAt > 0\n            ? positions[_nftIndex].debtAmountForRepurchase //calculate updated debt\n            : _calculateDebt(\n                totalDebtAmount + _calculateAdditionalInterest(),\n                positions[_nftIndex].debtPortion,\n                totalDebtPortion\n            );\n\n        if (debtPrincipal > debtAmount) debtAmount = debtPrincipal;\n\n        preview = PositionPreview({\n            owner: posOwner, \n            nftIndex: _nftIndex, \n            nftType: nftTypes[_nftIndex], \n            nftValueUSD: _getNFTValueUSD(_nftIndex), \n            vaultSettings: settings, \n            creditLimit: _getCreditLimit(_nftIndex), \n            debtPrincipal: debtPrincipal, \n            debtInterest: debtAmount - debtPrincipal, \n            borrowType: positions[_nftIndex].borrowType, \n            liquidatable: positions[_nftIndex].liquidatedAt == 0 &&\n                debtAmount >= _getLiquidationLimit(_nftIndex), \n            liquidatedAt: positions[_nftIndex].liquidatedAt, \n            liquidator: positions[_nftIndex].liquidator \n        });\n    }\n\n    function borrow(\n        uint256 _nftIndex,\n        uint256 _amount,\n        bool _useInsurance\n    ) external validNFTIndex(_nftIndex) nonReentrant {\n        accrue();\n\n        require(\n            msg.sender == positionOwner[_nftIndex] ||\n                address(0) == positionOwner[_nftIndex],\n            \"unauthorized\"\n        );\n        require(_amount > 0, \"invalid_amount\");\n        require(\n            totalDebtAmount + _amount <= settings.borrowAmountCap,\n            \"debt_cap\"\n        );\n\n        if (positionOwner[_nftIndex] == address(0)) {\n            _openPosition(msg.sender, _nftIndex);\n        }\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n        require(\n            position.borrowType == BorrowType.NOT_CONFIRMED ||\n                (position.borrowType == BorrowType.USE_INSURANCE &&\n                    _useInsurance) ||\n                (position.borrowType == BorrowType.NON_INSURANCE &&\n                    !_useInsurance),\n            \"invalid_insurance_mode\"\n        );\n\n        uint256 creditLimit = _getCreditLimit(_nftIndex);\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(debtAmount + _amount <= creditLimit, \"insufficient_credit\");\n\n        //calculate the borrow fee\n        uint256 organizationFee = (_amount *\n            settings.organizationFeeRate.numerator) /\n            settings.organizationFeeRate.denominator;\n\n        uint256 feeAmount = organizationFee;\n        if (position.borrowType == BorrowType.USE_INSURANCE || _useInsurance) {\n            feeAmount +=\n                (_amount * settings.insurancePurchaseRate.numerator) /\n                settings.insurancePurchaseRate.denominator;\n        }\n        totalFeeCollected += feeAmount;\n        stablecoin.mint(msg.sender, _amount - feeAmount);\n\n        if (position.borrowType == BorrowType.NOT_CONFIRMED) {\n            position.borrowType = _useInsurance\n                ? BorrowType.USE_INSURANCE\n                : BorrowType.NON_INSURANCE;\n        }\n\n        // update debt portion\n        if (totalDebtPortion == 0) {\n            totalDebtPortion = _amount;\n            position.debtPortion = _amount;\n        } else {\n            uint256 plusPortion = (totalDebtPortion * _amount) /\n                totalDebtAmount;\n            totalDebtPortion += plusPortion;\n            position.debtPortion += plusPortion;\n        }\n        position.debtPrincipal += _amount;\n        totalDebtAmount += _amount;\n\n        emit Borrowed(msg.sender, _nftIndex, _amount);\n    }\n    function repay(uint256 _nftIndex, uint256 _amount)\n        external\n        validNFTIndex(_nftIndex)\n        nonReentrant\n    {\n        accrue();\n\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(_amount > 0, \"invalid_amount\");\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(debtAmount > 0, \"position_not_borrowed\");\n\n        uint256 debtPrincipal = position.debtPrincipal;\n        uint256 debtInterest = debtAmount - debtPrincipal;\n\n        _amount = _amount > debtAmount ? debtAmount : _amount;\n        stablecoin.burnFrom(msg.sender, _amount);\n\n        uint256 paidPrincipal = _amount > debtInterest\n            ? _amount - debtInterest\n            : 0;\n\n        uint256 minusPortion = paidPrincipal == debtPrincipal\n            ? position.debtPortion\n            : (totalDebtPortion * _amount) / totalDebtAmount;\n\n        totalDebtPortion -= minusPortion;\n        position.debtPortion -= minusPortion;\n        position.debtPrincipal -= paidPrincipal;\n        totalDebtAmount -= _amount;\n\n        emit Repaid(msg.sender, _nftIndex, _amount);\n    }\n    function closePosition(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        accrue();\n\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(_getDebtAmount(_nftIndex) == 0, \"position_not_repaid\");\n\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        // transfer nft back to owner if nft was deposited\n        if (nftContract.ownerOf(_nftIndex) == address(this)) {\n            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n        }\n\n        emit PositionClosed(msg.sender, _nftIndex);\n    }\n    function liquidate(uint256 _nftIndex)\n        external\n        onlyRole(LIQUIDATOR_ROLE)\n        validNFTIndex(_nftIndex)\n        nonReentrant\n    {\n        accrue();\n\n        address posOwner = positionOwner[_nftIndex];\n        require(posOwner != address(0), \"position_not_exist\");\n\n        Position storage position = positions[_nftIndex];\n        require(position.liquidatedAt == 0, \"liquidated\");\n\n        uint256 debtAmount = _getDebtAmount(_nftIndex);\n        require(\n            debtAmount >= _getLiquidationLimit(_nftIndex),\n            \"position_not_liquidatable\"\n        );\n\n        // burn all payment\n        stablecoin.burnFrom(msg.sender, debtAmount);\n\n        // update debt portion\n        totalDebtPortion -= position.debtPortion;\n        totalDebtAmount -= debtAmount;\n        position.debtPortion = 0;\n\n        bool insured = position.borrowType == BorrowType.USE_INSURANCE;\n        if (insured) {\n            position.debtAmountForRepurchase = debtAmount;\n            position.liquidatedAt = block.timestamp;\n            position.liquidator = msg.sender;\n        } else {\n            // transfer nft to liquidator\n            positionOwner[_nftIndex] = address(0);\n            delete positions[_nftIndex];\n            positionIndexes.remove(_nftIndex);\n            nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n        }\n\n        emit Liquidated(msg.sender, posOwner, _nftIndex, insured);\n    }\n    function repurchase(uint256 _nftIndex) external validNFTIndex(_nftIndex) {\n        Position memory position = positions[_nftIndex];\n        require(msg.sender == positionOwner[_nftIndex], \"unauthorized\");\n        require(position.liquidatedAt > 0, \"not_liquidated\");\n        require(\n            position.borrowType == BorrowType.USE_INSURANCE,\n            \"non_insurance\"\n        );\n        require(\n            position.liquidatedAt + settings.insuraceRepurchaseTimeLimit >=\n                block.timestamp,\n            \"insurance_expired\"\n        );\n\n        uint256 debtAmount = position.debtAmountForRepurchase;\n        uint256 penalty = (debtAmount *\n            settings.insuranceLiquidationPenaltyRate.numerator) /\n            settings.insuranceLiquidationPenaltyRate.denominator;\n        stablecoin.transferFrom(\n            msg.sender,\n            position.liquidator,\n            debtAmount + penalty\n        );\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n\n        emit Repurchased(msg.sender, _nftIndex);\n    }\n    function claimExpiredInsuranceNFT(uint256 _nftIndex)\n        external\n        validNFTIndex(_nftIndex)\n    {\n        Position memory position = positions[_nftIndex];\n        address owner = positionOwner[_nftIndex];\n        require(address(0) != owner, \"no_position\");\n        require(position.liquidatedAt > 0, \"not_liquidated\");\n        require(\n            position.liquidatedAt + settings.insuraceRepurchaseTimeLimit <\n                block.timestamp,\n            \"insurance_not_expired\"\n        );\n        require(position.liquidator == msg.sender, \"unauthorized\");\n\n        positionOwner[_nftIndex] = address(0);\n        delete positions[_nftIndex];\n        positionIndexes.remove(_nftIndex);\n\n        nftContract.safeTransferFrom(address(this), msg.sender, _nftIndex);\n\n        emit InsuranceExpired(owner, _nftIndex);\n    }\n\n    /// @notice Allows the DAO to collect interest and fees before they are repaid\n    function collect() external nonReentrant onlyRole(DAO_ROLE) {\n        accrue();\n        stablecoin.mint(msg.sender, totalFeeCollected);\n        totalFeeCollected = 0;\n    }\n\n    uint256[50] private __gap;\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-04-jpegd#h-02-existing-users-locked-jpeg-could-be-overwritten-by-new-user-causing-permanent-loss-of-jpeg-funds",
	            "Location":"jpegLocker.lockFor(msg.sender, _nftIndex, toLockJpeg); in finalizePendingNFTValueETH function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Existing user’s locked JPEG could be overwritten by new user, causing permanent loss of JPEG funds,A user’s JPEG lock schedule can be overwritten by another user’s if he (the other user) submits and finalizes a proposal to change the same NFT index’s value.The existing user will be unable to withdraw his locked JPEGs, resulting in permanent lock up of JPEG in the locker contract.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract JPEGLock is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    event Lock(address indexed user, uint256 indexed nftIndex, uint256 amount);\n    event Unlock(address indexed user, uint256 indexed nftIndex, uint256 amount);\n\n    struct LockPosition {\n        address owner;\n        uint256 unlockAt;\n        uint256 lockAmount;\n    }\n\n    IERC20 public immutable jpeg;\n\n    uint256 public lockTime;\n\n    mapping(uint256 => LockPosition) public positions;\n\n    constructor(IERC20 _jpeg) Ownable() ReentrancyGuard() {\n        jpeg = _jpeg;\n        lockTime = 365 days;\n    }\n    function setLockTime(uint256 _newTime) external onlyOwner {\n        require(_newTime > 0, \"Invalid lock time\");\n        lockTime = _newTime;\n    }\n    function lockFor(\n        address _account,\n        uint256 _nftIndex,\n        uint256 _lockAmount\n    ) external onlyOwner nonReentrant {\n        jpeg.safeTransferFrom(_account, address(this), _lockAmount);\n\n        positions[_nftIndex] = LockPosition({\n            owner: _account,\n            unlockAt: block.timestamp + lockTime,\n            lockAmount: _lockAmount\n        });\n\n        emit Lock(_account, _nftIndex, _lockAmount);\n    }\n    function unlock(uint256 _nftIndex) external nonReentrant {\n        LockPosition memory position = positions[_nftIndex];\n        require(position.owner == msg.sender, \"unauthorized\");\n        require(position.unlockAt <= block.timestamp, \"locked\");\n\n        delete positions[_nftIndex];\n\n        jpeg.safeTransfer(msg.sender, position.lockAmount);\n\n        emit Unlock(msg.sender, _nftIndex, position.lockAmount);\n    }\n\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-04-jpegd#h-02-existing-users-locked-jpeg-could-be-overwritten-by-new-user-causing-permanent-loss-of-jpeg-funds",
	            "Location":"jpeg.safeTransferFrom(_account, address(this), _lockAmount);positions[_nftIndex] = LockPosition({owner: _account,unlockAt: block.timestamp + lockTime,lockAmount: _lockAmount});emit Lock(_account, _nftIndex, _lockAmount); in lockFor function",
	            "Type":"ID-related violations",
	            "Description":"ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Existing user’s locked JPEG could be overwritten by new user, causing permanent loss of JPEG funds,A user’s JPEG lock schedule can be overwritten by another user’s if he (the other user) submits and finalizes a proposal to change the same NFT index’s value.The existing user will be unable to withdraw his locked JPEGs, resulting in permanent lock up of JPEG in the locker contract.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity 0.8.6;\nimport \"./abstract/JBControllerUtility.sol\";\nimport \"./abstract/JBOperatable.sol\";\nimport \"./interfaces/IJBTokenStore.sol\";\nimport \"./libraries/JBOperations.sol\";\nimport \"./JBToken.sol\";\n\ncontract JBTokenStore is IJBTokenStore, JBControllerUtility, JBOperatable {\n  error CANT_REMOVE_TOKEN_IF_ITS_REQUIRED();\n  error EMPTY_NAME();\n  error EMPTY_SYMBOL();\n  error INSUFFICIENT_FUNDS();\n  error INSUFFICIENT_UNCLAIMED_TOKENS();\n  error PROJECT_ALREADY_HAS_TOKEN();\n  error RECIPIENT_ZERO_ADDRESS();\n  error TOKEN_ALREADY_IN_USE();\n  error TOKEN_NOT_FOUND();\n  error TOKENS_MUST_HAVE_18_DECIMALS();\n\n  IJBProjects public immutable override projects;\n\n  mapping(uint256 => IJBToken) public override tokenOf;\n\n  mapping(IJBToken => uint256) public override projectOf;\n\n  mapping(uint256 => uint256) public override unclaimedTotalSupplyOf;\n\n\n  mapping(address => mapping(uint256 => uint256)) public override unclaimedBalanceOf;\n\n  mapping(uint256 => bool) public override requireClaimFor;\n\n  function totalSupplyOf(uint256 _projectId) external view override returns (uint256 totalSupply) {\n\n    totalSupply = unclaimedTotalSupplyOf[_projectId];\n\n\n    IJBToken _token = tokenOf[_projectId];\n\n\n    if (_token != IJBToken(address(0))) totalSupply = totalSupply + _token.totalSupply(_projectId);\n  }\n\n  function balanceOf(address _holder, uint256 _projectId)\n    external\n    view\n    override\n    returns (uint256 balance)\n  {\n\n    balance = unclaimedBalanceOf[_holder][_projectId];\n\n    IJBToken _token = tokenOf[_projectId];\n\n\n    if (_token != IJBToken(address(0))) balance = balance + _token.balanceOf(_holder, _projectId);\n  }\n\n\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory\n  ) JBOperatable(_operatorStore) JBControllerUtility(_directory) {\n    projects = _projects;\n  }\n\n  function issueFor(\n    uint256 _projectId,\n    string calldata _name,\n    string calldata _symbol\n  ) external override onlyController(_projectId) returns (IJBToken token) {\n\n    if (bytes(_name).length == 0) revert EMPTY_NAME();\n\n\n    if (bytes(_symbol).length == 0) revert EMPTY_SYMBOL();\n\n\n    if (tokenOf[_projectId] != IJBToken(address(0))) revert PROJECT_ALREADY_HAS_TOKEN();\n\n\n    token = new JBToken(_name, _symbol);\n\n    tokenOf[_projectId] = token;\n\n    projectOf[token] = _projectId;\n\n    emit Issue(_projectId, token, _name, _symbol, msg.sender);\n  }\n\n  function changeFor(\n    uint256 _projectId,\n    IJBToken _token,\n    address _newOwner\n  ) external override onlyController(_projectId) returns (IJBToken oldToken) {\n\n    if (_token == IJBToken(address(0)) && requireClaimFor[_projectId])\n      revert CANT_REMOVE_TOKEN_IF_ITS_REQUIRED();\n\n\n    if (projectOf[_token] != 0) revert TOKEN_ALREADY_IN_USE();\n\n\n    if (_token != IJBToken(address(0)) && _token.decimals() != 18)\n      revert TOKENS_MUST_HAVE_18_DECIMALS();\n\n\n    oldToken = tokenOf[_projectId];\n\n\n    tokenOf[_projectId] = _token;\n\n\n    if (_token != IJBToken(address(0))) projectOf[_token] = _projectId;\n\n\n    if (oldToken != IJBToken(address(0))) projectOf[oldToken] = 0;\n\n\n    if (_newOwner != address(0) && oldToken != IJBToken(address(0)))\n      oldToken.transferOwnership(_projectId, _newOwner);\n\n    emit Change(_projectId, _token, oldToken, _newOwner, msg.sender);\n  }\n\n  function mintFor(\n    address _holder,\n    uint256 _projectId,\n    uint256 _amount,\n    bool _preferClaimedTokens\n  ) external override onlyController(_projectId) {\n\n    IJBToken _token = tokenOf[_projectId];\n\n    bool _shouldClaimTokens = (requireClaimFor[_projectId] || _preferClaimedTokens) &&\n      _token != IJBToken(address(0));\n\n    if (_shouldClaimTokens)\n      // If tokens should be claimed, mint tokens into the holder\"s wallet.\n      _token.mint(_projectId, _holder, _amount);\n    else {\n      // Otherwise, add the tokens to the unclaimed balance and total supply.\n      unclaimedBalanceOf[_holder][_projectId] = unclaimedBalanceOf[_holder][_projectId] + _amount;\n      unclaimedTotalSupplyOf[_projectId] = unclaimedTotalSupplyOf[_projectId] + _amount;\n    }\n\n    emit Mint(_holder, _projectId, _amount, _shouldClaimTokens, _preferClaimedTokens, msg.sender);\n  }\n\n\n  function burnFrom(\n    address _holder,\n    uint256 _projectId,\n    uint256 _amount,\n    bool _preferClaimedTokens\n  ) external override onlyController(_projectId) {\n    // Get a reference to the project\"s current token.\n    IJBToken _token = tokenOf[_projectId];\n\n    // Get a reference to the amount of unclaimed project tokens the holder has.\n    uint256 _unclaimedBalance = unclaimedBalanceOf[_holder][_projectId];\n\n    // Get a reference to the amount of the project\"s current token the holder has in their wallet.\n    uint256 _claimedBalance = _token == IJBToken(address(0))\n      ? 0\n      : _token.balanceOf(_holder, _projectId);\n\n    // There must be adequate tokens to burn across the holder\"s claimed and unclaimed balance.\n    if (_amount > _claimedBalance + _unclaimedBalance) revert INSUFFICIENT_FUNDS();\n\n    // The amount of tokens to burn.\n    uint256 _claimedTokensToBurn;\n\n    // If there\"s no balance, redeem no tokens.\n    if (_claimedBalance == 0)\n      _claimedTokensToBurn = 0;\n      // If prefer converted, redeem tokens before redeeming unclaimed tokens.\n    else if (_preferClaimedTokens)\n      _claimedTokensToBurn = _claimedBalance < _amount ? _claimedBalance : _amount;\n      // Otherwise, redeem unclaimed tokens before claimed tokens.\n    else _claimedTokensToBurn = _unclaimedBalance < _amount ? _amount - _unclaimedBalance : 0;\n\n    // The amount of unclaimed tokens to redeem.\n    uint256 _unclaimedTokensToBurn = _amount - _claimedTokensToBurn;\n\n    // Subtract the tokens from the unclaimed balance and total supply.\n    if (_unclaimedTokensToBurn > 0) {\n      // Reduce the holders balance and the total supply.\n      unclaimedBalanceOf[_holder][_projectId] =\n        unclaimedBalanceOf[_holder][_projectId] -\n        _unclaimedTokensToBurn;\n      unclaimedTotalSupplyOf[_projectId] =\n        unclaimedTotalSupplyOf[_projectId] -\n        _unclaimedTokensToBurn;\n    }\n\n    // Burn the claimed tokens.\n    if (_claimedTokensToBurn > 0) _token.burn(_projectId, _holder, _claimedTokensToBurn);\n\n    emit Burn(\n      _holder,\n      _projectId,\n      _amount,\n      _unclaimedBalance,\n      _claimedBalance,\n      _preferClaimedTokens,\n      msg.sender\n    );\n  }\n\n\n  function claimFor(\n    address _holder,\n    uint256 _projectId,\n    uint256 _amount\n  ) external override requirePermission(_holder, _projectId, JBOperations.CLAIM) {\n\n    IJBToken _token = tokenOf[_projectId];\n\n\n    if (_token == IJBToken(address(0))) revert TOKEN_NOT_FOUND();\n\n\n    uint256 _unclaimedBalance = unclaimedBalanceOf[_holder][_projectId];\n\n    if (_unclaimedBalance < _amount) revert INSUFFICIENT_UNCLAIMED_TOKENS();\n\n\n    unclaimedBalanceOf[_holder][_projectId] = unclaimedBalanceOf[_holder][_projectId] - _amount;\n\n\n    unclaimedTotalSupplyOf[_projectId] = unclaimedTotalSupplyOf[_projectId] - _amount;\n\n\n    _token.mint(_projectId, _holder, _amount);\n\n    emit Claim(_holder, _projectId, _unclaimedBalance, _amount, msg.sender);\n  }\n\n  function transferFrom(\n    address _holder,\n    uint256 _projectId,\n    address _recipient,\n    uint256 _amount\n  ) external override requirePermission(_holder, _projectId, JBOperations.TRANSFER) {\n\n    if (_recipient == address(0)) revert RECIPIENT_ZERO_ADDRESS();\n\n\n    uint256 _unclaimedBalance = unclaimedBalanceOf[_holder][_projectId];\n\n\n    if (_amount > _unclaimedBalance) revert INSUFFICIENT_UNCLAIMED_TOKENS();\n\n    unclaimedBalanceOf[_holder][_projectId] = unclaimedBalanceOf[_holder][_projectId] - _amount;\n\n \n    unclaimedBalanceOf[_recipient][_projectId] =\n      unclaimedBalanceOf[_recipient][_projectId] +\n      _amount;\n\n    emit Transfer(_holder, _projectId, _recipient, _amount, msg.sender);\n  }\n\n\n  function shouldRequireClaimingFor(uint256 _projectId, bool _flag)\n    external\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.REQUIRE_CLAIM)\n  {\n\n    IJBToken _token = tokenOf[_projectId];\n\n    if (_token == IJBToken(address(0))) revert TOKEN_NOT_FOUND();\n\n\n    requireClaimFor[_projectId] = _flag;\n\n    emit ShouldRequireClaim(_projectId, _flag, msg.sender);\n  }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-07-juicebox#h-02-token-change-can-be-frontrun-blocking-token",
	            "Location":" if (projectOf[_token] != 0) revert TOKEN_ALREADY_IN_USE(); in changeFor function",
	            "Type":"ID-related violations",
	            "Description":"Shared resource (e.g., token) without proper locks.Token Change Can Be Frontrun, Blocking Token,This vulnerability allows malicious actors to block other users from changing tokens of their projects. Furthermore if ownership over the token contract is transferred to the JBTokenStore contract prior to the change, as suggested in the recourse section of Juicebox’s 24.05.2022 post-mortem update, this vulnerability would allow an attacker to become the owner of tokens being transferred. For JBToken based tokens this would allow an attacker to begin issuing arbitrary amounts the token that was meant to be transferred.",
	            "Repair":""
            },
            {
                "Name":"https://code4rena.com/reports/2022-07-juicebox#h-02-token-change-can-be-frontrun-blocking-token",
	            "Location":"oldToken.transferOwnership(_projectId, _newOwner); in changeFor function",
	            "Type":"ID-related violations",
	            "Description":"Shared resource (e.g., token) without proper locks.Token Change Can Be Frontrun, Blocking Token,This vulnerability allows malicious actors to block other users from changing tokens of their projects. Furthermore if ownership over the token contract is transferred to the JBTokenStore contract prior to the change, as suggested in the recourse section of Juicebox’s 24.05.2022 post-mortem update, this vulnerability would allow an attacker to become the owner of tokens being transferred. For JBToken based tokens this would allow an attacker to begin issuing arbitrary amounts the token that was meant to be transferred.",
	            "Repair":""
            }
        ]
    },
    {
	    "Code":"pragma solidity 0.8.6;\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@paulrberg/contracts/math/PRBMath.sol\";\nimport \"./abstract/JBOperatable.sol\";\nimport \"./interfaces/IJBController.sol\";\nimport \"./interfaces/IJBMigratable.sol\";\nimport \"./interfaces/IJBOperatorStore.sol\";\nimport \"./interfaces/IJBPaymentTerminal.sol\";\nimport \"./interfaces/IJBProjects.sol\";\nimport \"./libraries/JBConstants.sol\";\nimport \"./libraries/JBFundingCycleMetadataResolver.sol\";\nimport \"./libraries/JBOperations.sol\";\nimport \"./libraries/JBSplitsGroups.sol\";\n\ncontract JBController is IJBController, IJBMigratable, JBOperatable, ERC165 {\n\n  using JBFundingCycleMetadataResolver for JBFundingCycle;\n\n  error BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n  error CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n  error CHANGE_TOKEN_NOT_ALLOWED();\n  error FUNDING_CYCLE_ALREADY_LAUNCHED();\n  error INVALID_BALLOT_REDEMPTION_RATE();\n  error INVALID_DISTRIBUTION_LIMIT();\n  error INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n  error INVALID_OVERFLOW_ALLOWANCE();\n  error INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n  error INVALID_REDEMPTION_RATE();\n  error INVALID_RESERVED_RATE();\n  error MIGRATION_NOT_ALLOWED();\n  error MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n  error NO_BURNABLE_TOKENS();\n  error NOT_CURRENT_CONTROLLER();\n  error ZERO_TOKENS_TO_MINT();\n\n  mapping(uint256 => int256) internal _processedTokenTrackerOf;\n\n\n  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))\n    internal _packedDistributionLimitDataOf;\n\n\n  mapping(uint256 => mapping(uint256 => mapping(IJBPaymentTerminal => mapping(address => uint256))))\n    internal _packedOverflowAllowanceDataOf;\n\n \n  IJBProjects public immutable override projects;\n\n \n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n\n  IJBTokenStore public immutable override tokenStore;\n\n \n  IJBSplitsStore public immutable override splitsStore;\n\n  IJBDirectory public immutable override directory;\n\n\n  function distributionLimitOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedDistributionLimitDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The limit is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data >> 232);\n  }\n\n\n  function overflowAllowanceOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    IJBPaymentTerminal _terminal,\n    address _token\n  ) external view override returns (uint256, uint256) {\n    // Get a reference to the packed data.\n    uint256 _data = _packedOverflowAllowanceDataOf[_projectId][_configuration][_terminal][_token];\n\n    // The allowance is in bits 0-231. The currency is in bits 232-255.\n    return (uint256(uint232(_data)), _data >> 232);\n  }\n\n  function reservedTokenBalanceOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    return\n      _reservedTokenAmountFrom(\n        _processedTokenTrackerOf[_projectId],\n        _reservedRate,\n        tokenStore.totalSupplyOf(_projectId)\n      );\n  }\n\n\n  function totalOutstandingTokensOf(uint256 _projectId, uint256 _reservedRate)\n    external\n    view\n    override\n    returns (uint256)\n  {\n    // Get the total number of tokens in circulation.\n    uint256 _totalSupply = tokenStore.totalSupplyOf(_projectId);\n\n    // Get the number of reserved tokens the project has.\n    uint256 _reservedTokenAmount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _reservedRate,\n      _totalSupply\n    );\n\n    // Add the reserved tokens to the total supply.\n    return _totalSupply + _reservedTokenAmount;\n  }\n\n  function getFundingCycleOf(uint256 _projectId, uint256 _configuration)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.get(_projectId, _configuration);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n \n  function latestConfiguredFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (\n      JBFundingCycle memory fundingCycle,\n      JBFundingCycleMetadata memory metadata,\n      JBBallotState ballotState\n    )\n  {\n    (fundingCycle, ballotState) = fundingCycleStore.latestConfiguredOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n\n  function currentFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.currentOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n  function queuedFundingCycleOf(uint256 _projectId)\n    external\n    view\n    override\n    returns (JBFundingCycle memory fundingCycle, JBFundingCycleMetadata memory metadata)\n  {\n    fundingCycle = fundingCycleStore.queuedOf(_projectId);\n    metadata = fundingCycle.expandMetadata();\n  }\n\n\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(ERC165, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBController).interfaceId ||\n      _interfaceId == type(IJBMigratable).interfaceId ||\n      _interfaceId == type(IJBOperatable).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  constructor(\n    IJBOperatorStore _operatorStore,\n    IJBProjects _projects,\n    IJBDirectory _directory,\n    IJBFundingCycleStore _fundingCycleStore,\n    IJBTokenStore _tokenStore,\n    IJBSplitsStore _splitsStore\n  ) JBOperatable(_operatorStore) {\n    projects = _projects;\n    directory = _directory;\n    fundingCycleStore = _fundingCycleStore;\n    tokenStore = _tokenStore;\n    splitsStore = _splitsStore;\n  }\n\n  function launchProjectFor(\n    address _owner,\n    JBProjectMetadata calldata _projectMetadata,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  ) external virtual override returns (uint256 projectId) {\n    // Mint the project into the wallet of the message sender.\n    projectId = projects.createFor(_owner, _projectMetadata);\n\n    // Set this contract as the project\"s controller in the directory.\n    directory.setControllerOf(projectId, address(this));\n\n    // Configure the first funding cycle.\n    uint256 _configuration = _configure(\n      projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length > 0) directory.setTerminalsOf(projectId, _terminals);\n\n    emit LaunchProject(_configuration, projectId, _memo, msg.sender);\n  }\n\n  function launchFundingCyclesFor(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints,\n    IJBPaymentTerminal[] memory _terminals,\n    string memory _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // If there is a previous configuration, reconfigureFundingCyclesOf should be called instead\n    if (fundingCycleStore.latestConfigurationOf(_projectId) > 0)\n      revert FUNDING_CYCLE_ALREADY_LAUNCHED();\n\n    // Set this contract as the project\"s controller in the directory.\n    directory.setControllerOf(_projectId, address(this));\n\n    // Configure the first funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    // Add the provided terminals to the list of terminals.\n    if (_terminals.length > 0) directory.setTerminalsOf(_projectId, _terminals);\n\n    emit LaunchFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n\n  function reconfigureFundingCyclesOf(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] calldata _groupedSplits,\n    JBFundAccessConstraints[] calldata _fundAccessConstraints,\n    string calldata _memo\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.RECONFIGURE)\n    returns (uint256 configuration)\n  {\n    // Configure the next funding cycle.\n    configuration = _configure(\n      _projectId,\n      _data,\n      _metadata,\n      _mustStartAtOrAfter,\n      _groupedSplits,\n      _fundAccessConstraints\n    );\n\n    emit ReconfigureFundingCycles(configuration, _projectId, _memo, msg.sender);\n  }\n\n  function issueTokenFor(\n    uint256 _projectId,\n    string calldata _name,\n    string calldata _symbol\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.ISSUE)\n    returns (IJBToken token)\n  {\n    // Issue the token in the store.\n    return tokenStore.issueFor(_projectId, _name, _symbol);\n  }\n\n\n  function changeTokenOf(\n    uint256 _projectId,\n    IJBToken _token,\n    address _newOwner\n  )\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.CHANGE_TOKEN)\n  {\n    // Get a reference to the project\"s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // The current funding cycle must not be paused.\n    if (!_fundingCycle.changeTokenAllowed()) revert CHANGE_TOKEN_NOT_ALLOWED();\n\n    // Change the token in the store.\n    tokenStore.changeFor(_projectId, _token, _newOwner);\n  }\n\n\n  function mintTokensOf(\n    uint256 _projectId,\n    uint256 _tokenCount,\n    address _beneficiary,\n    string calldata _memo,\n    bool _preferClaimedTokens,\n    bool _useReservedRate\n  ) external virtual override returns (uint256 beneficiaryTokenCount) {\n    // There should be tokens to mint.\n    if (_tokenCount == 0) revert ZERO_TOKENS_TO_MINT();\n\n    // Define variables that will be needed outside scoped section below.\n    // Keep a reference to the reserved rate to use\n    uint256 _reservedRate;\n\n    // Scoped section prevents stack too deep. `_fundingCycle` only used within scope.\n    {\n      // Get a reference to the project\"s current funding cycle.\n      JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n      // Minting limited to: project owner, authorized callers, project terminal and current funding cycle data source\n      _requirePermissionAllowingOverride(\n        projects.ownerOf(_projectId),\n        _projectId,\n        JBOperations.MINT,\n        directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) ||\n          msg.sender == address(_fundingCycle.dataSource())\n      );\n\n      // If the message sender is not a terminal or a datasource, the current funding cycle must allow minting.\n      if (\n        !_fundingCycle.mintingAllowed() &&\n        !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender)) &&\n        msg.sender != address(_fundingCycle.dataSource())\n      ) revert MINT_NOT_ALLOWED_AND_NOT_TERMINAL_DELEGATE();\n\n      // Determine the reserved rate to use.\n      _reservedRate = _useReservedRate ? _fundingCycle.reservedRate() : 0;\n    }\n\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE)\n      // Subtract the total weighted amount from the tracker so the full reserved token amount can be printed later.\n      _processedTokenTrackerOf[_projectId] =\n        _processedTokenTrackerOf[_projectId] -\n        int256(_tokenCount);\n    else {\n      // The unreserved token count that will be minted for the beneficiary.\n      beneficiaryTokenCount = PRBMath.mulDiv(\n        _tokenCount,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate,\n        JBConstants.MAX_RESERVED_RATE\n      );\n\n      if (_reservedRate == 0)\n        // If there\"s no reserved rate, increment the tracker with the newly minted tokens.\n        _processedTokenTrackerOf[_projectId] =\n          _processedTokenTrackerOf[_projectId] +\n          int256(beneficiaryTokenCount);\n\n      // Mint the tokens.\n      tokenStore.mintFor(_beneficiary, _projectId, beneficiaryTokenCount, _preferClaimedTokens);\n    }\n\n    emit MintTokens(\n      _beneficiary,\n      _projectId,\n      _tokenCount,\n      beneficiaryTokenCount,\n      _memo,\n      _reservedRate,\n      msg.sender\n    );\n  }\n\n\n  function burnTokensOf(\n    address _holder,\n    uint256 _projectId,\n    uint256 _tokenCount,\n    string calldata _memo,\n    bool _preferClaimedTokens\n  )\n    external\n    virtual\n    override\n    requirePermissionAllowingOverride(\n      _holder,\n      _projectId,\n      JBOperations.BURN,\n      directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    )\n  {\n    // There should be tokens to burn\n    if (_tokenCount == 0) revert NO_BURNABLE_TOKENS();\n\n    // Get a reference to the project\"s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // If the message sender is not a terminal, the current funding cycle must not be paused.\n    if (\n      _fundingCycle.burnPaused() &&\n      !directory.isTerminalOf(_projectId, IJBPaymentTerminal(msg.sender))\n    ) revert BURN_PAUSED_AND_SENDER_NOT_VALID_TERMINAL_DELEGATE();\n\n    // Update the token tracker so that reserved tokens will still be correctly mintable.\n    _processedTokenTrackerOf[_projectId] =\n      _processedTokenTrackerOf[_projectId] -\n      int256(_tokenCount);\n\n    // Burn the tokens.\n    tokenStore.burnFrom(_holder, _projectId, _tokenCount, _preferClaimedTokens);\n\n    emit BurnTokens(_holder, _projectId, _tokenCount, _memo, msg.sender);\n  }\n\n  function distributeReservedTokensOf(uint256 _projectId, string calldata _memo)\n    external\n    virtual\n    override\n    returns (uint256)\n  {\n    return _distributeReservedTokensOf(_projectId, _memo);\n  }\n\n  function prepForMigrationOf(uint256 _projectId, address _from) external virtual override {\n    // This controller must not be the project\"s current controller.\n    if (directory.controllerOf(_projectId) == address(this))\n      revert CANT_MIGRATE_TO_CURRENT_CONTROLLER();\n\n    // Set the tracker as the total supply.\n    _processedTokenTrackerOf[_projectId] = int256(tokenStore.totalSupplyOf(_projectId));\n\n    emit PrepMigration(_projectId, _from, msg.sender);\n  }\n\n  function migrate(uint256 _projectId, IJBMigratable _to)\n    external\n    virtual\n    override\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations.MIGRATE_CONTROLLER)\n  {\n    // This controller must be the project\"s current controller.\n    if (directory.controllerOf(_projectId) != address(this)) revert NOT_CURRENT_CONTROLLER();\n\n    // Get a reference to the project\"s current funding cycle.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Migration must be allowed.\n    if (!_fundingCycle.controllerMigrationAllowed()) revert MIGRATION_NOT_ALLOWED();\n\n    // All reserved tokens must be minted before migrating.\n    if (uint256(_processedTokenTrackerOf[_projectId]) != tokenStore.totalSupplyOf(_projectId))\n      _distributeReservedTokensOf(_projectId, \"\");\n\n    // Make sure the new controller is prepped for the migration.\n    _to.prepForMigrationOf(_projectId, address(this));\n\n    // Set the new controller.\n    directory.setControllerOf(_projectId, address(_to));\n\n    emit Migrate(_projectId, _to, msg.sender);\n  }\n\n\n  function _distributeReservedTokensOf(uint256 _projectId, string memory _memo)\n    internal\n    returns (uint256 tokenCount)\n  {\n    // Get the current funding cycle to read the reserved rate from.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.currentOf(_projectId);\n\n    // Get a reference to new total supply of tokens before minting reserved tokens.\n    uint256 _totalTokens = tokenStore.totalSupplyOf(_projectId);\n\n    // Get a reference to the number of tokens that need to be minted.\n    tokenCount = _reservedTokenAmountFrom(\n      _processedTokenTrackerOf[_projectId],\n      _fundingCycle.reservedRate(),\n      _totalTokens\n    );\n\n    // Set the tracker to be the new total supply.\n    _processedTokenTrackerOf[_projectId] = int256(_totalTokens + tokenCount);\n\n    // Get a reference to the project owner.\n    address _owner = projects.ownerOf(_projectId);\n\n    // Distribute tokens to splits and get a reference to the leftover amount to mint after all splits have gotten their share.\n    uint256 _leftoverTokenCount = tokenCount == 0\n      ? 0\n      : _distributeToReservedTokenSplitsOf(\n        _projectId,\n        _fundingCycle.configuration,\n        JBSplitsGroups.RESERVED_TOKENS,\n        tokenCount\n      );\n\n    // Mint any leftover tokens to the project owner.\n    if (_leftoverTokenCount > 0) tokenStore.mintFor(_owner, _projectId, _leftoverTokenCount, false);\n\n    emit DistributeReservedTokens(\n      _fundingCycle.configuration,\n      _fundingCycle.number,\n      _projectId,\n      _owner,\n      tokenCount,\n      _leftoverTokenCount,\n      _memo,\n      msg.sender\n    );\n  }\n\n  function _distributeToReservedTokenSplitsOf(\n    uint256 _projectId,\n    uint256 _domain,\n    uint256 _group,\n    uint256 _amount\n  ) internal returns (uint256 leftoverAmount) {\n    // Set the leftover amount to the initial amount.\n    leftoverAmount = _amount;\n\n    // Get a reference to the project\"s reserved token splits.\n    JBSplit[] memory _splits = splitsStore.splitsOf(_projectId, _domain, _group);\n\n    //Transfer between all splits.\n    for (uint256 _i = 0; _i < _splits.length; _i++) {\n      // Get a reference to the split being iterated on.\n      JBSplit memory _split = _splits[_i];\n\n      // The amount to send towards the split.\n      uint256 _tokenCount = PRBMath.mulDiv(\n        _amount,\n        _split.percent,\n        JBConstants.SPLITS_TOTAL_PERCENT\n      );\n\n      // Mints tokens for the split if needed.\n      if (_tokenCount > 0) {\n        tokenStore.mintFor(\n\n          _split.allocator != IJBSplitAllocator(address(0))\n            ? address(_split.allocator)\n            : _split.projectId != 0\n            ? projects.ownerOf(_split.projectId)\n            : _split.beneficiary != address(0)\n            ? _split.beneficiary\n            : msg.sender,\n          _projectId,\n          _tokenCount,\n          _split.preferClaimed\n        );\n\n        // If there\"s an allocator set, trigger its `allocate` function.\n        if (_split.allocator != IJBSplitAllocator(address(0)))\n          _split.allocator.allocate(\n            JBSplitAllocationData(\n              address(tokenStore.tokenOf(_projectId)),\n              _tokenCount,\n              18,\n              _projectId,\n              _group,\n              _split\n            )\n          );\n\n        // Subtract from the amount to be sent to the beneficiary.\n        leftoverAmount = leftoverAmount - _tokenCount;\n      }\n\n      emit DistributeToReservedTokenSplit(\n        _projectId,\n        _domain,\n        _group,\n        _split,\n        _tokenCount,\n        msg.sender\n      );\n    }\n  }\n\n\n  function _configure(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    JBFundingCycleMetadata calldata _metadata,\n    uint256 _mustStartAtOrAfter,\n    JBGroupedSplits[] memory _groupedSplits,\n    JBFundAccessConstraints[] memory _fundAccessConstraints\n  ) internal returns (uint256) {\n    // Make sure the provided reserved rate is valid.\n    if (_metadata.reservedRate > JBConstants.MAX_RESERVED_RATE) revert INVALID_RESERVED_RATE();\n\n    // Make sure the provided redemption rate is valid.\n    if (_metadata.redemptionRate > JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_REDEMPTION_RATE();\n\n    // Make sure the provided ballot redemption rate is valid.\n    if (_metadata.ballotRedemptionRate > JBConstants.MAX_REDEMPTION_RATE)\n      revert INVALID_BALLOT_REDEMPTION_RATE();\n\n    // Configure the funding cycle\"s properties.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.configureFor(\n      _projectId,\n      _data,\n      JBFundingCycleMetadataResolver.packFundingCycleMetadata(_metadata),\n      _mustStartAtOrAfter\n    );\n\n    // Set splits for the group.\n    splitsStore.set(_projectId, _fundingCycle.configuration, _groupedSplits);\n\n    // Set distribution limits if there are any.\n    for (uint256 _i; _i < _fundAccessConstraints.length; _i++) {\n      JBFundAccessConstraints memory _constraints = _fundAccessConstraints[_i];\n\n      // If distribution limit value is larger than 232 bits, revert.\n      if (_constraints.distributionLimit > type(uint232).max) revert INVALID_DISTRIBUTION_LIMIT();\n\n      // If distribution limit currency value is larger than 24 bits, revert.\n      if (_constraints.distributionLimitCurrency > type(uint24).max)\n        revert INVALID_DISTRIBUTION_LIMIT_CURRENCY();\n\n      // If overflow allowance value is larger than 232 bits, revert.\n      if (_constraints.overflowAllowance > type(uint232).max) revert INVALID_OVERFLOW_ALLOWANCE();\n\n      // If overflow allowance currency value is larger than 24 bits, revert.\n      if (_constraints.overflowAllowanceCurrency > type(uint24).max)\n        revert INVALID_OVERFLOW_ALLOWANCE_CURRENCY();\n\n      // Set the distribution limit if there is one.\n      if (_constraints.distributionLimit > 0)\n        _packedDistributionLimitDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.distributionLimit |\n          (_constraints.distributionLimitCurrency << 232);\n\n      // Set the overflow allowance if there is one.\n      if (_constraints.overflowAllowance > 0)\n        _packedOverflowAllowanceDataOf[_projectId][_fundingCycle.configuration][\n          _constraints.terminal\n        ][_constraints.token] =\n          _constraints.overflowAllowance |\n          (_constraints.overflowAllowanceCurrency << 232);\n\n      emit SetFundAccessConstraints(\n        _fundingCycle.configuration,\n        _fundingCycle.number,\n        _projectId,\n        _constraints,\n        msg.sender\n      );\n    }\n\n    return _fundingCycle.configuration;\n  }\n\n  function _reservedTokenAmountFrom(\n    int256 _processedTokenTracker,\n    uint256 _reservedRate,\n    uint256 _totalEligibleTokens\n  ) internal pure returns (uint256) {\n\n    uint256 _unprocessedTokenBalanceOf = _processedTokenTracker >= 0\n      ? _totalEligibleTokens - uint256(_processedTokenTracker)\n      : _totalEligibleTokens + uint256(-_processedTokenTracker);\n\n\n    if (_unprocessedTokenBalanceOf == 0) return 0;\n\n    if (_reservedRate == JBConstants.MAX_RESERVED_RATE) return _unprocessedTokenBalanceOf;\n\n    return\n      PRBMath.mulDiv(\n        _unprocessedTokenBalanceOf,\n        JBConstants.MAX_RESERVED_RATE,\n        JBConstants.MAX_RESERVED_RATE - _reservedRate\n      ) - _unprocessedTokenBalanceOf;\n  }\n}",
	    "VulnerabilityDesc":[
            {
                "Name":"https://code4rena.com/reports/2022-07-juicebox#h-02-token-change-can-be-frontrun-blocking-token",
	            "Location":"tokenStore.changeFor(_projectId, _token, _newOwner); in changeTokenOf function",
	            "Type":"ID-related violations",
	            "Description":"Shared resource (e.g., token) without proper locks.Token Change Can Be Frontrun, Blocking Token,This vulnerability allows malicious actors to block other users from changing tokens of their projects. Furthermore if ownership over the token contract is transferred to the JBTokenStore contract prior to the change, as suggested in the recourse section of Juicebox’s 24.05.2022 post-mortem update, this vulnerability would allow an attacker to become the owner of tokens being transferred. For JBToken based tokens this would allow an attacker to begin issuing arbitrary amounts the token that was meant to be transferred.",
	            "Repair":""
            }
        ]
    }
    
]