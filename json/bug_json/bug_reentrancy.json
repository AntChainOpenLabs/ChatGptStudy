[
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./Interfaces/ITracerPerpetualSwaps.sol\";\nimport \"./Interfaces/Types.sol\";\nimport \"./Interfaces/ITrader.sol\";\nimport \"./lib/LibPerpetuals.sol\";\nimport \"./lib/LibBalances.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/**\n * The Trader contract is used to validate and execute off chain signed and matched orders\n */\ncontract Trader is ITrader {\n    // EIP712 Constants\n    // https://eips.ethereum.org/EIPS/eip-712\n    string private constant EIP712_DOMAIN_NAME = \"Tracer Protocol\";\n    string private constant EIP712_DOMAIN_VERSION = \"1.0\";\n    bytes32 private constant EIP712_DOMAIN_SEPERATOR =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // EIP712 Types\n    bytes32 private constant ORDER_TYPE =\n        keccak256(\n            \"Order(address maker,address market,uint256 price,uint256 amount,uint256 side,uint256 expires,uint256 created)\"\n        );\n\n    uint256 public constant override chainId = 1337; // Changes per chain\n    bytes32 public immutable override EIP712_DOMAIN;\n\n    // order hash to memory\n    mapping(bytes32 => Perpetuals.Order) public orders;\n    // maps an order hash to its signed order if seen before\n    mapping(bytes32 => Types.SignedLimitOrder) public orderToSig;\n    // order hash to amount filled\n    mapping(bytes32 => uint256) public override filled;\n    // order hash to average execution price thus far\n    mapping(bytes32 => uint256) public override averageExecutionPrice;\n\n    constructor() {\n        // Construct the EIP712 Domain\n        EIP712_DOMAIN = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_SEPERATOR,\n                keccak256(bytes(EIP712_DOMAIN_NAME)),\n                keccak256(bytes(EIP712_DOMAIN_VERSION)),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function filledAmount(Perpetuals.Order memory order) external view override returns (uint256) {\n        return filled[Perpetuals.orderId(order)];\n    }\n\n    function getAverageExecutionPrice(Perpetuals.Order memory order) external view override returns (uint256) {\n        return averageExecutionPrice[Perpetuals.orderId(order)];\n    }\n\n    /**\n     * @notice Batch executes maker and taker orders against a given market. Currently matching works\n     *         by matching orders 1 to 1\n     * @param makers An array of signed make orders\n     * @param takers An array of signed take orders\n     */\n    function executeTrade(Types.SignedLimitOrder[] memory makers, Types.SignedLimitOrder[] memory takers)\n        external\n        override\n    {\n        require(makers.length == takers.length, \"TDR: Lengths differ\");\n\n        // safe as we've already bounds checked the array lengths\n        uint256 n = makers.length;\n\n        require(n > 0, \"TDR: Received empty arrays\");\n\n        for (uint256 i = 0; i < n; i++) {\n            // verify each order individually and together\n            if (\n                !isValidSignature(makers[i].order.maker, makers[i]) ||\n                !isValidSignature(takers[i].order.maker, takers[i]) ||\n                !isValidPair(takers[i], makers[i])\n            ) {\n                // skip if either order is invalid\n                continue;\n            }\n\n            // retrieve orders\n            // if the order does not exist, it is created here\n            Perpetuals.Order memory makeOrder = grabOrder(makers, i);\n            Perpetuals.Order memory takeOrder = grabOrder(takers, i);\n\n            bytes32 makerOrderId = Perpetuals.orderId(makeOrder);\n            bytes32 takerOrderId = Perpetuals.orderId(takeOrder);\n\n            uint256 makeOrderFilled = filled[makerOrderId];\n            uint256 takeOrderFilled = filled[takerOrderId];\n\n            uint256 fillAmount = Balances.fillAmount(makeOrder, makeOrderFilled, takeOrder, takeOrderFilled);\n\n            uint256 executionPrice = Perpetuals.getExecutionPrice(makeOrder, takeOrder);\n            uint256 newMakeAverage = Perpetuals.calculateAverageExecutionPrice(\n                makeOrderFilled,\n                averageExecutionPrice[makerOrderId],\n                fillAmount,\n                executionPrice\n            );\n            uint256 newTakeAverage = Perpetuals.calculateAverageExecutionPrice(\n                takeOrderFilled,\n                averageExecutionPrice[takerOrderId],\n                fillAmount,\n                executionPrice\n            );\n\n            // match orders\n            // referencing makeOrder.market is safe due to above require\n            // make low level call to catch revert\n            // todo this could be succeptible to re-entrancy as\n            // market is never verified\n            (bool success, ) = makeOrder.market.call(\n                abi.encodePacked(\n                    ITracerPerpetualSwaps(makeOrder.market).matchOrders.selector,\n                    abi.encode(makeOrder, takeOrder, fillAmount)\n                )\n            );\n\n            // ignore orders that cannot be executed\n            if (!success) continue;\n\n            // update order state\n            filled[makerOrderId] = makeOrderFilled + fillAmount;\n            filled[takerOrderId] = takeOrderFilled + fillAmount;\n            averageExecutionPrice[makerOrderId] = newMakeAverage;\n            averageExecutionPrice[takerOrderId] = newTakeAverage;\n        }\n    }\n\n    /**\n     * @notice Retrieves and validates an order from an order array\n     * @param signedOrders an array of signed orders\n     * @param index the index into the array where the desired order is\n     * @return the specified order\n     * @dev Should only be called with a verified signedOrder and with index\n     *      < signedOrders.length\n     */\n    function grabOrder(Types.SignedLimitOrder[] memory signedOrders, uint256 index)\n        internal\n        returns (Perpetuals.Order memory)\n    {\n        Perpetuals.Order memory rawOrder = signedOrders[index].order;\n\n        bytes32 orderHash = Perpetuals.orderId(rawOrder);\n        // check if order exists on chain, if not, create it\n        if (orders[orderHash].maker == address(0)) {\n            // store this order to keep track of state\n            orders[orderHash] = rawOrder;\n            // map the order hash to the signed order\n            orderToSig[orderHash] = signedOrders[index];\n        }\n\n        return orders[orderHash];\n    }\n\n    /**\n     * @notice hashes a limit order type in order to verify signatures, per EIP712\n     * @param order the limit order being hashed\n     * @return an EIP712 compliant hash (with headers) of the limit order\n     */\n    function hashOrder(Perpetuals.Order memory order) public view override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    EIP712_DOMAIN,\n                    keccak256(\n                        abi.encode(\n                            ORDER_TYPE,\n                            order.maker,\n                            order.market,\n                            order.price,\n                            order.amount,\n                            uint256(order.side),\n                            order.expires,\n                            order.created\n                        )\n                    )\n                )\n            );\n    }\n\n    /**\n     * @notice Gets the EIP712 domain hash of the contract\n     */\n    function getDomain() external view override returns (bytes32) {\n        return EIP712_DOMAIN;\n    }\n\n    /**\n     * @notice Verifies a given limit order has been signed by a given signer and has a correct nonce\n     * @param signer The signer who is being verified against the order\n     * @param signedOrder The signed order to verify the signature of\n     * @return if an order has a valid signature and a valid nonce\n     * @dev does not throw if the signature is invalid.\n     */\n    function isValidSignature(address signer, Types.SignedLimitOrder memory signedOrder) internal view returns (bool) {\n        return verifySignature(signer, signedOrder);\n    }\n\n    /**\n     * @notice Validates a given pair of signed orders against each other\n     * @param signedOrder1 the first signed order\n     * @param signedOrder2 the second signed order\n     * @return if signedOrder1 is compatible with signedOrder2\n     * @dev does not throw if pairs are invalid\n     */\n    function isValidPair(Types.SignedLimitOrder memory signedOrder1, Types.SignedLimitOrder memory signedOrder2)\n        internal\n        pure\n        returns (bool)\n    {\n        return (signedOrder1.order.market == signedOrder2.order.market);\n    }\n\n    /**\n     * @notice Verifies the signature component of a signed order\n     * @param signer The signer who is being verified against the order\n     * @param signedOrder The unsigned order to verify the signature of\n     * @return true is signer has signed the order, else false\n     */\n    function verifySignature(address signer, Types.SignedLimitOrder memory signedOrder)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            signer == ECDSA.recover(hashOrder(signedOrder.order), signedOrder.sigV, signedOrder.sigR, signedOrder.sigS);\n    }\n\n    /**\n     * @return An order that has been previously created in contract, given a user-supplied order\n     * @dev Useful for checking to see if a supplied order has actually been created\n     */\n    function getOrder(Perpetuals.Order calldata order) external view override returns (Perpetuals.Order memory) {\n        bytes32 orderId = Perpetuals.orderId(order);\n        return orders[orderId];\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-06-tracer-findings.json",
                "Location": "executeTrade function in Trader contract",
                "Type": "Reentrancy",
                "Description": "Reentrancy could happen in the executeTrade function of Trader since the makeOrder.market can be a user-controlled external contract.",
                "Repair": "Add a reentrancy guard to prevent users from reentering critical functions"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport './interfaces/IFactory.sol';\nimport './interfaces/IBasket.sol';\nimport \"./interfaces/IAuction.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Auction is IAuction {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant BASE = 1e18;\n    uint256 private constant ONE_DAY = 4 * 60 * 24;\n    uint256 private constant BLOCK_DECREMENT = 10000;\n    \n    bool public override auctionOngoing;\n    uint256 public override auctionStart;\n    bool public override hasBonded;\n    uint256 public override bondAmount;\n    uint256 public override bondTimestamp;\n    bool public override initialized;\n\n    IBasket public override basket;\n    IFactory public override factory;\n    address public override auctionBonder;\n\n    Bounty[] private _bounties;\n\n    modifier onlyBasket() {\n        require(msg.sender == address(basket), 'not basket');\n        _;\n    }\n\n    function startAuction() onlyBasket public override {\n        require(auctionOngoing == false, 'ongoing auction');\n\n        auctionOngoing = true;\n        auctionStart = block.number;\n\n        emit AuctionStarted();\n    }\n\n    function killAuction() onlyBasket public override {\n        auctionOngoing = false;\n    }\n\n    function initialize(address basket_, address factory_) public override {\n        require(!initialized);\n        basket = IBasket(basket_);\n        factory = IFactory(factory_);\n        initialized = true;\n    }\n\n    function bondForRebalance() public override {\n        require(auctionOngoing);\n        require(!hasBonded);\n\n        bondTimestamp = block.number;\n\n        IERC20 basketToken = IERC20(address(basket));\n        bondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\n        basketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\n        hasBonded = true;\n        auctionBonder = msg.sender;\n\n        emit Bonded(msg.sender, bondAmount);\n    }\n\n    function settleAuction(\n        uint256[] memory bountyIDs,\n        address[] memory inputTokens,\n        uint256[] memory inputWeights,\n        address[] memory outputTokens,\n        uint256[] memory outputWeights\n    ) public override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY > block.number);\n        require(msg.sender == auctionBonder);\n\n        for (uint256 i = 0; i < inputTokens.length; i++) {\n            IERC20(inputTokens[i]).safeTransferFrom(msg.sender, address(basket), inputWeights[i]);\n        }\n\n        for (uint256 i = 0; i < outputTokens.length; i++) {\n            IERC20(outputTokens[i]).safeTransferFrom(address(basket), msg.sender, outputWeights[i]);\n        }\n\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondTimestamp - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n        basketAsERC20.transfer(msg.sender, bondAmount);\n        withdrawBounty(bountyIDs);\n        basket.setNewWeights();\n        basket.updateIBRatio(newRatio);\n        auctionOngoing = false;\n        hasBonded = false;\n\n        emit AuctionSettled(msg.sender);\n    }\n\n    function bondBurn() external override {\n        require(auctionOngoing);\n        require(hasBonded);\n        require(bondTimestamp + ONE_DAY <= block.number);\n\n        basket.auctionBurn(bondAmount);\n        hasBonded = false;\n        auctionOngoing = false;\n        basket.deleteNewIndex();\n\n        emit BondBurned(msg.sender, auctionBonder, bondAmount);\n\n        auctionBonder = address(0);\n    }\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n    function withdrawBounty(uint256[] memory bountyIds) internal {\n        // withdraw bounties\n        for (uint256 i = 0; i < bountyIds.length; i++) {\n            Bounty memory bounty = _bounties[bountyIds[i]];\n            require(bounty.active);\n\n            IERC20(bounty.token).transfer(msg.sender, bounty.amount);\n            bounty.active = false;\n\n            emit BountyClaimed(msg.sender, bounty.token, bounty.amount, bountyIds[i]);\n        }\n    }\n }\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-09-defiProtocol-findings.json",
                "Location": "settleAuction() function in Auction.sol",
                "Type": "Reentrancy",
                "Description": "The function calls withdrawBounty() before setting auctionOngoing = false, allowing reentrancy and enabling a malicious publisher to bypass the index timelock mechanism and rug the basket.",
                "Repair": "Move basketAsERC20.transfer() and withdrawBounty() to the end of the function, conforming with Checks Effects Interactions pattern"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport './interfaces/IAuction.sol';\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\ncontract Basket is IBasket, ERC20Upgradeable {\n    using SafeERC20 for IERC20;\n\n    uint256 public constant TIMELOCK_DURATION = 4 * 60 * 24; // 1 day\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) public override {\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory) {\n        return (pendingWeights.tokens, pendingWeights.weights);\n    }\n\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        handleFees();\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        require(balanceOf(msg.sender) >= amount);\n\n        handleFees();\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction external override {\n        handleFees();\n\n        _burn(msg.sender, amount);\n\n        emit Burned(msg.sender, amount);\n    }\n\n    function handleFees() private {\n        if (lastFee == 0) {\n            lastFee = block.timestamp;\n        } else {\n            uint256 startSupply = totalSupply();\n\n            uint256 timeDiff = (block.timestamp - lastFee);\n            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n            uint256 fee = startSupply * feePct / (BASE - feePct);\n\n            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);\n            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n            lastFee = block.timestamp;\n\n            uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(ibRatio);\n        }\n    }\n\n    // changes publisher\n    // timelocked\n    function changePublisher(address newPublisher) onlyPublisher public override {\n        require(newPublisher != address(0));\n\n        if (pendingPublisher.publisher != address(0)) {\n            require(pendingPublisher.publisher == newPublisher);\n            require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);\n            publisher = pendingPublisher.publisher;\n\n            pendingPublisher.publisher = address(0);\n\n            emit ChangedPublisher(publisher);\n        } else {\n            pendingPublisher.publisher = newPublisher;\n            pendingPublisher.block = block.number;\n        }\n    }\n\n    //changes licenseFee\n    // timelocked\n    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {\n        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\n        if (pendingLicenseFee.licenseFee != 0) {\n            require(pendingLicenseFee.licenseFee == newLicenseFee);\n            require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);\n            licenseFee = pendingLicenseFee.licenseFee;\n\n            pendingLicenseFee.licenseFee = 0;\n\n            emit ChangedLicenseFee(licenseFee);\n        } else {\n            pendingLicenseFee.licenseFee = newLicenseFee;\n            pendingLicenseFee.block = block.number;\n        }\n    }\n\n    // publish new index\n    // timelocked\n    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights) onlyPublisher public override {\n        validateWeights(_tokens, _weights);\n\n        if (pendingWeights.pending) {\n            require(block.number >= pendingWeights.block + TIMELOCK_DURATION);\n            if (auction.auctionOngoing() == false) {\n                auction.startAuction();\n\n                emit PublishedNewIndex(publisher);\n            } else if (auction.hasBonded()) {\n\n            } else {\n                auction.killAuction();\n\n                pendingWeights.tokens = _tokens;\n                pendingWeights.weights = _weights;\n                pendingWeights.block = block.number;\n            }\n        } else {\n            pendingWeights.pending = true;\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.block = block.number;\n        }\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n\n    // delete pending index\n    function deleteNewIndex() public override {\n        require(msg.sender == publisher || msg.sender == address(auction));\n        require(auction.auctionOngoing() == false);\n\n        pendingWeights.pending = false;\n\n        emit DeletedNewIndex(publisher);\n    }\n\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n\n    function approveUnderlying(address spender) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            IERC20(tokens[i]).approve(spender, type(uint256).max);\n        }\n    }\n\n    function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-09-defiProtocol-findings.json",
                "Location": "mintTo() and burn() functions in Basket.sol",
                "Type": "Reentrancy",
                "Description": "The functions make external calls prior to updating the state, allowing attackers to mint free basket tokens and reenter the function to mint more tokens than deposited.",
                "Repair": "Move external calls after state updates in accordance with the check-effect-interact pattern"
            }
        ]
    },
    {
        "Code": "pragma solidity >=0.6.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/upgrades/contracts/Initializable.sol\";\n\nimport \"./interfaces/IDAO.sol\";\nimport \"./interfaces/IMiningService.sol\";\nimport \"./interfaces/IDexHandler.sol\";\nimport \"./interfaces/IMaltDataLab.sol\";\n\nimport \"./Permissions.sol\";\n\n\nstruct UserState {\n  uint256 bonded;\n\n  // TODO calculate average bonded period for log calc Tue 03 Aug 2021 11:22:39 BST\n  uint256 bondedEpoch;\n}\n\nstruct EpochState {\n  uint256 lastTotalBonded;\n  uint256 lastUpdateTime;\n  uint256 cumulativeTotalBonded;\n}\n\n\n/// @title LP Bonding\n/// @author 0xScotch <scotch@malt.money>\n/// @notice The contract which LP tokens are bonded to to make a user eligible for protocol rewards\ncontract Bonding is Initializable, Permissions {\n  ERC20 public malt;\n  ERC20 public rewardToken;\n  ERC20 public stakeToken;\n  IDAO public dao;\n  IMiningService public miningService;\n  IDexHandler public dexHandler;\n  IMaltDataLab public maltDataLab;\n\n  uint256 internal _globalBonded;\n  uint256 internal _currentEpoch;\n  address internal offering;\n  mapping(address => UserState) internal userState;\n  mapping(uint256 => EpochState) internal epochState;\n\n  event Bond(address indexed account, uint256 value);\n  event Unbond(address indexed account, uint256 value);\n  event UnbondAndBreak(address indexed account, uint256 amountLPToken, uint256 amountMalt, uint256 amountReward);\n\n  function initialize(\n    address _timelock,\n    address initialAdmin,\n    address _malt,\n    address _rewardToken,\n    address _stakeToken,\n    address _dao,\n    address _miningService,\n    address _offering,\n    address _dexHandler,\n    address _maltDataLab\n  ) external initializer {\n    _adminSetup(_timelock);\n\n    _setupRole(ADMIN_ROLE, initialAdmin);\n\n    dao = IDAO(_dao);\n    offering = _offering;\n    stakeToken = ERC20(_stakeToken);\n    miningService = IMiningService(_miningService);\n    dexHandler = IDexHandler(_dexHandler);\n    malt = ERC20(_malt);\n    rewardToken = ERC20(_rewardToken);\n    maltDataLab = IMaltDataLab(_maltDataLab);\n  }\n\n  function bond(uint256 amount) external {\n    bondToAccount(msg.sender, amount);\n  }\n\n  function bondToAccount(address account, uint256 amount)\n    public\n  {\n    if (msg.sender != offering) {\n      _notSameBlock();\n    }\n    require(amount > 0, \"Cannot bond 0\");\n\n    miningService.onBond(account, amount);\n\n    _bond(account, amount);\n  }\n\n  function unbond(uint256 amount)\n    external\n  {\n    require(amount > 0, \"Cannot unbond 0\");\n\n    uint256 bondedBalance = balanceOfBonded(msg.sender);\n\n    require(bondedBalance > 0, \"< bonded balance\");\n    require(amount <= bondedBalance, \"< bonded balance\");\n\n    // Avoid leaving dust behind\n    if (amount.add(1e16) > bondedBalance) {\n      amount = bondedBalance;\n    }\n\n    miningService.onUnbond(msg.sender, amount);\n\n    _unbond(amount);\n  }\n\n  function unbondAndBreak(uint256 amount)\n    external\n  {\n    require(amount > 0, \"Cannot unbond 0\");\n\n    uint256 bondedBalance = balanceOfBonded(msg.sender);\n\n    require(bondedBalance > 0, \"< bonded balance\");\n    require(amount <= bondedBalance, \"< bonded balance\");\n\n    // Avoid leaving dust behind\n    if (amount.add(1e16) > bondedBalance) {\n      amount = bondedBalance;\n    }\n\n    miningService.onUnbond(msg.sender, amount);\n\n    _unbondAndBreak(amount);\n  }\n\n  /*\n   * PUBLIC VIEW FUNCTIONS\n   */\n  function averageBondedValue(uint256 epoch) public view returns (uint256) {\n    EpochState storage state = epochState[epoch];\n    uint256 epochLength = dao.epochLength();\n    uint256 timeElapsed = epochLength;\n    uint256 epochStartTime = dao.getEpochStartTime(epoch);\n    uint256 diff;\n    uint256 lastUpdateTime = state.lastUpdateTime;\n    uint256 lastTotalBonded = state.lastTotalBonded;\n\n    if (lastUpdateTime == 0) {\n      lastUpdateTime = epochStartTime;\n    }\n\n    if (lastTotalBonded == 0) {\n      lastTotalBonded = _globalBonded;\n    }\n\n    if (block.timestamp < epochStartTime) {\n      return 0;\n    }\n\n    if (epochStartTime + epochLength <= lastUpdateTime) {\n      return maltDataLab.realValueOfLPToken((state.cumulativeTotalBonded) / epochLength);\n    }\n\n    if (epochStartTime + epochLength < block.timestamp) {\n      // The desired epoch is in the past\n      diff = (epochStartTime + epochLength) - lastUpdateTime;\n    } else {\n      diff = block.timestamp - lastUpdateTime;\n      timeElapsed = block.timestamp - epochStartTime;\n    }\n\n    if (timeElapsed == 0) {\n      // Only way timeElapsed should == 0 is when block.timestamp == epochStartTime\n      // Therefore just return the lastTotalBonded value\n      return maltDataLab.realValueOfLPToken(lastTotalBonded);\n    }\n\n    uint256 endValue = state.cumulativeTotalBonded + (lastTotalBonded.mul(diff));\n    return maltDataLab.realValueOfLPToken((endValue) / timeElapsed);\n  }\n\n  function totalBonded() public view returns (uint256) {\n    return _globalBonded;\n  }\n\n  function balanceOfBonded(address account) public view returns (uint256) {\n    return userState[account].bonded;\n  }\n\n  function bondedEpoch(address account) public view returns (uint256) {\n    return userState[account].bondedEpoch;\n  }\n\n  function epochData(uint256 epoch) public view returns(uint256, uint256, uint256) {\n    return (epochState[epoch].lastTotalBonded, epochState[epoch].lastUpdateTime, epochState[epoch].cumulativeTotalBonded);\n  }\n\n  /*\n   * INTERNAL VIEW FUNCTIONS\n   */\n  function _balanceCheck() internal view {\n    require(stakeToken.balanceOf(address(this)) >= totalBonded(), \"Balance inconsistency\");\n  }\n\n  /*\n   * INTERNAL FUNCTIONS\n   */\n  function _bond(address account, uint256 amount) internal {\n    stakeToken.safeTransferFrom(msg.sender, address(this), amount);\n\n    _addToBonded(account, amount);\n\n    _balanceCheck();\n\n    emit Bond(account, amount);\n  }\n\n  function _unbond(uint256 amountLPToken) internal notSameBlock {\n    _removeFromBonded(msg.sender, amountLPToken, \"LP: Insufficient bonded balance\");\n\n    stakeToken.safeTransfer(msg.sender, amountLPToken);\n\n    _balanceCheck();\n\n    emit Unbond(msg.sender, amountLPToken);\n  }\n\n  function _unbondAndBreak(uint256 amountLPToken) internal notSameBlock {\n    _removeFromBonded(msg.sender, amountLPToken, \"LP: Insufficient bonded balance\");\n\n    stakeToken.safeTransfer(address(dexHandler), amountLPToken);\n\n    (uint256 amountMalt, uint256 amountReward) = dexHandler.removeLiquidity();\n\n    malt.safeTransfer(msg.sender, amountMalt);\n    rewardToken.safeTransfer(msg.sender, amountReward);\n\n    _balanceCheck();\n\n    emit UnbondAndBreak(msg.sender, amountLPToken, amountMalt, amountReward);\n  }\n\n  function _addToBonded(address account, uint256 amount) internal {\n    userState[account].bonded = userState[account].bonded.add(amount);\n\n    _updateEpochState(_globalBonded.add(amount));\n\n    if (userState[account].bondedEpoch == 0) {\n      userState[account].bondedEpoch = dao.epoch();\n    }\n  }\n\n  function _removeFromBonded(address account, uint256 amount, string memory reason) internal {\n    userState[account].bonded = userState[account].bonded.sub(amount, reason);\n\n    _updateEpochState(_globalBonded.sub(amount, reason));\n  }\n\n  function _updateEpochState(uint256 newTotalBonded) internal {\n    EpochState storage state = epochState[_currentEpoch];\n    uint256 epoch = dao.epoch();\n    uint256 epochStartTime = dao.getEpochStartTime(_currentEpoch);\n    uint256 lastUpdateTime = state.lastUpdateTime;\n    uint256 lengthOfEpoch = dao.epochLength();\n    uint256 epochEndTime = epochStartTime + lengthOfEpoch;\n\n    if (lastUpdateTime == 0) {\n      lastUpdateTime = epochStartTime;\n    }\n\n    if (lastUpdateTime > epochEndTime) {\n      lastUpdateTime = epochEndTime;\n    }\n\n    if (epoch == _currentEpoch) {\n      // We are still in the same epoch. Just update\n      uint256 finalTime = block.timestamp;\n      if (block.timestamp > epochEndTime) {\n        // We are past the end of the epoch so cap to end of epoch\n        finalTime = epochEndTime;\n      } \n\n      uint256 diff = finalTime - lastUpdateTime;\n\n      if (diff > 0) {\n        state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));\n\n        state.lastUpdateTime = finalTime;\n        state.lastTotalBonded = newTotalBonded;\n      }\n    } else {\n      // We have crossed at least 1 epoch boundary\n\n      // Won't underflow due to check on lastUpdateTime above\n      uint256 diff = epochEndTime - lastUpdateTime;\n\n      state.cumulativeTotalBonded = state.cumulativeTotalBonded + (state.lastTotalBonded.mul(diff));\n      state.lastUpdateTime = epochEndTime;\n      state.lastTotalBonded = _globalBonded;\n\n      for (uint256 i = _currentEpoch + 1; i <= epoch; i += 1) {\n        state = epochState[i];\n        epochStartTime = dao.getEpochStartTime(i);\n        epochEndTime = epochStartTime + lengthOfEpoch;\n        state.lastTotalBonded = _globalBonded;\n\n        if (epochEndTime < block.timestamp) {\n          // The desired epoch is in the past\n          diff = lengthOfEpoch;\n          state.lastUpdateTime = epochEndTime;\n        } else {\n          diff = block.timestamp - epochStartTime;\n          state.lastUpdateTime = block.timestamp;\n        }\n\n        state.cumulativeTotalBonded = state.lastTotalBonded.mul(diff);\n      }\n\n      state.lastTotalBonded = newTotalBonded;\n      _currentEpoch = epoch;\n    } \n\n    _globalBonded = newTotalBonded;\n  }\n\n  /*\n   * PRIVILEDGED FUNCTIONS\n   */\n  function setMiningService(address _miningService)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_miningService != address(0), \"Cannot set 0 address\");\n    miningService = IMiningService(_miningService);\n  }\n\n  function setDAO(address _dao)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_dao != address(0), \"Cannot set 0 address\");\n    dao = IDAO(_dao);\n  }\n\n  function setDexHandler(address _dexHandler)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    require(_dexHandler != address(0), \"Cannot set 0 address\");\n    dexHandler = IDexHandler(_dexHandler);\n  }\n\n  function setCurrentEpoch(uint256 _epoch)\n    public\n    onlyRole(ADMIN_ROLE, \"Must have admin privs\")\n  {\n    _currentEpoch = _epoch;\n  }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-11-malt-findings.json",
                "Location": "Bonding.sol",
                "Type": "Reentrancy",
                "Description": "The _notSameBlock() function in Bonding.sol can be circumvented in bondToAccount() by calling it via a smart contract, leading to potential risks from reentrancy attacks.",
                "Repair": "Add access controls to the function bondToAccount() to prevent reentrancy attacks"
            }
        ]
    },
    {
        "Code": "pragma solidity =0.8.7;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC20Upgradeable } from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport './interfaces/IAuction.sol';\nimport \"./interfaces/IBasket.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"hardhat/console.sol\";\n\n//TODO: add revert reasons or v8 custom errors back in\ncontract Basket is IBasket, ERC20Upgradeable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    //TODO: recommend using block timestamp instead of block numbers here\n    uint256 public constant TIMELOCK_DURATION = 1 days; // 1 day\n    uint256 public constant ONE_YEAR = 365.25 days;\n    uint256 private constant BASE = 1e18;\n\n    uint256 public maxSupply;\n\n    address public publisher;\n    uint256 public licenseFee;\n\n    IFactory public override factory;\n    IAuction public override auction;\n\n    uint256 public override ibRatio;\n\n    PendingPublisher public pendingPublisher;\n    PendingLicenseFee public pendingLicenseFee;\n    PendingWeights public pendingWeights;\n    PendingMaxSupply public pendingMaxSupply;\n\n    address[] public tokens;\n    uint256[] public weights;\n\n    uint256 public override lastFee;\n\n    bool public override initialized;\n\n    function initialize(IFactory.Proposal memory proposal, IAuction auction_) external override {\n        require(address(factory) == address(0));\n        require(!initialized);\n\n        publisher = proposal.proposer;\n        licenseFee = proposal.licenseFee;\n        factory = IFactory(msg.sender);\n        auction = auction_;\n        ibRatio = BASE;\n        tokens = proposal.tokens;\n        weights = proposal.weights;\n        maxSupply = proposal.maxSupply;\n        approveUnderlying(address(auction));\n\n        __ERC20_init(proposal.tokenName, proposal.tokenSymbol);\n\n        initialized = true;\n    }\n\n    function getPendingWeights() external override view returns (address[] memory, uint256[] memory, uint256) {\n        return (pendingWeights.tokens, pendingWeights.weights, pendingWeights.minIbRatio);\n    }\n\n    function validateWeights(address[] memory _tokens, uint256[] memory _weights) public override pure {\n        require(_tokens.length > 0);\n        require(_tokens.length == _weights.length);\n        uint256 length = _tokens.length;\n        address[] memory tokenList = new address[](length);\n\n        // check uniqueness of tokens and not token(0)\n\n        for (uint i = 0; i < length; i++) {\n            require(_tokens[i] != address(0));\n            require(_weights[i] > 0);\n\n            for (uint256 x = 0; x < tokenList.length; x++) {\n                require(_tokens[i] != tokenList[x]);\n            }\n\n            tokenList[i] = _tokens[i];\n        }\n    }\n\n    function mint(uint256 amount) public override {\n        mintTo(amount, msg.sender);\n    }\n\n    function mintTo(uint256 amount, address to) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n        uint256 startSupply = totalSupply();\n        require(startSupply + amount <= maxSupply);\n\n        handleFees(startSupply);\n\n        pullUnderlying(amount, msg.sender);\n\n        _mint(to, amount);\n\n        require(totalSupply() <= maxSupply);\n\n        emit Minted(to, amount);\n    }\n\n    function burn(uint256 amount) public nonReentrant override {\n        require(auction.auctionOngoing() == false);\n        require(amount > 0);\n\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n\n        pushUnderlying(amount, msg.sender);\n        _burn(msg.sender, amount);\n        \n        emit Burned(msg.sender, amount);\n    }\n\n    function auctionBurn(uint256 amount) onlyAuction nonReentrant external override {\n        uint256 startSupply = totalSupply();\n        handleFees(startSupply);\n        _burn(msg.sender, amount);\n\n        uint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);\n        ibRatio = newIbRatio;\n\n        emit NewIBRatio(newIbRatio);\n        emit Burned(msg.sender, amount);\n    }\n\n    function handleFees(uint256 startSupply) private {\n        if (lastFee == 0) {\n            lastFee = block.timestamp;\n        } else if (startSupply == 0) {\n            return;\n        } else {\n            uint256 timeDiff = (block.timestamp - lastFee);\n            uint256 feePct = timeDiff * licenseFee / ONE_YEAR;\n            uint256 fee = startSupply * feePct / (BASE - feePct);\n\n\n            _mint(publisher, fee * (BASE - factory.ownerSplit()) / BASE);\n            _mint(Ownable(address(factory)).owner(), fee * factory.ownerSplit() / BASE);\n            lastFee = block.timestamp;\n\n            uint256 newIbRatio = ibRatio * startSupply / totalSupply();\n            ibRatio = newIbRatio;\n\n            emit NewIBRatio(ibRatio);\n        }\n    }\n\n    // changes publisher\n    // timelocked\n    function changePublisher(address newPublisher) onlyPublisher public override {\n        require(newPublisher != address(0));\n\n        if (pendingPublisher.publisher != address(0) && pendingPublisher.publisher == newPublisher) {\n            require(block.timestamp >= pendingPublisher.timestamp + TIMELOCK_DURATION);\n            publisher = newPublisher;\n\n            pendingPublisher.publisher = address(0);\n\n            emit ChangedPublisher(publisher);\n        } else {\n            pendingPublisher.publisher = newPublisher;\n            pendingPublisher.timestamp = block.timestamp;\n\n            emit NewPublisherSubmitted(newPublisher);\n        }\n    }\n\n    //changes licenseFee\n    // timelocked\n    function changeLicenseFee(uint256 newLicenseFee) onlyPublisher public override {\n        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\n        if (pendingLicenseFee.licenseFee != 0 && pendingLicenseFee.licenseFee == newLicenseFee) {\n            require(block.timestamp >= pendingLicenseFee.timestamp + TIMELOCK_DURATION);\n            licenseFee = newLicenseFee;\n\n            pendingLicenseFee.licenseFee = 0;\n\n            emit ChangedLicenseFee(licenseFee);\n        } else {\n            pendingLicenseFee.licenseFee = newLicenseFee;\n            pendingLicenseFee.timestamp = block.timestamp;\n\n            emit NewLicenseFeeSubmitted(newLicenseFee);\n        }\n    }\n\n    //changes maxSupply\n    // timelocked\n    function setNewMaxSupply(uint256 newMaxSupply) onlyPublisher public override {\n        require(newMaxSupply > totalSupply());\n\n        if (pendingMaxSupply.maxSupply != 0 && pendingMaxSupply.maxSupply == newMaxSupply) {\n            require(block.timestamp >= pendingMaxSupply.timestamp + TIMELOCK_DURATION);\n            maxSupply = newMaxSupply;\n\n            pendingMaxSupply.maxSupply = 0;\n\n            emit ChangedMaxSupply(newMaxSupply);\n        } else {\n            pendingMaxSupply.maxSupply = newMaxSupply;\n            pendingMaxSupply.timestamp = block.timestamp;\n\n            emit NewMaxSupplySubmitted(newMaxSupply);\n        }\n    }\n\n    // publish new index\n    // timelocked\n    function publishNewIndex(address[] memory _tokens, uint256[] memory _weights, uint256 _minIbRatio) onlyPublisher public override {\n        validateWeights(_tokens, _weights);\n\n        if (pendingWeights.pending) {\n            require(block.timestamp >= pendingWeights.timestamp + TIMELOCK_DURATION);\n            if (auction.auctionOngoing() == false) {\n                auction.startAuction();\n\n                emit PublishedNewIndex(publisher);\n            } else if (auction.hasBonded()) {\n\n            } else {\n                auction.killAuction();\n\n                pendingWeights.tokens = _tokens;\n                pendingWeights.weights = _weights;\n                pendingWeights.timestamp = block.timestamp;\n                pendingWeights.minIbRatio = _minIbRatio;\n            }\n        } else {\n            pendingWeights.pending = true;\n            pendingWeights.tokens = _tokens;\n            pendingWeights.weights = _weights;\n            pendingWeights.timestamp = block.timestamp;\n            pendingWeights.minIbRatio = _minIbRatio;\n\n            emit NewIndexSubmitted();\n        }\n    }\n\n    function setNewWeights() onlyAuction external override {\n        tokens = pendingWeights.tokens;\n        weights = pendingWeights.weights;\n        pendingWeights.pending = false;\n\n        approveUnderlying(address(auction));\n\n        emit WeightsSet();\n    }\n\n    // delete pending index\n    function deleteNewIndex() public override {\n        require(msg.sender == publisher || msg.sender == address(auction));\n        require(auction.auctionOngoing() == false);\n\n        pendingWeights.pending = false;\n\n        emit DeletedNewIndex(msg.sender);\n    }\n\n    function updateIBRatio(uint256 newRatio) onlyAuction external override returns (uint256) {\n        ibRatio = newRatio;\n\n        emit NewIBRatio(ibRatio);\n\n        return ibRatio;\n    }\n\n    function approveUnderlying(address spender) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            IERC20(tokens[i]).safeApprove(spender, 0);\n            IERC20(tokens[i]).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    function pushUnderlying(uint256 amount, address to) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            IERC20(tokens[i]).safeTransfer(to, tokenAmount);\n        }\n    }\n\n    function pullUnderlying(uint256 amount, address from) private {\n        for (uint256 i = 0; i < weights.length; i++) {\n            uint256 tokenAmount = amount * weights[i] * ibRatio / BASE / BASE;\n            require(tokenAmount > 0);\n            IERC20(tokens[i]).safeTransferFrom(from, address(this), tokenAmount);\n        }\n    }\n\n    modifier onlyAuction() {\n        require(msg.sender == address(auction));\n        _;\n    }\n\n    modifier onlyPublisher() {\n        require(msg.sender == address(publisher));\n        _;\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-12-defiprotocol-findings.json",
                "Location": "Basket contract's initialize() method",
                "Type": "Reentrancy",
                "Description": "A malicious publisher can create a basket proposal that mixes real ERC20 tokens with a malicious ERC20 token containing a reentrancy callback in its approve() method.",
                "Repair": "Use the initializer modifier available in ERC20Upgradeable to prevent reentrancy attacks"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.6.11;\n\nimport \"./Interfaces/IBorrowerOperations.sol\";\nimport \"./Interfaces/ITroveManager.sol\";\nimport \"./Interfaces/IYUSDToken.sol\";\nimport \"./Interfaces/ICollSurplusPool.sol\";\nimport \"./Interfaces/ISortedTroves.sol\";\nimport \"./Interfaces/ISYETI.sol\";\nimport \"./Interfaces/IWhitelist.sol\";\nimport \"./Interfaces/IYetiRouter.sol\";\nimport \"./Interfaces/IERC20.sol\";\nimport \"./Dependencies/LiquityBase.sol\";\nimport \"./Dependencies/Ownable.sol\";\nimport \"./Dependencies/CheckContract.sol\";\nimport \"./Dependencies/SafeMath.sol\";\nimport \"./Dependencies/ReentrancyGuard.sol\";\nimport \"./Interfaces/IWAsset.sol\";\n\n/** \n * BorrowerOperations is the contract that handles most of external facing trove activities that \n * a user would make with their own trove, like opening, closing, adjusting, increasing leverage, etc.\n */\n\n /**\n   A summary of Lever Up:\n   Takes in a collateral token A, and simulates borrowing of YUSD at a certain collateral ratio and\n   buying more token A, putting back into protocol, buying more A, etc. at a certain leverage amount.\n   So if at 3x leverage and 1000$ token A, it will mint 1000 * 3x * 2/3 = $2000 YUSD, then swap for\n   token A by using some router strategy, returning a little under $2000 token A to put back in the\n   trove. The number here is 2/3 because the math works out to be that collateral ratio is 150% if\n   we have a 3x leverage. They now have a trove with $3000 of token A and a collateral ratio of 150%.\n  */\n\ncontract BorrowerOperations is LiquityBase, Ownable, CheckContract, IBorrowerOperations, ReentrancyGuard {\n    using SafeMath for uint256;\n    string public constant NAME = \"BorrowerOperations\";\n\n    // --- Connected contract declarations ---\n\n    ITroveManager internal troveManager;\n\n    address internal stabilityPoolAddress;\n\n    address internal gasPoolAddress;\n\n    ICollSurplusPool internal collSurplusPool;\n\n    ISYETI internal sYETI;\n    address internal sYETIAddress;\n\n    IYUSDToken internal yusdToken;\n\n    uint internal constant BOOTSTRAP_PERIOD = 14 days;\n    uint deploymentTime;\n\n    // A doubly linked list of Troves, sorted by their collateral ratios\n    ISortedTroves internal sortedTroves;\n\n    struct CollateralData {\n        address collateral;\n        uint256 amount;\n    }\n\n    struct DepositFeeCalc {\n        uint256 collateralYUSDFee;\n        uint256 systemCollateralVC;\n        uint256 collateralInputVC;\n        uint256 systemTotalVC;\n        address token;\n    }\n\n    /* --- Variable container structs  ---\n\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n    struct AdjustTrove_Params {\n        address[] _collsIn;\n        uint256[] _amountsIn;\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        uint256 _YUSDChange;\n        uint256 _totalYUSDDebtFromLever;\n        bool _isDebtIncrease;\n        bool _isUnlever;\n        address _upperHint;\n        address _lowerHint;\n        uint256 _maxFeePercentage;\n    }\n\n    struct LocalVariables_adjustTrove {\n        uint256 netDebtChange;\n        bool isCollIncrease;\n        uint256 collChange;\n        uint256 currVC;\n        uint256 newVC;\n        uint256 debt;\n        address[] currAssets;\n        uint256[] currAmounts;\n        address[] newAssets;\n        uint256[] newAmounts;\n        uint256 oldICR;\n        uint256 newICR;\n        uint256 newTCR;\n        uint256 YUSDFee;\n        uint256 variableYUSDFee;\n        uint256 newDebt;\n        uint256 VCin;\n        uint256 VCout;\n        uint256 maxFeePercentageFactor;\n    }\n\n    struct LocalVariables_openTrove {\n        address[] collaterals;\n        uint256[] prices;\n        uint256 YUSDFee;\n        uint256 netDebt;\n        uint256 compositeDebt;\n        uint256 ICR;\n        uint256 arrayIndex;\n        address collAddress;\n        uint256 VC;\n        uint256 newTCR;\n        bool isRecoveryMode;\n    }\n\n    struct CloseTrove_Params {\n        address[] _collsOut;\n        uint256[] _amountsOut;\n        uint256[] _maxSlippages;\n        bool _isUnlever;\n    }\n\n    struct ContractsCache {\n        ITroveManager troveManager;\n        IActivePool activePool;\n        IYUSDToken yusdToken;\n    }\n\n    enum BorrowerOperation {\n        openTrove,\n        closeTrove,\n        adjustTrove\n    }\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event YUSDTokenAddressChanged(address _yusdTokenAddress);\n    event SYETIAddressChanged(address _sYETIAddress);\n\n    event TroveCreated(address indexed _borrower, uint256 arrayIndex);\n    event TroveUpdated(\n        address indexed _borrower,\n        uint256 _debt,\n        address[] _tokens,\n        uint256[] _amounts,\n        BorrowerOperation operation\n    );\n    event YUSDBorrowingFeePaid(address indexed _borrower, uint256 _YUSDFee);\n\n    // --- Dependency setters ---\n\n    function setAddresses(\n        address _troveManagerAddress,\n        address _activePoolAddress,\n        address _defaultPoolAddress,\n        address _stabilityPoolAddress,\n        address _gasPoolAddress,\n        address _collSurplusPoolAddress,\n        address _sortedTrovesAddress,\n        address _yusdTokenAddress,\n        address _sYETIAddress,\n        address _whitelistAddress\n    ) external override onlyOwner {\n        // This makes impossible to open a trove with zero withdrawn YUSD\n        require(MIN_NET_DEBT != 0, \"BO:MIN_NET_DEBT==0\");\n\n        deploymentTime = block.timestamp;\n\n        checkContract(_troveManagerAddress);\n        checkContract(_activePoolAddress);\n        checkContract(_defaultPoolAddress);\n        checkContract(_stabilityPoolAddress);\n        checkContract(_gasPoolAddress);\n        checkContract(_collSurplusPoolAddress);\n        checkContract(_sortedTrovesAddress);\n        checkContract(_yusdTokenAddress);\n        checkContract(_sYETIAddress);\n        checkContract(_whitelistAddress);\n\n        troveManager = ITroveManager(_troveManagerAddress);\n        activePool = IActivePool(_activePoolAddress);\n        defaultPool = IDefaultPool(_defaultPoolAddress);\n        whitelist = IWhitelist(_whitelistAddress);\n        stabilityPoolAddress = _stabilityPoolAddress;\n        gasPoolAddress = _gasPoolAddress;\n        collSurplusPool = ICollSurplusPool(_collSurplusPoolAddress);\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\n        yusdToken = IYUSDToken(_yusdTokenAddress);\n        sYETIAddress = _sYETIAddress;\n\n        emit TroveManagerAddressChanged(_troveManagerAddress);\n        emit ActivePoolAddressChanged(_activePoolAddress);\n        emit DefaultPoolAddressChanged(_defaultPoolAddress);\n        emit StabilityPoolAddressChanged(_stabilityPoolAddress);\n        emit GasPoolAddressChanged(_gasPoolAddress);\n        emit CollSurplusPoolAddressChanged(_collSurplusPoolAddress);\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\n        emit YUSDTokenAddressChanged(_yusdTokenAddress);\n        emit SYETIAddressChanged(_sYETIAddress);\n\n        _renounceOwnership();\n    }\n\n    // --- Borrower Trove Operations ---\n\n    function openTrove(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] calldata _colls,\n        uint256[] calldata _amounts\n    ) external override nonReentrant {\n        _requireLengthNonzero(_amounts.length);\n        _requireValidDepositCollateral(_colls, _amounts);\n        _requireNoDuplicateColls(_colls); // Check that there is no overlap in _colls\n\n        // transfer collateral into ActivePool\n        _transferCollateralsIntoActivePool(msg.sender, _colls, _amounts);\n\n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            0,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // Lever up. Takes in a leverage amount (11x) and a token, and calculates the amount\n    // of that token that would be at the specific collateralization ratio. Mints YUSD\n    // according to the price of the token and the amount. Calls LeverUp.sol's\n    // function to perform the swap through a router or our special staked tokens, depending\n    // on the token. Then opens a trove with the new collateral from the swap, ensuring that\n    // the amount is enough to cover the debt. There is no new debt taken out from the trove,\n    // and the amount minted previously is attributed to this trove. Reverts if the swap was\n    // not able to get the correct amount of collateral according to slippage passed in.\n    // _leverage is like 11e18 for 11x. \n    function openTroveLeverUp(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts, \n        uint256[] memory _leverages,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant{\n        uint256 collsLen = _colls.length;\n        _requireLengthNonzero(collsLen);\n        _requireValidDepositCollateral(_colls, _amounts);\n        // Must check additional passed in arrays\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(_colls);\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i < collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _colls[i],\n                    _amounts[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amounts[i] = additionalTokenAmount.add(_amounts[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        \n        _openTroveInternal(\n            msg.sender,\n            _maxFeePercentage,\n            _YUSDAmount,\n            totalYUSDDebtFromLever,\n            _upperHint,\n            _lowerHint,\n            _colls,\n            _amounts\n        );\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist's approved router. \n    function _singleLeverUp(address _token, \n        uint256 _amount, \n        uint256 _leverage, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalTokenAmount, uint256 _additionalYUSDDebt) {\n        require(_leverage > 1e18, \"WrongLeverage\");\n        require(_maxSlippage <= 1e18, \"WrongSlippage\");\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // leverage is 5e18 for 5x leverage. Minus 1 for what the user already has in collateral value.\n        uint _additionalTokenAmount = _amount.mul(_leverage.sub(1e18)).div(1e18); \n        _additionalYUSDDebt = whitelist.getValueUSD(_token, _additionalTokenAmount);\n\n        // 1/(1-1/ICR) = leverage. (1 - 1/ICR) = 1/leverage\n        // 1 - 1/leverage = 1/ICR. ICR = 1/(1 - 1/leverage) = (1/((leverage-1)/leverage)) = leverage / (leverage - 1)\n        // ICR = leverage / (leverage - 1)\n        \n        // ICR = VC value of collateral / debt \n        // debt = VC value of collateral / ICR.\n        // debt = VC value of collateral * (leverage - 1) / leverage\n\n        uint256 slippageAdjustedValue = _additionalTokenAmount.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        \n        yusdToken.mint(address(this), _additionalYUSDDebt);\n        yusdToken.approve(address(router), _additionalYUSDDebt);\n        // route will swap the tokens and transfer it to the active pool automatically. Router will send to active pool and \n        // reward balance will be sent to the user if wrapped asset. \n        IERC20 erc20Token = IERC20(_token);\n        uint256 balanceBefore = erc20Token.balanceOf(address(activePool));\n        _finalTokenAmount = router.route(address(this), address(yusdToken), _token, _additionalYUSDDebt, slippageAdjustedValue);\n        require(erc20Token.balanceOf(address(activePool)) == balanceBefore.add(_finalTokenAmount), \"BO:RouteLeverUpNotSent\");\n    }\n\n\n    // amounts should be a uint array giving the amount of each collateral\n    // to be transferred in in order of the current whitelist\n    // Should be called *after* collateral has been already sent to the active pool\n    // Should confirm _colls, is valid collateral prior to calling this\n    function _openTroveInternal(\n        address _troveOwner,\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        uint256 _totalYUSDDebtFromLever,\n        address _upperHint,\n        address _lowerHint,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        LocalVariables_openTrove memory vars;\n\n        vars.isRecoveryMode = _checkRecoveryMode();\n\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireValidMaxFeePercentage(_maxFeePercentage, vars.isRecoveryMode);\n        _requireTroveisNotActive(contractsCache.troveManager, _troveOwner);\n\n        vars.netDebt = _YUSDAmount;\n\n        // For every collateral type in, calculate the VC and get the variable fee\n        vars.VC = _getVC(_colls, _amounts);\n\n        if (!vars.isRecoveryMode) {\n            // when not in recovery mode, add in the 0.5% fee\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                _YUSDAmount,\n                vars.VC, // here it is just VC in, which is always larger than YUSD amount\n                _maxFeePercentage\n            );\n            _maxFeePercentage = _maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.VC));\n        }\n\n        // Add in variable fee. Always present, even in recovery mode.\n        vars.YUSDFee = vars.YUSDFee.add(\n            _getTotalVariableDepositFee(_colls, _amounts, vars.VC, 0, vars.VC, _maxFeePercentage, contractsCache)\n        );\n\n        // Adds total fees to netDebt\n        vars.netDebt = vars.netDebt.add(vars.YUSDFee); // The raw debt change includes the fee\n\n        _requireAtLeastMinNetDebt(vars.netDebt);\n        // ICR is based on the composite debt, i.e. the requested YUSD amount + YUSD borrowing fee + YUSD gas comp.\n        // _getCompositeDebt returns  vars.netDebt + YUSD gas comp.\n        vars.compositeDebt = _getCompositeDebt(vars.netDebt);\n\n        vars.ICR = LiquityMath._computeCR(vars.VC, vars.compositeDebt);\n        if (vars.isRecoveryMode) {\n            _requireICRisAboveCCR(vars.ICR);\n        } else {\n            _requireICRisAboveMCR(vars.ICR);\n            vars.newTCR = _getNewTCRFromTroveChange(vars.VC, true, vars.compositeDebt, true); // bools: coll increase, debt increase\n            _requireNewTCRisAboveCCR(vars.newTCR);\n        }\n\n        // Set the trove struct's properties\n        contractsCache.troveManager.setTroveStatus(_troveOwner, 1);\n\n        contractsCache.troveManager.updateTroveColl(_troveOwner, _colls, _amounts);\n        contractsCache.troveManager.increaseTroveDebt(_troveOwner, vars.compositeDebt);\n\n        contractsCache.troveManager.updateTroveRewardSnapshots(_troveOwner);\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(_troveOwner);\n\n        sortedTroves.insert(_troveOwner, vars.ICR, _upperHint, _lowerHint);\n        vars.arrayIndex = contractsCache.troveManager.addTroveOwnerToArray(_troveOwner);\n        emit TroveCreated(_troveOwner, vars.arrayIndex);\n\n        contractsCache.activePool.receiveCollateral(_colls, _amounts);\n\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            _troveOwner,\n            _YUSDAmount.sub(_totalYUSDDebtFromLever),\n            vars.netDebt\n        );\n\n        // Move the YUSD gas compensation to the Gas Pool\n        _withdrawYUSD(\n            contractsCache.activePool,\n            contractsCache.yusdToken,\n            gasPoolAddress,\n            YUSD_GAS_COMPENSATION,\n            YUSD_GAS_COMPENSATION\n        );\n\n        emit TroveUpdated(\n            _troveOwner,\n            vars.compositeDebt,\n            _colls,\n            _amounts,\n            BorrowerOperation.openTrove\n        );\n        emit YUSDBorrowingFeePaid(_troveOwner, vars.YUSDFee);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params. \n    function addColl(\n        address[] calldata _collsIn,\n        uint256[] calldata _amountsIn,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, params._amountsIn);\n        _requireNoDuplicateColls(_collsIn); // Check that there is no overlap with in or out in itself\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, params._collsIn, params._amountsIn);\n        _adjustTrove(params);\n    }\n\n\n    // add collateral to trove. Calls _adjustTrove with correct params.\n    function addCollLeverUp(\n        address[] memory _collsIn,\n        uint256[] memory _amountsIn,\n        uint256[] memory _leverages,\n        uint256[] memory _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint, \n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._maxFeePercentage = _maxFeePercentage;\n        uint256 collsLen = _collsIn.length;\n\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        // Must check that other passed in arrays are correct length\n        _requireLengthsEqual(collsLen, _leverages.length);\n        _requireLengthsEqual(collsLen, _maxSlippages.length);\n        _requireNoDuplicateColls(params._collsIn); // Check that there is no overlap with in or out in itself\n\n        uint additionalTokenAmount;\n        uint additionalYUSDDebt;\n        uint totalYUSDDebtFromLever;\n        for (uint256 i; i < collsLen; ++i) {\n            if (_leverages[i] != 0) {\n                (additionalTokenAmount, additionalYUSDDebt) = _singleLeverUp(\n                    _collsIn[i],\n                    _amountsIn[i],\n                    _leverages[i],\n                    _maxSlippages[i]\n                );\n                // Transfer into active pool, non levered amount. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n                // additional token amount was set to the original amount * leverage. \n                _amountsIn[i] = additionalTokenAmount.add(_amountsIn[i]);\n                totalYUSDDebtFromLever = totalYUSDDebtFromLever.add(additionalYUSDDebt);\n            } else {\n                // Otherwise skip and do normal transfer that amount into active pool. \n                _singleTransferCollateralIntoActivePool(msg.sender, _collsIn[i], _amountsIn[i]);\n            }\n        }\n        _YUSDAmount = _YUSDAmount.add(totalYUSDDebtFromLever);\n        params._totalYUSDDebtFromLever = totalYUSDDebtFromLever;\n\n        params._YUSDChange = _YUSDAmount;\n        params._isDebtIncrease = true;\n\n        params._collsIn = _collsIn;\n        params._amountsIn = _amountsIn;\n        _adjustTrove(params);\n    }\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params. \n    function withdrawColl(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(params._collsOut, params._amountsOut);\n        _requireNoDuplicateColls(params._collsOut); // Check that there is no overlap with in or out in itself\n\n        _adjustTrove(params);\n    }\n\n    // Withdraw YUSD tokens from a trove: mint new YUSD tokens to the owner, and increase the trove's debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function withdrawYUSD(\n        uint256 _maxFeePercentage,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._maxFeePercentage = _maxFeePercentage;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = true;\n        _adjustTrove(params);\n    }\n\n    // Repay YUSD tokens to a Trove: Burn the repaid YUSD tokens, and reduce the trove's debt accordingly. \n    // Calls _adjustTrove with correct params. \n    function repayYUSD(\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n    ) external override nonReentrant {\n        AdjustTrove_Params memory params;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isDebtIncrease = false;\n        _adjustTrove(params);\n    }\n\n    // Adjusts trove with multiple colls in / out. Calls _adjustTrove with correct params.\n    function adjustTrove(\n        address[] calldata _collsIn,\n        uint256[] memory _amountsIn,\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        address _upperHint,\n        address _lowerHint,\n        uint256 _maxFeePercentage\n    ) external override nonReentrant {\n        // check that all _collsIn collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsIn, _amountsIn);\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoOverlapColls(_collsIn, _collsOut); // check that there are no overlap between _collsIn and _collsOut\n        _requireNoDuplicateColls(_collsIn);\n        _requireNoDuplicateColls(_collsOut);\n\n        // pull in deposit collateral\n        _transferCollateralsIntoActivePool(msg.sender, _collsIn, _amountsIn);\n        uint256[] memory maxSlippages = new uint256[](0);\n\n        AdjustTrove_Params memory params = AdjustTrove_Params(\n            _collsIn,\n            _amountsIn,\n            _collsOut,\n            _amountsOut,\n            maxSlippages,\n            _YUSDChange,\n            0,\n            _isDebtIncrease,\n            false,\n            _upperHint,\n            _lowerHint,\n            _maxFeePercentage\n        );\n\n        _adjustTrove(params);\n    }\n\n    /*\n     * _adjustTrove(): Alongside a debt change, this function can perform either a collateral top-up or a collateral withdrawal.\n     * the ith element of _amountsIn and _amountsOut corresponds to the ith element of the addresses _collsIn and _collsOut passed in\n     *\n     * Should be called after the collsIn has been sent to ActivePool\n     */\n    function _adjustTrove(AdjustTrove_Params memory params) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n        LocalVariables_adjustTrove memory vars;\n\n        bool isRecoveryMode = _checkRecoveryMode();\n\n        if (params._isDebtIncrease) {\n            _requireValidMaxFeePercentage(params._maxFeePercentage, isRecoveryMode);\n            _requireNonZeroDebtChange(params._YUSDChange);\n        }\n\n        // Checks that at least one array is non-empty, and also that at least one value is 1. \n        _requireNonZeroAdjustment(params._amountsIn, params._amountsOut, params._YUSDChange);\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n        vars.netDebtChange = params._YUSDChange;\n\n        vars.VCin = _getVC(params._collsIn, params._amountsIn);\n        vars.VCout = _getVC(params._collsOut, params._amountsOut);\n\n        if (params._isDebtIncrease) {\n            vars.maxFeePercentageFactor = LiquityMath._max(vars.VCin, params._YUSDChange);\n        } else {\n            vars.maxFeePercentageFactor = vars.VCin;\n        }\n        \n        // If the adjustment incorporates a debt increase and system is in Normal Mode, then trigger a borrowing fee\n        if (params._isDebtIncrease && !isRecoveryMode) {\n            vars.YUSDFee = _triggerBorrowingFee(\n                contractsCache.troveManager,\n                contractsCache.yusdToken,\n                params._YUSDChange,\n                vars.maxFeePercentageFactor, // max of VC in and YUSD change here to see what the max borrowing fee is triggered on.\n                params._maxFeePercentage\n            );\n            // passed in max fee minus actual fee percent applied so far\n            params._maxFeePercentage = params._maxFeePercentage.sub(vars.YUSDFee.mul(DECIMAL_PRECISION).div(vars.maxFeePercentageFactor)); \n            vars.netDebtChange = vars.netDebtChange.add(vars.YUSDFee); // The raw debt change includes the fee\n        }\n\n        // get current portfolio in trove\n        (vars.currAssets, vars.currAmounts) = contractsCache.troveManager.getTroveColls(msg.sender);\n        // current VC based on current portfolio and latest prices\n        vars.currVC = _getVC(vars.currAssets, vars.currAmounts);\n\n        // get new portfolio in trove after changes. Will error if invalid changes:\n        (vars.newAssets, vars.newAmounts) = _getNewPortfolio(\n            vars.currAssets,\n            vars.currAmounts,\n            params._collsIn,\n            params._amountsIn,\n            params._collsOut,\n            params._amountsOut\n        );\n        // new VC based on new portfolio and latest prices\n        vars.newVC = _getVC(vars.newAssets, vars.newAmounts);\n\n        vars.isCollIncrease = vars.newVC > vars.currVC;\n        vars.collChange = 0;\n        if (vars.isCollIncrease) {\n            vars.collChange = (vars.newVC).sub(vars.currVC);\n        } else {\n            vars.collChange = (vars.currVC).sub(vars.newVC);\n        }\n\n        vars.debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        if (params._collsIn.length != 0) {\n            vars.variableYUSDFee = _getTotalVariableDepositFee(\n                    params._collsIn,\n                    params._amountsIn,\n                    vars.VCin,\n                    vars.VCout,\n                    vars.maxFeePercentageFactor,\n                    params._maxFeePercentage,\n                    contractsCache\n            );\n        }\n\n        // Get the trove's old ICR before the adjustment, and what its new ICR will be after the adjustment\n        vars.oldICR = LiquityMath._computeCR(vars.currVC, vars.debt);\n\n        vars.debt = vars.debt.add(vars.variableYUSDFee); \n\n        vars.newICR = _getNewICRFromTroveChange(vars.newVC,\n            vars.debt, // with variableYUSDFee already added. \n            vars.netDebtChange,\n            params._isDebtIncrease \n        );\n\n        // Check the adjustment satisfies all conditions for the current system mode\n        _requireValidAdjustmentInCurrentMode(\n            isRecoveryMode,\n            params._amountsOut,\n            params._isDebtIncrease,\n            vars\n        );\n\n        // When the adjustment is a debt repayment, check it's a valid amount and that the caller has enough YUSD\n        if (!params._isUnlever && !params._isDebtIncrease && params._YUSDChange != 0) {\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(vars.netDebtChange));\n            _requireValidYUSDRepayment(vars.debt, vars.netDebtChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, vars.netDebtChange);\n        }\n\n        if (params._collsIn.length != 0) {\n            contractsCache.activePool.receiveCollateral(params._collsIn, params._amountsIn);\n        }\n\n        (vars.newVC, vars.newDebt) = _updateTroveFromAdjustment(\n            contractsCache.troveManager,\n            msg.sender,\n            vars.newAssets,\n            vars.newAmounts,\n            vars.newVC,\n            vars.netDebtChange,\n            params._isDebtIncrease, \n            vars.variableYUSDFee\n        );\n\n        contractsCache.troveManager.updateStakeAndTotalStakes(msg.sender);\n\n        // Re-insert trove in to the sorted list\n        sortedTroves.reInsert(msg.sender, vars.newICR, params._upperHint, params._lowerHint);\n\n        emit TroveUpdated(\n            msg.sender,\n            vars.newDebt,\n            vars.newAssets,\n            vars.newAmounts,\n            BorrowerOperation.adjustTrove\n        );\n        emit YUSDBorrowingFeePaid(msg.sender, vars.YUSDFee);\n\n        // in case of unlever up\n        if (params._isUnlever) {\n            // 1. Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, params._collsOut, params._amountsOut, params._maxSlippages);\n\n            // 2. update the trove with the new collateral and debt, repaying the total amount of YUSD specified. \n            // if not enough coll sold for YUSD, must cover from user balance\n            _requireAtLeastMinNetDebt(_getNetDebt(vars.debt).sub(params._YUSDChange));\n            _requireValidYUSDRepayment(vars.debt, params._YUSDChange);\n            _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, params._YUSDChange);\n            _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, params._YUSDChange);\n        } else {\n            // Use the unmodified _YUSDChange here, as we don't send the fee to the user\n            _moveYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                params._YUSDChange.sub(params._totalYUSDDebtFromLever), // 0 in non lever case\n                params._isDebtIncrease,\n                vars.netDebtChange\n            );\n\n            // Additionally move the variable deposit fee to the active pool manually, as it is always an increase in debt\n            _withdrawYUSD(\n                contractsCache.activePool,\n                contractsCache.yusdToken,\n                msg.sender,\n                0,\n                vars.variableYUSDFee\n            );\n\n            // transfer withdrawn collateral to msg.sender from ActivePool\n            activePool.sendCollateralsUnwrap(msg.sender, msg.sender, params._collsOut, params._amountsOut);\n        }\n    }\n\n    // internal function for minting yusd at certain leverage and max slippage, and then performing \n    // swap with whitelist's approved router. \n    function _singleUnleverUp(address _token, \n        uint256 _amount, \n        uint256 _maxSlippage) \n        internal\n        returns (uint256 _finalYUSDAmount) {\n        require(_maxSlippage <= 1e18, \"WrongSlippage\");\n        // if wrapped token, then does i t automatically transfer to active pool?\n        // It should actually transfer to the owner, who will have bOps pre approved\n        // cause of original approve\n        IYetiRouter router = IYetiRouter(whitelist.getDefaultRouterAddress(_token));\n        // then calculate value amount of expected YUSD output based on amount of token to sell\n\n        uint valueOfCollateral = whitelist.getValueUSD(_token, _amount);\n        uint256 slippageAdjustedValue = valueOfCollateral.mul(DECIMAL_PRECISION.sub(_maxSlippage)).div(1e18);\n        IERC20 yusdTokenCached = yusdToken;\n        require(IERC20(_token).approve(address(router), valueOfCollateral));\n        uint256 balanceBefore = yusdToken.balanceOf(address(this));\n        _finalYUSDAmount = router.unRoute(address(this), _token, address(yusdTokenCached), _amount, slippageAdjustedValue);\n        require(yusdTokenCached.balanceOf(address(this)) == balanceBefore.add(_finalYUSDAmount), \"BO:YUSDNotSentUnLever\");\n    }\n\n    // Takes the colls and amounts, transfer non levered from the active pool to the user, and unlevered to this contract \n    // temporarily. Then takes the unlevered ones and calls relevant router to swap them to the user. \n    function _unleverColls(\n        IActivePool _activePool, \n        address[] memory _colls, \n        uint256[] memory _amounts, \n        uint256[] memory _maxSlippages\n    ) internal {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i < collsLen; ++i) {\n            if (_maxSlippages[i] != 0) {\n                _activePool.sendSingleCollateral(address(this), _colls[i], _amounts[i]);\n                _singleUnleverUp(_colls[i], _amounts[i], _maxSlippages[i]);\n            } else {\n                _activePool.sendSingleCollateralUnwrap(msg.sender, msg.sender, _colls[i], _amounts[i]);\n            }\n        }\n    }\n\n\n    // Withdraw collateral from a trove. Calls _adjustTrove with correct params.\n    // Specifies amount of collateral to withdraw and how much debt to repay, \n    // Can withdraw coll and *only* pay back debt using this function. Will take \n    // the collateral given and send YUSD back to user. Then they will pay back debt\n    // first transfers amount of collateral from active pool then sells. \n    // calls _singleUnleverUp() to perform the swaps using the wrappers. \n    // should have no fees. \n    function withdrawCollUnleverUp(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages,\n        uint256 _YUSDAmount,\n        address _upperHint,\n        address _lowerHint\n        ) external override nonReentrant {\n        // check that all _collsOut collateral types are in the whitelist\n        _requireValidDepositCollateral(_collsOut, _amountsOut);\n        _requireNoDuplicateColls(_collsOut); // Check that there is no overlap with out in itself\n        _requireLengthsEqual(_amountsOut.length, _maxSlippages.length);\n\n        AdjustTrove_Params memory params; \n        params._collsOut = _collsOut;\n        params._amountsOut = _amountsOut;\n        params._maxSlippages = _maxSlippages;\n        params._YUSDChange = _YUSDAmount;\n        params._upperHint = _upperHint;\n        params._lowerHint = _lowerHint;\n        params._isUnlever = true;\n\n        _adjustTrove(params);\n    }\n\n    function closeTroveUnlever(\n        address[] calldata _collsOut,\n        uint256[] calldata _amountsOut,\n        uint256[] calldata _maxSlippages\n    ) external override nonReentrant {\n        CloseTrove_Params memory params = CloseTrove_Params({\n            _collsOut: _collsOut,\n            _amountsOut: _amountsOut,\n            _maxSlippages: _maxSlippages,\n            _isUnlever: true\n            }\n        );\n        _closeTrove(params);\n    }\n\n    function closeTrove() external override nonReentrant{\n        CloseTrove_Params memory params; // default false\n        _closeTrove(params);\n    }\n\n    /** \n     * Closes trove by applying pending rewards, making sure that the YUSD Balance is sufficient, and transferring the \n     * collateral to the owner, and repaying the debt.\n     * if it is a unlever, then it will transfer the collaterals / sell before. Otherwise it will just do it last. \n     */\n    function _closeTrove(\n        CloseTrove_Params memory params\n        ) internal {\n        ContractsCache memory contractsCache = ContractsCache(troveManager, activePool, yusdToken);\n\n        _requireTroveisActive(contractsCache.troveManager, msg.sender);\n        _requireNotInRecoveryMode();\n\n        contractsCache.troveManager.applyPendingRewards(msg.sender);\n\n        uint256 troveVC = contractsCache.troveManager.getTroveVC(msg.sender); // should get the latest VC\n        (address[] memory colls, uint256[] memory amounts) = contractsCache.troveManager.getTroveColls(\n            msg.sender\n        );\n        uint256 debt = contractsCache.troveManager.getTroveDebt(msg.sender);\n\n        // if unlever, will do extra.\n        uint finalYUSDAmount;\n        uint YUSDAmount;\n        if (params._isUnlever) {\n            // Withdraw the collateral from active pool and perform swap using single unlever up and corresponding router. \n            _unleverColls(contractsCache.activePool, colls, amounts, params._maxSlippages);\n            // tracks the amount of YUSD that is received from swaps. Will send the _YUSDAmount back to repay debt while keeping remainder.\n        }\n\n        // do check after unlever (if applies)\n        _requireSufficientYUSDBalance(contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        uint256 newTCR = _getNewTCRFromTroveChange(troveVC, false, debt, false);\n        _requireNewTCRisAboveCCR(newTCR);\n\n        contractsCache.troveManager.removeStake(msg.sender);\n        contractsCache.troveManager.closeTrove(msg.sender);\n\n        address[] memory finalColls;\n        uint256[] memory finalAmounts;\n\n        emit TroveUpdated(msg.sender, 0, finalColls, finalAmounts, BorrowerOperation.closeTrove);\n\n        // Burn the repaid YUSD from the user's balance and the gas compensation from the Gas Pool\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, msg.sender, debt.sub(YUSD_GAS_COMPENSATION));\n        _repayYUSD(contractsCache.activePool, contractsCache.yusdToken, gasPoolAddress, YUSD_GAS_COMPENSATION);\n\n        // Send the collateral back to the user\n        // Also sends the rewards\n        if (!params._isUnlever) {\n            contractsCache.activePool.sendCollateralsUnwrap(msg.sender, msg.sender, colls, amounts);\n        }\n    }\n\n    /**\n     * Claim remaining collateral from a redemption or from a liquidation with ICR > MCR in Recovery Mode\n     * to do all necessary interactions. Can delete if this is the only way to reduce size.\n     */\n    function claimCollateral() external override {\n        // send collateral from CollSurplus Pool to owner\n        collSurplusPool.claimColl(msg.sender);\n    }\n\n    // --- Helper functions ---\n\n    /** \n     * Gets the variable deposit fee from the whitelist calculation. Multiplies the \n     * fee by the vc of the collateral.\n     */\n    function _getTotalVariableDepositFee(\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        uint256 _VCin,\n        uint256 _VCout,\n        uint256 _maxFeePercentageFactor, \n        uint256 _maxFeePercentage,\n        ContractsCache memory _contractsCache\n    ) internal returns (uint256 YUSDFee) {\n        if (_VCin == 0) {\n            return 0;\n        }\n        DepositFeeCalc memory vars;\n        // active pool total VC at current state.\n        vars.systemTotalVC = _contractsCache.activePool.getVC().add(\n            defaultPool.getVC()\n        );\n        // active pool total VC post adding and removing all collaterals\n        uint256 activePoolVCPost = vars.systemTotalVC.add(_VCin).sub(_VCout);\n        uint256 whitelistFee;\n        uint256 tokensLen = _tokensIn.length;\n        for (uint256 i; i < tokensLen; ++i) {\n            vars.token = _tokensIn[i];\n            // VC value of collateral of this type inputted\n            vars.collateralInputVC = whitelist.getValueVC(vars.token, _amountsIn[i]);\n\n            // total value in VC of this collateral in active pool (post adding input)\n            vars.systemCollateralVC = _contractsCache.activePool.getCollateralVC(vars.token).add(\n                defaultPool.getCollateralVC(vars.token)\n            );\n\n            // (collateral VC In) * (Collateral's Fee Given Yeti Protocol Backed by Given Collateral)\n            whitelistFee = \n                    whitelist.getFeeAndUpdate(\n                        vars.token,\n                        vars.collateralInputVC,\n                        vars.systemCollateralVC,\n                        vars.systemTotalVC,\n                        activePoolVCPost\n                    );\n            if (_isBeforeFeeBootstrapPeriod()) {\n                whitelistFee = LiquityMath._min(whitelistFee, 1e16); // cap at 1%\n            } \n            vars.collateralYUSDFee = vars.collateralInputVC\n                .mul(whitelistFee).div(1e18);\n\n            YUSDFee = YUSDFee.add(vars.collateralYUSDFee);\n        }\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n        _triggerDepositFee(_contractsCache.yusdToken, YUSDFee);\n    }\n\n    // Transfer in collateral and send to ActivePool\n    // (where collateral is held)\n    function _transferCollateralsIntoActivePool(\n        address _from,\n        address[] memory _colls,\n        uint256[] memory _amounts\n    ) internal {\n        uint256 amountsLen = _amounts.length;\n        for (uint256 i; i < amountsLen; ++i) {\n            address collAddress = _colls[i];\n            uint256 amount = _amounts[i];\n            _singleTransferCollateralIntoActivePool(\n                _from,\n                collAddress,\n                amount\n            );\n        }\n    }\n\n    // does one transfer of collateral into active pool. Checks that it transferred to the active pool correctly.\n    function _singleTransferCollateralIntoActivePool(\n        address _from,\n        address _coll,\n        uint256 _amount\n    ) internal {\n        if (whitelist.isWrapped(_coll)) {\n            // If wrapped asset then it wraps it and sends the wrapped version to the active pool, \n            // and updates reward balance to the new owner. \n            IWAsset(_coll).wrap(_amount, _from, address(activePool), _from); \n        } else {\n            require(IERC20(_coll).transferFrom(_from, address(activePool), _amount), \"BO:TransferCollsFailed\");\n        }\n    }\n\n    /**\n     * Triggers normal borrowing fee, calculated from base rate and on YUSD amount.\n     */\n    function _triggerBorrowingFee(\n        ITroveManager _troveManager,\n        IYUSDToken _yusdToken,\n        uint256 _YUSDAmount,\n        uint256 _maxFeePercentageFactor,\n        uint256 _maxFeePercentage\n    ) internal returns (uint256) {\n        _troveManager.decayBaseRateFromBorrowing(); // decay the baseRate state variable\n        uint256 YUSDFee = _troveManager.getBorrowingFee(_YUSDAmount);\n\n        _requireUserAcceptsFee(YUSDFee, _maxFeePercentageFactor, _maxFeePercentage);\n\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, YUSDFee);\n        return YUSDFee;\n    }\n\n    function _triggerDepositFee(IYUSDToken _yusdToken, uint256 _YUSDFee) internal {\n        // Send fee to sYETI contract\n        _yusdToken.mint(sYETIAddress, _YUSDFee);\n    }\n\n    // Update trove's coll and debt based on whether they increase or decrease\n    function _updateTroveFromAdjustment(\n        ITroveManager _troveManager,\n        address _borrower,\n        address[] memory _finalColls,\n        uint256[] memory _finalAmounts,\n        uint256 _newVC,\n        uint256 _debtChange,\n        bool _isDebtIncrease, \n        uint256 _variableYUSDFee\n    ) internal returns (uint256, uint256) {\n        uint256 newDebt;\n        _troveManager.updateTroveColl(_borrower, _finalColls, _finalAmounts);\n        if (_isDebtIncrease) { // if debt increase, increase by both amounts\n           newDebt = _troveManager.increaseTroveDebt(_borrower, _debtChange.add(_variableYUSDFee));\n        } else {\n            if (_debtChange > _variableYUSDFee) { // if debt decrease, and greater than variable fee, decrease \n                newDebt = _troveManager.decreaseTroveDebt(_borrower, _debtChange - _variableYUSDFee); // already checked no safemath needed\n            } else { // otherwise increase by opposite subtraction\n                newDebt = _troveManager.increaseTroveDebt(_borrower, _variableYUSDFee - _debtChange); // already checked no safemath needed\n            }\n        }\n\n        return (_newVC, newDebt);\n    }\n\n    // gets the finalColls and finalAmounts after all deposits and withdrawals have been made\n    // this function will error if trying to deposit a collateral that is not in the whitelist\n    // or trying to withdraw more collateral of any type that is not in the trove\n    function _getNewPortfolio(\n        address[] memory _initialTokens,\n        uint256[] memory _initialAmounts,\n        address[] memory _tokensIn,\n        uint256[] memory _amountsIn,\n        address[] memory _tokensOut,\n        uint256[] memory _amountsOut\n    ) internal view returns (address[] memory, uint256[] memory) {\n        _requireValidDepositCollateral(_tokensIn, _amountsIn);\n        _requireValidDepositCollateral(_tokensOut, _amountsOut);\n\n        // Initial Colls + Input Colls\n        newColls memory cumulativeIn = _sumColls(\n            _initialTokens,\n            _initialAmounts,\n            _tokensIn,\n            _amountsIn\n        );\n\n        newColls memory newPortfolio = _subColls(cumulativeIn, _tokensOut, _amountsOut);\n        return (newPortfolio.tokens, newPortfolio.amounts);\n    }\n\n    // Moves the YUSD around based on whether it is an increase or decrease in debt.\n    function _moveYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _YUSDChange,\n        bool _isDebtIncrease,\n        uint256 _netDebtChange\n    ) internal {\n        if (_isDebtIncrease) {\n            _withdrawYUSD(_activePool, _yusdToken, _borrower, _YUSDChange, _netDebtChange);\n        } else {\n            _repayYUSD(_activePool, _yusdToken, _borrower, _YUSDChange);\n        }\n    }\n\n    // Issue the specified amount of YUSD to _account and increases the total active debt (_netDebtIncrease potentially includes a YUSDFee)\n    function _withdrawYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSDAmount,\n        uint256 _netDebtIncrease\n    ) internal {\n        _activePool.increaseYUSDDebt(_netDebtIncrease);\n        _yusdToken.mint(_account, _YUSDAmount);\n    }\n\n    // Burn the specified amount of YUSD from _account and decreases the total active debt\n    function _repayYUSD(\n        IActivePool _activePool,\n        IYUSDToken _yusdToken,\n        address _account,\n        uint256 _YUSD\n    ) internal {\n        _activePool.decreaseYUSDDebt(_YUSD);\n        _yusdToken.burn(_account, _YUSD);\n    }\n\n    // --- 'Require' wrapper functions ---\n\n    function _requireValidDepositCollateral(address[] memory _colls, uint256[] memory _amounts) internal view {\n        uint256 collsLen = _colls.length;\n        _requireLengthsEqual(collsLen, _amounts.length);\n        for (uint256 i; i < collsLen; ++i) {\n            require(whitelist.getIsActive(_colls[i]), \"BO:BadColl\");\n            require(_amounts[i] != 0, \"BO:NoAmounts\");\n        }\n    }\n\n    function _requireNonZeroAdjustment(\n        uint256[] memory _amountsIn,\n        uint256[] memory _amountsOut,\n        uint256 _YUSDChange\n    ) internal pure {\n        require(\n            _arrayIsNonzero(_amountsIn) || _arrayIsNonzero(_amountsOut) || _YUSDChange != 0,\n            \"BO:0Adjust\"\n        );\n    }\n\n    function _arrayIsNonzero(uint256[] memory arr) internal pure returns (bool) {\n        uint256 arrLen = arr.length;\n        for (uint256 i; i < arrLen; ++i) {\n            if (arr[i] != 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _isBeforeFeeBootstrapPeriod() internal view returns (bool) {\n        return block.timestamp < deploymentTime + BOOTSTRAP_PERIOD; // won't overflow\n    }\n\n    function _requireTroveisActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(_troveManager.isTroveActive(_borrower), \"BO:TroveInactive\");\n    }\n\n    function _requireTroveisNotActive(ITroveManager _troveManager, address _borrower) internal view {\n        require(!_troveManager.isTroveActive(_borrower), \"BO:TroveActive\");\n    }\n\n    function _requireNonZeroDebtChange(uint256 _YUSDChange) internal pure {\n        require(_YUSDChange != 0, \"BO:NoDebtChange\");\n    }\n\n    function _requireNoOverlapColls(address[] calldata _colls1, address[] calldata _colls2)\n        internal\n        pure\n    {\n        uint256 colls1Len = _colls1.length;\n        uint256 colls2Len = _colls2.length;\n        for (uint256 i; i < colls1Len; ++i) {\n            for (uint256 j; j < colls2Len; j++) {\n                require(_colls1[i] != _colls2[j], \"BO:OverlapColls\");\n            }\n        }\n    }\n\n    function _requireNoDuplicateColls(address[] memory _colls) internal pure {\n        uint256 collsLen = _colls.length;\n        for (uint256 i; i < collsLen; ++i) {\n            for (uint256 j = i.add(1); j < collsLen; j++) {\n                require(_colls[i] != _colls[j], \"BO:OverlapColls\");\n            }\n        }\n    }\n\n    function _requireNotInRecoveryMode() internal view {\n        require(!_checkRecoveryMode(), \"BO:InRecMode\");\n    }\n\n    function _requireNoCollWithdrawal(uint256[] memory _amountOut) internal pure {\n        require(\n            !_arrayIsNonzero(_amountOut),\n            \"BO:InRecMode\"\n        );\n    }\n\n    // Function require length nonzero, used to save contract size on revert strings. \n    function _requireLengthNonzero(uint256 length) internal pure {\n        require(length != 0, \"BOps:Len0\");\n    }\n\n    // Function require length equal, used to save contract size on revert strings.\n    function _requireLengthsEqual(uint256 length1, uint256 length2) internal pure {\n        require(length1 == length2, \"BO:LenMismatch\");\n    }\n\n    function _requireValidAdjustmentInCurrentMode(\n        bool _isRecoveryMode,\n        uint256[] memory _collWithdrawal,\n        bool _isDebtIncrease,\n        LocalVariables_adjustTrove memory _vars\n    ) internal view {\n        /*\n         *In Recovery Mode, only allow:\n         *\n         * - Pure collateral top-up\n         * - Pure debt repayment\n         * - Collateral top-up with debt repayment\n         * - A debt increase combined with a collateral top-up which makes the ICR >= 150% and improves the ICR (and by extension improves the TCR).\n         *\n         * In Normal Mode, ensure:\n         *\n         * - The new ICR is above MCR\n         * - The adjustment won't pull the TCR below CCR\n         */\n        if (_isRecoveryMode) {\n            _requireNoCollWithdrawal(_collWithdrawal);\n            if (_isDebtIncrease) {\n                _requireICRisAboveCCR(_vars.newICR);\n                _requireNewICRisAboveOldICR(_vars.newICR, _vars.oldICR);\n            }\n        } else {\n            // if Normal Mode\n            _requireICRisAboveMCR(_vars.newICR);\n            _vars.newTCR = _getNewTCRFromTroveChange(\n                _vars.collChange,\n                _vars.isCollIncrease,\n                _vars.netDebtChange,\n                _isDebtIncrease\n            );\n            _requireNewTCRisAboveCCR(_vars.newTCR);\n        }\n    }\n\n    function _requireICRisAboveMCR(uint256 _newICR) internal pure {\n        require(\n            _newICR >= MCR,\n            \"BO:ReqICR>MCR\"\n        );\n    }\n\n    function _requireICRisAboveCCR(uint256 _newICR) internal pure {\n        require(_newICR >= CCR, \"BO:ReqICR>CCR\");\n    }\n\n    function _requireNewICRisAboveOldICR(uint256 _newICR, uint256 _oldICR) internal pure {\n        require(\n            _newICR >= _oldICR,\n            \"BO:RecMode:ICR<oldICR\"\n        );\n    }\n\n    function _requireNewTCRisAboveCCR(uint256 _newTCR) internal pure {\n        require(\n            _newTCR >= CCR,\n            \"BO:ReqTCR>CCR\"\n        );\n    }\n\n    function _requireAtLeastMinNetDebt(uint256 _netDebt) internal pure {\n        require(\n            _netDebt >= MIN_NET_DEBT,\n            \"BO:netDebt<2000\"\n        );\n    }\n\n    function _requireValidYUSDRepayment(uint256 _currentDebt, uint256 _debtRepayment) internal pure {\n        require(\n            _debtRepayment <= _currentDebt.sub(YUSD_GAS_COMPENSATION),\n            \"BO:InvalidYUSDRepay\"\n        );\n    }\n\n    function _requireSufficientYUSDBalance(\n        IYUSDToken _yusdToken,\n        address _borrower,\n        uint256 _debtRepayment\n    ) internal view {\n        require(\n            _yusdToken.balanceOf(_borrower) >= _debtRepayment,\n            \"BO:InsuffYUSDBal\"\n        );\n    }\n\n    function _requireValidMaxFeePercentage(uint256 _maxFeePercentage, bool _isRecoveryMode)\n        internal\n        pure\n    {\n        // Alwawys require max fee to be less than 100%, and if not in recovery mode then max fee must be greater than 0.5%\n        if (_maxFeePercentage > DECIMAL_PRECISION || (!_isRecoveryMode && _maxFeePercentage < BORROWING_FEE_FLOOR)) {\n            revert(\"BO:InvalidMaxFee\");\n        }\n    }\n\n    // checks lengths are all good and that all passed in routers are valid routers\n    // function _requireValidRouterParams(\n    //     address[] memory _finalRoutedColls,\n    //     uint[] memory _amounts,\n    //     uint[] memory _minSwapAmounts,\n    //     IYetiRouter[] memory _routers) internal view {\n    //     require(_finalRoutedColls.length == _amounts.length,  \"_requireValidRouterParams: _finalRoutedColls length mismatch\");\n    //     require(_amounts.length == _routers.length, \"_requireValidRouterParams: _routers length mismatch\");\n    //     require(_amounts.length == _minSwapAmounts.length, \"_minSwapAmounts: finalRoutedColls length mismatch\");\n    //     for (uint256 i; i < _routers.length; ++i) {\n    //         require(whitelist.isValidRouter(address(_routers[i])), \"_requireValidRouterParams: not a valid router\");\n    //     }\n    // }\n\n    // // requires that avax indices are in order\n    // function _requireRouterAVAXIndicesInOrder(uint[] memory _indices) internal pure {\n    //     for (uint256 i; i < _indices.length - 1; ++i) {\n    //         require(_indices[i] < _indices[i.add(1)], \"_requireRouterAVAXIndicesInOrder: indices out of order\");\n    //     }\n    // }\n\n\n    // --- ICR and TCR getters ---\n\n    // Compute the new collateral ratio, considering the change in coll and debt. Assumes 0 pending rewards.\n    function _getNewICRFromTroveChange(\n        uint256 _newVC,\n        uint256 _debt,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal pure returns (uint256) {\n        uint256 newDebt = _isDebtIncrease ? _debt.add(_debtChange) : _debt.sub(_debtChange);\n\n        uint256 newICR = LiquityMath._computeCR(_newVC, newDebt);\n        return newICR;\n    }\n\n    function _getNewTCRFromTroveChange(\n        uint256 _collChange,\n        bool _isCollIncrease,\n        uint256 _debtChange,\n        bool _isDebtIncrease\n    ) internal view returns (uint256) {\n        uint256 totalColl = getEntireSystemColl();\n        uint256 totalDebt = getEntireSystemDebt();\n\n        totalColl = _isCollIncrease ? totalColl.add(_collChange) : totalColl.sub(_collChange);\n        totalDebt = _isDebtIncrease ? totalDebt.add(_debtChange) : totalDebt.sub(_debtChange);\n\n        uint256 newTCR = LiquityMath._computeCR(totalColl, totalDebt);\n        return newTCR;\n    }\n\n    function getCompositeDebt(uint256 _debt) external pure override returns (uint256) {\n        return _getCompositeDebt(_debt);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2021-12-yetifinance-findings.json",
                "Location": "BorrowerOperations.sol",
                "Type": "Reentrancy",
                "Description": "Several functions in BorrowerOperations.sol are potentially re-entrant as they are external but have no re-entrancy guard declared.",
                "Repair": "Add a re-entrancy guard similar to OpenZeppelin's ReentrancyGuard"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"./Governable.sol\";\nimport \"hardhat/console.sol\";\nimport \"../facades/Burnable.sol\";\n\n///@title Flash Governance Arbiter\n///@author Justin Goro\n/**@notice LimboDAO offers two forms of governance: flash and proposal. Proposals are contracts that have authorization to execute guarded functions on contracts that implement the Governable abstract contract.\n * Proposals require Fate to be put forward for voting and Fate is the spendable voting token.\n * Flash governance occurs in the duration of one transaction and is more appropriate for variable tweaking such as changing the Flan per Second or Threshold of a pool.\n * Flash governance requires an asset be deposited into an adjudication contract. The community can then vote, through a proposal, whether the decision was legitimate. If not, the deposit can be slashed\n * By default, the asset is EYE.\n */\ncontract FlashGovernanceArbiter is Governable {\n  /**\n   * @param actor user making flash governance decision\n   * @param deposit_asset is the asset type put up as decision collateral. Must be burnable.\n   * @param amount is the amount of the deposit_asset to be put up as decision collateral.\n   * @param target is the contract that will be affected by the flash governance decision.\n   */\n  event flashDecision(address actor, address deposit_asset, uint256 amount, address target);\n\n  mapping(address => bool) enforceLimitsActive;\n\n  constructor(address dao) Governable(dao) {}\n\n  struct FlashGovernanceConfig {\n    address asset;\n    uint256 amount;\n    uint256 unlockTime;\n    bool assetBurnable;\n  }\n\n  //Note: epoch settings prevent DOS attacks. Change tolerance curtails the damage of bad flash governance.\n  struct SecurityParameters {\n    uint8 maxGovernanceChangePerEpoch; //prevents flash governance from wrecking the incentives.\n    uint256 epochSize; //only one flash governance action can happen per epoch to prevent governance DOS\n    uint256 lastFlashGovernanceAct;\n    uint8 changeTolerance; //1-100 maximum percentage any numeric variable can be changed through flash gov\n  }\n\n  //the current parameters determining the rules of flash governance\n  FlashGovernanceConfig public flashGovernanceConfig;\n  SecurityParameters public security;\n\n  /*For every decision, we record the config at the time of the decision. This allows governance to change the rules\n   *without undermining the terms under which pending decisions were made.\n   */\n  mapping(address => mapping(address => FlashGovernanceConfig)) public pendingFlashDecision; //contract->user->config\n\n  /**\n   *@notice An attempt is made to withdraw the current deposit requirement.\n   * For a given user, flash governance decisions can only happen one at a time\n   *@param sender is the user making the flash governance decision\n   *@param target is the contract that will be affected by the flash governance decision.\n   *@param emergency flash governance decisions are restricted in frequency per epoch but some decisions are too important. These can be marked emergency.\n   *@dev be very careful about setting emergency to true. Only decisions which preclude the execution of other flash governance decisions should be considered candidtes for emergency.\n   */\n  function assertGovernanceApproved(\n    address sender,\n    address target,\n    bool emergency\n  ) public {\n    if (\n      IERC20(flashGovernanceConfig.asset).transferFrom(sender, address(this), flashGovernanceConfig.amount) &&\n      pendingFlashDecision[target][sender].unlockTime < block.timestamp\n    ) {\n      require(\n        emergency || (block.timestamp - security.lastFlashGovernanceAct > security.epochSize),\n        \"Limbo: flash governance disabled for rest of epoch\"\n      );\n      pendingFlashDecision[target][sender] = flashGovernanceConfig;\n      pendingFlashDecision[target][sender].unlockTime += block.timestamp;\n\n      security.lastFlashGovernanceAct = block.timestamp;\n      emit flashDecision(sender, flashGovernanceConfig.asset, flashGovernanceConfig.amount, target);\n    } else {\n      revert(\"LIMBO: governance decision rejected.\");\n    }\n  }\n\n  /**\n   *@param asset is the asset type put up as decision collateral. Must be burnable.\n   *@param amount is the amount of the deposit_asset to be put up as decision collateral.\n   *@param unlockTime is the duration for which the deposit collateral must be locked in order to give the community time to weigh up the decision\n   *@param assetBurnable is a technical parameter to determined the manner in which burning should occur. Non burnable assets are just no longer accounted for and accumulate within this contract.\n   */\n  function configureFlashGovernance(\n    address asset,\n    uint256 amount,\n    uint256 unlockTime,\n    bool assetBurnable\n  ) public virtual onlySuccessfulProposal {\n    flashGovernanceConfig.asset = asset;\n    flashGovernanceConfig.amount = amount;\n    flashGovernanceConfig.unlockTime = unlockTime;\n    flashGovernanceConfig.assetBurnable = assetBurnable;\n  }\n\n  /**\n    @param maxGovernanceChangePerEpoch max number of flash governance decisions per epoch to prevent DOS\n    @param epochSize is the duration of a flash governance epoch and reflects proposal deliberation durations\n    @param changeTolerance is the amount by which a variable can be changed through flash governance.\n    */\n  function configureSecurityParameters(\n    uint8 maxGovernanceChangePerEpoch,\n    uint256 epochSize,\n    uint8 changeTolerance\n  ) public virtual onlySuccessfulProposal {\n    security.maxGovernanceChangePerEpoch = maxGovernanceChangePerEpoch;\n    security.epochSize = epochSize;\n    require(security.changeTolerance < 100, \"Limbo: % between 0 and 100\");\n    security.changeTolerance = changeTolerance;\n  }\n\n  /**\n    @notice LimboDAO proposals for burning flash governance collateral act through this function\n    @param targetContract is the contract that is affected by the flash governance decision.\n    @param user is the user who made the flash governance decision\n    @param asset is the collateral asset to be burnt\n    @param amount is the amount of the collateral to be burnt\n    */\n  function burnFlashGovernanceAsset(\n    address targetContract,\n    address user,\n    address asset,\n    uint256 amount\n  ) public virtual onlySuccessfulProposal {\n    if (pendingFlashDecision[targetContract][user].assetBurnable) {\n      Burnable(asset).burn(amount);\n    }\n\n    pendingFlashDecision[targetContract][user] = flashGovernanceConfig;\n  }\n\n  /**\n   *@notice Assuming a flash governance decision was not rejected during the lock window, the user is free to withdraw their asset\n   *@param targetContract is the contract that is affected by the flash governance decision.\n   *@param asset is the collateral asset to be withdrawn\n   */\n  function withdrawGovernanceAsset(address targetContract, address asset) public virtual {\n    require(\n      pendingFlashDecision[targetContract][msg.sender].asset == asset &&\n        pendingFlashDecision[targetContract][msg.sender].amount > 0 &&\n        pendingFlashDecision[targetContract][msg.sender].unlockTime < block.timestamp,\n      \"Limbo: Flashgovernance decision pending.\"\n    );\n    IERC20(pendingFlashDecision[targetContract][msg.sender].asset).transfer(\n      msg.sender,\n      pendingFlashDecision[targetContract][msg.sender].amount\n    );\n    delete pendingFlashDecision[targetContract][msg.sender];\n  }\n\n  /**\n   *@notice when a governance function is executed, it can enforce change limits on variables in the event that the execution is through flash governance\n   * However, a proposal is subject to the full deliberation of the DAO and such limits may thwart good governance.\n   * @param enforce for the given context, set whether variable movement limits are enforced or not.\n   */\n  function setEnforcement(bool enforce) public {\n    enforceLimitsActive[msg.sender] = enforce;\n  }\n\n  ///@dev for negative values, relative comparisons need to be calculated correctly.\n  function enforceToleranceInt(int256 v1, int256 v2) public view {\n    if (!configured) return;\n    uint256 uv1 = uint256(v1 > 0 ? v1 : -1 * v1);\n    uint256 uv2 = uint256(v2 > 0 ? v2 : -1 * v2);\n    enforceTolerance(uv1, uv2);\n  }\n\n  ///@notice Allows functions to enforce maximum limits on a per variable basis\n  ///@dev the 100 factor is just to allow for simple percentage comparisons without worrying about enormous precision.\n  function enforceTolerance(uint256 v1, uint256 v2) public view {\n    if (!configured || !enforceLimitsActive[msg.sender]) return;\n    //bonus points for readability\n    if (v1 > v2) {\n      if (v2 == 0) require(v1 <= 1, \"FE1\");\n      else require(((v1 - v2) * 100) < security.changeTolerance * v1, \"FE1\");\n    } else {\n      if (v1 == 0) require(v2 <= 1, \"FE1\");\n      else require(((v2 - v1) * 100) < security.changeTolerance * v1, \"FE1\");\n    }\n  }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-behodler-findings.json",
                "Location": "withdrawGovernanceAsset function of FlashGovernanceArbiter.sol",
                "Type": "Reentrancy",
                "Description": "The function withdrawGovernanceAsset is vulnerable to reentrancy.",
                "Repair": "Implement the check-effects-interactions pattern or delete the pendingFlashDecision before making the external call"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Trust} from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\nimport {IVault} from \"./vault/IVault.sol\";\nimport {IVaultSponsoring} from \"./vault/IVaultSponsoring.sol\";\nimport {PercentMath} from \"./lib/PercentMath.sol\";\nimport {Depositors} from \"./vault/Depositors.sol\";\nimport {Claimers} from \"./vault/Claimers.sol\";\nimport {IIntegration} from \"./integrations/IIntegration.sol\";\nimport {IStrategy} from \"./strategy/IStrategy.sol\";\nimport {ERC165Query} from \"./lib/ERC165Query.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * A vault where other accounts can deposit an underlying token\n * currency and set distribution params for their principal and yield\n *\n * @dev Yield generation strategies not yet implemented\n */\n\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n    using Counters for Counters.Counter;\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n    using Address for address;\n    using ERC165Query for address;\n\n    //\n    // Constants\n    //\n\n    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n    uint256 public constant SHARES_MULTIPLIER = 10**18;\n\n    //\n    // State\n    //\n\n    /// Underlying ERC20 token accepted by the vault\n    /// See {IVault}\n    IERC20 public override(IVault) underlying;\n\n    /// See {IVault}\n    IStrategy public strategy;\n\n    /// See {IVault}\n    uint256 public investPerc;\n\n    /// See {IVault}\n    uint256 public immutable override(IVault) minLockPeriod;\n\n    /// See {IVaultSponsoring}\n    uint256 public override(IVaultSponsoring) totalSponsored;\n\n    /// Depositors, represented as an NFT per deposit\n    Depositors public depositors;\n\n    /// Yield allocation\n    Claimers public claimers;\n\n    /// Unique IDs to correlate donations that belong to the same foundation\n    Counters.Counter private _depositGroupIds;\n\n    /**\n     * @param _underlying Underlying ERC20 token to use.\n     */\n    constructor(\n        IERC20 _underlying,\n        uint256 _minLockPeriod,\n        uint256 _investPerc,\n        address _owner\n    ) Trust(_owner) {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n        require(\n            address(_underlying) != address(0x0),\n            \"VaultContext: underlying cannot be 0x0\"\n        );\n        investPerc = _investPerc;\n        underlying = _underlying;\n        minLockPeriod = _minLockPeriod;\n\n        depositors = new Depositors(address(this), \"depositors\", \"p\");\n        claimers = new Claimers(address(this));\n    }\n\n    //\n    // IVault\n    //\n\n    /// See {IVault}\n    function setStrategy(address _strategy)\n        external\n        override(IVault)\n        requiresTrust\n    {\n        require(_strategy != address(0), \"Vault: strategy 0x\");\n        require(\n            IStrategy(_strategy).vault() == address(this),\n            \"Vault: invalid vault\"\n        );\n        require(\n            address(strategy) == address(0) || strategy.investedAssets() == 0,\n            \"Vault: strategy has invested funds\"\n        );\n\n        strategy = IStrategy(_strategy);\n    }\n\n    /// See {IVault}\n    function totalUnderlying() public view override(IVault) returns (uint256) {\n        if (address(strategy) != address(0)) {\n            return\n                underlying.balanceOf(address(this)) + strategy.investedAssets();\n        } else {\n            return underlying.balanceOf(address(this));\n        }\n    }\n\n    /// See {IVault}\n    function totalShares() public view override(IVault) returns (uint256) {\n        return claimers.totalShares();\n    }\n\n    /// See {IVault}\n    function yieldFor(address _to)\n        public\n        view\n        override(IVault)\n        returns (uint256)\n    {\n        uint256 tokenId = claimers.addressToTokenID(_to);\n        uint256 claimerPrincipal = claimers.principalOf(tokenId);\n        uint256 claimerShares = claimers.sharesOf(tokenId);\n        uint256 currentClaimerPrincipal = _computeAmount(\n            claimerShares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        if (currentClaimerPrincipal <= claimerPrincipal) {\n            return 0;\n        }\n\n        return currentClaimerPrincipal - claimerPrincipal;\n    }\n\n    /// See {IVault}\n    function deposit(DepositParams calldata _params) external {\n        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);\n        _transferAndCheckUnderlying(_msgSender(), _params.amount);\n    }\n\n    /// See {IVault}\n    function claimYield(address _to) external override(IVault) {\n        uint256 yield = yieldFor(_msgSender());\n\n        if (yield == 0) return;\n\n        uint256 shares = _computeShares(\n            yield,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n        uint256 sharesAmount = _computeAmount(\n            shares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);\n\n        underlying.safeTransfer(_to, sharesAmount);\n    }\n\n    /// See {IVault}\n    function withdraw(address _to, uint256[] memory _ids)\n        external\n        override(IVault)\n    {\n        _withdraw(_to, _ids, false);\n    }\n\n    /// See {IVault}\n    function forceWithdraw(address _to, uint256[] memory _ids) external {\n        _withdraw(_to, _ids, true);\n    }\n\n    /// See {IVault}\n    function setInvestPerc(uint16 _investPerc) external requiresTrust {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n\n        emit InvestPercentageUpdated(_investPerc);\n\n        investPerc = _investPerc;\n    }\n\n    /// See {IVault}\n    function investableAmount() public view returns (uint256) {\n        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);\n\n        uint256 alreadyInvested = strategy.investedAssets();\n\n        if (alreadyInvested >= maxInvestableAssets) {\n            return 0;\n        } else {\n            return maxInvestableAssets - alreadyInvested;\n        }\n    }\n\n    /// See {IVault}\n    function updateInvested() external requiresTrust {\n        require(address(strategy) != address(0), \"Vault: strategy is not set\");\n\n        uint256 _investable = investableAmount();\n\n        if (_investable > 0) {\n            underlying.safeTransfer(address(strategy), _investable);\n\n            emit Invested(_investable);\n        }\n\n        strategy.doHardWork();\n    }\n\n    //\n    // IVaultSponsoring\n\n    /// See {IVaultSponsoring}\n    function sponsor(uint256 _amount, uint256 _lockedUntil)\n        external\n        override(IVaultSponsoring)\n    {\n        if (_lockedUntil == 0)\n            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;\n        else\n            require(\n                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            _amount,\n            0,\n            _lockedUntil\n        );\n\n        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);\n\n        totalSponsored += _amount;\n        _transferAndCheckUnderlying(_msgSender(), _amount);\n    }\n\n    /// See {IVaultSponsoring}\n    function unsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, false);\n    }\n\n    /// See {IVaultSponsoring}\n    function forceUnsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, true);\n    }\n\n    //\n    // Public API\n    //\n\n    /**\n     * Computes the total amount of principal + yield currently controlled by the\n     * vault and the strategy. The principal + yield is the total amount\n     * of underlying that can be claimed or withdrawn, excluding the sponsored amount.\n     *\n     * @return Total amount of principal and yield help by the vault (not including sponsored amount).\n     */\n    function totalUnderlyingMinusSponsored() public view returns (uint256) {\n        // TODO no invested amount yet\n        return totalUnderlying() - totalSponsored;\n    }\n\n    //\n    // ERC165\n    //\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IVault).interfaceId ||\n            interfaceId == type(IVaultSponsoring).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    //\n    // Internal API\n    //\n\n    /**\n     * Withdraws the principal from the deposits with the ids provided in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _withdraw(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();\n        uint256 amount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            amount += _withdrawDeposit(\n                _ids[i],\n                localTotalShares,\n                localTotalPrincipal,\n                _to,\n                _force\n            );\n        }\n\n        underlying.safeTransfer(_to, amount);\n    }\n\n    /**\n     * Withdraws the sponsored amount for the deposits with the ids provided\n     * in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _unsponsor(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 sponsorAmount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            uint256 tokenId = _ids[i];\n\n            require(\n                depositors.ownerOf(tokenId) == _msgSender(),\n                \"Vault: you are not the owner of a sponsor\"\n            );\n\n            (\n                uint256 depositAmount,\n                uint256 claimerId,\n                uint256 lockedUntil\n            ) = depositors.deposits(tokenId);\n            require(lockedUntil <= block.timestamp, \"Vault: amount is locked\");\n\n            require(claimerId == 0, \"Vault: token id is not a sponsor\");\n\n            depositors.burn(tokenId);\n\n            emit Unsponsored(tokenId);\n\n            sponsorAmount += depositAmount;\n        }\n\n        uint256 sponsorToTransfer = sponsorAmount;\n\n        if (_force && sponsorAmount > totalUnderlying()) {\n            sponsorToTransfer = totalUnderlying();\n        } else if (!_force) {\n            require(\n                sponsorToTransfer <= totalUnderlying(),\n                \"Vault: not enough funds to unsponsor\"\n            );\n        }\n\n        totalSponsored -= sponsorAmount;\n\n        underlying.safeTransfer(_to, sponsorToTransfer);\n    }\n\n    /**\n     * Creates a deposit with the given amount of underlying and claim\n     * structure. The deposit is locked until the timestamp specified in @param _lockedUntil.\n     * @notice This function assumes underlying will be transfered elsewhere in\n     * the transaction.\n     *\n     * @notice Underlying must be transfered *after* this function, in order to\n     * correctly calculate shares.\n     *\n     * @notice claims must add up to 100%.\n     *\n     * @param _amount Amount of underlying to consider @param claims claim\n     * @param _lockedUntil When the depositor can unsponsor the amount.\n     * @param claims Claim params\n     * params.\n     */\n    function _createDeposit(\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams[] calldata claims\n    ) internal {\n        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;\n        else\n            require(\n                _lockedUntil >= block.timestamp + minLockPeriod,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();\n        uint256 pct = 0;\n\n        for (uint256 i = 0; i < claims.length; ++i) {\n            ClaimParams memory data = claims[i];\n            _createClaim(\n                _depositGroupIds.current(),\n                _amount,\n                _lockedUntil,\n                data,\n                localTotalShares,\n                localTotalUnderlying\n            );\n            pct += data.pct;\n        }\n\n        _depositGroupIds.increment();\n\n        require(pct.is100Perc(), \"Vault: claims don't add up to 100%\");\n    }\n\n    function _createClaim(\n        uint256 _depositGroupId,\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams memory _claim,\n        uint256 _localTotalShares,\n        uint256 _localTotalPrincipal\n    ) internal {\n        uint256 amount = _amount.percOf(_claim.pct);\n\n        uint256 newShares = _computeShares(\n            amount,\n            _localTotalShares,\n            _localTotalPrincipal\n        );\n\n        uint256 claimerId = claimers.mint(\n            _claim.beneficiary,\n            amount,\n            newShares\n        );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            amount,\n            claimerId,\n            _lockedUntil\n        );\n\n        if (_isIntegration(_claim.beneficiary)) {\n            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(\n                tokenId,\n                newShares,\n                _claim.data\n            );\n\n            require(\n                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector\n            );\n        }\n\n        emit DepositMinted(\n            tokenId,\n            _depositGroupId,\n            amount,\n            newShares,\n            _msgSender(),\n            _claim.beneficiary,\n            claimerId,\n            _lockedUntil\n        );\n    }\n\n    /**\n     * Burns a deposit NFT and reduces the principal and shares of the claimer.\n     * If there were any yield to be claimed, the claimer will also keep shares to withdraw later on.\n     *\n     * @notice This function doesn't transfer any funds, it only updates the state.\n     *\n     * @notice Only the owner of the deposit may call this function.\n     *\n     * @param _tokenId The deposit ID to withdraw from.\n     * @param _totalShares The total shares to consider for the withdraw.\n     * @param _totalUnderlyingMinusSponsored The total underlying to consider for the withdraw.\n     *\n     * @return the amount to withdraw.\n     */\n    function _withdrawDeposit(\n        uint256 _tokenId,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored,\n        address _to,\n        bool _force\n    ) internal returns (uint256) {\n        require(\n            depositors.ownerOf(_tokenId) == _msgSender(),\n            \"Vault: you are not the owner of a deposit\"\n        );\n\n        (\n            uint256 depositAmount,\n            uint256 claimerId,\n            uint256 lockedUntil\n        ) = depositors.deposits(_tokenId);\n        require(lockedUntil <= block.timestamp, \"Vault: deposit is locked\");\n\n        require(claimerId != 0, \"Vault: token id is not a withdraw\");\n\n        uint256 claimerShares = claimers.sharesOf(claimerId);\n\n        uint256 depositShares = _computeShares(\n            depositAmount,\n            _totalShares,\n            _totalUnderlyingMinusSponsored\n        );\n\n        if (_force && depositShares > claimerShares) {\n            depositShares = claimerShares;\n        } else if (!_force) {\n            require(\n                claimerShares >= depositShares,\n                \"Vault: cannot withdraw more than the available amount\"\n            );\n        }\n\n        claimers.onWithdraw(claimerId, depositAmount, depositShares);\n        depositors.burn(_tokenId);\n\n        address claimer = claimers.ownerOf(claimerId);\n\n        if (_isIntegration(claimer)) {\n            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);\n\n            require(ret == IIntegration(claimer).onDepositBurned.selector);\n        }\n\n        emit DepositBurned(_tokenId, depositShares, _to);\n\n        return\n            _computeAmount(\n                depositShares,\n                _totalShares,\n                _totalUnderlyingMinusSponsored\n            );\n    }\n\n    function _transferAndCheckUnderlying(address _from, uint256 _amount)\n        internal\n    {\n        uint256 balanceBefore = totalUnderlying();\n        underlying.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = totalUnderlying();\n\n        require(\n            balanceAfter == balanceBefore + _amount,\n            \"Vault: amount received does not match params\"\n        );\n    }\n\n    function _blockTimestamp() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    /**\n     * Computes amount of shares that will be received for a given deposit amount\n     *\n     * @param _amount Amount of deposit to consider.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount of shares the deposit will receive.\n     */\n    function _computeShares(\n        uint256 _amount,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_amount == 0) return 0;\n        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;\n\n        require(\n            _totalUnderlyingMinusSponsored > 0,\n            \"Vault: cannot compute shares when there's no principal\"\n        );\n\n        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;\n    }\n\n    /**\n     * Computes the amount of underlying from a given number of shares\n     *\n     * @param _shares Number of shares.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount that corresponds to the number of shares.\n     */\n    function _computeAmount(\n        uint256 _shares,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {\n            return 0;\n        } else {\n            // TODO exclude sponsored assets\n            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);\n        }\n    }\n\n    /**\n     * Checks if the given address is a contract implementing IIntegration\n     *\n     * @param addr Address to check\n     * @return true if contract is an IIntegraiont\n     */\n    function _isIntegration(address addr) internal view returns (bool) {\n        return\n            addr.doesContractImplementInterface(type(IIntegration).interfaceId);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-sandclock-findings.json",
                "Location": "onDepositBurned function in Vault.sol",
                "Type": "Reentrancy",
                "Description": "The impact of this is that users can get significantly more UST withdrawn than they would be allotted if they had done non-reentrant withdraw calls.",
                "Repair": "Add reentrancy guards. Simplify some of the shares logic."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Trust} from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\nimport {IVault} from \"./vault/IVault.sol\";\nimport {IVaultSponsoring} from \"./vault/IVaultSponsoring.sol\";\nimport {PercentMath} from \"./lib/PercentMath.sol\";\nimport {Depositors} from \"./vault/Depositors.sol\";\nimport {Claimers} from \"./vault/Claimers.sol\";\nimport {IIntegration} from \"./integrations/IIntegration.sol\";\nimport {IStrategy} from \"./strategy/IStrategy.sol\";\nimport {ERC165Query} from \"./lib/ERC165Query.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * A vault where other accounts can deposit an underlying token\n * currency and set distribution params for their principal and yield\n *\n * @dev Yield generation strategies not yet implemented\n */\n\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n    using Counters for Counters.Counter;\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n    using Address for address;\n    using ERC165Query for address;\n\n    //\n    // Constants\n    //\n\n    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n    uint256 public constant SHARES_MULTIPLIER = 10**18;\n\n    //\n    // State\n    //\n\n    /// Underlying ERC20 token accepted by the vault\n    /// See {IVault}\n    IERC20 public override(IVault) underlying;\n\n    /// See {IVault}\n    IStrategy public strategy;\n\n    /// See {IVault}\n    uint256 public investPerc;\n\n    /// See {IVault}\n    uint256 public immutable override(IVault) minLockPeriod;\n\n    /// See {IVaultSponsoring}\n    uint256 public override(IVaultSponsoring) totalSponsored;\n\n    /// Depositors, represented as an NFT per deposit\n    Depositors public depositors;\n\n    /// Yield allocation\n    Claimers public claimers;\n\n    /// Unique IDs to correlate donations that belong to the same foundation\n    Counters.Counter private _depositGroupIds;\n\n    /**\n     * @param _underlying Underlying ERC20 token to use.\n     */\n    constructor(\n        IERC20 _underlying,\n        uint256 _minLockPeriod,\n        uint256 _investPerc,\n        address _owner\n    ) Trust(_owner) {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n        require(\n            address(_underlying) != address(0x0),\n            \"VaultContext: underlying cannot be 0x0\"\n        );\n        investPerc = _investPerc;\n        underlying = _underlying;\n        minLockPeriod = _minLockPeriod;\n\n        depositors = new Depositors(address(this), \"depositors\", \"p\");\n        claimers = new Claimers(address(this));\n    }\n\n    //\n    // IVault\n    //\n\n    /// See {IVault}\n    function setStrategy(address _strategy)\n        external\n        override(IVault)\n        requiresTrust\n    {\n        require(_strategy != address(0), \"Vault: strategy 0x\");\n        require(\n            IStrategy(_strategy).vault() == address(this),\n            \"Vault: invalid vault\"\n        );\n        require(\n            address(strategy) == address(0) || strategy.investedAssets() == 0,\n            \"Vault: strategy has invested funds\"\n        );\n\n        strategy = IStrategy(_strategy);\n    }\n\n    /// See {IVault}\n    function totalUnderlying() public view override(IVault) returns (uint256) {\n        if (address(strategy) != address(0)) {\n            return\n                underlying.balanceOf(address(this)) + strategy.investedAssets();\n        } else {\n            return underlying.balanceOf(address(this));\n        }\n    }\n\n    /// See {IVault}\n    function totalShares() public view override(IVault) returns (uint256) {\n        return claimers.totalShares();\n    }\n\n    /// See {IVault}\n    function yieldFor(address _to)\n        public\n        view\n        override(IVault)\n        returns (uint256)\n    {\n        uint256 tokenId = claimers.addressToTokenID(_to);\n        uint256 claimerPrincipal = claimers.principalOf(tokenId);\n        uint256 claimerShares = claimers.sharesOf(tokenId);\n        uint256 currentClaimerPrincipal = _computeAmount(\n            claimerShares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        if (currentClaimerPrincipal <= claimerPrincipal) {\n            return 0;\n        }\n\n        return currentClaimerPrincipal - claimerPrincipal;\n    }\n\n    /// See {IVault}\n    function deposit(DepositParams calldata _params) external {\n        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);\n        _transferAndCheckUnderlying(_msgSender(), _params.amount);\n    }\n\n    /// See {IVault}\n    function claimYield(address _to) external override(IVault) {\n        uint256 yield = yieldFor(_msgSender());\n\n        if (yield == 0) return;\n\n        uint256 shares = _computeShares(\n            yield,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n        uint256 sharesAmount = _computeAmount(\n            shares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);\n\n        underlying.safeTransfer(_to, sharesAmount);\n    }\n\n    /// See {IVault}\n    function withdraw(address _to, uint256[] memory _ids)\n        external\n        override(IVault)\n    {\n        _withdraw(_to, _ids, false);\n    }\n\n    /// See {IVault}\n    function forceWithdraw(address _to, uint256[] memory _ids) external {\n        _withdraw(_to, _ids, true);\n    }\n\n    /// See {IVault}\n    function setInvestPerc(uint16 _investPerc) external requiresTrust {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n\n        emit InvestPercentageUpdated(_investPerc);\n\n        investPerc = _investPerc;\n    }\n\n    /// See {IVault}\n    function investableAmount() public view returns (uint256) {\n        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);\n\n        uint256 alreadyInvested = strategy.investedAssets();\n\n        if (alreadyInvested >= maxInvestableAssets) {\n            return 0;\n        } else {\n            return maxInvestableAssets - alreadyInvested;\n        }\n    }\n\n    /// See {IVault}\n    function updateInvested() external requiresTrust {\n        require(address(strategy) != address(0), \"Vault: strategy is not set\");\n\n        uint256 _investable = investableAmount();\n\n        if (_investable > 0) {\n            underlying.safeTransfer(address(strategy), _investable);\n\n            emit Invested(_investable);\n        }\n\n        strategy.doHardWork();\n    }\n\n    //\n    // IVaultSponsoring\n\n    /// See {IVaultSponsoring}\n    function sponsor(uint256 _amount, uint256 _lockedUntil)\n        external\n        override(IVaultSponsoring)\n    {\n        if (_lockedUntil == 0)\n            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;\n        else\n            require(\n                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            _amount,\n            0,\n            _lockedUntil\n        );\n\n        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);\n\n        totalSponsored += _amount;\n        _transferAndCheckUnderlying(_msgSender(), _amount);\n    }\n\n    /// See {IVaultSponsoring}\n    function unsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, false);\n    }\n\n    /// See {IVaultSponsoring}\n    function forceUnsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, true);\n    }\n\n    //\n    // Public API\n    //\n\n    /**\n     * Computes the total amount of principal + yield currently controlled by the\n     * vault and the strategy. The principal + yield is the total amount\n     * of underlying that can be claimed or withdrawn, excluding the sponsored amount.\n     *\n     * @return Total amount of principal and yield help by the vault (not including sponsored amount).\n     */\n    function totalUnderlyingMinusSponsored() public view returns (uint256) {\n        // TODO no invested amount yet\n        return totalUnderlying() - totalSponsored;\n    }\n\n    //\n    // ERC165\n    //\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IVault).interfaceId ||\n            interfaceId == type(IVaultSponsoring).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    //\n    // Internal API\n    //\n\n    /**\n     * Withdraws the principal from the deposits with the ids provided in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _withdraw(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();\n        uint256 amount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            amount += _withdrawDeposit(\n                _ids[i],\n                localTotalShares,\n                localTotalPrincipal,\n                _to,\n                _force\n            );\n        }\n\n        underlying.safeTransfer(_to, amount);\n    }\n\n    /**\n     * Withdraws the sponsored amount for the deposits with the ids provided\n     * in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _unsponsor(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 sponsorAmount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            uint256 tokenId = _ids[i];\n\n            require(\n                depositors.ownerOf(tokenId) == _msgSender(),\n                \"Vault: you are not the owner of a sponsor\"\n            );\n\n            (\n                uint256 depositAmount,\n                uint256 claimerId,\n                uint256 lockedUntil\n            ) = depositors.deposits(tokenId);\n            require(lockedUntil <= block.timestamp, \"Vault: amount is locked\");\n\n            require(claimerId == 0, \"Vault: token id is not a sponsor\");\n\n            depositors.burn(tokenId);\n\n            emit Unsponsored(tokenId);\n\n            sponsorAmount += depositAmount;\n        }\n\n        uint256 sponsorToTransfer = sponsorAmount;\n\n        if (_force && sponsorAmount > totalUnderlying()) {\n            sponsorToTransfer = totalUnderlying();\n        } else if (!_force) {\n            require(\n                sponsorToTransfer <= totalUnderlying(),\n                \"Vault: not enough funds to unsponsor\"\n            );\n        }\n\n        totalSponsored -= sponsorAmount;\n\n        underlying.safeTransfer(_to, sponsorToTransfer);\n    }\n\n    /**\n     * Creates a deposit with the given amount of underlying and claim\n     * structure. The deposit is locked until the timestamp specified in @param _lockedUntil.\n     * @notice This function assumes underlying will be transfered elsewhere in\n     * the transaction.\n     *\n     * @notice Underlying must be transfered *after* this function, in order to\n     * correctly calculate shares.\n     *\n     * @notice claims must add up to 100%.\n     *\n     * @param _amount Amount of underlying to consider @param claims claim\n     * @param _lockedUntil When the depositor can unsponsor the amount.\n     * @param claims Claim params\n     * params.\n     */\n    function _createDeposit(\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams[] calldata claims\n    ) internal {\n        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;\n        else\n            require(\n                _lockedUntil >= block.timestamp + minLockPeriod,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();\n        uint256 pct = 0;\n\n        for (uint256 i = 0; i < claims.length; ++i) {\n            ClaimParams memory data = claims[i];\n            _createClaim(\n                _depositGroupIds.current(),\n                _amount,\n                _lockedUntil,\n                data,\n                localTotalShares,\n                localTotalUnderlying\n            );\n            pct += data.pct;\n        }\n\n        _depositGroupIds.increment();\n\n        require(pct.is100Perc(), \"Vault: claims don't add up to 100%\");\n    }\n\n    function _createClaim(\n        uint256 _depositGroupId,\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams memory _claim,\n        uint256 _localTotalShares,\n        uint256 _localTotalPrincipal\n    ) internal {\n        uint256 amount = _amount.percOf(_claim.pct);\n\n        uint256 newShares = _computeShares(\n            amount,\n            _localTotalShares,\n            _localTotalPrincipal\n        );\n\n        uint256 claimerId = claimers.mint(\n            _claim.beneficiary,\n            amount,\n            newShares\n        );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            amount,\n            claimerId,\n            _lockedUntil\n        );\n\n        if (_isIntegration(_claim.beneficiary)) {\n            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(\n                tokenId,\n                newShares,\n                _claim.data\n            );\n\n            require(\n                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector\n            );\n        }\n\n        emit DepositMinted(\n            tokenId,\n            _depositGroupId,\n            amount,\n            newShares,\n            _msgSender(),\n            _claim.beneficiary,\n            claimerId,\n            _lockedUntil\n        );\n    }\n\n    /**\n     * Burns a deposit NFT and reduces the principal and shares of the claimer.\n     * If there were any yield to be claimed, the claimer will also keep shares to withdraw later on.\n     *\n     * @notice This function doesn't transfer any funds, it only updates the state.\n     *\n     * @notice Only the owner of the deposit may call this function.\n     *\n     * @param _tokenId The deposit ID to withdraw from.\n     * @param _totalShares The total shares to consider for the withdraw.\n     * @param _totalUnderlyingMinusSponsored The total underlying to consider for the withdraw.\n     *\n     * @return the amount to withdraw.\n     */\n    function _withdrawDeposit(\n        uint256 _tokenId,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored,\n        address _to,\n        bool _force\n    ) internal returns (uint256) {\n        require(\n            depositors.ownerOf(_tokenId) == _msgSender(),\n            \"Vault: you are not the owner of a deposit\"\n        );\n\n        (\n            uint256 depositAmount,\n            uint256 claimerId,\n            uint256 lockedUntil\n        ) = depositors.deposits(_tokenId);\n        require(lockedUntil <= block.timestamp, \"Vault: deposit is locked\");\n\n        require(claimerId != 0, \"Vault: token id is not a withdraw\");\n\n        uint256 claimerShares = claimers.sharesOf(claimerId);\n\n        uint256 depositShares = _computeShares(\n            depositAmount,\n            _totalShares,\n            _totalUnderlyingMinusSponsored\n        );\n\n        if (_force && depositShares > claimerShares) {\n            depositShares = claimerShares;\n        } else if (!_force) {\n            require(\n                claimerShares >= depositShares,\n                \"Vault: cannot withdraw more than the available amount\"\n            );\n        }\n\n        claimers.onWithdraw(claimerId, depositAmount, depositShares);\n        depositors.burn(_tokenId);\n\n        address claimer = claimers.ownerOf(claimerId);\n\n        if (_isIntegration(claimer)) {\n            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);\n\n            require(ret == IIntegration(claimer).onDepositBurned.selector);\n        }\n\n        emit DepositBurned(_tokenId, depositShares, _to);\n\n        return\n            _computeAmount(\n                depositShares,\n                _totalShares,\n                _totalUnderlyingMinusSponsored\n            );\n    }\n\n    function _transferAndCheckUnderlying(address _from, uint256 _amount)\n        internal\n    {\n        uint256 balanceBefore = totalUnderlying();\n        underlying.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = totalUnderlying();\n\n        require(\n            balanceAfter == balanceBefore + _amount,\n            \"Vault: amount received does not match params\"\n        );\n    }\n\n    function _blockTimestamp() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    /**\n     * Computes amount of shares that will be received for a given deposit amount\n     *\n     * @param _amount Amount of deposit to consider.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount of shares the deposit will receive.\n     */\n    function _computeShares(\n        uint256 _amount,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_amount == 0) return 0;\n        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;\n\n        require(\n            _totalUnderlyingMinusSponsored > 0,\n            \"Vault: cannot compute shares when there's no principal\"\n        );\n\n        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;\n    }\n\n    /**\n     * Computes the amount of underlying from a given number of shares\n     *\n     * @param _shares Number of shares.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount that corresponds to the number of shares.\n     */\n    function _computeAmount(\n        uint256 _shares,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {\n            return 0;\n        } else {\n            // TODO exclude sponsored assets\n            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);\n        }\n    }\n\n    /**\n     * Checks if the given address is a contract implementing IIntegration\n     *\n     * @param addr Address to check\n     * @return true if contract is an IIntegraiont\n     */\n    function _isIntegration(address addr) internal view returns (bool) {\n        return\n            addr.doesContractImplementInterface(type(IIntegration).interfaceId);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-sandclock-findings.json",
                "Location": "sponsor() function in Vault.sol",
                "Type": "Reentrancy",
                "Description": "In Vault.sol the sponsor() function does not have a reentrancy guard allowing an attacker to reenter the function because the depositors.mint() function has as callback to the msg.sender.",
                "Repair": "Add a reentrancy guard modifier to the sponsor() function in Vault.sol"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {Counters} from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {Trust} from \"@rari-capital/solmate/src/auth/Trust.sol\";\n\nimport {IVault} from \"./vault/IVault.sol\";\nimport {IVaultSponsoring} from \"./vault/IVaultSponsoring.sol\";\nimport {PercentMath} from \"./lib/PercentMath.sol\";\nimport {Depositors} from \"./vault/Depositors.sol\";\nimport {Claimers} from \"./vault/Claimers.sol\";\nimport {IIntegration} from \"./integrations/IIntegration.sol\";\nimport {IStrategy} from \"./strategy/IStrategy.sol\";\nimport {ERC165Query} from \"./lib/ERC165Query.sol\";\n\nimport \"hardhat/console.sol\";\n\n/**\n * A vault where other accounts can deposit an underlying token\n * currency and set distribution params for their principal and yield\n *\n * @dev Yield generation strategies not yet implemented\n */\n\ncontract Vault is IVault, IVaultSponsoring, Context, ERC165, Trust {\n    using Counters for Counters.Counter;\n    using SafeERC20 for IERC20;\n    using PercentMath for uint256;\n    using Address for address;\n    using ERC165Query for address;\n\n    //\n    // Constants\n    //\n\n    uint256 public constant MIN_SPONSOR_LOCK_DURATION = 1209600; // 2 weeks in seconds\n    uint256 public constant SHARES_MULTIPLIER = 10**18;\n\n    //\n    // State\n    //\n\n    /// Underlying ERC20 token accepted by the vault\n    /// See {IVault}\n    IERC20 public override(IVault) underlying;\n\n    /// See {IVault}\n    IStrategy public strategy;\n\n    /// See {IVault}\n    uint256 public investPerc;\n\n    /// See {IVault}\n    uint256 public immutable override(IVault) minLockPeriod;\n\n    /// See {IVaultSponsoring}\n    uint256 public override(IVaultSponsoring) totalSponsored;\n\n    /// Depositors, represented as an NFT per deposit\n    Depositors public depositors;\n\n    /// Yield allocation\n    Claimers public claimers;\n\n    /// Unique IDs to correlate donations that belong to the same foundation\n    Counters.Counter private _depositGroupIds;\n\n    /**\n     * @param _underlying Underlying ERC20 token to use.\n     */\n    constructor(\n        IERC20 _underlying,\n        uint256 _minLockPeriod,\n        uint256 _investPerc,\n        address _owner\n    ) Trust(_owner) {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n        require(\n            address(_underlying) != address(0x0),\n            \"VaultContext: underlying cannot be 0x0\"\n        );\n        investPerc = _investPerc;\n        underlying = _underlying;\n        minLockPeriod = _minLockPeriod;\n\n        depositors = new Depositors(address(this), \"depositors\", \"p\");\n        claimers = new Claimers(address(this));\n    }\n\n    //\n    // IVault\n    //\n\n    /// See {IVault}\n    function setStrategy(address _strategy)\n        external\n        override(IVault)\n        requiresTrust\n    {\n        require(_strategy != address(0), \"Vault: strategy 0x\");\n        require(\n            IStrategy(_strategy).vault() == address(this),\n            \"Vault: invalid vault\"\n        );\n        require(\n            address(strategy) == address(0) || strategy.investedAssets() == 0,\n            \"Vault: strategy has invested funds\"\n        );\n\n        strategy = IStrategy(_strategy);\n    }\n\n    /// See {IVault}\n    function totalUnderlying() public view override(IVault) returns (uint256) {\n        if (address(strategy) != address(0)) {\n            return\n                underlying.balanceOf(address(this)) + strategy.investedAssets();\n        } else {\n            return underlying.balanceOf(address(this));\n        }\n    }\n\n    /// See {IVault}\n    function totalShares() public view override(IVault) returns (uint256) {\n        return claimers.totalShares();\n    }\n\n    /// See {IVault}\n    function yieldFor(address _to)\n        public\n        view\n        override(IVault)\n        returns (uint256)\n    {\n        uint256 tokenId = claimers.addressToTokenID(_to);\n        uint256 claimerPrincipal = claimers.principalOf(tokenId);\n        uint256 claimerShares = claimers.sharesOf(tokenId);\n        uint256 currentClaimerPrincipal = _computeAmount(\n            claimerShares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        if (currentClaimerPrincipal <= claimerPrincipal) {\n            return 0;\n        }\n\n        return currentClaimerPrincipal - claimerPrincipal;\n    }\n\n    /// See {IVault}\n    function deposit(DepositParams calldata _params) external {\n        _createDeposit(_params.amount, _params.lockedUntil, _params.claims);\n        _transferAndCheckUnderlying(_msgSender(), _params.amount);\n    }\n\n    /// See {IVault}\n    function claimYield(address _to) external override(IVault) {\n        uint256 yield = yieldFor(_msgSender());\n\n        if (yield == 0) return;\n\n        uint256 shares = _computeShares(\n            yield,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n        uint256 sharesAmount = _computeAmount(\n            shares,\n            totalShares(),\n            totalUnderlyingMinusSponsored()\n        );\n\n        claimers.claimYield(_msgSender(), _to, sharesAmount, shares);\n\n        underlying.safeTransfer(_to, sharesAmount);\n    }\n\n    /// See {IVault}\n    function withdraw(address _to, uint256[] memory _ids)\n        external\n        override(IVault)\n    {\n        _withdraw(_to, _ids, false);\n    }\n\n    /// See {IVault}\n    function forceWithdraw(address _to, uint256[] memory _ids) external {\n        _withdraw(_to, _ids, true);\n    }\n\n    /// See {IVault}\n    function setInvestPerc(uint16 _investPerc) external requiresTrust {\n        require(\n            PercentMath.validPerc(_investPerc),\n            \"Vault: invalid investPerc\"\n        );\n\n        emit InvestPercentageUpdated(_investPerc);\n\n        investPerc = _investPerc;\n    }\n\n    /// See {IVault}\n    function investableAmount() public view returns (uint256) {\n        uint256 maxInvestableAssets = totalUnderlying().percOf(investPerc);\n\n        uint256 alreadyInvested = strategy.investedAssets();\n\n        if (alreadyInvested >= maxInvestableAssets) {\n            return 0;\n        } else {\n            return maxInvestableAssets - alreadyInvested;\n        }\n    }\n\n    /// See {IVault}\n    function updateInvested() external requiresTrust {\n        require(address(strategy) != address(0), \"Vault: strategy is not set\");\n\n        uint256 _investable = investableAmount();\n\n        if (_investable > 0) {\n            underlying.safeTransfer(address(strategy), _investable);\n\n            emit Invested(_investable);\n        }\n\n        strategy.doHardWork();\n    }\n\n    //\n    // IVaultSponsoring\n\n    /// See {IVaultSponsoring}\n    function sponsor(uint256 _amount, uint256 _lockedUntil)\n        external\n        override(IVaultSponsoring)\n    {\n        if (_lockedUntil == 0)\n            _lockedUntil = block.timestamp + MIN_SPONSOR_LOCK_DURATION;\n        else\n            require(\n                _lockedUntil >= block.timestamp + MIN_SPONSOR_LOCK_DURATION,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            _amount,\n            0,\n            _lockedUntil\n        );\n\n        emit Sponsored(tokenId, _amount, _msgSender(), _lockedUntil);\n\n        totalSponsored += _amount;\n        _transferAndCheckUnderlying(_msgSender(), _amount);\n    }\n\n    /// See {IVaultSponsoring}\n    function unsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, false);\n    }\n\n    /// See {IVaultSponsoring}\n    function forceUnsponsor(address _to, uint256[] memory _ids) external {\n        _unsponsor(_to, _ids, true);\n    }\n\n    //\n    // Public API\n    //\n\n    /**\n     * Computes the total amount of principal + yield currently controlled by the\n     * vault and the strategy. The principal + yield is the total amount\n     * of underlying that can be claimed or withdrawn, excluding the sponsored amount.\n     *\n     * @return Total amount of principal and yield help by the vault (not including sponsored amount).\n     */\n    function totalUnderlyingMinusSponsored() public view returns (uint256) {\n        // TODO no invested amount yet\n        return totalUnderlying() - totalSponsored;\n    }\n\n    //\n    // ERC165\n    //\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IVault).interfaceId ||\n            interfaceId == type(IVaultSponsoring).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    //\n    // Internal API\n    //\n\n    /**\n     * Withdraws the principal from the deposits with the ids provided in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _withdraw(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalPrincipal = totalUnderlyingMinusSponsored();\n        uint256 amount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            amount += _withdrawDeposit(\n                _ids[i],\n                localTotalShares,\n                localTotalPrincipal,\n                _to,\n                _force\n            );\n        }\n\n        underlying.safeTransfer(_to, amount);\n    }\n\n    /**\n     * Withdraws the sponsored amount for the deposits with the ids provided\n     * in @param _ids and sends it to @param _to.\n     *\n     * @notice the NFTs of the deposits will be burned.\n     *\n     * @param _to Address that will receive the funds.\n     * @param _ids Array with the ids of the deposits.\n     * @param _force Boolean to specify if the action should be perfomed when there's loss.\n     */\n    function _unsponsor(\n        address _to,\n        uint256[] memory _ids,\n        bool _force\n    ) internal {\n        uint256 sponsorAmount;\n\n        for (uint8 i = 0; i < _ids.length; i++) {\n            uint256 tokenId = _ids[i];\n\n            require(\n                depositors.ownerOf(tokenId) == _msgSender(),\n                \"Vault: you are not the owner of a sponsor\"\n            );\n\n            (\n                uint256 depositAmount,\n                uint256 claimerId,\n                uint256 lockedUntil\n            ) = depositors.deposits(tokenId);\n            require(lockedUntil <= block.timestamp, \"Vault: amount is locked\");\n\n            require(claimerId == 0, \"Vault: token id is not a sponsor\");\n\n            depositors.burn(tokenId);\n\n            emit Unsponsored(tokenId);\n\n            sponsorAmount += depositAmount;\n        }\n\n        uint256 sponsorToTransfer = sponsorAmount;\n\n        if (_force && sponsorAmount > totalUnderlying()) {\n            sponsorToTransfer = totalUnderlying();\n        } else if (!_force) {\n            require(\n                sponsorToTransfer <= totalUnderlying(),\n                \"Vault: not enough funds to unsponsor\"\n            );\n        }\n\n        totalSponsored -= sponsorAmount;\n\n        underlying.safeTransfer(_to, sponsorToTransfer);\n    }\n\n    /**\n     * Creates a deposit with the given amount of underlying and claim\n     * structure. The deposit is locked until the timestamp specified in @param _lockedUntil.\n     * @notice This function assumes underlying will be transfered elsewhere in\n     * the transaction.\n     *\n     * @notice Underlying must be transfered *after* this function, in order to\n     * correctly calculate shares.\n     *\n     * @notice claims must add up to 100%.\n     *\n     * @param _amount Amount of underlying to consider @param claims claim\n     * @param _lockedUntil When the depositor can unsponsor the amount.\n     * @param claims Claim params\n     * params.\n     */\n    function _createDeposit(\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams[] calldata claims\n    ) internal {\n        if (_lockedUntil == 0) _lockedUntil = block.timestamp + minLockPeriod;\n        else\n            require(\n                _lockedUntil >= block.timestamp + minLockPeriod,\n                \"Vault: lock time is too small\"\n            );\n\n        uint256 localTotalShares = totalShares();\n        uint256 localTotalUnderlying = totalUnderlyingMinusSponsored();\n        uint256 pct = 0;\n\n        for (uint256 i = 0; i < claims.length; ++i) {\n            ClaimParams memory data = claims[i];\n            _createClaim(\n                _depositGroupIds.current(),\n                _amount,\n                _lockedUntil,\n                data,\n                localTotalShares,\n                localTotalUnderlying\n            );\n            pct += data.pct;\n        }\n\n        _depositGroupIds.increment();\n\n        require(pct.is100Perc(), \"Vault: claims don't add up to 100%\");\n    }\n\n    function _createClaim(\n        uint256 _depositGroupId,\n        uint256 _amount,\n        uint256 _lockedUntil,\n        ClaimParams memory _claim,\n        uint256 _localTotalShares,\n        uint256 _localTotalPrincipal\n    ) internal {\n        uint256 amount = _amount.percOf(_claim.pct);\n\n        uint256 newShares = _computeShares(\n            amount,\n            _localTotalShares,\n            _localTotalPrincipal\n        );\n\n        uint256 claimerId = claimers.mint(\n            _claim.beneficiary,\n            amount,\n            newShares\n        );\n\n        uint256 tokenId = depositors.mint(\n            _msgSender(),\n            amount,\n            claimerId,\n            _lockedUntil\n        );\n\n        if (_isIntegration(_claim.beneficiary)) {\n            bytes4 ret = IIntegration(_claim.beneficiary).onDepositMinted(\n                tokenId,\n                newShares,\n                _claim.data\n            );\n\n            require(\n                ret == IIntegration(_claim.beneficiary).onDepositMinted.selector\n            );\n        }\n\n        emit DepositMinted(\n            tokenId,\n            _depositGroupId,\n            amount,\n            newShares,\n            _msgSender(),\n            _claim.beneficiary,\n            claimerId,\n            _lockedUntil\n        );\n    }\n\n    /**\n     * Burns a deposit NFT and reduces the principal and shares of the claimer.\n     * If there were any yield to be claimed, the claimer will also keep shares to withdraw later on.\n     *\n     * @notice This function doesn't transfer any funds, it only updates the state.\n     *\n     * @notice Only the owner of the deposit may call this function.\n     *\n     * @param _tokenId The deposit ID to withdraw from.\n     * @param _totalShares The total shares to consider for the withdraw.\n     * @param _totalUnderlyingMinusSponsored The total underlying to consider for the withdraw.\n     *\n     * @return the amount to withdraw.\n     */\n    function _withdrawDeposit(\n        uint256 _tokenId,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored,\n        address _to,\n        bool _force\n    ) internal returns (uint256) {\n        require(\n            depositors.ownerOf(_tokenId) == _msgSender(),\n            \"Vault: you are not the owner of a deposit\"\n        );\n\n        (\n            uint256 depositAmount,\n            uint256 claimerId,\n            uint256 lockedUntil\n        ) = depositors.deposits(_tokenId);\n        require(lockedUntil <= block.timestamp, \"Vault: deposit is locked\");\n\n        require(claimerId != 0, \"Vault: token id is not a withdraw\");\n\n        uint256 claimerShares = claimers.sharesOf(claimerId);\n\n        uint256 depositShares = _computeShares(\n            depositAmount,\n            _totalShares,\n            _totalUnderlyingMinusSponsored\n        );\n\n        if (_force && depositShares > claimerShares) {\n            depositShares = claimerShares;\n        } else if (!_force) {\n            require(\n                claimerShares >= depositShares,\n                \"Vault: cannot withdraw more than the available amount\"\n            );\n        }\n\n        claimers.onWithdraw(claimerId, depositAmount, depositShares);\n        depositors.burn(_tokenId);\n\n        address claimer = claimers.ownerOf(claimerId);\n\n        if (_isIntegration(claimer)) {\n            bytes4 ret = IIntegration(claimer).onDepositBurned(_tokenId);\n\n            require(ret == IIntegration(claimer).onDepositBurned.selector);\n        }\n\n        emit DepositBurned(_tokenId, depositShares, _to);\n\n        return\n            _computeAmount(\n                depositShares,\n                _totalShares,\n                _totalUnderlyingMinusSponsored\n            );\n    }\n\n    function _transferAndCheckUnderlying(address _from, uint256 _amount)\n        internal\n    {\n        uint256 balanceBefore = totalUnderlying();\n        underlying.safeTransferFrom(_from, address(this), _amount);\n        uint256 balanceAfter = totalUnderlying();\n\n        require(\n            balanceAfter == balanceBefore + _amount,\n            \"Vault: amount received does not match params\"\n        );\n    }\n\n    function _blockTimestamp() public view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n\n    /**\n     * Computes amount of shares that will be received for a given deposit amount\n     *\n     * @param _amount Amount of deposit to consider.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount of shares the deposit will receive.\n     */\n    function _computeShares(\n        uint256 _amount,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_amount == 0) return 0;\n        if (_totalShares == 0) return _amount * SHARES_MULTIPLIER;\n\n        require(\n            _totalUnderlyingMinusSponsored > 0,\n            \"Vault: cannot compute shares when there's no principal\"\n        );\n\n        return (_amount * _totalShares) / _totalUnderlyingMinusSponsored;\n    }\n\n    /**\n     * Computes the amount of underlying from a given number of shares\n     *\n     * @param _shares Number of shares.\n     * @param _totalShares Amount of existing shares to consider.\n     * @param _totalUnderlyingMinusSponsored Amounf of existing underlying to consider.\n     * @return Amount that corresponds to the number of shares.\n     */\n    function _computeAmount(\n        uint256 _shares,\n        uint256 _totalShares,\n        uint256 _totalUnderlyingMinusSponsored\n    ) internal pure returns (uint256) {\n        if (_totalShares == 0 || _totalUnderlyingMinusSponsored == 0) {\n            return 0;\n        } else {\n            // TODO exclude sponsored assets\n            return ((_totalUnderlyingMinusSponsored * _shares) / _totalShares);\n        }\n    }\n\n    /**\n     * Checks if the given address is a contract implementing IIntegration\n     *\n     * @param addr Address to check\n     * @return true if contract is an IIntegraiont\n     */\n    function _isIntegration(address addr) internal view returns (bool) {\n        return\n            addr.doesContractImplementInterface(type(IIntegration).interfaceId);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-sandclock-findings.json",
                "Location": "deposit() function in Vault.sol",
                "Type": "Reentrancy",
                "Description": "The deposit() function in Vault.sol is vulnerable to reentrancy attacks due to the lack of reentrancy guard modifiers.",
                "Repair": "Add reentrancy guard modifiers to deposit(), withdraw(), and other important protocol functions"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IDue} from './interfaces/IDue.sol';\nimport {IERC721Receiver} from '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport {IConvenience} from './interfaces/IConvenience.sol';\nimport {IPair} from '@timeswap-labs/timeswap-v1-core/contracts/interfaces/IPair.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport {ERC721Permit} from './base/ERC721Permit.sol';\nimport {SafeMetadata} from './libraries/SafeMetadata.sol';\nimport {Strings} from '@openzeppelin/contracts/utils/Strings.sol';\nimport {NFTTokenURIScaffold} from './libraries/NFTTokenURIScaffold.sol';\n\ncontract CollateralizedDebt is IDue, ERC721Permit {\n    using Strings for uint256;\n    using SafeMetadata for IERC20;\n\n    IConvenience public immutable override convenience;\n    IPair public immutable override pair;\n    uint256 public immutable override maturity;\n\n    function name() external view override returns (string memory) {\n        string memory assetName = pair.asset().safeName();\n        string memory collateralName = pair.collateral().safeName();\n        return\n            string(\n                abi.encodePacked(\n                    'Timeswap Collateralized Debt - ',\n                    assetName,\n                    ' - ',\n                    collateralName,\n                    ' - ',\n                    maturity.toString()\n                )\n            );\n    }\n\n    function symbol() external view override returns (string memory) {\n        string memory assetSymbol = pair.asset().safeSymbol();\n        string memory collateralSymbol = pair.collateral().safeSymbol();\n        return string(abi.encodePacked('TS-CDT-', assetSymbol, '-', collateralSymbol, '-', maturity.toString()));\n    }\n\n    function tokenURI(uint256 id) external view override returns (string memory) {\n        require(ownerOf[id] != address(0), 'E404');\n        return NFTTokenURIScaffold.tokenURI(id, pair, dueOf(id), maturity);\n    }\n\n    function assetDecimals() external view override returns (uint8) {\n        return pair.asset().safeDecimals();\n    }\n\n    function collateralDecimals() external view override returns (uint8) {\n        return pair.collateral().safeDecimals();\n    }\n\n    function dueOf(uint256 id) public view override returns (IPair.Due memory) {\n        return pair.dueOf(maturity, address(this), id);\n    }\n\n    constructor(\n        IConvenience _convenience,\n        IPair _pair,\n        uint256 _maturity\n    ) ERC721Permit('Timeswap Collateralized Debt') {\n        convenience = _convenience;\n        pair = _pair;\n        maturity = _maturity;\n    }\n\n    modifier onlyConvenience() {\n        require(msg.sender == address(convenience), 'E403');\n        _;\n    }\n\n    function mint(address to, uint256 id) external override onlyConvenience {\n        _safeMint(to, id);\n    }\n\n    function burn(\n        address to,\n        uint256[] memory ids,\n        uint112[] memory assetsIn,\n        uint112[] memory collateralsOut,\n        bytes calldata data\n    ) external override onlyConvenience returns (uint128 assetIn, uint128 collateralOut) {\n        (assetIn, collateralOut) = pair.pay(maturity, to, address(this), ids, assetsIn, collateralsOut, data);\n    }\n\n    function timeswapPayCallback(uint128 assetIn, bytes calldata data) external override {\n        require(msg.sender == address(pair), 'E401');\n\n        convenience.collateralizedDebtCallback(pair, maturity, assetIn, data);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-01-timeswap-findings.json",
                "Location": "CollateralizedDebt.sol#mint()",
                "Type": "Reentrancy",
                "Description": "Functions with callbacks should have reentrancy guards in place for protection against possible malicious actors both from inside and outside the protocol.",
                "Repair": "Add a reentrancy guard modifier on the mint() function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IShelter } from \"./interfaces/IShelter.sol\";\nimport { IShelterClient } from \"./interfaces/IShelterClient.sol\";\n\ncontract Shelter is IShelter {\n    using SafeERC20 for IERC20;\n\n    IShelterClient public immutable client;\n\n    uint256 public constant GRACE_PERIOD = 1 weeks;\n\n    mapping(IERC20 => mapping(address => bool)) public override claimed;\n\n    mapping(IERC20 => uint256) public activated;\n\n    mapping(IERC20 => uint256) public savedTokens;\n\n    modifier onlyClient {\n        require(msg.sender == address(client), \"!client\");\n        _;\n    }\n\n    constructor(IShelterClient _client){\n        client = _client;\n    }\n\n    function donate(IERC20 _token, uint256 _amount) external {\n        require(activated[_token] != 0, \"!activated\");\n        savedTokens[_token] += _amount;\n        _token.safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function activate(IERC20 _token) external override onlyClient {\n        activated[_token] = block.timestamp;\n        savedTokens[_token] = _token.balanceOf(address(this));\n        emit ShelterActivated(_token);\n    }\n\n    function deactivate(IERC20 _token) external override onlyClient {\n        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD > block.timestamp, \"too late\");\n        activated[_token] = 0;\n        savedTokens[_token] = 0;\n        _token.safeTransfer(msg.sender, _token.balanceOf(address(this)));\n        emit ShelterDeactivated(_token);\n    }\n\n    function withdraw(IERC20 _token, address _to) external override {\n        require(activated[_token] != 0 && activated[_token] + GRACE_PERIOD < block.timestamp, \"shelter not activated\");\n        uint256 amount = savedTokens[_token] * client.shareOf(_token, msg.sender) / client.totalShare(_token);\n        claimed[_token][_to] = true;\n        emit ExitShelter(_token, msg.sender, _to, amount);\n        _token.safeTransfer(_to, amount);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-02-concur-findings.json",
                "Location": "Shelter.sol withdraw() function",
                "Type": "Reentrancy",
                "Description": "Repeated calls to Shelter.withdraw can drain all funds in Shelter, allowing an attacker that can successfully call withdraw() once on a shelter, to call it repeatedly to steal the funds of others.",
                "Repair": "Check claims against msg.sender and record who is withdrawing"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.11;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IConcurRewardClaim} from \"./interfaces/IConcurRewardClaim.sol\";\n\ncontract ConcurRewardPool is IConcurRewardClaim {\n    using SafeERC20 for IERC20;\n    address public immutable rewardNotifier;\n\n    mapping(address => mapping(address => uint256)) public reward;\n\n    constructor(address _notifier) {\n        rewardNotifier = _notifier;\n    }\n\n    /// @notice push reward to `_recipient`\n    /// @param _recipient reward recipient address\n    /// @param _token token to reward\n    /// @param _amount amount of tokens to allocate to `_recipient`\n    function pushReward(\n        address _recipient,\n        address _token,\n        uint256 _amount\n    ) external override {\n        require(msg.sender == rewardNotifier, \"!notifier\");\n        reward[_recipient][_token] += _amount;\n    }\n\n    /// @notice claim rewards of `msg.sender`\n    /// @param _tokens array of tokens to claim\n    function claimRewards(address[] calldata _tokens) external override {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            uint256 getting = reward[msg.sender][_tokens[i]];\n            IERC20(_tokens[i]).safeTransfer(msg.sender, getting);\n            reward[msg.sender][_tokens[i]] = 0;\n        }\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-02-concur-findings.json",
                "Location": "ConcurRewardPool.sol#L34",
                "Type": "Reentrancy",
                "Description": "The reward tokens are transferred before the balances are set to 0, making it possible to perform a reentrancy attack if the reward token has some kind of call back functionality.",
                "Repair": "Use a nonReentrant modifier, set balances to 0 first before disbursing the rewards"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ITransactionManager } from \"../Interfaces/ITransactionManager.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title NXTP (Connext) Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through NXTP (Connext)\n */\ncontract NXTPFacet is ILiFi, Swapper {\n    /* ========== Storage ========== */\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.nxtp\");\n    struct Storage {\n        ITransactionManager nxtpTxManager;\n    }\n\n    /* ========== Events ========== */\n\n    event NXTPBridgeStarted(\n        bytes32 indexed lifiTransactionId,\n        bytes32 nxtpTransactionId,\n        ITransactionManager.TransactionData txData\n    );\n\n    /* ========== Init ========== */\n\n    function initNXTP(ITransactionManager _txMgrAddr) external {\n        Storage storage s = getStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.nxtpTxManager = _txMgrAddr;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice This function starts a cross-chain transaction using the NXTP protocol\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _nxtpData data needed to complete an NXTP cross-chain transaction\n     */\n    function startBridgeTokensViaNXTP(LiFiData memory _lifiData, ITransactionManager.PrepareArgs memory _nxtpData)\n        public\n        payable\n    {\n        // Ensure sender has enough to complete the bridge transaction\n        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;\n        if (sendingAssetId == address(0)) require(msg.value == _nxtpData.amount, \"ERR_INVALID_AMOUNT\");\n        else {\n            uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _nxtpData.amount);\n            require(\n                LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _nxtpData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        }\n\n        // Start the bridge process\n        _startBridge(_lifiData.transactionId, _nxtpData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice This function performs a swap or multiple swaps and then starts a cross-chain transaction\n     *         using the NXTP protocol.\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData array of data needed for swaps\n     * @param _nxtpData data needed to complete an NXTP cross-chain transaction\n     */\n    function swapAndStartBridgeTokensViaNXTP(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        ITransactionManager.PrepareArgs memory _nxtpData\n    ) public payable {\n        address sendingAssetId = _nxtpData.invariantData.sendingAssetId;\n        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;\n\n        require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n        _nxtpData.amount = _postSwapBalance;\n\n        _startBridge(_lifiData.transactionId, _nxtpData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Completes a cross-chain transaction on the receiving chain using the NXTP protocol.\n     * @param _lifiData data used purely for tracking and analytics\n     * @param assetId token received on the receiving chain\n     * @param receiver address that will receive the tokens\n     * @param amount number of tokens received\n     */\n    function completeBridgeTokensViaNXTP(\n        LiFiData memory _lifiData,\n        address assetId,\n        address receiver,\n        uint256 amount\n    ) public payable {\n        if (LibAsset.isNativeAsset(assetId)) {\n            require(msg.value == amount, \"INVALID_ETH_AMOUNT\");\n        } else {\n            require(msg.value == 0, \"ETH_WITH_ERC\");\n            LibAsset.transferFromERC20(assetId, msg.sender, address(this), amount);\n        }\n\n        LibAsset.transferAsset(assetId, payable(receiver), amount);\n\n        emit LiFiTransferCompleted(_lifiData.transactionId, assetId, receiver, amount, block.timestamp);\n    }\n\n    /**\n     * @notice Performs a swap before completing a cross-chain transaction\n     *         on the receiving chain using the NXTP protocol.\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData array of data needed for swaps\n     * @param finalAssetId token received on the receiving chain\n     * @param receiver address that will receive the tokens\n     */\n    function swapAndCompleteBridgeTokensViaNXTP(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        address finalAssetId,\n        address receiver\n    ) public payable {\n        uint256 startingBalance = LibAsset.getOwnBalance(finalAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(finalAssetId);\n\n        uint256 finalBalance;\n\n        if (postSwapBalance > startingBalance) {\n            finalBalance = postSwapBalance - startingBalance;\n            LibAsset.transferAsset(finalAssetId, payable(receiver), finalBalance);\n        }\n\n        emit LiFiTransferCompleted(_lifiData.transactionId, finalAssetId, receiver, finalBalance, block.timestamp);\n    }\n\n    /* ========== Internal Functions ========== */\n\n    function _startBridge(bytes32 _transactionId, ITransactionManager.PrepareArgs memory _nxtpData) internal {\n        Storage storage s = getStorage();\n        IERC20 sendingAssetId = IERC20(_nxtpData.invariantData.sendingAssetId);\n\n        // Give Connext approval to bridge tokens\n        LibAsset.approveERC20(IERC20(sendingAssetId), address(s.nxtpTxManager), _nxtpData.amount);\n\n        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId)) ? _nxtpData.amount : 0;\n\n        // Initiate bridge transaction on sending chain\n        ITransactionManager.TransactionData memory result = s.nxtpTxManager.prepare{ value: value }(_nxtpData);\n\n        emit NXTPBridgeStarted(_transactionId, result.transactionId, result);\n    }\n\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n\n    /* ========== Getter Functions ========== */\n\n    /**\n     * @notice show the NXTP transaction manager contract address\n     */\n    function getNXTPTransactionManager() external view returns (address) {\n        Storage storage s = getStorage();\n        return address(s.nxtpTxManager);\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibStorage } from \"../Libraries/LibStorage.sol\";\n\ncontract Swapper is ILiFi {\n    /* ========== Storage ========== */\n    LibStorage internal ls;\n\n    function _executeSwaps(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) internal {\n        // Swap\n        for (uint8 i; i < _swapData.length; i++) {\n            require(\n                ls.dexWhitelist[_swapData[i].approveTo] == true && ls.dexWhitelist[_swapData[i].callTo] == true,\n                \"Contract call not allowed!\"\n            );\n\n            LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Generic Swap Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for swapping through ANY DEX\n * @dev Uses calldata to execute arbitrary methods on DEXs\n */\ncontract GenericSwapFacet is ILiFi, Swapper {\n    /* ========== Public Functions ========== */\n\n    /**\n     * @notice Performs a swap and that's it\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     */\n    function swapTokensGeneric(LiFiData memory _lifiData, LibSwap.SwapData[] calldata _swapData) public payable {\n        uint256 receivingAssetIdBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 postSwapBalance = LibAsset.getOwnBalance(_lifiData.receivingAssetId) - receivingAssetIdBalance;\n\n        LibAsset.transferAsset(_lifiData.receivingAssetId, payable(msg.sender), postSwapBalance);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IHopBridge } from \"../Interfaces/IHopBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Hop Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through Hop\n */\ncontract HopFacet is ILiFi, Swapper {\n    /* ========== Storage ========== */\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.hop\");\n    struct Storage {\n        mapping(string => IHopBridge.BridgeConfig) hopBridges;\n        uint256 hopChainId;\n    }\n\n    /* ========== Types ========== */\n\n    struct HopData {\n        string asset;\n        address recipient;\n        uint256 chainId;\n        uint256 amount;\n        uint256 bonderFee;\n        uint256 amountOutMin;\n        uint256 deadline;\n        uint256 destinationAmountOutMin;\n        uint256 destinationDeadline;\n    }\n\n    /* ========== Init ========== */\n\n    function initHop(\n        string[] memory _tokens,\n        IHopBridge.BridgeConfig[] memory _bridgeConfigs,\n        uint256 _chainId\n    ) external {\n        Storage storage s = getStorage();\n        LibDiamond.enforceIsContractOwner();\n\n        for (uint8 i; i < _tokens.length; i++) {\n            s.hopBridges[_tokens[i]] = _bridgeConfigs[i];\n        }\n        s.hopChainId = _chainId;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via Hop Protocol\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _hopData data specific to Hop Protocol\n     */\n    function startBridgeTokensViaHop(LiFiData memory _lifiData, HopData calldata _hopData) public payable {\n        address sendingAssetId = _bridge(_hopData.asset).token;\n\n        if (sendingAssetId == address(0)) require(msg.value == _hopData.amount, \"ERR_INVALID_AMOUNT\");\n        else {\n            uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n            LibAsset.transferFromERC20(sendingAssetId, msg.sender, address(this), _hopData.amount);\n            require(\n                LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance == _hopData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        }\n\n        _startBridge(_hopData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via Hop Protocol\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _hopData data specific to Hop Protocol\n     */\n    function swapAndStartBridgeTokensViaHop(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData memory _hopData\n    ) public payable {\n        address sendingAssetId = _bridge(_hopData.asset).token;\n\n        uint256 _sendingAssetIdBalance = LibAsset.getOwnBalance(sendingAssetId);\n\n        // Swap\n        _executeSwaps(_lifiData, _swapData);\n\n        uint256 _postSwapBalance = LibAsset.getOwnBalance(sendingAssetId) - _sendingAssetIdBalance;\n\n        require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n        _hopData.amount = _postSwapBalance;\n\n        _startBridge(_hopData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /**\n     * @dev Conatains the business logic for the bridge via Hop Protocol\n     * @param _hopData data specific to Hop Protocol\n     */\n    function _startBridge(HopData memory _hopData) internal {\n        Storage storage s = getStorage();\n        address sendingAssetId = _bridge(_hopData.asset).token;\n\n        address bridge;\n        if (s.hopChainId == 1) {\n            bridge = _bridge(_hopData.asset).bridge;\n        } else {\n            bridge = _bridge(_hopData.asset).ammWrapper;\n        }\n\n        // Do HOP stuff\n        require(s.hopChainId != _hopData.chainId, \"Cannot bridge to the same network.\");\n\n        // Give Hop approval to bridge tokens\n        LibAsset.approveERC20(IERC20(sendingAssetId), bridge, _hopData.amount);\n\n        uint256 value = LibAsset.isNativeAsset(address(sendingAssetId)) ? _hopData.amount : 0;\n\n        if (s.hopChainId == 1) {\n            // Ethereum L1\n            IHopBridge(bridge).sendToL2{ value: value }(\n                _hopData.chainId,\n                _hopData.recipient,\n                _hopData.amount,\n                _hopData.destinationAmountOutMin,\n                _hopData.destinationDeadline,\n                address(0),\n                0\n            );\n        } else {\n            // L2\n            // solhint-disable-next-line check-send-result\n            IHopBridge(bridge).swapAndSend{ value: value }(\n                _hopData.chainId,\n                _hopData.recipient,\n                _hopData.amount,\n                _hopData.bonderFee,\n                _hopData.amountOutMin,\n                _hopData.deadline,\n                _hopData.destinationAmountOutMin,\n                _hopData.destinationDeadline\n            );\n        }\n    }\n\n    function _bridge(string memory _asset) internal view returns (IHopBridge.BridgeConfig memory) {\n        Storage storage s = getStorage();\n        return s.hopBridges[_asset];\n    }\n\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IAnyswapRouter } from \"../Interfaces/IAnyswapRouter.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { IAnyswapToken } from \"../Interfaces/IAnyswapToken.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title Anyswap Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through Multichain (Prev. AnySwap)\n */\ncontract AnyswapFacet is ILiFi, Swapper {\n    /* ========== Types ========== */\n\n    struct AnyswapData {\n        address token;\n        address router;\n        uint256 amount;\n        address recipient;\n        uint256 toChainId;\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _anyswapData data specific to Anyswap\n     */\n    function startBridgeTokensViaAnyswap(LiFiData memory _lifiData, AnyswapData calldata _anyswapData) public payable {\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            if (underlyingToken == address(0)) {\n                underlyingToken = _anyswapData.token;\n            }\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n            LibAsset.transferFromERC20(underlyingToken, msg.sender, address(this), _anyswapData.amount);\n\n            require(\n                LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance == _anyswapData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        } else {\n            require(msg.value == _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via Anyswap\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _anyswapData data specific to Anyswap\n     */\n    function swapAndStartBridgeTokensViaAnyswap(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        AnyswapData memory _anyswapData\n    ) public payable {\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n        if (_anyswapData.token != address(0) && underlyingToken != IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            if (underlyingToken == address(0)) {\n                underlyingToken = _anyswapData.token;\n            }\n\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /**\n     * @dev Conatains the business logic for the bridge via Anyswap\n     * @param _anyswapData data specific to Anyswap\n     */\n    function _startBridge(AnyswapData memory _anyswapData) internal {\n        // Check chain id\n        require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");\n        address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n\n        if (underlyingToken == IAnyswapRouter(_anyswapData.router).wNATIVE()) {\n            IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(\n                _anyswapData.token,\n                _anyswapData.recipient,\n                _anyswapData.toChainId\n            );\n            return;\n        }\n\n        if (_anyswapData.token != address(0)) {\n            // Has underlying token?\n            if (underlyingToken != address(0)) {\n                // Give Anyswap approval to bridge tokens\n                LibAsset.approveERC20(IERC20(underlyingToken), _anyswapData.router, _anyswapData.amount);\n\n                IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.amount,\n                    _anyswapData.toChainId\n                );\n            } else {\n                // Give Anyswap approval to bridge tokens\n                LibAsset.approveERC20(IERC20(_anyswapData.token), _anyswapData.router, _anyswapData.amount);\n\n                IAnyswapRouter(_anyswapData.router).anySwapOut(\n                    _anyswapData.token,\n                    _anyswapData.recipient,\n                    _anyswapData.amount,\n                    _anyswapData.toChainId\n                );\n            }\n        }\n    }\n}\n\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ICBridge } from \"../Interfaces/ICBridge.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\nimport \"./Swapper.sol\";\n\n/**\n * @title CBridge Facet\n * @author Li.Finance (https://li.finance)\n * @notice Provides functionality for bridging through CBridge\n */\ncontract CBridgeFacet is ILiFi, Swapper {\n    /* ========== Storage ========== */\n\n    bytes32 internal constant NAMESPACE = keccak256(\"com.lifi.facets.cbridge2\");\n    struct Storage {\n        address cBridge;\n        uint64 cBridgeChainId;\n    }\n\n    /* ========== Types ========== */\n\n    struct CBridgeData {\n        address receiver;\n        address token;\n        uint256 amount;\n        uint64 dstChainId;\n        uint64 nonce;\n        uint32 maxSlippage;\n    }\n\n    /* ========== Init ========== */\n\n    /**\n     * @notice Initializes local variables for the CBridge facet\n     * @param _cBridge address of the canonical CBridge router contract\n     * @param _chainId chainId of this deployed contract\n     */\n    function initCbridge(address _cBridge, uint64 _chainId) external {\n        Storage storage s = getStorage();\n        LibDiamond.enforceIsContractOwner();\n        s.cBridge = _cBridge;\n        s.cBridgeChainId = _chainId;\n        emit Inited(s.cBridge, s.cBridgeChainId);\n    }\n\n    /* ========== Public Bridge Functions ========== */\n\n    /**\n     * @notice Bridges tokens via CBridge\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _cBridgeData data specific to CBridge\n     */\n    function startBridgeTokensViaCBridge(LiFiData memory _lifiData, CBridgeData calldata _cBridgeData) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n            LibAsset.transferFromERC20(_cBridgeData.token, msg.sender, address(this), _cBridgeData.amount);\n\n            require(\n                LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance == _cBridgeData.amount,\n                \"ERR_INVALID_AMOUNT\"\n            );\n        } else {\n            require(msg.value >= _cBridgeData.amount, \"ERR_INVALID_AMOUNT\");\n        }\n\n        _startBridge(_cBridgeData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Performs a swap before bridging via CBridge\n     * @param _lifiData data used purely for tracking and analytics\n     * @param _swapData an array of swap related data for performing swaps before bridging\n     * @param _cBridgeData data specific to CBridge\n     */\n    function swapAndStartBridgeTokensViaCBridge(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        CBridgeData memory _cBridgeData\n    ) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _cBridgeData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            _executeSwaps(_lifiData, _swapData);\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _cBridgeData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_cBridgeData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }\n\n    /* ========== Internal Functions ========== */\n\n    /*\n     * @dev Conatains the business logic for the bridge via CBridge\n     * @param _cBridgeData data specific to CBridge\n     */\n    function _startBridge(CBridgeData memory _cBridgeData) internal {\n        Storage storage s = getStorage();\n        address bridge = _bridge();\n\n        // Do CBridge stuff\n        require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");\n\n        if (LibAsset.isNativeAsset(_cBridgeData.token)) {\n            ICBridge(bridge).sendNative(\n                _cBridgeData.receiver,\n                _cBridgeData.amount,\n                _cBridgeData.dstChainId,\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        } else {\n            // Give CBridge approval to bridge tokens\n            LibAsset.approveERC20(IERC20(_cBridgeData.token), bridge, _cBridgeData.amount);\n            // solhint-disable check-send-result\n            ICBridge(bridge).send(\n                _cBridgeData.receiver,\n                _cBridgeData.token,\n                _cBridgeData.amount,\n                _cBridgeData.dstChainId,\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        }\n    }\n\n    /*\n     * @dev Public view function for the CBridge router address\n     * @returns the router address\n     */\n    function _bridge() internal view returns (address) {\n        Storage storage s = getStorage();\n        return s.cBridge;\n    }\n\n    /**\n     * @dev fetch local storage\n     */\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-03-lifinance-findings.json",
                "Location": "Functions which call Swapper._executeSwap() such as GenericSwapFacet.swapTokensGeneric(), CBridgeFacet.swapAndStartBridgeTokensViaCBridge(), AnyswapFacet.swapAndStartBridgeTokensViaAnyswap(), HopFacet.swapAndStartBridgeTokensViaHop(), NXTPFacet.swapAndStartBridgeTokensViaNXTP(), and NXTPFacet.swapAndCompleteBridgeTokensViaNXTP()",
                "Type": "Reentrancy",
                "Description": "There is a reentrancy vulnerability in functions which call Swapper._executeSwap() which would allow the attacker to change their postSwapBalance. The issue occurs since it is possible for an attacker to reenter this function during _executeSwaps(), that is because execute swap makes numerous external calls, such as to the AMM, or to untrusted ERC20 token addresses.",
                "Repair": "Add a reentrancy guard over every function which may send or receive tokens. Ensure the same slot is used to store the reentrancy guard so all required functions are covered by a single guard."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\n\n// Private Pool (NFT collateral)\n\n//    (                (   (\n//    )\\      )    (   )\\  )\\ )  (\n//  (((_)  ( /(   ))\\ ((_)(()/(  )(    (    (\n//  )\\___  )(_)) /((_) _   ((_))(()\\   )\\   )\\ )\n// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(\n//  | (__ / _` || || || |/ _` | | '_|/ _ \\| ' \\))\n//   \\___|\\__,_| \\_,_||_|\\__,_| |_|  \\___/|_||_|\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"./interfaces/IERC721.sol\";\nimport \"./interfaces/INFTOracle.sol\";\n\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n    uint16 ltvBPS; // Required to avoid liquidation\n    INFTOracle oracle; // oracle used\n}\n\nstruct SignatureParams {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\ninterface ILendingClub {\n    // Per token settings.\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\n\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n\n    function asset() external view returns (IERC20);\n\n    function masterContract() external view returns (address);\n\n    function bentoBox() external view returns (IBentoBoxV1);\n\n    function removeCollateral(uint256 tokenId, address to) external;\n}\n\n/// @title NFTPairWithOracle\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\ncontract NFTPairWithOracle is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event LogRequestLoan(\n        address indexed borrower,\n        uint256 indexed tokenId,\n        uint128 valuation,\n        uint64 duration,\n        uint16 annualInterestBPS,\n        uint16 ltvBPS\n    );\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS, uint16 ltvBPS);\n    // This automatically clears the associated loan, if any\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    // Details are in the loan request\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPairWithOracle public immutable masterContract;\n\n    // MasterContract variables\n    address public feeTo;\n\n    // Per clone variables\n    // Clone init settings\n    IERC721 public collateral;\n    IERC20 public asset;\n\n    // A note on terminology:\n    // \"Shares\" are BentoBox shares.\n\n    // Track assets we own. Used to allow skimming the excesss.\n    uint256 public feesEarnedShare;\n\n    // Per token settings.\n    mapping(uint256 => TokenLoanParams) public tokenLoanParams;\n\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {\n        address borrower;\n        address lender;\n        uint64 startTime;\n        uint8 status;\n    }\n    mapping(uint256 => TokenLoan) public tokenLoan;\n\n    // Do not go over 100% on either of these..\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n\n    // Highest order term in the Maclaurin series for exp used by\n    // `calculateIntest`.\n    // Intuitive interpretation: interest continuously accrues on the principal.\n    // That interest, in turn, earns \"second-order\" interest-on-interest, which\n    // itself earns \"third-order\" interest, etc. This constant determines how\n    // far we take this until we stop counting.\n    //\n    // The error, in terms of the interest rate, is at least\n    //\n    //            ----- n                        ----- Infinity\n    //             \\           x^k                \\              x^k\n    //      e^x -   )          ---   , which is    )             --- ,\n    //             /            k!                /               k!\n    //            ----- k = 1       k            ----- k = n + 1\n    //\n    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of\n    // interest that is owed at rate r over time t. It makes no difference if\n    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation\n    // is the same. Why \"at least\"? There are also rounding errors. See\n    // `calculateInterest` for more detail.\n    // The factorial in the denominator \"wins\"; for all reasonable (and quite\n    // a few unreasonable) interest rates, the lower-order terms contribute the\n    // most to the total. The following table lists some of the calculated\n    // approximations for different values of n, along with the \"true\" result:\n    //\n    // Total:         10%    20%    50%    100%    200%      500%       1000%\n    // -----------------------------------------------------------------------\n    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%\n    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%\n    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%\n    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%\n    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%\n    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%\n    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%\n    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%\n    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%\n    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%\n    //\n    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%\n    //\n    // For instance, calculating the compounding effects of 200% in \"total\"\n    // interest to the sixth order results in 635.6%, whereas the true result\n    // is 638.9%.\n    // At 500% that difference is a little more dramatic, but it is still in\n    // the same ballpark -- and of little practical consequence unless the\n    // collateral can be expected to go up more than 112 times in value.\n    // Still, for volatile tokens, or an asset that is somehow known to be very\n    // inflationary, use a different number.\n    // Zero (no interest at all) is ignored and treated as one (linear only).\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n\n    // For signed lend / borrow requests:\n    mapping(address => uint256) public nonces;\n\n    /// @notice The constructor is only used for the initial master contract.\n    /// @notice Subsequent clones are initialised via `init`.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n\n    /// @notice De facto constructor for clone contracts\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), \"NFTPair: already initialized\");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), \"NFTPair: bad pair\");\n    }\n\n    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_OUTSTANDING) {\n            // The lender can change terms so long as the changes are strictly\n            // the same or better for the borrower:\n            require(msg.sender == loan.lender, \"NFTPair: not the lender\");\n            TokenLoanParams memory cur = tokenLoanParams[tokenId];\n            require(\n                params.duration >= cur.duration &&\n                    params.valuation <= cur.valuation &&\n                    params.annualInterestBPS <= cur.annualInterestBPS &&\n                    params.ltvBPS <= cur.ltvBPS,\n                \"NFTPair: worse params\"\n            );\n        } else if (loan.status == LOAN_REQUESTED) {\n            // The borrower has already deposited the collateral and can\n            // change whatever they like\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else {\n            // The loan has not been taken out yet; the borrower needs to\n            // provide collateral.\n            revert(\"NFTPair: no collateral\");\n        }\n        tokenLoanParams[tokenId] = params;\n        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    function _requestLoan(\n        address collateralProvider,\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) private {\n        // Edge case: valuation can be zero. That effectively gifts the NFT and\n        // is therefore a bad idea, but does not break the contract.\n        require(tokenLoan[tokenId].status == LOAN_INITIAL, \"NFTPair: loan exists\");\n        if (skim) {\n            require(collateral.ownerOf(tokenId) == address(this), \"NFTPair: skim failed\");\n        } else {\n            collateral.transferFrom(collateralProvider, address(this), tokenId);\n        }\n        TokenLoan memory loan;\n        loan.borrower = to;\n        loan.status = LOAN_REQUESTED;\n        tokenLoan[tokenId] = loan;\n        tokenLoanParams[tokenId] = params;\n\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS, params.ltvBPS);\n    }\n\n    /// @notice Deposit an NFT as collateral and request a loan against it\n    /// @param tokenId ID of the NFT\n    /// @param to Address to receive the loan, or option to withdraw collateral\n    /// @param params Loan conditions on offer\n    /// @param skim True if the token has already been transfered\n    function requestLoan(\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) public {\n        _requestLoan(msg.sender, tokenId, params, to, skim);\n    }\n\n    /// @notice Removes `tokenId` as collateral and transfers it to `to`.\n    /// @notice This destroys the loan.\n    /// @param tokenId The token\n    /// @param to The receiver of the token.\n    function removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral towards the lender. The loan has to be\n            // expired and not paid off, or underwater and not paid off:\n            require(to == loan.lender, \"NFTPair: not the lender\");\n\n            if (uint256(loan.startTime) + tokenLoanParams[tokenId].duration > block.timestamp) {\n                TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n                // No underflow: loan.startTime is only ever set to a block timestamp\n                // Cast is safe: if this overflows, then all loans have expired anyway\n                uint256 interest = calculateInterest(\n                    loanParams.valuation,\n                    uint64(block.timestamp - loan.startTime),\n                    loanParams.annualInterestBPS\n                ).to128();\n                uint256 amount = loanParams.valuation + interest;\n                (, uint256 rate) = loanParams.oracle.get(address(this), tokenId);\n                require(rate.mul(loanParams.ltvBPS) / BPS < amount, \"NFT is still valued\");\n            }\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with `skim` set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, \"NFTPair: not available\");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as `accepted`.\n        require(\n            params.valuation == accepted.valuation &&\n                params.duration <= accepted.duration &&\n                params.annualInterestBPS >= accepted.annualInterestBPS &&\n                params.ltvBPS >= accepted.ltvBPS,\n            \"NFTPair: bad params\"\n        );\n\n        if (params.oracle != INFTOracle(0)) {\n            (, uint256 rate) = params.oracle.get(address(this), tokenId);\n            require(rate.mul(uint256(params.ltvBPS)) / BPS >= params.valuation, \"Oracle: price too low.\");\n        }\n\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                \"NFTPair: skim too much\"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS <= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n\n        emit LogLend(lender, tokenId);\n    }\n\n    /// @notice Lends with the parameters specified by the borrower.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param accepted Loan parameters as the lender saw them, for security\n    /// @param skim True if the funds have been transfered to the contract\n    function lend(\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) public {\n        _lend(msg.sender, tokenId, accepted, skim);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // NOTE on signature hashes: the domain separator only guarantees that the\n    // chain ID and master contract are a match, so we explicitly include the\n    // clone address (and the asset/collateral addresses):\n\n    // keccak256(\"Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant LEND_SIGNATURE_HASH = 0x4bfd5d24664945f4bb81f6061bd624907d74ba338190bdd6aa37f65838a8a533;\n\n    // keccak256(\"Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint16 ltvBPS,address oracle,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant BORROW_SIGNATURE_HASH = 0xfc58c7a8ea6a96e25d218e36759058a704bbf0bebb53a109a44ca82f025cb769;\n\n    /// @notice Request and immediately borrow from a pre-committed lender\n\n    /// @notice Caller provides collateral; loan can go to a different address.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param lender Lender, whose BentoBox balance the funds will come from\n    /// @param recipient Address to receive the loan.\n    /// @param params Loan parameters requested, and signed by the lender\n    /// @param skimCollateral True if the collateral has already been transfered\n    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.\n    function requestAndBorrow(\n        uint256 tokenId,\n        address lender,\n        address recipient,\n        TokenLoanParams memory params,\n        bool skimCollateral,\n        bool anyTokenId,\n        SignatureParams memory signature\n    ) public {\n        if (signature.v == 0 && signature.r == bytes32(0) && signature.s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), \"NFTPair: LendingClub does not like you\");\n        } else {\n            require(block.timestamp <= signature.deadline, \"NFTPair: signature expired\");\n            uint256 nonce = nonces[lender]++;\n            bytes32 dataHash = keccak256(\n                abi.encode(\n                    LEND_SIGNATURE_HASH,\n                    address(this),\n                    anyTokenId ? 0 : tokenId,\n                    anyTokenId,\n                    params.valuation,\n                    params.duration,\n                    params.annualInterestBPS,\n                    params.ltvBPS,\n                    params.oracle,\n                    nonce,\n                    signature.deadline\n                )\n            );\n            require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == lender, \"NFTPair: signature invalid\");\n        }\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);\n        _lend(lender, tokenId, params, false);\n    }\n\n    /// @notice Take collateral from a pre-commited borrower and lend against it\n    /// @notice Collateral must come from the borrower, not a third party.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param borrower Address that provides collateral and receives the loan\n    /// @param params Loan terms offered, and signed by the borrower\n    /// @param skimFunds True if the funds have been transfered to the contract\n    function takeCollateralAndLend(\n        uint256 tokenId,\n        address borrower,\n        TokenLoanParams memory params,\n        bool skimFunds,\n        SignatureParams memory signature\n    ) public {\n        require(block.timestamp <= signature.deadline, \"NFTPair: signature expired\");\n        uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                BORROW_SIGNATURE_HASH,\n                address(this),\n                tokenId,\n                params.valuation,\n                params.duration,\n                params.annualInterestBPS,\n                params.ltvBPS,\n                params.oracle,\n                nonce,\n                signature.deadline\n            )\n        );\n        require(ecrecover(_getDigest(dataHash), signature.v, signature.r, signature.s) == borrower, \"NFTPair: signature invalid\");\n        _requestLoan(borrower, tokenId, params, borrower, false);\n        _lend(msg.sender, tokenId, params, skimFunds);\n    }\n\n    /// Approximates continuous compounding. Uses Horner's method to evaluate\n    /// the truncated Maclaurin series for exp - 1, accumulating rounding\n    /// errors along the way. The following is always guaranteed:\n    ///\n    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),\n    ///\n    /// where time = t/YEAR, up to at most the rounding error obtained in\n    /// calculating linear interest.\n    ///\n    /// If the theoretical result that we are approximating (the rightmost part\n    /// of the above inquality) fits in 128 bits, then the function is\n    /// guaranteed not to revert (unless n > 250, which is way too high).\n    /// If even the linear interest (leftmost part of the inequality) does not\n    /// the function will revert.\n    /// Otherwise, the function may revert, return a reasonable result, or\n    /// return a very inaccurate result. Even then the above inequality is\n    /// respected.\n    function calculateInterest(\n        uint256 principal,\n        uint64 t,\n        uint16 aprBPS\n    ) public pure returns (uint256 interest) {\n        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)\n        //\n        // We calculate\n        //\n        //  ----- n                                       ----- n\n        //   \\           principal * (t * aprBPS)^k        \\\n        //    )          --------------------------   =:    )          term_k\n        //   /                k! * YEAR_BPS^k              /\n        //  ----- k = 1                                   ----- k = 1\n        //\n        // which approaches, but never exceeds the \"theoretical\" result,\n        //\n        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1\n        //\n        // as n goes to infinity. We use the fact that\n        //\n        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)\n        //      term_k = ---------------------------------------------\n        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS\n        //\n        //                             t * aprBPS\n        //             = term_{k-1} * ------------                          (*)\n        //                            k * YEAR_BPS\n        //\n        // to calculate the terms one by one. The principal affords us the\n        // precision to carry out the division without resorting to fixed-point\n        // math. Any rounding error is downward, which we consider acceptable.\n        //\n        // Since all numbers involved are positive, each term is certainly\n        // bounded above by M. From (*) we see that any intermediate results\n        // are at most\n        //\n        //                      denom_k := k * YEAR_BPS.\n        //\n        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,\n        // which proves that all calculations will certainly not overflow if M\n        // fits in 128 bits.\n        //\n        // If M does not fit, then the intermediate results for some term may\n        // eventually overflow, but this cannot happen at the first term, and\n        // neither can the total overflow because it uses checked math.\n        //\n        // This constitutes a guarantee of specified behavior when M >= 2^128.\n        uint256 x = uint256(t) * aprBPS;\n        uint256 term_k = (principal * x) / YEAR_BPS;\n        uint256 denom_k = YEAR_BPS;\n\n        interest = term_k;\n        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {\n            denom_k += YEAR_BPS;\n            term_k = (term_k * x) / denom_k;\n            interest = interest.add(term_k); // <- Only overflow check we need\n        }\n\n        if (interest >= 2**128) {\n            revert();\n        }\n    }\n\n    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_OUTSTANDING, \"NFTPair: no loan\");\n        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n        require(\n            // Addition is safe: both summands are smaller than 256 bits\n            uint256(loan.startTime) + loanParams.duration > block.timestamp,\n            \"NFTPair: loan expired\"\n        );\n\n        uint128 principal = loanParams.valuation;\n\n        // No underflow: loan.startTime is only ever set to a block timestamp\n        // Cast is safe: if this overflows, then all loans have expired anyway\n        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();\n        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;\n        amount = principal + interest;\n\n        uint256 totalShare = bentoBox.toShare(asset, amount, false);\n        uint256 feeShare = bentoBox.toShare(asset, fee, false);\n\n        address from;\n        if (skim) {\n            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), \"NFTPair: skim too much\");\n            from = address(this);\n            // No overflow: result fits in BentoBox\n        } else {\n            bentoBox.transfer(asset, msg.sender, address(this), feeShare);\n            from = msg.sender;\n        }\n        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.\n        feesEarnedShare += feeShare;\n        delete tokenLoan[tokenId];\n\n        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);\n        collateral.transferFrom(address(this), loan.borrower, tokenId);\n\n        emit LogRepay(from, tokenId);\n    }\n\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n\n    uint8 internal constant ACTION_REQUEST_LOAN = 12;\n    uint8 internal constant ACTION_LEND = 13;\n\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n\n    // Signed requests\n    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;\n    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;\n\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n\n    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n\n    /// @dev Helper function for depositing into `bentoBox`.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n\n    /// @dev Helper function to withdraw from the `bentoBox`.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.\n    /// This also means that calls made from this contract shall *not* be trusted.\n    function _call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n\n        if (useValue1 && !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n\n        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), \"NFTPair: can't call\");\n\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, \"NFTPair: call failed\");\n        return (returnData, returnValues);\n    }\n\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).\n    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.\n    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.\n    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        for (uint256 i = 0; i < actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_REPAY) {\n                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));\n                repay(tokenId, skim);\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));\n                removeCollateral(tokenId, to);\n            } else if (action == ACTION_REQUEST_LOAN) {\n                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(\n                    datas[i],\n                    (uint256, TokenLoanParams, address, bool)\n                );\n                requestLoan(tokenId, params, to, skim);\n            } else if (action == ACTION_LEND) {\n                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));\n                lend(tokenId, params, skim);\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_REQUEST_AND_BORROW) {\n                (\n                    uint256 tokenId,\n                    address lender,\n                    address recipient,\n                    TokenLoanParams memory params,\n                    bool skimCollateral,\n                    bool anyTokenId,\n                    SignatureParams memory signature\n                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, SignatureParams));\n                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, signature);\n            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {\n                (uint256 tokenId, address borrower, TokenLoanParams memory params, bool skimFunds, SignatureParams memory signature) = abi\n                    .decode(datas[i], (uint256, address, TokenLoanParams, bool, SignatureParams));\n                takeCollateralAndLend(tokenId, borrower, params, skimFunds, signature);\n            }\n        }\n    }\n\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        address to = masterContract.feeTo();\n\n        uint256 _share = feesEarnedShare;\n        if (_share > 0) {\n            bentoBox.transfer(asset, address(this), to, _share);\n            feesEarnedShare = 0;\n        }\n\n        emit LogWithdrawFees(to, _share);\n    }\n\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\n\n// Private Pool (NFT collateral)\n\n//    (                (   (\n//    )\\      )    (   )\\  )\\ )  (\n//  (((_)  ( /(   ))\\ ((_)(()/(  )(    (    (\n//  )\\___  )(_)) /((_) _   ((_))(()\\   )\\   )\\ )\n// ((/ __|((_)_ (_))( | |  _| |  ((_) ((_) _(_/(\n//  | (__ / _` || || || |/ _` | | '_|/ _ \\| ' \\))\n//   \\___|\\__,_| \\_,_||_|\\__,_| |_|  \\___/|_||_|\n\n// Copyright (c) 2021 BoringCrypto - All rights reserved\n// Twitter: @Boring_Crypto\n\n// Special thanks to:\n// @0xKeno - for all his invaluable contributions\n// @burger_crypto - for the idea of trying to let the LPs benefit from liquidations\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringMath.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/BoringOwnable.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/Domain.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/interfaces/IMasterContract.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol\";\nimport \"@boringcrypto/boring-solidity/contracts/libraries/BoringERC20.sol\";\nimport \"@sushiswap/bentobox-sdk/contracts/IBentoBoxV1.sol\";\nimport \"./interfaces/IERC721.sol\";\n\nstruct TokenLoanParams {\n    uint128 valuation; // How much will you get? OK to owe until expiration.\n    uint64 duration; // Length of loan in seconds\n    uint16 annualInterestBPS; // Variable cost of taking out the loan\n}\n\ninterface ILendingClub {\n    // Per token settings.\n    function willLend(uint256 tokenId, TokenLoanParams memory params) external view returns (bool);\n\n    function lendingConditions(address nftPair, uint256 tokenId) external view returns (TokenLoanParams memory);\n}\n\ninterface INFTPair {\n    function collateral() external view returns (IERC721);\n\n    function asset() external view returns (IERC20);\n\n    function masterContract() external view returns (address);\n\n    function bentoBox() external view returns (IBentoBoxV1);\n\n    function removeCollateral(uint256 tokenId, address to) external;\n}\n\n/// @title NFTPair\n/// @dev This contract allows contract calls to any contract (except BentoBox)\n/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\ncontract NFTPair is BoringOwnable, Domain, IMasterContract {\n    using BoringMath for uint256;\n    using BoringMath128 for uint128;\n    using RebaseLibrary for Rebase;\n    using BoringERC20 for IERC20;\n\n    event LogRequestLoan(address indexed borrower, uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);\n    event LogUpdateLoanParams(uint256 indexed tokenId, uint128 valuation, uint64 duration, uint16 annualInterestBPS);\n    // This automatically clears the associated loan, if any\n    event LogRemoveCollateral(uint256 indexed tokenId, address recipient);\n    // Details are in the loan request\n    event LogLend(address indexed lender, uint256 indexed tokenId);\n    event LogRepay(address indexed from, uint256 indexed tokenId);\n    event LogFeeTo(address indexed newFeeTo);\n    event LogWithdrawFees(address indexed feeTo, uint256 feeShare);\n\n    // Immutables (for MasterContract and all clones)\n    IBentoBoxV1 public immutable bentoBox;\n    NFTPair public immutable masterContract;\n\n    // MasterContract variables\n    address public feeTo;\n\n    // Per clone variables\n    // Clone init settings\n    IERC721 public collateral;\n    IERC20 public asset;\n\n    // A note on terminology:\n    // \"Shares\" are BentoBox shares.\n\n    // Track assets we own. Used to allow skimming the excesss.\n    uint256 public feesEarnedShare;\n\n    // Per token settings.\n    mapping(uint256 => TokenLoanParams) public tokenLoanParams;\n\n    uint8 private constant LOAN_INITIAL = 0;\n    uint8 private constant LOAN_REQUESTED = 1;\n    uint8 private constant LOAN_OUTSTANDING = 2;\n    struct TokenLoan {\n        address borrower;\n        address lender;\n        uint64 startTime;\n        uint8 status;\n    }\n    mapping(uint256 => TokenLoan) public tokenLoan;\n\n    // Do not go over 100% on either of these..\n    uint256 private constant PROTOCOL_FEE_BPS = 1000;\n    uint256 private constant OPEN_FEE_BPS = 100;\n    uint256 private constant BPS = 10_000;\n    uint256 private constant YEAR_BPS = 3600 * 24 * 365 * 10_000;\n\n    // Highest order term in the Maclaurin series for exp used by\n    // `calculateIntest`.\n    // Intuitive interpretation: interest continuously accrues on the principal.\n    // That interest, in turn, earns \"second-order\" interest-on-interest, which\n    // itself earns \"third-order\" interest, etc. This constant determines how\n    // far we take this until we stop counting.\n    //\n    // The error, in terms of the interest rate, is at least\n    //\n    //            ----- n                        ----- Infinity\n    //             \\           x^k                \\              x^k\n    //      e^x -   )          ---   , which is    )             --- ,\n    //             /            k!                /               k!\n    //            ----- k = 1       k            ----- k = n + 1\n    //\n    // where n = COMPOUND_INTEREST_TERMS, and x = rt is the total amount of\n    // interest that is owed at rate r over time t. It makes no difference if\n    // this is, say, 5%/year for 10 years, or 50% in one year; the calculation\n    // is the same. Why \"at least\"? There are also rounding errors. See\n    // `calculateInterest` for more detail.\n    // The factorial in the denominator \"wins\"; for all reasonable (and quite\n    // a few unreasonable) interest rates, the lower-order terms contribute the\n    // most to the total. The following table lists some of the calculated\n    // approximations for different values of n, along with the \"true\" result:\n    //\n    // Total:         10%    20%    50%    100%    200%      500%       1000%\n    // -----------------------------------------------------------------------\n    // n = 1:         10.0%  20.0%  50.0%  100.0%  200.0%    500.0%     1000.0%\n    // n = 2:         10.5%  22.0%  62.5%  150.0%  400.0%   1750.0%     6000.0%\n    // n = 3:         10.5%  22.1%  64.6%  166.7%  533.3%   3833.3%    22666.7%\n    // n = 4:         10.5%  22.1%  64.8%  170.8%  600.0%   6437.5%    64333.3%\n    // n = 5:         10.5%  22.1%  64.9%  171.7%  626.7%   9041.7%   147666.7%\n    // n = 6:         10.5%  22.1%  64.9%  171.8%  635.6%  11211.8%   286555.6%\n    // n = 7:         10.5%  22.1%  64.9%  171.8%  638.1%  12761.9%   484968.3%\n    // n = 8:         10.5%  22.1%  64.9%  171.8%  638.7%  13730.7%   732984.1%\n    // n = 9:         10.5%  22.1%  64.9%  171.8%  638.9%  14268.9%  1008557.3%\n    // n = 10:        10.5%  22.1%  64.9%  171.8%  638.9%  14538.1%  1284130.5%\n    //\n    // (n=Infinity):  10.5%  22.1%  64.9%  171.8%  638.9%  14741.3%  2202546.6%\n    //\n    // For instance, calculating the compounding effects of 200% in \"total\"\n    // interest to the sixth order results in 635.6%, whereas the true result\n    // is 638.9%.\n    // At 500% that difference is a little more dramatic, but it is still in\n    // the same ballpark -- and of little practical consequence unless the\n    // collateral can be expected to go up more than 112 times in value.\n    // Still, for volatile tokens, or an asset that is somehow known to be very\n    // inflationary, use a different number.\n    // Zero (no interest at all) is ignored and treated as one (linear only).\n    uint8 private constant COMPOUND_INTEREST_TERMS = 6;\n\n    // For signed lend / borrow requests:\n    mapping(address => uint256) public nonces;\n\n    /// @notice The constructor is only used for the initial master contract.\n    /// @notice Subsequent clones are initialised via `init`.\n    constructor(IBentoBoxV1 bentoBox_) public {\n        bentoBox = bentoBox_;\n        masterContract = this;\n    }\n\n    /// @notice De facto constructor for clone contracts\n    function init(bytes calldata data) public payable override {\n        require(address(collateral) == address(0), \"NFTPair: already initialized\");\n        (collateral, asset) = abi.decode(data, (IERC721, IERC20));\n        require(address(collateral) != address(0), \"NFTPair: bad pair\");\n    }\n\n    function updateLoanParams(uint256 tokenId, TokenLoanParams memory params) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_OUTSTANDING) {\n            // The lender can change terms so long as the changes are strictly\n            // the same or better for the borrower:\n            require(msg.sender == loan.lender, \"NFTPair: not the lender\");\n            TokenLoanParams memory cur = tokenLoanParams[tokenId];\n            require(\n                params.duration >= cur.duration && params.valuation <= cur.valuation && params.annualInterestBPS <= cur.annualInterestBPS,\n                \"NFTPair: worse params\"\n            );\n        } else if (loan.status == LOAN_REQUESTED) {\n            // The borrower has already deposited the collateral and can\n            // change whatever they like\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else {\n            // The loan has not been taken out yet; the borrower needs to\n            // provide collateral.\n            revert(\"NFTPair: no collateral\");\n        }\n        tokenLoanParams[tokenId] = params;\n        emit LogUpdateLoanParams(tokenId, params.valuation, params.duration, params.annualInterestBPS);\n    }\n\n    function _requestLoan(\n        address collateralProvider,\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) private {\n        // Edge case: valuation can be zero. That effectively gifts the NFT and\n        // is therefore a bad idea, but does not break the contract.\n        require(tokenLoan[tokenId].status == LOAN_INITIAL, \"NFTPair: loan exists\");\n        if (skim) {\n            require(collateral.ownerOf(tokenId) == address(this), \"NFTPair: skim failed\");\n        } else {\n            collateral.transferFrom(collateralProvider, address(this), tokenId);\n        }\n        TokenLoan memory loan;\n        loan.borrower = to;\n        loan.status = LOAN_REQUESTED;\n        tokenLoan[tokenId] = loan;\n        tokenLoanParams[tokenId] = params;\n\n        emit LogRequestLoan(to, tokenId, params.valuation, params.duration, params.annualInterestBPS);\n    }\n\n    /// @notice Deposit an NFT as collateral and request a loan against it\n    /// @param tokenId ID of the NFT\n    /// @param to Address to receive the loan, or option to withdraw collateral\n    /// @param params Loan conditions on offer\n    /// @param skim True if the token has already been transfered\n    function requestLoan(\n        uint256 tokenId,\n        TokenLoanParams memory params,\n        address to,\n        bool skim\n    ) public {\n        _requestLoan(msg.sender, tokenId, params, to, skim);\n    }\n\n    /// @notice Removes `tokenId` as collateral and transfers it to `to`.\n    /// @notice This destroys the loan.\n    /// @param tokenId The token\n    /// @param to The receiver of the token.\n    function removeCollateral(uint256 tokenId, address to) public {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        if (loan.status == LOAN_REQUESTED) {\n            // We are withdrawing collateral that is not in use:\n            require(msg.sender == loan.borrower, \"NFTPair: not the borrower\");\n        } else if (loan.status == LOAN_OUTSTANDING) {\n            // We are seizing collateral as the lender. The loan has to be\n            // expired and not paid off:\n            require(to == loan.lender, \"NFTPair: not the lender\");\n            require(\n                // Addition is safe: both summands are smaller than 256 bits\n                uint256(loan.startTime) + tokenLoanParams[tokenId].duration <= block.timestamp,\n                \"NFTPair: not expired\"\n            );\n        }\n        // If there somehow is collateral but no accompanying loan, then anyone\n        // can claim it by first requesting a loan with `skim` set to true, and\n        // then withdrawing. So we might as well allow it here..\n        delete tokenLoan[tokenId];\n        collateral.transferFrom(address(this), to, tokenId);\n        emit LogRemoveCollateral(tokenId, to);\n    }\n\n    // Assumes the lender has agreed to the loan.\n    function _lend(\n        address lender,\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) internal {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_REQUESTED, \"NFTPair: not available\");\n        TokenLoanParams memory params = tokenLoanParams[tokenId];\n\n        // Valuation has to be an exact match, everything else must be at least\n        // as good for the lender as `accepted`.\n        require(\n            params.valuation == accepted.valuation &&\n                params.duration <= accepted.duration &&\n                params.annualInterestBPS >= accepted.annualInterestBPS,\n            \"NFTPair: bad params\"\n        );\n\n        uint256 totalShare = bentoBox.toShare(asset, params.valuation, false);\n        // No overflow: at most 128 + 16 bits (fits in BentoBox)\n        uint256 openFeeShare = (totalShare * OPEN_FEE_BPS) / BPS;\n        uint256 protocolFeeShare = (openFeeShare * PROTOCOL_FEE_BPS) / BPS;\n\n        if (skim) {\n            require(\n                bentoBox.balanceOf(asset, address(this)) >= (totalShare - openFeeShare + protocolFeeShare + feesEarnedShare),\n                \"NFTPair: skim too much\"\n            );\n        } else {\n            bentoBox.transfer(asset, lender, address(this), totalShare - openFeeShare + protocolFeeShare);\n        }\n        // No underflow: follows from OPEN_FEE_BPS <= BPS\n        uint256 borrowerShare = totalShare - openFeeShare;\n        bentoBox.transfer(asset, address(this), loan.borrower, borrowerShare);\n        // No overflow: addends (and result) must fit in BentoBox\n        feesEarnedShare += protocolFeeShare;\n\n        loan.lender = lender;\n        loan.status = LOAN_OUTSTANDING;\n        loan.startTime = uint64(block.timestamp); // Do not use in 12e10 years..\n        tokenLoan[tokenId] = loan;\n\n        emit LogLend(lender, tokenId);\n    }\n\n    /// @notice Lends with the parameters specified by the borrower.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param accepted Loan parameters as the lender saw them, for security\n    /// @param skim True if the funds have been transfered to the contract\n    function lend(\n        uint256 tokenId,\n        TokenLoanParams memory accepted,\n        bool skim\n    ) public {\n        _lend(msg.sender, tokenId, accepted, skim);\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // NOTE on signature hashes: the domain separator only guarantees that the\n    // chain ID and master contract are a match, so we explicitly include the\n    // clone address (and the asset/collateral addresses):\n\n    // keccak256(\"Lend(address contract,uint256 tokenId,bool anyTokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant LEND_SIGNATURE_HASH = 0x06bcca6f35b7c1b98f11abbb10957d273a681069ba90358de25404f49e2430f8;\n\n    // keccak256(\"Borrow(address contract,uint256 tokenId,uint128 valuation,uint64 duration,uint16 annualInterestBPS,uint256 nonce,uint256 deadline)\")\n    bytes32 private constant BORROW_SIGNATURE_HASH = 0xf2c9128b0fb8406af3168320897e5ff08f3bb536dd5f804c29ed276e93ec4336;\n\n    /// @notice Request and immediately borrow from a pre-committed lender\n\n    /// @notice Caller provides collateral; loan can go to a different address.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param lender Lender, whose BentoBox balance the funds will come from\n    /// @param recipient Address to receive the loan.\n    /// @param params Loan parameters requested, and signed by the lender\n    /// @param skimCollateral True if the collateral has already been transfered\n    /// @param anyTokenId Set if lender agreed to any token. Must have tokenId 0 in signature.\n    function requestAndBorrow(\n        uint256 tokenId,\n        address lender,\n        address recipient,\n        TokenLoanParams memory params,\n        bool skimCollateral,\n        bool anyTokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        if (v == 0 && r == bytes32(0) && s == bytes32(0)) {\n            require(ILendingClub(lender).willLend(tokenId, params), \"NFTPair: LendingClub does not like you\");\n        } else {\n            require(block.timestamp <= deadline, \"NFTPair: signature expired\");\n            uint256 nonce = nonces[lender]++;\n            bytes32 dataHash = keccak256(\n                abi.encode(\n                    LEND_SIGNATURE_HASH,\n                    address(this),\n                    anyTokenId ? 0 : tokenId,\n                    anyTokenId,\n                    params.valuation,\n                    params.duration,\n                    params.annualInterestBPS,\n                    nonce,\n                    deadline\n                )\n            );\n            require(ecrecover(_getDigest(dataHash), v, r, s) == lender, \"NFTPair: signature invalid\");\n        }\n        _requestLoan(msg.sender, tokenId, params, recipient, skimCollateral);\n        _lend(lender, tokenId, params, false);\n    }\n\n    /// @notice Take collateral from a pre-commited borrower and lend against it\n    /// @notice Collateral must come from the borrower, not a third party.\n    /// @param tokenId ID of the token that will function as collateral\n    /// @param borrower Address that provides collateral and receives the loan\n    /// @param params Loan terms offered, and signed by the borrower\n    /// @param skimFunds True if the funds have been transfered to the contract\n    function takeCollateralAndLend(\n        uint256 tokenId,\n        address borrower,\n        TokenLoanParams memory params,\n        bool skimFunds,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        require(block.timestamp <= deadline, \"NFTPair: signature expired\");\n        uint256 nonce = nonces[borrower]++;\n        bytes32 dataHash = keccak256(\n            abi.encode(\n                BORROW_SIGNATURE_HASH,\n                address(this),\n                tokenId,\n                params.valuation,\n                params.duration,\n                params.annualInterestBPS,\n                nonce,\n                deadline\n            )\n        );\n        require(ecrecover(_getDigest(dataHash), v, r, s) == borrower, \"NFTPair: signature invalid\");\n        _requestLoan(borrower, tokenId, params, borrower, false);\n        _lend(msg.sender, tokenId, params, skimFunds);\n    }\n\n    /// Approximates continuous compounding. Uses Horner's method to evaluate\n    /// the truncated Maclaurin series for exp - 1, accumulating rounding\n    /// errors along the way. The following is always guaranteed:\n    ///\n    ///   principal * time * apr <= result <= principal * (e^(time * apr) - 1),\n    ///\n    /// where time = t/YEAR, up to at most the rounding error obtained in\n    /// calculating linear interest.\n    ///\n    /// If the theoretical result that we are approximating (the rightmost part\n    /// of the above inquality) fits in 128 bits, then the function is\n    /// guaranteed not to revert (unless n > 250, which is way too high).\n    /// If even the linear interest (leftmost part of the inequality) does not\n    /// the function will revert.\n    /// Otherwise, the function may revert, return a reasonable result, or\n    /// return a very inaccurate result. Even then the above inequality is\n    /// respected.\n    function calculateInterest(\n        uint256 principal,\n        uint64 t,\n        uint16 aprBPS\n    ) public pure returns (uint256 interest) {\n        // (NOTE: n is hardcoded as COMPOUND_INTEREST_TERMS)\n        //\n        // We calculate\n        //\n        //  ----- n                                       ----- n\n        //   \\           principal * (t * aprBPS)^k        \\\n        //    )          --------------------------   =:    )          term_k\n        //   /                k! * YEAR_BPS^k              /\n        //  ----- k = 1                                   ----- k = 1\n        //\n        // which approaches, but never exceeds the \"theoretical\" result,\n        //\n        //          M := principal * [ exp (t * aprBPS / YEAR_BPS) - 1\n        //\n        // as n goes to infinity. We use the fact that\n        //\n        //               principal * (t * aprBPS)^(k-1) * (t * aprBPS)\n        //      term_k = ---------------------------------------------\n        //                  (k-1)! * k * YEAR_BPS^(k-1) * YEAR_BPS\n        //\n        //                             t * aprBPS\n        //             = term_{k-1} * ------------                          (*)\n        //                            k * YEAR_BPS\n        //\n        // to calculate the terms one by one. The principal affords us the\n        // precision to carry out the division without resorting to fixed-point\n        // math. Any rounding error is downward, which we consider acceptable.\n        //\n        // Since all numbers involved are positive, each term is certainly\n        // bounded above by M. From (*) we see that any intermediate results\n        // are at most\n        //\n        //                      denom_k := k * YEAR_BPS.\n        //\n        // times M. Since YEAR_BPS fits in 38 bits, denom_k fits in 46 bits,\n        // which proves that all calculations will certainly not overflow if M\n        // fits in 128 bits.\n        //\n        // If M does not fit, then the intermediate results for some term may\n        // eventually overflow, but this cannot happen at the first term, and\n        // neither can the total overflow because it uses checked math.\n        //\n        // This constitutes a guarantee of specified behavior when M >= 2^128.\n        uint256 x = uint256(t) * aprBPS;\n        uint256 term_k = (principal * x) / YEAR_BPS;\n        uint256 denom_k = YEAR_BPS;\n\n        interest = term_k;\n        for (uint256 k = 2; k <= COMPOUND_INTEREST_TERMS; k++) {\n            denom_k += YEAR_BPS;\n            term_k = (term_k * x) / denom_k;\n            interest = interest.add(term_k); // <- Only overflow check we need\n        }\n\n        if (interest >= 2**128) {\n            revert();\n        }\n    }\n\n    function repay(uint256 tokenId, bool skim) public returns (uint256 amount) {\n        TokenLoan memory loan = tokenLoan[tokenId];\n        require(loan.status == LOAN_OUTSTANDING, \"NFTPair: no loan\");\n        TokenLoanParams memory loanParams = tokenLoanParams[tokenId];\n        require(\n            // Addition is safe: both summands are smaller than 256 bits\n            uint256(loan.startTime) + loanParams.duration > block.timestamp,\n            \"NFTPair: loan expired\"\n        );\n\n        uint128 principal = loanParams.valuation;\n\n        // No underflow: loan.startTime is only ever set to a block timestamp\n        // Cast is safe: if this overflows, then all loans have expired anyway\n        uint256 interest = calculateInterest(principal, uint64(block.timestamp - loan.startTime), loanParams.annualInterestBPS).to128();\n        uint256 fee = (interest * PROTOCOL_FEE_BPS) / BPS;\n        amount = principal + interest;\n\n        uint256 totalShare = bentoBox.toShare(asset, amount, false);\n        uint256 feeShare = bentoBox.toShare(asset, fee, false);\n\n        address from;\n        if (skim) {\n            require(bentoBox.balanceOf(asset, address(this)) >= (totalShare + feesEarnedShare), \"NFTPair: skim too much\");\n            from = address(this);\n            // No overflow: result fits in BentoBox\n        } else {\n            bentoBox.transfer(asset, msg.sender, address(this), feeShare);\n            from = msg.sender;\n        }\n        // No underflow: PROTOCOL_FEE_BPS < BPS by construction.\n        feesEarnedShare += feeShare;\n        delete tokenLoan[tokenId];\n\n        bentoBox.transfer(asset, from, loan.lender, totalShare - feeShare);\n        collateral.transferFrom(address(this), loan.borrower, tokenId);\n\n        emit LogRepay(from, tokenId);\n    }\n\n    uint8 internal constant ACTION_REPAY = 2;\n    uint8 internal constant ACTION_REMOVE_COLLATERAL = 4;\n\n    uint8 internal constant ACTION_REQUEST_LOAN = 12;\n    uint8 internal constant ACTION_LEND = 13;\n\n    // Function on BentoBox\n    uint8 internal constant ACTION_BENTO_DEPOSIT = 20;\n    uint8 internal constant ACTION_BENTO_WITHDRAW = 21;\n    uint8 internal constant ACTION_BENTO_TRANSFER = 22;\n    uint8 internal constant ACTION_BENTO_TRANSFER_MULTIPLE = 23;\n    uint8 internal constant ACTION_BENTO_SETAPPROVAL = 24;\n\n    // Any external call (except to BentoBox)\n    uint8 internal constant ACTION_CALL = 30;\n\n    // Signed requests\n    uint8 internal constant ACTION_REQUEST_AND_BORROW = 40;\n    uint8 internal constant ACTION_TAKE_COLLATERAL_AND_LEND = 41;\n\n    int256 internal constant USE_VALUE1 = -1;\n    int256 internal constant USE_VALUE2 = -2;\n\n    /// @dev Helper function for choosing the correct value (`value1` or `value2`) depending on `inNum`.\n    function _num(\n        int256 inNum,\n        uint256 value1,\n        uint256 value2\n    ) internal pure returns (uint256 outNum) {\n        outNum = inNum >= 0 ? uint256(inNum) : (inNum == USE_VALUE1 ? value1 : value2);\n    }\n\n    /// @dev Helper function for depositing into `bentoBox`.\n    function _bentoDeposit(\n        bytes memory data,\n        uint256 value,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        amount = int256(_num(amount, value1, value2)); // Done this way to avoid stack too deep errors\n        share = int256(_num(share, value1, value2));\n        return bentoBox.deposit{value: value}(token, msg.sender, to, uint256(amount), uint256(share));\n    }\n\n    /// @dev Helper function to withdraw from the `bentoBox`.\n    function _bentoWithdraw(\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (uint256, uint256) {\n        (IERC20 token, address to, int256 amount, int256 share) = abi.decode(data, (IERC20, address, int256, int256));\n        return bentoBox.withdraw(token, msg.sender, to, _num(amount, value1, value2), _num(share, value1, value2));\n    }\n\n    /// @dev Helper function to perform a contract call and eventually extracting revert messages on failure.\n    /// Calls to `bentoBox` or `collateral` are not allowed for security reasons.\n    /// This also means that calls made from this contract shall *not* be trusted.\n    function _call(\n        uint256 value,\n        bytes memory data,\n        uint256 value1,\n        uint256 value2\n    ) internal returns (bytes memory, uint8) {\n        (address callee, bytes memory callData, bool useValue1, bool useValue2, uint8 returnValues) = abi.decode(\n            data,\n            (address, bytes, bool, bool, uint8)\n        );\n\n        if (useValue1 && !useValue2) {\n            callData = abi.encodePacked(callData, value1);\n        } else if (!useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value2);\n        } else if (useValue1 && useValue2) {\n            callData = abi.encodePacked(callData, value1, value2);\n        }\n\n        require(callee != address(bentoBox) && callee != address(collateral) && callee != address(this), \"NFTPair: can't call\");\n\n        (bool success, bytes memory returnData) = callee.call{value: value}(callData);\n        require(success, \"NFTPair: call failed\");\n        return (returnData, returnValues);\n    }\n\n    /// @notice Executes a set of actions and allows composability (contract calls) to other contracts.\n    /// @param actions An array with a sequence of actions to execute (see ACTION_ declarations).\n    /// @param values A one-to-one mapped array to `actions`. ETH amounts to send along with the actions.\n    /// Only applicable to `ACTION_CALL`, `ACTION_BENTO_DEPOSIT`.\n    /// @param datas A one-to-one mapped array to `actions`. Contains abi encoded data of function arguments.\n    /// @return value1 May contain the first positioned return value of the last executed action (if applicable).\n    /// @return value2 May contain the second positioned return value of the last executed action which returns 2 values (if applicable).\n    function cook(\n        uint8[] calldata actions,\n        uint256[] calldata values,\n        bytes[] calldata datas\n    ) external payable returns (uint256 value1, uint256 value2) {\n        for (uint256 i = 0; i < actions.length; i++) {\n            uint8 action = actions[i];\n            if (action == ACTION_REPAY) {\n                (uint256 tokenId, bool skim) = abi.decode(datas[i], (uint256, bool));\n                repay(tokenId, skim);\n            } else if (action == ACTION_REMOVE_COLLATERAL) {\n                (uint256 tokenId, address to) = abi.decode(datas[i], (uint256, address));\n                removeCollateral(tokenId, to);\n            } else if (action == ACTION_REQUEST_LOAN) {\n                (uint256 tokenId, TokenLoanParams memory params, address to, bool skim) = abi.decode(\n                    datas[i],\n                    (uint256, TokenLoanParams, address, bool)\n                );\n                requestLoan(tokenId, params, to, skim);\n            } else if (action == ACTION_LEND) {\n                (uint256 tokenId, TokenLoanParams memory params, bool skim) = abi.decode(datas[i], (uint256, TokenLoanParams, bool));\n                lend(tokenId, params, skim);\n            } else if (action == ACTION_BENTO_SETAPPROVAL) {\n                (address user, address _masterContract, bool approved, uint8 v, bytes32 r, bytes32 s) = abi.decode(\n                    datas[i],\n                    (address, address, bool, uint8, bytes32, bytes32)\n                );\n                bentoBox.setMasterContractApproval(user, _masterContract, approved, v, r, s);\n            } else if (action == ACTION_BENTO_DEPOSIT) {\n                (value1, value2) = _bentoDeposit(datas[i], values[i], value1, value2);\n            } else if (action == ACTION_BENTO_WITHDRAW) {\n                (value1, value2) = _bentoWithdraw(datas[i], value1, value2);\n            } else if (action == ACTION_BENTO_TRANSFER) {\n                (IERC20 token, address to, int256 share) = abi.decode(datas[i], (IERC20, address, int256));\n                bentoBox.transfer(token, msg.sender, to, _num(share, value1, value2));\n            } else if (action == ACTION_BENTO_TRANSFER_MULTIPLE) {\n                (IERC20 token, address[] memory tos, uint256[] memory shares) = abi.decode(datas[i], (IERC20, address[], uint256[]));\n                bentoBox.transferMultiple(token, msg.sender, tos, shares);\n            } else if (action == ACTION_CALL) {\n                (bytes memory returnData, uint8 returnValues) = _call(values[i], datas[i], value1, value2);\n\n                if (returnValues == 1) {\n                    (value1) = abi.decode(returnData, (uint256));\n                } else if (returnValues == 2) {\n                    (value1, value2) = abi.decode(returnData, (uint256, uint256));\n                }\n            } else if (action == ACTION_REQUEST_AND_BORROW) {\n                (\n                    uint256 tokenId,\n                    address lender,\n                    address recipient,\n                    TokenLoanParams memory params,\n                    bool skimCollateral,\n                    bool anyTokenId,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = abi.decode(datas[i], (uint256, address, address, TokenLoanParams, bool, bool, uint256, uint8, bytes32, bytes32));\n                requestAndBorrow(tokenId, lender, recipient, params, skimCollateral, anyTokenId, deadline, v, r, s);\n            } else if (action == ACTION_TAKE_COLLATERAL_AND_LEND) {\n                (\n                    uint256 tokenId,\n                    address borrower,\n                    TokenLoanParams memory params,\n                    bool skimFunds,\n                    uint256 deadline,\n                    uint8 v,\n                    bytes32 r,\n                    bytes32 s\n                ) = abi.decode(datas[i], (uint256, address, TokenLoanParams, bool, uint256, uint8, bytes32, bytes32));\n                takeCollateralAndLend(tokenId, borrower, params, skimFunds, deadline, v, r, s);\n            }\n        }\n    }\n\n    /// @notice Withdraws the fees accumulated.\n    function withdrawFees() public {\n        address to = masterContract.feeTo();\n\n        uint256 _share = feesEarnedShare;\n        if (_share > 0) {\n            bentoBox.transfer(asset, address(this), to, _share);\n            feesEarnedShare = 0;\n        }\n\n        emit LogWithdrawFees(to, _share);\n    }\n\n    /// @notice Sets the beneficiary of fees accrued in liquidations.\n    /// MasterContract Only Admin function.\n    /// @param newFeeTo The address of the receiver.\n    function setFeeTo(address newFeeTo) public onlyOwner {\n        feeTo = newFeeTo;\n        emit LogFeeTo(newFeeTo);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-abranft-findings.json",
                "Location": "NFTPair.sol:218, NFTPairWithOracle.sol:238",
                "Type": "Reentrancy",
                "Description": "The NFTPair contract can be reentered, and a loan can be requested without the borrower supplying the collateral.",
                "Repair": "Move the external call to the end of the function to conform with checks-effects-interaction pattern"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.9;\n\nimport { IAxelarGatewayMultisig } from './interfaces/IAxelarGatewayMultisig.sol';\n\nimport { ECDSA } from './ECDSA.sol';\nimport { AxelarGateway } from './AxelarGateway.sol';\n\ncontract AxelarGatewayMultisig is IAxelarGatewayMultisig, AxelarGateway {\n    error InvalidAddress();\n    error InvalidOwners();\n    error InvalidOwnerThreshold();\n    error DuplicateOwner(address owner);\n    error InvalidOperators();\n    error InvalidOperatorThreshold();\n    error DuplicateOperator(address operator);\n    error NotProxy();\n    error InvalidChainId();\n    error MalformedSigners();\n    error InvalidCommands();\n\n    // AUDIT: slot names should be prefixed with some standard string\n    // AUDIT: constants should be literal and their derivation should be in comments\n    bytes32 internal constant KEY_OWNER_EPOCH = keccak256('owner-epoch');\n\n    bytes32 internal constant PREFIX_OWNER = keccak256('owner');\n    bytes32 internal constant PREFIX_OWNER_COUNT = keccak256('owner-count');\n    bytes32 internal constant PREFIX_OWNER_THRESHOLD = keccak256('owner-threshold');\n    bytes32 internal constant PREFIX_IS_OWNER = keccak256('is-owner');\n\n    bytes32 internal constant KEY_OPERATOR_EPOCH = keccak256('operator-epoch');\n\n    bytes32 internal constant PREFIX_OPERATOR = keccak256('operator');\n    bytes32 internal constant PREFIX_OPERATOR_COUNT = keccak256('operator-count');\n    bytes32 internal constant PREFIX_OPERATOR_THRESHOLD = keccak256('operator-threshold');\n    bytes32 internal constant PREFIX_IS_OPERATOR = keccak256('is-operator');\n\n    constructor(address tokenDeployer) AxelarGateway(tokenDeployer) {}\n\n    function _isSortedAscAndContainsNoDuplicate(address[] memory accounts) internal pure returns (bool) {\n        for (uint256 i; i < accounts.length - 1; ++i) {\n            if (accounts[i] >= accounts[i + 1]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /************************\\\n    |* Owners Functionality *|\n    \\************************/\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getOwnerKey(uint256 epoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OWNER, epoch, index));\n    }\n\n    function _getOwnerCountKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OWNER_COUNT, epoch));\n    }\n\n    function _getOwnerThresholdKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OWNER_THRESHOLD, epoch));\n    }\n\n    function _getIsOwnerKey(uint256 epoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_OWNER, epoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _ownerEpoch() internal view returns (uint256) {\n        return getUint(KEY_OWNER_EPOCH);\n    }\n\n    function _getOwner(uint256 epoch, uint256 index) internal view returns (address) {\n        return getAddress(_getOwnerKey(epoch, index));\n    }\n\n    function _getOwnerCount(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOwnerCountKey(epoch));\n    }\n\n    function _getOwnerThreshold(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOwnerThresholdKey(epoch));\n    }\n\n    function _isOwner(uint256 epoch, address account) internal view returns (bool) {\n        return getBool(_getIsOwnerKey(epoch, account));\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are owners within the last `OLD_KEY_RETENTION + 1` owner epochs (excluding the current one).\n    function _areValidPreviousOwners(address[] memory accounts) internal view returns (bool) {\n        uint256 epoch = _ownerEpoch();\n        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);\n        uint256 lowerBoundOwnerEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0);\n\n        --epoch;\n        while (epoch > lowerBoundOwnerEpoch) {\n            if (_areValidOwnersInEpoch(epoch--, accounts)) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are owners in the `ownerEpoch`.\n    function _areValidOwnersInEpoch(uint256 epoch, address[] memory accounts) internal view returns (bool) {\n        uint256 threshold = _getOwnerThreshold(epoch);\n        uint256 validSignerCount;\n\n        for (uint256 i; i < accounts.length; i++) {\n            if (_isOwner(epoch, accounts[i]) && ++validSignerCount >= threshold) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns the current `ownerEpoch`.\n    function ownerEpoch() external view override returns (uint256) {\n        return _ownerEpoch();\n    }\n\n    /// @dev Returns the threshold for a given `ownerEpoch`.\n    function ownerThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getOwnerThreshold(epoch);\n    }\n\n    /// @dev Returns the array of owners within a given `ownerEpoch`.\n    function owners(uint256 epoch) public view override returns (address[] memory results) {\n        uint256 ownerCount = _getOwnerCount(epoch);\n        results = new address[](ownerCount);\n\n        for (uint256 i; i < ownerCount; i++) {\n            results[i] = _getOwner(epoch, i);\n        }\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setOwnerEpoch(uint256 epoch) internal {\n        _setUint(KEY_OWNER_EPOCH, epoch);\n    }\n\n    function _setOwner(\n        uint256 epoch,\n        uint256 index,\n        address account\n    ) internal {\n        if (account == address(0)) revert InvalidAddress();\n\n        _setAddress(_getOwnerKey(epoch, index), account);\n    }\n\n    function _setOwnerCount(uint256 epoch, uint256 ownerCount) internal {\n        _setUint(_getOwnerCountKey(epoch), ownerCount);\n    }\n\n    function _setOwners(\n        uint256 epoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 accountLength = accounts.length;\n\n        if (accountLength < threshold) revert InvalidOwners();\n\n        if (threshold == uint256(0)) revert InvalidOwnerThreshold();\n\n        _setOwnerThreshold(epoch, threshold);\n        _setOwnerCount(epoch, accountLength);\n\n        for (uint256 i; i < accountLength; i++) {\n            address account = accounts[i];\n\n            // Check that the account wasn't already set as an owner for this ownerEpoch.\n            if (_isOwner(epoch, account)) revert DuplicateOwner(account);\n\n            // Set this account as the i-th owner in this ownerEpoch (needed to we can get all the owners for `owners`).\n            _setOwner(epoch, i, account);\n            _setIsOwner(epoch, account, true);\n        }\n    }\n\n    function _setOwnerThreshold(uint256 epoch, uint256 threshold) internal {\n        _setUint(_getOwnerThresholdKey(epoch), threshold);\n    }\n\n    function _setIsOwner(\n        uint256 epoch,\n        address account,\n        bool isOwner\n    ) internal {\n        _setBool(_getIsOwnerKey(epoch, account), isOwner);\n    }\n\n    /**************************\\\n    |* Operator Functionality *|\n    \\**************************/\n\n    /********************\\\n    |* Pure Key Getters *|\n    \\********************/\n\n    function _getOperatorKey(uint256 epoch, uint256 index) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR, epoch, index));\n    }\n\n    function _getOperatorCountKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR_COUNT, epoch));\n    }\n\n    function _getOperatorThresholdKey(uint256 epoch) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_OPERATOR_THRESHOLD, epoch));\n    }\n\n    function _getIsOperatorKey(uint256 epoch, address account) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PREFIX_IS_OPERATOR, epoch, account));\n    }\n\n    /***********\\\n    |* Getters *|\n    \\***********/\n\n    function _operatorEpoch() internal view returns (uint256) {\n        return getUint(KEY_OPERATOR_EPOCH);\n    }\n\n    function _getOperator(uint256 epoch, uint256 index) internal view returns (address) {\n        return getAddress(_getOperatorKey(epoch, index));\n    }\n\n    function _getOperatorCount(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOperatorCountKey(epoch));\n    }\n\n    function _getOperatorThreshold(uint256 epoch) internal view returns (uint256) {\n        return getUint(_getOperatorThresholdKey(epoch));\n    }\n\n    function _isOperator(uint256 epoch, address account) internal view returns (bool) {\n        return getBool(_getIsOperatorKey(epoch, account));\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the same `operatorEpoch`, within the last `OLD_KEY_RETENTION + 1` operator epochs.\n    function _areValidRecentOperators(address[] memory accounts) internal view returns (bool) {\n        uint256 epoch = _operatorEpoch();\n        uint256 recentEpochs = OLD_KEY_RETENTION + uint256(1);\n        uint256 lowerBoundOperatorEpoch = epoch > recentEpochs ? epoch - recentEpochs : uint256(0);\n\n        while (epoch > lowerBoundOperatorEpoch) {\n            if (_areValidOperatorsInEpoch(epoch--, accounts)) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns true if a sufficient quantity of `accounts` are operator in the `operatorEpoch`.\n    function _areValidOperatorsInEpoch(uint256 epoch, address[] memory accounts) internal view returns (bool) {\n        uint256 threshold = _getOperatorThreshold(epoch);\n        uint256 validSignerCount;\n\n        for (uint256 i; i < accounts.length; i++) {\n            if (_isOperator(epoch, accounts[i]) && ++validSignerCount >= threshold) return true;\n        }\n\n        return false;\n    }\n\n    /// @dev Returns the current `operatorEpoch`.\n    function operatorEpoch() external view override returns (uint256) {\n        return _operatorEpoch();\n    }\n\n    /// @dev Returns the threshold for a given `operatorEpoch`.\n    function operatorThreshold(uint256 epoch) external view override returns (uint256) {\n        return _getOperatorThreshold(epoch);\n    }\n\n    /// @dev Returns the array of operators within a given `operatorEpoch`.\n    function operators(uint256 epoch) public view override returns (address[] memory results) {\n        uint256 operatorCount = _getOperatorCount(epoch);\n        results = new address[](operatorCount);\n\n        for (uint256 i; i < operatorCount; i++) {\n            results[i] = _getOperator(epoch, i);\n        }\n    }\n\n    /***********\\\n    |* Setters *|\n    \\***********/\n\n    function _setOperatorEpoch(uint256 epoch) internal {\n        _setUint(KEY_OPERATOR_EPOCH, epoch);\n    }\n\n    function _setOperator(\n        uint256 epoch,\n        uint256 index,\n        address account\n    ) internal {\n        _setAddress(_getOperatorKey(epoch, index), account);\n    }\n\n    function _setOperatorCount(uint256 epoch, uint256 operatorCount) internal {\n        _setUint(_getOperatorCountKey(epoch), operatorCount);\n    }\n\n    function _setOperators(\n        uint256 epoch,\n        address[] memory accounts,\n        uint256 threshold\n    ) internal {\n        uint256 accountLength = accounts.length;\n\n        if (accountLength < threshold) revert InvalidOperators();\n\n        if (threshold == uint256(0)) revert InvalidOperatorThreshold();\n\n        _setOperatorThreshold(epoch, threshold);\n        _setOperatorCount(epoch, accountLength);\n\n        for (uint256 i; i < accountLength; i++) {\n            address account = accounts[i];\n\n            // Check that the account wasn't already set as an operator for this operatorEpoch.\n            if (_isOperator(epoch, account)) revert DuplicateOperator(account);\n\n            if (account == address(0)) revert InvalidAddress();\n\n            // Set this account as the i-th operator in this operatorEpoch (needed to we can get all the operators for `operators`).\n            _setOperator(epoch, i, account);\n            _setIsOperator(epoch, account, true);\n        }\n    }\n\n    function _setOperatorThreshold(uint256 epoch, uint256 threshold) internal {\n        _setUint(_getOperatorThresholdKey(epoch), threshold);\n    }\n\n    function _setIsOperator(\n        uint256 epoch,\n        address account,\n        bool isOperator\n    ) internal {\n        _setBool(_getIsOperatorKey(epoch, account), isOperator);\n    }\n\n    /**********************\\\n    |* Self Functionality *|\n    \\**********************/\n\n    function deployToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory name, string memory symbol, uint8 decimals, uint256 cap, address tokenAddr) = abi.decode(\n            params,\n            (string, string, uint8, uint256, address)\n        );\n\n        _deployToken(name, symbol, decimals, cap, tokenAddr);\n    }\n\n    function mintToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, address account, uint256 amount) = abi.decode(params, (string, address, uint256));\n\n        _mintToken(symbol, account, amount);\n    }\n\n    function burnToken(bytes calldata params, bytes32) external onlySelf {\n        (string memory symbol, bytes32 salt) = abi.decode(params, (string, bytes32));\n\n        _burnToken(symbol, salt);\n    }\n\n    function approveContractCall(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, bytes32, uint256));\n\n        _approveContractCall(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function approveContractCallWithMint(bytes calldata params, bytes32 commandId) external onlySelf {\n        (\n            string memory sourceChain,\n            string memory sourceAddress,\n            address contractAddress,\n            bytes32 payloadHash,\n            string memory symbol,\n            uint256 amount,\n            bytes32 sourceTxHash,\n            uint256 sourceEventIndex\n        ) = abi.decode(params, (string, string, address, bytes32, string, uint256, bytes32, uint256));\n\n        _approveContractCallWithMint(\n            commandId,\n            sourceChain,\n            sourceAddress,\n            contractAddress,\n            payloadHash,\n            symbol,\n            amount,\n            sourceTxHash,\n            sourceEventIndex\n        );\n    }\n\n    function transferOwnership(bytes calldata params, bytes32) external onlySelf {\n        (address[] memory newOwners, uint256 newThreshold) = abi.decode(params, (address[], uint256));\n\n        uint256 epoch = _ownerEpoch();\n\n        emit OwnershipTransferred(owners(epoch), _getOwnerThreshold(epoch), newOwners, newThreshold);\n\n        _setOwnerEpoch(++epoch);\n        _setOwners(epoch, newOwners, newThreshold);\n    }\n\n    function transferOperatorship(bytes calldata params, bytes32) external onlySelf {\n        (address[] memory newOperators, uint256 newThreshold) = abi.decode(params, (address[], uint256));\n\n        uint256 epoch = _operatorEpoch();\n\n        emit OperatorshipTransferred(operators(epoch), _getOperatorThreshold(epoch), newOperators, newThreshold);\n\n        _setOperatorEpoch(++epoch);\n        _setOperators(epoch, newOperators, newThreshold);\n    }\n\n    /**************************\\\n    |* External Functionality *|\n    \\**************************/\n\n    function setup(bytes calldata params) external override {\n        // Prevent setup from being called on a non-proxy (the implementation).\n        if (implementation() == address(0)) revert NotProxy();\n\n        (\n            address[] memory adminAddresses,\n            uint256 newAdminThreshold,\n            address[] memory ownerAddresses,\n            uint256 newOwnerThreshold,\n            address[] memory operatorAddresses,\n            uint256 newOperatorThreshold\n        ) = abi.decode(params, (address[], uint256, address[], uint256, address[], uint256));\n\n        uint256 newAdminEpoch = _adminEpoch() + uint256(1);\n        _setAdminEpoch(newAdminEpoch);\n        _setAdmins(newAdminEpoch, adminAddresses, newAdminThreshold);\n\n        uint256 newOwnerEpoch = _ownerEpoch() + uint256(1);\n        _setOwnerEpoch(newOwnerEpoch);\n        _setOwners(newOwnerEpoch, ownerAddresses, newOwnerThreshold);\n\n        uint256 newOperatorEpoch = _operatorEpoch() + uint256(1);\n        _setOperatorEpoch(newOperatorEpoch);\n        _setOperators(newOperatorEpoch, operatorAddresses, newOperatorThreshold);\n\n        emit OwnershipTransferred(new address[](uint256(0)), uint256(0), ownerAddresses, newOwnerThreshold);\n        emit OperatorshipTransferred(new address[](uint256(0)), uint256(0), operatorAddresses, newOperatorThreshold);\n    }\n\n    function execute(bytes calldata input) external override {\n        (bytes memory data, bytes[] memory signatures) = abi.decode(input, (bytes, bytes[]));\n\n        _execute(data, signatures);\n    }\n\n    function _execute(bytes memory data, bytes[] memory signatures) internal {\n        uint256 signatureCount = signatures.length;\n\n        address[] memory signers = new address[](signatureCount);\n\n        for (uint256 i; i < signatureCount; i++) {\n            signers[i] = ECDSA.recover(ECDSA.toEthSignedMessageHash(keccak256(data)), signatures[i]);\n        }\n\n        (\n            uint256 chainId,\n            Role signersRole,\n            bytes32[] memory commandIds,\n            string[] memory commands,\n            bytes[] memory params\n        ) = abi.decode(data, (uint256, Role, bytes32[], string[], bytes[]));\n\n        if (chainId != block.chainid) revert InvalidChainId();\n\n        if (!_isSortedAscAndContainsNoDuplicate(signers)) revert MalformedSigners();\n\n        uint256 commandsLength = commandIds.length;\n\n        if (commandsLength != commands.length || commandsLength != params.length) revert InvalidCommands();\n\n        bool areValidCurrentOwners;\n        bool areValidRecentOwners;\n        bool areValidRecentOperators;\n\n        if (signersRole == Role.Owner) {\n            areValidCurrentOwners = _areValidOwnersInEpoch(_ownerEpoch(), signers);\n            areValidRecentOwners = areValidCurrentOwners || _areValidPreviousOwners(signers);\n        } else if (signersRole == Role.Operator) {\n            areValidRecentOperators = _areValidRecentOperators(signers);\n        }\n\n        for (uint256 i; i < commandsLength; i++) {\n            bytes32 commandId = commandIds[i];\n\n            if (isCommandExecuted(commandId)) continue; /* Ignore if duplicate commandId received */\n\n            bytes4 commandSelector;\n            bytes32 commandHash = keccak256(abi.encodePacked(commands[i]));\n\n            if (commandHash == SELECTOR_DEPLOY_TOKEN) {\n                if (!areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.deployToken.selector;\n            } else if (commandHash == SELECTOR_MINT_TOKEN) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.mintToken.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.approveContractCall.selector;\n            } else if (commandHash == SELECTOR_APPROVE_CONTRACT_CALL_WITH_MINT) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.approveContractCallWithMint.selector;\n            } else if (commandHash == SELECTOR_BURN_TOKEN) {\n                if (!areValidRecentOperators && !areValidRecentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.burnToken.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OWNERSHIP) {\n                if (!areValidCurrentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.transferOwnership.selector;\n            } else if (commandHash == SELECTOR_TRANSFER_OPERATORSHIP) {\n                if (!areValidCurrentOwners) continue;\n\n                commandSelector = AxelarGatewayMultisig.transferOperatorship.selector;\n            } else {\n                continue; /* Ignore if unknown command received */\n            }\n\n            // Prevent a re-entrancy from executing this command before it can be marked as successful.\n            _setCommandExecuted(commandId, true);\n            (bool success, ) = address(this).call(abi.encodeWithSelector(commandSelector, params[i], commandId));\n            _setCommandExecuted(commandId, success);\n\n            if (success) {\n                emit Executed(commandId);\n            }\n        }\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-axelar-findings.json",
                "Location": "AxelarGatewayMultisig.sol#L484, AxelarGatewayMultisig.sol#L490, AxelarGatewayMultisig.sol#L529",
                "Type": "Reentrancy",
                "Description": "The _execute function and its wrapper execute are both reentrant. If an attacker manages to reenter the _execute function with the same batch of commands and signatures, previously successfully executed and ongoing commands will be skipped due to premature marking of the success flag. This allows later commands to be executed before the current ongoing command is finished. The reentrant attack can be nested to perform further reordering of commands.",
                "Repair": "Make execute nonReentrant, Add an ever increasing nonce to signatures to prevent replay"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.12;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {SafeTransferLib, ERC20} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';\nimport {IERC721Mintable} from './interfaces/IERC721Mintable.sol';\nimport {ILendTicket} from './interfaces/ILendTicket.sol';\n\ncontract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {\n    using SafeTransferLib for ERC20;\n\n    // ==== constants ====\n\n    /** \n     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     \n     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%\n     */\n    uint8 public constant override INTEREST_RATE_DECIMALS = 3;\n\n    /// See {INFTLoanFacilitator-SCALAR}.\n    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;\n\n    \n    // ==== state variables ====\n\n    /// See {INFTLoanFacilitator-originationFeeRate}.\n    /// @dev starts at 1%\n    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);\n\n    /// See {INFTLoanFacilitator-requiredImprovementRate}.\n    /// @dev starts at 10%\n    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);\n\n    /// See {INFTLoanFacilitator-lendTicketContract}.\n    address public override lendTicketContract;\n\n    /// See {INFTLoanFacilitator-borrowTicketContract}.\n    address public override borrowTicketContract;\n\n    /// See {INFTLoanFacilitator-loanInfo}.\n    mapping(uint256 => Loan) public loanInfo;\n\n    /// @dev tracks loan count\n    uint256 private _nonce = 1;\n\n    \n    // ==== modifiers ====\n\n    modifier notClosed(uint256 loanId) { \n        require(!loanInfo[loanId].closed, \"NFTLoanFacilitator: loan closed\");\n        _; \n    }\n\n\n    // ==== constructor ====\n\n    constructor(address _manager) {\n        transferOwnership(_manager);\n    }\n\n    \n    // ==== state changing external functions ====\n\n    /// See {INFTLoanFacilitator-createLoan}.\n    function createLoan(\n        uint256 collateralTokenId,\n        address collateralContractAddress,\n        uint16 maxPerAnumInterest,\n        uint128 minLoanAmount,\n        address loanAssetContractAddress,\n        uint32 minDurationSeconds,\n        address mintBorrowTicketTo\n    )\n        external\n        override\n        returns (uint256 id) \n    {\n        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');\n        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');\n        require(collateralContractAddress != lendTicketContract,\n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        require(collateralContractAddress != borrowTicketContract, \n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        \n        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);\n\n        unchecked {\n            id = _nonce++;\n        }\n\n        Loan storage loan = loanInfo[id];\n        loan.loanAssetContractAddress = loanAssetContractAddress;\n        loan.loanAmount = minLoanAmount;\n        loan.collateralTokenId = collateralTokenId;\n        loan.collateralContractAddress = collateralContractAddress;\n        loan.perAnumInterestRate = maxPerAnumInterest;\n        loan.durationSeconds = minDurationSeconds;\n        \n        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);\n        emit CreateLoan(\n            id,\n            msg.sender,\n            collateralTokenId,\n            collateralContractAddress,\n            maxPerAnumInterest,\n            loanAssetContractAddress,\n            minLoanAmount,\n            minDurationSeconds\n        );\n    }\n\n    /// See {INFTLoanFacilitator-closeLoan}.\n    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,\n        \"NFTLoanFacilitator: borrow ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(loan.lastAccumulatedTimestamp == 0, \"NFTLoanFacilitator: has lender, use repayAndCloseLoan\");\n        \n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-lend}.\n    function lend(\n        uint256 loanId,\n        uint16 interestRate,\n        uint128 amount,\n        uint32 durationSeconds,\n        address sendLendTicketTo\n    )\n        external\n        override\n        notClosed(loanId)\n    {\n        Loan storage loan = loanInfo[loanId];\n        \n        if (loan.lastAccumulatedTimestamp == 0) {\n            address loanAssetContractAddress = loan.loanAssetContractAddress;\n            require(loanAssetContractAddress != address(0), \"NFTLoanFacilitator: invalid loan\");\n\n            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');\n            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');\n            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');\n        \n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n\n            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);\n            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;\n            ERC20(loanAssetContractAddress).safeTransfer(\n                IERC721(borrowTicketContract).ownerOf(loanId),\n                amount - facilitatorTake\n            );\n            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);\n        } else {\n            uint256 previousLoanAmount = loan.loanAmount;\n            // will underflow if amount < previousAmount\n            uint256 amountIncrease = amount - previousLoanAmount;\n\n            {\n                uint256 previousInterestRate = loan.perAnumInterestRate;\n                uint256 previousDurationSeconds = loan.durationSeconds;\n\n                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');\n                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');\n\n                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease\n                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds \n                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0\n                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), \n                \"NFTLoanFacilitator: proposed terms must be better than existing terms\");\n            }\n\n            uint256 accumulatedInterest = _interestOwed(\n                previousLoanAmount,\n                loan.lastAccumulatedTimestamp,\n                loan.perAnumInterestRate,\n                loan.accumulatedInterest\n            );\n\n            require(accumulatedInterest <= type(uint128).max,\n            \"NFTLoanFacilitator: accumulated interest exceeds uint128\");\n\n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n            loan.accumulatedInterest = uint128(accumulatedInterest);\n\n            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);\n            if (amountIncrease > 0) {\n                address loanAssetContractAddress = loan.loanAssetContractAddress;\n                ERC20(loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amount + accumulatedInterest\n                );\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    IERC721(borrowTicketContract).ownerOf(loanId),\n                    amountIncrease - facilitatorTake\n                );\n            } else {\n                ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n            }\n            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n            \n            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);\n        }\n\n        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);\n    }\n\n    /// See {INFTLoanFacilitator-repayAndCloseLoan}.\n    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {\n        Loan storage loan = loanInfo[loanId];\n\n        uint256 interest = _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n        address lender = IERC721(lendTicketContract).ownerOf(loanId);\n        loan.closed = true;\n        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            IERC721(borrowTicketContract).ownerOf(loanId),\n            loan.collateralTokenId\n        );\n\n        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-seizeCollateral}.\n    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, \n        \"NFTLoanFacilitator: lend ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,\n        \"NFTLoanFacilitator: payment is not late\");\n\n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            sendCollateralTo,\n            loan.collateralTokenId\n        );\n\n        emit SeizeCollateral(loanId);\n        emit Close(loanId);\n    }\n\n    \n    // === owner state changing ===\n\n    /**\n     * @notice Sets lendTicketContract to _contract\n     * @dev cannot be set if lendTicketContract is already set\n     */\n    function setLendTicketContract(address _contract) external onlyOwner {\n        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        lendTicketContract = _contract;\n    }\n\n    /**\n     * @notice Sets borrowTicketContract to _contract\n     * @dev cannot be set if borrowTicketContract is already set\n     */\n    function setBorrowTicketContract(address _contract) external onlyOwner {\n        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        borrowTicketContract = _contract;\n    }\n\n    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`\n    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {\n        ERC20(asset).safeTransfer(to, amount);\n\n        emit WithdrawOriginationFees(asset, amount, to);\n    }\n\n    /**\n     * @notice Updates originationFeeRate the faciliator keeps of each loan amount\n     * @dev Cannot be set higher than 5%\n     */\n    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {\n        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), \"NFTLoanFacilitator: max fee 5%\");\n        \n        originationFeeRate = _originationFeeRate;\n\n        emit UpdateOriginationFeeRate(_originationFeeRate);\n    }\n\n    /**\n     * @notice updates the percent improvement required of at least one loan term when buying out lender \n     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount\n     * must be 10% higher or interest rate must be 10% lower. \n     * @dev Cannot be 0.\n     */\n    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {\n        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');\n\n        requiredImprovementRate = _improvementRate;\n\n        emit UpdateRequiredImprovementRate(_improvementRate);\n    }\n\n    \n    // ==== external view ====\n\n    /// See {INFTLoanFacilitator-loanInfoStruct}.\n    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {\n        return loanInfo[loanId];\n    }\n\n    /// See {INFTLoanFacilitator-totalOwed}.\n    function totalOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return loanInfo[loanId].loanAmount + _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-interestOwed}.\n    function interestOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-loanEndSeconds}.\n    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        return loan.durationSeconds + loan.lastAccumulatedTimestamp;\n    }\n\n    \n    // === private ===\n\n    /// @dev Returns the total interest owed on loan\n    function _interestOwed(\n        uint256 loanAmount,\n        uint256 lastAccumulatedTimestamp,\n        uint256 perAnumInterestRate,\n        uint256 accumulatedInterest\n    ) \n        internal \n        view \n        returns (uint256) \n    {\n        return loanAmount\n            * (block.timestamp - lastAccumulatedTimestamp)\n            * (perAnumInterestRate * 1e18 / 365 days)\n            / 1e21 // SCALAR * 1e18\n            + accumulatedInterest;\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-backed-findings.json",
                "Location": "NFTLoanFacilitator.sol#L205-L208, NFTLoanFacilitator.sol#L215-L218",
                "Type": "Reentrancy",
                "Description": "An attacker can manipulate loanInfo by reentrancy attack when any lenders try to buyout. The attacker can set bad values of lendInfo (e.g. very long duration, and 0 interest rate) that the lender who wants to buyout don't expect.",
                "Repair": "Use nonReentrant modifier on lend() to prevent reentrancy attack or block ERC777 tokens"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.12;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {SafeTransferLib, ERC20} from \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {INFTLoanFacilitator} from './interfaces/INFTLoanFacilitator.sol';\nimport {IERC721Mintable} from './interfaces/IERC721Mintable.sol';\nimport {ILendTicket} from './interfaces/ILendTicket.sol';\n\ncontract NFTLoanFacilitator is Ownable, INFTLoanFacilitator {\n    using SafeTransferLib for ERC20;\n\n    // ==== constants ====\n\n    /** \n     * See {INFTLoanFacilitator-INTEREST_RATE_DECIMALS}.     \n     * @dev lowest non-zero APR possible = (1/10^3) = 0.001 = 0.1%\n     */\n    uint8 public constant override INTEREST_RATE_DECIMALS = 3;\n\n    /// See {INFTLoanFacilitator-SCALAR}.\n    uint256 public constant override SCALAR = 10 ** INTEREST_RATE_DECIMALS;\n\n    \n    // ==== state variables ====\n\n    /// See {INFTLoanFacilitator-originationFeeRate}.\n    /// @dev starts at 1%\n    uint256 public override originationFeeRate = 10 ** (INTEREST_RATE_DECIMALS - 2);\n\n    /// See {INFTLoanFacilitator-requiredImprovementRate}.\n    /// @dev starts at 10%\n    uint256 public override requiredImprovementRate = 10 ** (INTEREST_RATE_DECIMALS - 1);\n\n    /// See {INFTLoanFacilitator-lendTicketContract}.\n    address public override lendTicketContract;\n\n    /// See {INFTLoanFacilitator-borrowTicketContract}.\n    address public override borrowTicketContract;\n\n    /// See {INFTLoanFacilitator-loanInfo}.\n    mapping(uint256 => Loan) public loanInfo;\n\n    /// @dev tracks loan count\n    uint256 private _nonce = 1;\n\n    \n    // ==== modifiers ====\n\n    modifier notClosed(uint256 loanId) { \n        require(!loanInfo[loanId].closed, \"NFTLoanFacilitator: loan closed\");\n        _; \n    }\n\n\n    // ==== constructor ====\n\n    constructor(address _manager) {\n        transferOwnership(_manager);\n    }\n\n    \n    // ==== state changing external functions ====\n\n    /// See {INFTLoanFacilitator-createLoan}.\n    function createLoan(\n        uint256 collateralTokenId,\n        address collateralContractAddress,\n        uint16 maxPerAnumInterest,\n        uint128 minLoanAmount,\n        address loanAssetContractAddress,\n        uint32 minDurationSeconds,\n        address mintBorrowTicketTo\n    )\n        external\n        override\n        returns (uint256 id) \n    {\n        require(minDurationSeconds != 0, 'NFTLoanFacilitator: 0 duration');\n        require(minLoanAmount != 0, 'NFTLoanFacilitator: 0 loan amount');\n        require(collateralContractAddress != lendTicketContract,\n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        require(collateralContractAddress != borrowTicketContract, \n        'NFTLoanFacilitator: cannot use tickets as collateral');\n        \n        IERC721(collateralContractAddress).transferFrom(msg.sender, address(this), collateralTokenId);\n\n        unchecked {\n            id = _nonce++;\n        }\n\n        Loan storage loan = loanInfo[id];\n        loan.loanAssetContractAddress = loanAssetContractAddress;\n        loan.loanAmount = minLoanAmount;\n        loan.collateralTokenId = collateralTokenId;\n        loan.collateralContractAddress = collateralContractAddress;\n        loan.perAnumInterestRate = maxPerAnumInterest;\n        loan.durationSeconds = minDurationSeconds;\n        \n        IERC721Mintable(borrowTicketContract).mint(mintBorrowTicketTo, id);\n        emit CreateLoan(\n            id,\n            msg.sender,\n            collateralTokenId,\n            collateralContractAddress,\n            maxPerAnumInterest,\n            loanAssetContractAddress,\n            minLoanAmount,\n            minDurationSeconds\n        );\n    }\n\n    /// See {INFTLoanFacilitator-closeLoan}.\n    function closeLoan(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(borrowTicketContract).ownerOf(loanId) == msg.sender,\n        \"NFTLoanFacilitator: borrow ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(loan.lastAccumulatedTimestamp == 0, \"NFTLoanFacilitator: has lender, use repayAndCloseLoan\");\n        \n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).transferFrom(address(this), sendCollateralTo, loan.collateralTokenId);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-lend}.\n    function lend(\n        uint256 loanId,\n        uint16 interestRate,\n        uint128 amount,\n        uint32 durationSeconds,\n        address sendLendTicketTo\n    )\n        external\n        override\n        notClosed(loanId)\n    {\n        Loan storage loan = loanInfo[loanId];\n        \n        if (loan.lastAccumulatedTimestamp == 0) {\n            address loanAssetContractAddress = loan.loanAssetContractAddress;\n            require(loanAssetContractAddress != address(0), \"NFTLoanFacilitator: invalid loan\");\n\n            require(interestRate <= loan.perAnumInterestRate, 'NFTLoanFacilitator: rate too high');\n            require(durationSeconds >= loan.durationSeconds, 'NFTLoanFacilitator: duration too low');\n            require(amount >= loan.loanAmount, 'NFTLoanFacilitator: amount too low');\n        \n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n\n            ERC20(loanAssetContractAddress).safeTransferFrom(msg.sender, address(this), amount);\n            uint256 facilitatorTake = amount * originationFeeRate / SCALAR;\n            ERC20(loanAssetContractAddress).safeTransfer(\n                IERC721(borrowTicketContract).ownerOf(loanId),\n                amount - facilitatorTake\n            );\n            IERC721Mintable(lendTicketContract).mint(sendLendTicketTo, loanId);\n        } else {\n            uint256 previousLoanAmount = loan.loanAmount;\n            // will underflow if amount < previousAmount\n            uint256 amountIncrease = amount - previousLoanAmount;\n\n            {\n                uint256 previousInterestRate = loan.perAnumInterestRate;\n                uint256 previousDurationSeconds = loan.durationSeconds;\n\n                require(interestRate <= previousInterestRate, 'NFTLoanFacilitator: rate too high');\n                require(durationSeconds >= previousDurationSeconds, 'NFTLoanFacilitator: duration too low');\n\n                require((previousLoanAmount * requiredImprovementRate / SCALAR) <= amountIncrease\n                || previousDurationSeconds + (previousDurationSeconds * requiredImprovementRate / SCALAR) <= durationSeconds \n                || (previousInterestRate != 0 // do not allow rate improvement if rate already 0\n                    && previousInterestRate - (previousInterestRate * requiredImprovementRate / SCALAR) >= interestRate), \n                \"NFTLoanFacilitator: proposed terms must be better than existing terms\");\n            }\n\n            uint256 accumulatedInterest = _interestOwed(\n                previousLoanAmount,\n                loan.lastAccumulatedTimestamp,\n                loan.perAnumInterestRate,\n                loan.accumulatedInterest\n            );\n\n            require(accumulatedInterest <= type(uint128).max,\n            \"NFTLoanFacilitator: accumulated interest exceeds uint128\");\n\n            loan.perAnumInterestRate = interestRate;\n            loan.lastAccumulatedTimestamp = uint40(block.timestamp);\n            loan.durationSeconds = durationSeconds;\n            loan.loanAmount = amount;\n            loan.accumulatedInterest = uint128(accumulatedInterest);\n\n            address currentLoanOwner = IERC721(lendTicketContract).ownerOf(loanId);\n            if (amountIncrease > 0) {\n                address loanAssetContractAddress = loan.loanAssetContractAddress;\n                ERC20(loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    address(this),\n                    amount + accumulatedInterest\n                );\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n                uint256 facilitatorTake = (amountIncrease * originationFeeRate / SCALAR);\n                ERC20(loanAssetContractAddress).safeTransfer(\n                    IERC721(borrowTicketContract).ownerOf(loanId),\n                    amountIncrease - facilitatorTake\n                );\n            } else {\n                ERC20(loan.loanAssetContractAddress).safeTransferFrom(\n                    msg.sender,\n                    currentLoanOwner,\n                    accumulatedInterest + previousLoanAmount\n                );\n            }\n            ILendTicket(lendTicketContract).loanFacilitatorTransfer(currentLoanOwner, sendLendTicketTo, loanId);\n            \n            emit BuyoutLender(loanId, msg.sender, currentLoanOwner, accumulatedInterest, previousLoanAmount);\n        }\n\n        emit Lend(loanId, msg.sender, interestRate, amount, durationSeconds);\n    }\n\n    /// See {INFTLoanFacilitator-repayAndCloseLoan}.\n    function repayAndCloseLoan(uint256 loanId) external override notClosed(loanId) {\n        Loan storage loan = loanInfo[loanId];\n\n        uint256 interest = _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n        address lender = IERC721(lendTicketContract).ownerOf(loanId);\n        loan.closed = true;\n        ERC20(loan.loanAssetContractAddress).safeTransferFrom(msg.sender, lender, interest + loan.loanAmount);\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            IERC721(borrowTicketContract).ownerOf(loanId),\n            loan.collateralTokenId\n        );\n\n        emit Repay(loanId, msg.sender, lender, interest, loan.loanAmount);\n        emit Close(loanId);\n    }\n\n    /// See {INFTLoanFacilitator-seizeCollateral}.\n    function seizeCollateral(uint256 loanId, address sendCollateralTo) external override notClosed(loanId) {\n        require(IERC721(lendTicketContract).ownerOf(loanId) == msg.sender, \n        \"NFTLoanFacilitator: lend ticket holder only\");\n\n        Loan storage loan = loanInfo[loanId];\n        require(block.timestamp > loan.durationSeconds + loan.lastAccumulatedTimestamp,\n        \"NFTLoanFacilitator: payment is not late\");\n\n        loan.closed = true;\n        IERC721(loan.collateralContractAddress).safeTransferFrom(\n            address(this),\n            sendCollateralTo,\n            loan.collateralTokenId\n        );\n\n        emit SeizeCollateral(loanId);\n        emit Close(loanId);\n    }\n\n    \n    // === owner state changing ===\n\n    /**\n     * @notice Sets lendTicketContract to _contract\n     * @dev cannot be set if lendTicketContract is already set\n     */\n    function setLendTicketContract(address _contract) external onlyOwner {\n        require(lendTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        lendTicketContract = _contract;\n    }\n\n    /**\n     * @notice Sets borrowTicketContract to _contract\n     * @dev cannot be set if borrowTicketContract is already set\n     */\n    function setBorrowTicketContract(address _contract) external onlyOwner {\n        require(borrowTicketContract == address(0), 'NFTLoanFacilitator: already set');\n\n        borrowTicketContract = _contract;\n    }\n\n    /// @notice Transfers `amount` of loan origination fees for `asset` to `to`\n    function withdrawOriginationFees(address asset, uint256 amount, address to) external onlyOwner {\n        ERC20(asset).safeTransfer(to, amount);\n\n        emit WithdrawOriginationFees(asset, amount, to);\n    }\n\n    /**\n     * @notice Updates originationFeeRate the faciliator keeps of each loan amount\n     * @dev Cannot be set higher than 5%\n     */\n    function updateOriginationFeeRate(uint32 _originationFeeRate) external onlyOwner {\n        require(_originationFeeRate <= 5 * (10 ** (INTEREST_RATE_DECIMALS - 2)), \"NFTLoanFacilitator: max fee 5%\");\n        \n        originationFeeRate = _originationFeeRate;\n\n        emit UpdateOriginationFeeRate(_originationFeeRate);\n    }\n\n    /**\n     * @notice updates the percent improvement required of at least one loan term when buying out lender \n     * a loan that already has a lender. E.g. setting this value to 10 means duration or amount\n     * must be 10% higher or interest rate must be 10% lower. \n     * @dev Cannot be 0.\n     */\n    function updateRequiredImprovementRate(uint256 _improvementRate) external onlyOwner {\n        require(_improvementRate > 0, 'NFTLoanFacilitator: 0 improvement rate');\n\n        requiredImprovementRate = _improvementRate;\n\n        emit UpdateRequiredImprovementRate(_improvementRate);\n    }\n\n    \n    // ==== external view ====\n\n    /// See {INFTLoanFacilitator-loanInfoStruct}.\n    function loanInfoStruct(uint256 loanId) external view override returns (Loan memory) {\n        return loanInfo[loanId];\n    }\n\n    /// See {INFTLoanFacilitator-totalOwed}.\n    function totalOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if (loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return loanInfo[loanId].loanAmount + _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-interestOwed}.\n    function interestOwed(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        if(loan.closed || loan.lastAccumulatedTimestamp == 0) return 0;\n\n        return _interestOwed(\n            loan.loanAmount,\n            loan.lastAccumulatedTimestamp,\n            loan.perAnumInterestRate,\n            loan.accumulatedInterest\n        );\n    }\n\n    /// See {INFTLoanFacilitator-loanEndSeconds}.\n    function loanEndSeconds(uint256 loanId) external view override returns (uint256) {\n        Loan storage loan = loanInfo[loanId];\n        return loan.durationSeconds + loan.lastAccumulatedTimestamp;\n    }\n\n    \n    // === private ===\n\n    /// @dev Returns the total interest owed on loan\n    function _interestOwed(\n        uint256 loanAmount,\n        uint256 lastAccumulatedTimestamp,\n        uint256 perAnumInterestRate,\n        uint256 accumulatedInterest\n    ) \n        internal \n        view \n        returns (uint256) \n    {\n        return loanAmount\n            * (block.timestamp - lastAccumulatedTimestamp)\n            * (perAnumInterestRate * 1e18 / 365 days)\n            / 1e21 // SCALAR * 1e18\n            + accumulatedInterest;\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-backed-findings.json",
                "Location": "NFTLoanFacilitator.sol#L214-L221, NFTLoanFacilitator.sol#L230-L250",
                "Type": "Reentrancy",
                "Description": "If borrower lends their own loan, they can repay and close the loan before ownership of the lend ticket is transferred to the new lender. The borrower will keep the NFT + loan amount + accrued interest.",
                "Repair": "Move the line to transfer the lend ticket to the new lender above the line to transfer to funds to the original lender. Or, use reentrancyGuard from OpenZeppelin to remove the risk of reentrant calls completely. If desired, also require that the lender cannot be the same account as the borrower of a loan."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../interfaces/IController.sol\";\nimport \"../../interfaces/IYVault.sol\";\n\n/// @title JPEG'd yVault\n/// @notice Allows users to deposit fungible assets into autocompounding strategy contracts (e.g. {StrategyPUSDConvex}).\n/// Non whitelisted contracts can't deposit/withdraw.\n/// Owner is DAO\ncontract YVault is ERC20, Ownable {\n    using SafeERC20 for ERC20;\n    using Address for address;\n\n    event Deposit(address indexed depositor, uint256 wantAmount);\n    event Withdrawal(address indexed withdrawer, uint256 wantAmount);\n\n    struct Rate {\n        uint128 numerator;\n        uint128 denominator;\n    }\n\n    ERC20 public immutable token;\n    IController public controller;\n    \n    address public farm;\n    \n    Rate internal availableTokensRate;\n\n    mapping(address => bool) public whitelistedContracts;\n\n    /// @param _token The token managed by this vault\n    /// @param _controller The JPEG'd strategies controller\n    constructor(\n        address _token,\n        address _controller,\n        Rate memory _availableTokensRate\n    )\n        ERC20(\n            string(\n                abi.encodePacked(\"JPEG\\xE2\\x80\\x99d \", ERC20(_token).name())\n            ),\n            string(abi.encodePacked(\"JPEGD\", ERC20(_token).symbol()))\n        )\n    {\n        setController(_controller);\n        setAvailableTokensRate(_availableTokensRate);\n        token = ERC20(_token);\n    }\n\n    /// @dev Modifier that ensures that non-whitelisted contracts can't interact with the vault.\n    /// Prevents non-whitelisted 3rd party contracts from diluting stakers.\n    /// The {isContract} function returns false when `_account` is a contract executing constructor code.\n    /// This may lead to some contracts being able to bypass this check.\n    /// @param _account Address to check\n    modifier noContract(address _account) {\n        require(\n            !_account.isContract() || whitelistedContracts[_account],\n            \"Contracts not allowed\"\n        );\n        _;\n    }\n\n    /// @inheritdoc ERC20\n    function decimals() public view virtual override returns (uint8) {\n        return token.decimals();\n    }\n\n    /// @return The total amount of tokens managed by this vault and the underlying strategy\n    function balance() public view returns (uint256) {\n        return\n            token.balanceOf(address(this)) +\n            controller.balanceOf(address(token));\n    }\n\n    // @return The amount of JPEG tokens claimable by {YVaultLPFarming}\n    function balanceOfJPEG() external view returns (uint256) {\n        return controller.balanceOfJPEG(address(token));\n    }\n\n    /// @notice Allows the owner to whitelist/blacklist contracts\n    /// @param _contract The contract address to whitelist/blacklist\n    /// @param _isWhitelisted Whereter to whitelist or blacklist `_contract`\n    function setContractWhitelisted(address _contract, bool _isWhitelisted)\n        external\n        onlyOwner\n    {\n        whitelistedContracts[_contract] = _isWhitelisted;\n    }\n\n    /// @notice Allows the owner to set the rate of tokens held by this contract that the underlying strategy should be able to borrow\n    /// @param _rate The new rate\n    function setAvailableTokensRate(Rate memory _rate) public onlyOwner {\n        require(\n            _rate.numerator > 0 && _rate.denominator >= _rate.numerator,\n            \"INVALID_RATE\"\n        );\n        availableTokensRate = _rate;\n    }\n\n    /// @notice ALlows the owner to set this vault's controller\n    /// @param _controller The new controller\n    function setController(address _controller) public onlyOwner {\n        require(_controller != address(0), \"INVALID_CONTROLLER\");\n        controller = IController(_controller);\n    }\n\n    /// @notice Allows the owner to set the yVault LP farm\n    /// @param _farm The new farm\n    function setFarmingPool(address _farm) public onlyOwner {\n        require(_farm != address(0), \"INVALID_FARMING_POOL\");\n        farm = _farm;\n    }\n\n    /// @return How much the vault allows to be borrowed by the underlying strategy.\n    /// Sets minimum required on-hand to keep small withdrawals cheap\n    function available() public view returns (uint256) {\n        return\n            (token.balanceOf(address(this)) * availableTokensRate.numerator) /\n            availableTokensRate.denominator;\n    }\n\n    /// @notice Deposits `token` into the underlying strategy\n    function earn() external {\n        uint256 _bal = available();\n        token.safeTransfer(address(controller), _bal);\n        controller.earn(address(token), _bal);\n    }\n\n    /// @notice Allows users to deposit their entire `token` balance\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /// @notice Allows users to deposit `token`. Contracts can't call this function\n    /// @param _amount The amount to deposit\n    function deposit(uint256 _amount) public noContract(msg.sender) {\n        require(_amount > 0, \"INVALID_AMOUNT\");\n        uint256 balanceBefore = balance();\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 supply = totalSupply();\n        uint256 shares;\n        if (supply == 0) {\n            shares = _amount;\n        } else {\n            //balanceBefore can't be 0 if totalSupply is > 0\n            shares = (_amount * supply) / balanceBefore;\n        }\n        _mint(msg.sender, shares);\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /// @notice Allows users to withdraw all their deposited balance\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /// @notice Allows users to withdraw tokens. Contracts can't call this function\n    /// @param _shares The amount of shares to burn\n    function withdraw(uint256 _shares) public noContract(msg.sender) {\n        require(_shares > 0, \"INVALID_AMOUNT\");\n\n        uint256 supply = totalSupply();\n        require(supply > 0, \"NO_TOKENS_DEPOSITED\");\n\n        uint256 backingTokens = (balance() * _shares) / supply;\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 vaultBalance = token.balanceOf(address(this));\n        if (vaultBalance < backingTokens) {\n            uint256 toWithdraw = backingTokens - vaultBalance;\n            controller.withdraw(address(token), toWithdraw);\n        }\n\n        token.safeTransfer(msg.sender, backingTokens);\n        emit Withdrawal(msg.sender, backingTokens);\n    }\n\n    /// @notice Allows anyone to withdraw JPEG to `farm` \n    function withdrawJPEG() external {\n        require(farm != address(0), \"NO_FARM\");\n        controller.withdrawJPEG(address(token), farm);\n    }\n\n    /// @return The underlying tokens per share\n    function getPricePerFullShare() external view returns (uint256) {\n        uint256 supply = totalSupply();\n        if (supply == 0) return 0;\n        return (balance() * 1e18) / supply;\n    }\n\n    /// @dev Prevent the owner from renouncing ownership. Having no owner would render this contract unusable due to the inability to create new epochs\n    function renounceOwnership() public view override onlyOwner {\n        revert(\"Cannot renounce ownership\");\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-04-jpegd-findings.json",
                "Location": "yVault.sol#L144-L145",
                "Type": "Reentrancy",
                "Description": "In deposit, the balance is cached and then a token.transferFrom is triggered which can lead to exploits if the token is a token that gives control to the sender, like ERC777 tokens.",
                "Repair": "Make safeTransferFrom the last call in deposit"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts-0.6/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-0.6/utils/Context.sol\";\nimport \"@openzeppelin/contracts-0.6/access/Ownable.sol\";\nimport \"./interfaces/IRewarder.sol\";\n\n/**\n * @title   ConvexMasterChef\n * @author  ConvexFinance\n * @notice  Masterchef can distribute rewards to n pools over x time\n * @dev     There are some caveats with this usage - once it's turned on it can't be turned off,\n *          and thus it can over complicate the distribution of these rewards.\n *          To kick things off, just transfer CVX here and add some pools - rewards will be distributed\n *          pro-rata based on the allocation points in each pool vs the total alloc.\n */\ncontract ConvexMasterChef is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount; // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of CVXs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accCvxPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accCvxPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; // Address of LP token contract.\n        uint256 allocPoint; // How many allocation points assigned to this pool. CVX to distribute per block.\n        uint256 lastRewardBlock; // Last block number that CVXs distribution occurs.\n        uint256 accCvxPerShare; // Accumulated CVXs per share, times 1e12. See below.\n        IRewarder rewarder;\n    }\n\n    //cvx\n    IERC20 public immutable cvx;\n    // CVX tokens created per block.\n    uint256 public immutable rewardPerBlock;\n    // Bonus muliplier for early cvx makers.\n    uint256 public constant BONUS_MULTIPLIER = 2;\n\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n    // Info of each user that stakes LP tokens.\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint = 0;\n    // The block number when CVX mining starts.\n    uint256 public immutable startBlock;\n    uint256 public immutable endBlock;\n\n    // Events\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event RewardPaid(address indexed user,  uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount\n    );\n\n    constructor(\n        IERC20 _cvx,\n        uint256 _rewardPerBlock,\n        uint256 _startBlock,\n        uint256 _endBlock\n    ) public {\n        cvx = _cvx;\n        rewardPerBlock = _rewardPerBlock;\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    // Add a new lp to the pool. Can only be called by the owner.\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n    function add(\n        uint256 _allocPoint,\n        IERC20 _lpToken,\n        IRewarder _rewarder,\n        bool _withUpdate\n    ) public onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        uint256 lastRewardBlock = block.number > startBlock\n            ? block.number\n            : startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        poolInfo.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accCvxPerShare: 0,\n                rewarder: _rewarder\n            })\n        );\n    }\n\n    // Update the given pool's CVX allocation point. Can only be called by the owner.\n    function set(\n        uint256 _pid,\n        uint256 _allocPoint,\n        IRewarder _rewarder,\n        bool _withUpdate,\n        bool _updateRewarder\n    ) public onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\n            _allocPoint\n        );\n        poolInfo[_pid].allocPoint = _allocPoint;\n        if(_updateRewarder){\n            poolInfo[_pid].rewarder = _rewarder;\n        }\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint256 _from, uint256 _to)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 clampedTo = _to > endBlock ? endBlock : _to;\n        uint256 clampedFrom = _from > endBlock ? endBlock : _from;\n        return clampedTo.sub(clampedFrom);\n    }\n\n    // View function to see pending CVXs on frontend.\n    function pendingCvx(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accCvxPerShare = pool.accCvxPerShare;\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 multiplier = getMultiplier(\n                pool.lastRewardBlock,\n                block.number\n            );\n            uint256 cvxReward = multiplier\n                .mul(rewardPerBlock)\n                .mul(pool.allocPoint)\n                .div(totalAllocPoint);\n            accCvxPerShare = accCvxPerShare.add(\n                cvxReward.mul(1e12).div(lpSupply)\n            );\n        }\n        return user.amount.mul(accCvxPerShare).div(1e12).sub(user.rewardDebt);\n    }\n\n    // Update reward vairables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint256 cvxReward = multiplier\n            .mul(rewardPerBlock)\n            .mul(pool.allocPoint)\n            .div(totalAllocPoint);\n        //cvx.mint(address(this), cvxReward);\n        pool.accCvxPerShare = pool.accCvxPerShare.add(\n            cvxReward.mul(1e12).div(lpSupply)\n        );\n        pool.lastRewardBlock = block.number;\n    }\n\n    // Deposit LP tokens to MasterChef for CVX allocation.\n    function deposit(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) {\n            uint256 pending = user\n                .amount\n                .mul(pool.accCvxPerShare)\n                .div(1e12)\n                .sub(user.rewardDebt);\n            safeRewardTransfer(msg.sender, pending);\n        }\n        pool.lpToken.safeTransferFrom(\n            address(msg.sender),\n            address(this),\n            _amount\n        );\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, user.amount);\n        }\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    // Withdraw LP tokens from MasterChef.\n    function withdraw(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw: not good\");\n        updatePool(_pid);\n        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(\n            user.rewardDebt\n        );\n        safeRewardTransfer(msg.sender, pending);\n        user.amount = user.amount.sub(_amount);\n        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);\n        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, pending, user.amount);\n        }\n\n        emit RewardPaid(msg.sender, _pid, pending);\n        emit Withdraw(msg.sender, _pid, _amount);\n    }\n\n    function claim(uint256 _pid, address _account) external{\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_account];\n\n        updatePool(_pid);\n        uint256 pending = user.amount.mul(pool.accCvxPerShare).div(1e12).sub(\n            user.rewardDebt\n        );\n        safeRewardTransfer(_account, pending);\n        user.rewardDebt = user.amount.mul(pool.accCvxPerShare).div(1e12);\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, _account, _account, pending, user.amount);\n        }\n\n        emit RewardPaid(_account, _pid, pending);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n\n        //extra rewards\n        IRewarder _rewarder = pool.rewarder;\n        if (address(_rewarder) != address(0)) {\n            _rewarder.onReward(_pid, msg.sender, msg.sender, 0, 0);\n        }\n    }\n\n    // Safe cvx transfer function, just in case if rounding error causes pool to not have enough CVXs.\n    function safeRewardTransfer(address _to, uint256 _amount) internal {\n        uint256 cvxBal = cvx.balanceOf(address(this));\n        if (_amount > cvxBal) {\n            cvx.safeTransfer(_to, cvxBal);\n        } else {\n            cvx.safeTransfer(_to, _amount);\n        }\n    }\n\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-aura-findings.json",
                "Location": "ConvexMasterChef.sol#L209-L221, ConvexMasterChef.sol#L239-L250",
                "Type": "Reentrancy",
                "Description": "Reward token accounting update in deposit() and withdraw() happens after reward transfer. If reward token allows for the control of transfer call flow or can be upgraded to allow it in the future, the current implementation makes it possible to drain all the reward token funds of the contract by directly reentering deposit() or withdraw() with tiny _amount.",
                "Repair": "Consider adding a direct reentrancy control, e.g. nonReentrant modifier. Also, consider finishing all internal state updates prior to external calls."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./VestingWallet.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title BathBuddy\n * @dev *** This contract is a lightly modified version of Vesting Wallet by OpenZeppelin\n * @dev PLEASE FIND OZ DOCUMENTATION FOR THIS CONTRACT HERE: https://docs.openzeppelin.com/contracts/4.x/api/finance#VestingWallet\n *\n * @dev The only entrypoint used in the system is the release function called by the Bath Token. Extra care should be taken to make sure only the beneficiary can ever access the funds and send them to the withdrawer (and fee to self)\n *\n * @dev This contract handles the vesting ERC20 tokens for a given beneficiary. Custody of multiple tokens\n * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.\n * The vesting schedule is customizable through the {vestedAmount} function.\n *\n * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.\n * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)\n * be immediately releasable.\n */\ncontract BathBuddy is IBathBuddy {\n    using SafeMath for uint256;\n\n    // Public versions of the base VestingWallet storage\n    uint256 private _released;\n    mapping(address => uint256) private _erc20Released;\n\n    // Beneficiary must be the Bath Token vault recipient that will call release() for its withdrawer\n    address public beneficiary;\n    uint64 public start;\n    uint64 public duration;\n\n    /**\n     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.\n     */\n    constructor(\n        address beneficiaryAddress,\n        uint64 startTimestamp,\n        uint64 durationSeconds\n    ) {\n        require(\n            beneficiaryAddress != address(0),\n            \"VestingWallet: beneficiary is zero address\"\n        );\n        beneficiary = beneficiaryAddress;\n        start = startTimestamp;\n        duration = durationSeconds;\n    }\n\n    // OZ\n    event EtherReleased(uint256 amount);\n    event ERC20Released(address indexed token, uint256 amount);\n\n    /// @notice Log bonus token reward event\n    event LogClaimBonusToken(\n        address indexed receiver,\n        address indexed callingPool,\n        uint256 amountReceived,\n        uint256 shares,\n        IERC20 bonusToken,\n        uint256 releasableAmountToWholePool\n    );\n\n    /**\n     * @dev The contract should be able to receive Eth.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Amount of eth already released\n     */\n    function released() public view returns (uint256) {\n        return _released;\n    }\n\n    /**\n     * @dev Amount of token already released\n     */\n    function released(address token) public view returns (uint256) {\n        return _erc20Released[token];\n    }\n\n    /// @inheritdoc IBathBuddy\n    /// @dev Added and modified release function. Should be the only callable release function\n    function release(\n        IERC20 token,\n        address recipient,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply,\n        uint256 poolFee\n    ) external override {\n        require(\n            msg.sender == beneficiary,\n            \"Caller is not the Bath Token beneficiary of these rewards\"\n        );\n        uint256 releasable = vestedAmount(\n            address(token),\n            uint64(block.timestamp)\n        ) - released(address(token));\n        if (releasable > 0) {\n            uint256 amount = releasable.mul(sharesWithdrawn).div(\n                initialTotalSupply\n            );\n            uint256 _fee = amount.mul(poolFee).div(10000);\n\n            // If FeeTo == address(this) then the fee is effectively accrued by the pool\n            // Assume the caller is the liquidity pool and they receive the fee\n            // Keep tokens here by not transfering the _fee anywhere, it is accrued to the Bath Token's Bath Buddy\n            // token.transfer(address(this), _fee);\n\n            uint256 amountWithdrawn = amount.sub(_fee);\n            token.transfer(recipient, amountWithdrawn);\n\n            _erc20Released[address(token)] += amount;\n            emit ERC20Released(address(token), amount);\n\n            emit LogClaimBonusToken(\n                recipient,\n                msg.sender,\n                amountWithdrawn,\n                sharesWithdrawn,\n                token,\n                releasable\n            );\n        }\n    }\n\n    /**\n     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.\n     */\n    function vestedAmount(address token, uint64 timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            _vestingSchedule(\n                IERC20(token).balanceOf(address(this)) + released(token),\n                timestamp\n            );\n    }\n\n    /**\n     * @dev Virtual implementation of the vesting formula. This returns the amount vested, as a function of time, for\n     * an asset given its total historical allocation.\n     */\n    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp)\n        internal\n        view\n        returns (uint256)\n    {\n        if (timestamp < start) {\n            return 0;\n        } else if (timestamp > start + duration) {\n            return totalAllocation;\n        } else {\n            return (totalAllocation * (timestamp - start)) / duration;\n        }\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-rubicon-findings.json",
                "Location": "release() function in BathBuddy.sol",
                "Type": "Reentrancy",
                "Description": "If a token with callback capabilities is used as a token to vested, then a malicious beneficiary may get the vested amount back without waiting for the vesting period. In the function release, there’s no modifier to stop reentrancy, in the other contracts it would be the synchronized modifier. If a token could reenter with a hook in a malicious contract (an ERC777 token, for example, which is backwards compatible with ERC20), released token counter array wouldn’t be updated, enabling the withdrawal of the vested amount before the vesting period ends.",
                "Repair": "Add a mutex such as nonReentrant, or the synchronized modifier used in the other contracts. Implement checks-effects-interactions pattern."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress 📈\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress 📈\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public rewardsVestingWallet;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n\n        // Complete constract instantiation\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse {\n        bathHouse = newBathHouse;\n    }\n\n    /// @notice Admin-only function to approve Bath Token's RubiconMarketAddress with the maximum integer value (infinite approval)\n    function approveMarket() external onlyBathHouse {\n        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setFeeBPS(uint256 _feeBPS) external onlyBathHouse {\n        feeBPS = _feeBPS;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient, typically the pool itself\n    function setFeeTo(address _feeTo) external onlyBathHouse {\n        feeTo = _feeTo;\n    }\n\n    /// @notice Admin-only function to add a bonus token to bonusTokens for pool incentives\n    function setBonusToken(address newBonusERC20) external onlyBathHouse {\n        bonusTokens.push(newBonusERC20);\n    }\n\n    /// *** External Functions - Only Approved Bath Pair / Strategist Contract ***\n\n    /// ** Rubicon Market Functions **\n\n    /// @notice The function for a strategist to cancel an outstanding Market Offer\n    function cancel(uint256 id, uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        IRubiconMarket(RubiconMarketAddress).cancel(id);\n\n        emit LogPoolCancel(\n            id,\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice A function called by BathPair to maintain proper accounting of outstandingAmount\n    function removeFilledTradeAmount(uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        emit LogRemoveFilledTradeAmount(\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice The function that places a bid and/or ask in the orderbook for a given pair from this pool\n    function placeOffer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) external onlyPair returns (uint256) {\n        // Place an offer in RubiconMarket\n        // If incomplete offer return 0\n        if (\n            pay_amt == 0 ||\n            pay_gem == ERC20(0) ||\n            buy_amt == 0 ||\n            buy_gem == ERC20(0)\n        ) {\n            return 0;\n        }\n\n        uint256 id = IRubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            false\n        );\n        outstandingAmount = outstandingAmount.add(pay_amt);\n\n        emit LogPoolOffer(\n            id,\n            IERC20(underlyingToken),\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        return (id);\n    }\n\n    /// @notice This function returns filled orders to the correct liquidity pool and sends strategist rewards to the Bath Pair\n    /// @dev Sends non-underlyingToken fill elsewhere in the Pools system, typically it's sister asset within a trading pair (e.g. ETH-USDC)\n    /// @dev Strategists presently accrue rewards in the filled asset not underlyingToken\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance, /* sister or fill asset */\n        uint256 stratProportion,\n        uint256 rebalAmt\n    ) external onlyPair {\n        uint256 stratReward = (stratProportion.mul(rebalAmt)).div(10000);\n        IERC20(filledAssetToRebalance).transfer(\n            destination,\n            rebalAmt.sub(stratReward)\n        );\n        IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward);\n\n        emit LogRebalance(\n            IERC20(underlyingToken),\n            destination,\n            IERC20(filledAssetToRebalance),\n            rebalAmt,\n            stratReward,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// *** EIP 4626 Implementation ***\n    // https://eips.ethereum.org/EIPS/eip-4626#specification\n\n    /// @notice Withdraw your bathTokens for the underlyingToken\n    function withdraw(uint256 _shares)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        return _withdraw(_shares, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function asset() public view returns (address assetTokenAddress) {\n        assetTokenAddress = address(underlyingToken);\n    }\n\n    /// @notice * EIP 4626 *\n    function totalAssets() public view returns (uint256 totalManagedAssets) {\n        return underlyingBalance();\n    }\n\n    /// @notice * EIP 4626 *\n    function convertToShares(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // Note: Inflationary tokens may affect this logic\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(totalAssets());\n    }\n\n    // Note: MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// @notice * EIP 4626 *\n    function convertToAssets(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = (totalAssets().mul(shares)).div(totalSupply);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxDeposit(address receiver)\n        public\n        pure\n        returns (uint256 maxAssets)\n    {\n        maxAssets = 2**256 - 1; // No limit on deposits in current implementation  = Max UINT\n    }\n\n    /// @notice * EIP 4626 *\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // The exact same logic is used, no deposit fee - only difference is deflationary token check (rare condition and probably redundant)\n        shares = convertToShares(assets);\n    }\n\n    // Single asset override to reflect old functionality\n    function deposit(uint256 assets) public returns (uint256 shares) {\n        // Note: msg.sender is the same throughout the same contract context\n        return _deposit(assets, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\n        maxShares = 2**256 - 1; // No limit on shares that could be created via deposit in current implementation - Max UINT\n    }\n\n    // Given I want these shares, how much do I have to deposit\n    /// @notice * EIP 4626 *\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        (totalSupply == 0) ? assets = shares : assets = (\n            shares.mul(totalAssets())\n        ).div(totalSupply);\n    }\n\n    // Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @notice * EIP 4626 *\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    // A user can withdraw whatever they hold\n    /// @notice * EIP 4626 *\n    function maxWithdraw(address owner)\n        public\n        view\n        returns (uint256 maxAssets)\n    {\n        if (totalSupply == 0) {\n            maxAssets = 0;\n        } else {\n            uint256 ownerShares = balanceOf[owner];\n            maxAssets = convertToAssets(ownerShares);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        if (totalSupply == 0) {\n            shares = 0;\n        } else {\n            uint256 amountWithdrawn;\n            uint256 _fee = assets.mul(feeBPS).div(10000);\n            amountWithdrawn = assets.sub(_fee);\n            shares = convertToShares(amountWithdrawn);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public returns (uint256 shares) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        uint256 expectedShares = previewWithdraw(assets);\n        uint256 assetsReceived = _withdraw(expectedShares, receiver);\n        require(\n            assetsReceived >= assets,\n            \"You cannot withdraw the amount of assets you expected\"\n        );\n        shares = expectedShares;\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return balanceOf[owner];\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        uint256 r = (underlyingBalance().mul(shares)).div(totalSupply);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        assets = r.sub(_fee);\n    }\n\n    /// @notice * EIP 4626 *\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public returns (uint256 assets) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        assets = _withdraw(shares, receiver);\n    }\n\n    /// *** Internal Functions ***\n\n    /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        // **Assume caller is depositor**\n        underlyingToken.transferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); // Additional check for deflationary tokens\n\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(_pool);\n\n        // Send shares to designated target\n        _mint(receiver, shares);\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /// @notice Withdraw share for the user and send underlyingToken to receiver with any accrued yield and incentive tokens\n    function _withdraw(uint256 _shares, address receiver)\n        internal\n        returns (uint256 amountWithdrawn)\n    {\n        uint256 _initialTotalSupply = totalSupply;\n\n        // Distribute network rewards first in order to handle bonus token == underlying token case; it only releases vested tokens in this call\n        distributeBonusTokenRewards(receiver, _shares, _initialTotalSupply);\n\n        uint256 r = (underlyingBalance().mul(_shares)).div(_initialTotalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.transfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.transfer(receiver, amountWithdrawn);\n\n        emit LogWithdraw(\n            amountWithdrawn,\n            underlyingToken,\n            _shares,\n            msg.sender,\n            _fee,\n            feeTo,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Withdraw(\n            msg.sender,\n            receiver,\n            msg.sender,\n            amountWithdrawn,\n            _shares\n        );\n    }\n\n    /// @notice Function to distibute non-underlyingToken Bath Token incentives to pool withdrawers\n    /// @dev Note that bonusTokens adhere to the same feeTo and feeBPS pattern. Fees sit on BathBuddy to act as effectively accrued to the pool.\n    function distributeBonusTokenRewards(\n        address receiver,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply\n    ) internal {\n        if (bonusTokens.length > 0) {\n            for (uint256 index = 0; index < bonusTokens.length; index++) {\n                IERC20 token = IERC20(bonusTokens[index]);\n                // Note: Shares already burned in Bath Token _withdraw\n\n                // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they\n                //  are released their relative share of this pool, of vested BathBuddy rewards\n                // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens\n                if (rewardsVestingWallet != IBathBuddy(0)) {\n                    rewardsVestingWallet.release(\n                        (token),\n                        receiver,\n                        sharesWithdrawn,\n                        initialTotalSupply,\n                        feeBPS\n                    );\n                }\n            }\n        }\n    }\n\n    /// *** ERC - 20 Standard ***\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"bathToken: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The underlying ERC-20 that this bathToken handles\n    function underlyingERC20() external view returns (address) {\n        return address(underlyingToken);\n    }\n\n    /// @notice The best-guess total claim on assets the Bath Token has\n    /// @dev returns the amount of underlying ERC20 tokens in this pool in addition to any tokens that are outstanding in the Rubicon order book seeking market-making yield (outstandingAmount)\n    function underlyingBalance() public view returns (uint256) {\n        uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n        return _pool.add(outstandingAmount);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-rubicon-findings.json",
                "Location": "BathToken.initialize()",
                "Type": "Reentrancy",
                "Description": "Malicious pools can be deployed through BathHouse. Reentrancy in BathToken.initialize() can be exploited and this allows to create a pool which has a legitimate underlying token (even one for which a pool already exists), and has given full approval of underlying Token to an attacker.",
                "Repair": "Add onlyBathHouse modifier to initialize function in BathToken to avoid reentrancy from malicious tokens."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: BUSL-1.1\n\n/// @author Rubicon DeFi Inc. - bghughes.eth\n/// @notice This contract represents a single-asset liquidity pool for Rubicon Pools\n/// @notice Any user can deposit assets into this pool and earn yield from successful strategist market making with their liquidity\n/// @notice This contract looks to both BathPairs and the BathHouse as its admin\n\npragma solidity =0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../interfaces/IBathHouse.sol\";\nimport \"../interfaces/IRubiconMarket.sol\";\nimport \"../interfaces/IBathBuddy.sol\";\n\ncontract BathToken {\n    using SafeMath for uint256;\n\n    /// *** Storage Variables ***\n\n    /// @notice The initialization status of the Bath Token\n    bool public initialized;\n\n    /// @notice  ** ERC-20 **\n    string public symbol;\n    string public name;\n    uint8 public decimals;\n\n    /// @notice The RubiconMarket.sol instance that all pool liquidity is intially directed to as market-making offers\n    address public RubiconMarketAddress;\n\n    /// @notice The Bath House admin of the Bath Token\n    address public bathHouse;\n\n    /// @notice The withdrawal fee recipient, typically the Bath Token itself\n    address public feeTo;\n\n    /// @notice The underlying ERC-20 token which is the core asset of the Bath Token vault\n    IERC20 public underlyingToken;\n\n    /// @notice The basis point fee rate that is paid on withdrawing the underlyingToken and bonusTokens\n    uint256 public feeBPS;\n\n    /// @notice ** ERC-20 **\n    uint256 public totalSupply;\n\n    /// @notice The amount of underlying deposits that are outstanding attempting market-making on the order book for yield\n    /// @dev quantity of underlyingToken that is in the orderbook that the pool still has a claim on\n    /// @dev The underlyingToken is effectively mark-to-marketed when it enters the book and it could be returned at a loss due to poor strategist performance\n    /// @dev outstandingAmount is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists\n    uint256 public outstandingAmount;\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress 📈\n    /// @dev Keeping deprecated variables maintains consistent network-agnostic contract abis when moving to new chains and versions\n    uint256[] deprecatedStorageArray; // Kept in to avoid storage collision bathTokens that are proxy upgraded\n\n    /// @dev Intentionally unused DEPRECATED STORAGE VARIABLE to maintain contiguous state on proxy-wrapped contracts. Consider it a beautiful scar of incremental progress 📈\n    mapping(uint256 => uint256) deprecatedMapping; // Kept in to avoid storage collision on bathTokens that are upgraded\n    // *******************************************\n\n    /// @notice  ** ERC-20 **\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /// @notice EIP-2612\n    bytes32 public DOMAIN_SEPARATOR;\n\n    /// @notice EIP-2612\n    /// @dev keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /// @notice EIP-2612\n    mapping(address => uint256) public nonces;\n\n    /// @notice Array of Bonus ERC-20 tokens that are given as liquidity incentives to pool withdrawers\n    address[] public bonusTokens;\n\n    /// @notice Address of the OZ Vesting Wallet which acts as means to vest bonusToken incentives to pool HODLers\n    IBathBuddy public rewardsVestingWallet;\n\n    /// *** Events ***\n\n    /// @notice ** ERC-20 **\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice ** ERC-20 **\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Time of Bath Token instantiation\n    event LogInit(uint256 timeOfInit);\n\n    /// @notice Log details about a pool deposit\n    event LogDeposit(\n        uint256 depositedAmt,\n        IERC20 asset,\n        uint256 sharesReceived,\n        address depositor,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool withdraw\n    event LogWithdraw(\n        uint256 amountWithdrawn,\n        IERC20 asset,\n        uint256 sharesWithdrawn,\n        address withdrawer,\n        uint256 fee,\n        address feeTo,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool rebalance\n    event LogRebalance(\n        IERC20 pool_asset,\n        address destination,\n        IERC20 transferAsset,\n        uint256 rebalAmt,\n        uint256 stratReward,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order canceled in the Rubicon Market book\n    event LogPoolCancel(\n        uint256 orderId,\n        IERC20 pool_asset,\n        uint256 outstandingAmountToCancel,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log details about a pool order placed in the Rubicon Market book\n    event LogPoolOffer(\n        uint256 id,\n        IERC20 pool_asset,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice Log the credit to outstanding amount for funds that have been filled market-making\n    event LogRemoveFilledTradeAmount(\n        IERC20 pool_asset,\n        uint256 fillAmount,\n        uint256 underlyingBalance,\n        uint256 outstandingAmount,\n        uint256 totalSupply\n    );\n\n    /// @notice * EIP 4626 *\n    event Deposit(\n        address indexed caller,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// @notice * EIP 4626 *\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /// *** Constructor ***\n\n    /// @notice Proxy-safe initialization of storage; the constructor\n    function initialize(\n        ERC20 token,\n        address market,\n        address _feeTo\n    ) external {\n        require(!initialized);\n        string memory _symbol = string(\n            abi.encodePacked((\"bath\"), token.symbol())\n        );\n        symbol = _symbol;\n        underlyingToken = token;\n        RubiconMarketAddress = market;\n        bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        name = string(abi.encodePacked(_symbol, (\" v1\")));\n        decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n        // Add infinite approval of Rubicon Market for this asset\n        IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n        emit LogInit(block.timestamp);\n\n        feeTo = address(this); //This contract is the fee recipient, rewarding HODLers\n        feeBPS = 3; //Fee set to 3 BPS initially\n\n        // Complete constract instantiation\n        initialized = true;\n    }\n\n    /// *** Modifiers ***\n\n    modifier onlyPair() {\n        require(\n            IBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n            \"not an approved pair - bathToken\"\n        );\n        _;\n    }\n\n    modifier onlyBathHouse() {\n        require(\n            msg.sender == bathHouse,\n            \"caller is not bathHouse - BathToken.sol\"\n        );\n        _;\n    }\n\n    /// *** External Functions - Only Bath House / Admin ***\n\n    /// @notice Admin-only function to set a Bath Token's market address\n    function setMarket(address newRubiconMarket) external onlyBathHouse {\n        RubiconMarketAddress = newRubiconMarket;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's Bath House admin\n    function setBathHouse(address newBathHouse) external onlyBathHouse {\n        bathHouse = newBathHouse;\n    }\n\n    /// @notice Admin-only function to approve Bath Token's RubiconMarketAddress with the maximum integer value (infinite approval)\n    function approveMarket() external onlyBathHouse {\n        underlyingToken.approve(RubiconMarketAddress, 2**256 - 1);\n    }\n\n    /// @notice Admin-only function to set a Bath Token's feeBPS\n    function setFeeBPS(uint256 _feeBPS) external onlyBathHouse {\n        feeBPS = _feeBPS;\n    }\n\n    /// @notice Admin-only function to set a Bath Token's fee recipient, typically the pool itself\n    function setFeeTo(address _feeTo) external onlyBathHouse {\n        feeTo = _feeTo;\n    }\n\n    /// @notice Admin-only function to add a bonus token to bonusTokens for pool incentives\n    function setBonusToken(address newBonusERC20) external onlyBathHouse {\n        bonusTokens.push(newBonusERC20);\n    }\n\n    /// *** External Functions - Only Approved Bath Pair / Strategist Contract ***\n\n    /// ** Rubicon Market Functions **\n\n    /// @notice The function for a strategist to cancel an outstanding Market Offer\n    function cancel(uint256 id, uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        IRubiconMarket(RubiconMarketAddress).cancel(id);\n\n        emit LogPoolCancel(\n            id,\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice A function called by BathPair to maintain proper accounting of outstandingAmount\n    function removeFilledTradeAmount(uint256 amt) external onlyPair {\n        outstandingAmount = outstandingAmount.sub(amt);\n        emit LogRemoveFilledTradeAmount(\n            IERC20(underlyingToken),\n            amt,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// @notice The function that places a bid and/or ask in the orderbook for a given pair from this pool\n    function placeOffer(\n        uint256 pay_amt,\n        ERC20 pay_gem,\n        uint256 buy_amt,\n        ERC20 buy_gem\n    ) external onlyPair returns (uint256) {\n        // Place an offer in RubiconMarket\n        // If incomplete offer return 0\n        if (\n            pay_amt == 0 ||\n            pay_gem == ERC20(0) ||\n            buy_amt == 0 ||\n            buy_gem == ERC20(0)\n        ) {\n            return 0;\n        }\n\n        uint256 id = IRubiconMarket(RubiconMarketAddress).offer(\n            pay_amt,\n            pay_gem,\n            buy_amt,\n            buy_gem,\n            0,\n            false\n        );\n        outstandingAmount = outstandingAmount.add(pay_amt);\n\n        emit LogPoolOffer(\n            id,\n            IERC20(underlyingToken),\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        return (id);\n    }\n\n    /// @notice This function returns filled orders to the correct liquidity pool and sends strategist rewards to the Bath Pair\n    /// @dev Sends non-underlyingToken fill elsewhere in the Pools system, typically it's sister asset within a trading pair (e.g. ETH-USDC)\n    /// @dev Strategists presently accrue rewards in the filled asset not underlyingToken\n    function rebalance(\n        address destination,\n        address filledAssetToRebalance, /* sister or fill asset */\n        uint256 stratProportion,\n        uint256 rebalAmt\n    ) external onlyPair {\n        uint256 stratReward = (stratProportion.mul(rebalAmt)).div(10000);\n        IERC20(filledAssetToRebalance).transfer(\n            destination,\n            rebalAmt.sub(stratReward)\n        );\n        IERC20(filledAssetToRebalance).transfer(msg.sender, stratReward);\n\n        emit LogRebalance(\n            IERC20(underlyingToken),\n            destination,\n            IERC20(filledAssetToRebalance),\n            rebalAmt,\n            stratReward,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n    }\n\n    /// *** EIP 4626 Implementation ***\n    // https://eips.ethereum.org/EIPS/eip-4626#specification\n\n    /// @notice Withdraw your bathTokens for the underlyingToken\n    function withdraw(uint256 _shares)\n        external\n        returns (uint256 amountWithdrawn)\n    {\n        return _withdraw(_shares, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function asset() public view returns (address assetTokenAddress) {\n        assetTokenAddress = address(underlyingToken);\n    }\n\n    /// @notice * EIP 4626 *\n    function totalAssets() public view returns (uint256 totalManagedAssets) {\n        return underlyingBalance();\n    }\n\n    /// @notice * EIP 4626 *\n    function convertToShares(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // Note: Inflationary tokens may affect this logic\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(totalAssets());\n    }\n\n    // Note: MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n    /// @notice * EIP 4626 *\n    function convertToAssets(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        assets = (totalAssets().mul(shares)).div(totalSupply);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxDeposit(address receiver)\n        public\n        pure\n        returns (uint256 maxAssets)\n    {\n        maxAssets = 2**256 - 1; // No limit on deposits in current implementation  = Max UINT\n    }\n\n    /// @notice * EIP 4626 *\n    function previewDeposit(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        // The exact same logic is used, no deposit fee - only difference is deflationary token check (rare condition and probably redundant)\n        shares = convertToShares(assets);\n    }\n\n    // Single asset override to reflect old functionality\n    function deposit(uint256 assets) public returns (uint256 shares) {\n        // Note: msg.sender is the same throughout the same contract context\n        return _deposit(assets, msg.sender);\n    }\n\n    /// @notice * EIP 4626 *\n    function deposit(uint256 assets, address receiver)\n        public\n        returns (uint256 shares)\n    {\n        return _deposit(assets, receiver);\n    }\n\n    // Note: Unused function param to adhere to standard\n    /// @notice * EIP 4626 *\n    function maxMint(address receiver) public pure returns (uint256 maxShares) {\n        maxShares = 2**256 - 1; // No limit on shares that could be created via deposit in current implementation - Max UINT\n    }\n\n    // Given I want these shares, how much do I have to deposit\n    /// @notice * EIP 4626 *\n    function previewMint(uint256 shares) public view returns (uint256 assets) {\n        (totalSupply == 0) ? assets = shares : assets = (\n            shares.mul(totalAssets())\n        ).div(totalSupply);\n    }\n\n    // Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n    /// @notice * EIP 4626 *\n    function mint(uint256 shares, address receiver)\n        public\n        returns (uint256 assets)\n    {\n        assets = previewMint(shares);\n        uint256 _shares = _deposit(assets, receiver);\n        require(_shares == shares, \"did not mint expected share count\");\n    }\n\n    // A user can withdraw whatever they hold\n    /// @notice * EIP 4626 *\n    function maxWithdraw(address owner)\n        public\n        view\n        returns (uint256 maxAssets)\n    {\n        if (totalSupply == 0) {\n            maxAssets = 0;\n        } else {\n            uint256 ownerShares = balanceOf[owner];\n            maxAssets = convertToAssets(ownerShares);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function previewWithdraw(uint256 assets)\n        public\n        view\n        returns (uint256 shares)\n    {\n        if (totalSupply == 0) {\n            shares = 0;\n        } else {\n            uint256 amountWithdrawn;\n            uint256 _fee = assets.mul(feeBPS).div(10000);\n            amountWithdrawn = assets.sub(_fee);\n            shares = convertToShares(amountWithdrawn);\n        }\n    }\n\n    /// @notice * EIP 4626 *\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public returns (uint256 shares) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        uint256 expectedShares = previewWithdraw(assets);\n        uint256 assetsReceived = _withdraw(expectedShares, receiver);\n        require(\n            assetsReceived >= assets,\n            \"You cannot withdraw the amount of assets you expected\"\n        );\n        shares = expectedShares;\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function maxRedeem(address owner) public view returns (uint256 maxShares) {\n        return balanceOf[owner];\n    }\n\n    // Constraint: msg.sender is owner of shares when withdrawing\n    /// @notice * EIP 4626 *\n    function previewRedeem(uint256 shares)\n        public\n        view\n        returns (uint256 assets)\n    {\n        uint256 r = (underlyingBalance().mul(shares)).div(totalSupply);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        assets = r.sub(_fee);\n    }\n\n    /// @notice * EIP 4626 *\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public returns (uint256 assets) {\n        require(\n            owner == msg.sender,\n            \"This implementation does not support non-sender owners from withdrawing user shares\"\n        );\n        assets = _withdraw(shares, receiver);\n    }\n\n    /// *** Internal Functions ***\n\n    /// @notice Deposit assets for the user and mint Bath Token shares to receiver\n    function _deposit(uint256 assets, address receiver)\n        internal\n        returns (uint256 shares)\n    {\n        uint256 _pool = underlyingBalance();\n        uint256 _before = underlyingToken.balanceOf(address(this));\n\n        // **Assume caller is depositor**\n        underlyingToken.transferFrom(msg.sender, address(this), assets);\n        uint256 _after = underlyingToken.balanceOf(address(this));\n        assets = _after.sub(_before); // Additional check for deflationary tokens\n\n        (totalSupply == 0) ? shares = assets : shares = (\n            assets.mul(totalSupply)\n        ).div(_pool);\n\n        // Send shares to designated target\n        _mint(receiver, shares);\n        emit LogDeposit(\n            assets,\n            underlyingToken,\n            shares,\n            msg.sender,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Deposit(msg.sender, msg.sender, assets, shares);\n    }\n\n    /// @notice Withdraw share for the user and send underlyingToken to receiver with any accrued yield and incentive tokens\n    function _withdraw(uint256 _shares, address receiver)\n        internal\n        returns (uint256 amountWithdrawn)\n    {\n        uint256 _initialTotalSupply = totalSupply;\n\n        // Distribute network rewards first in order to handle bonus token == underlying token case; it only releases vested tokens in this call\n        distributeBonusTokenRewards(receiver, _shares, _initialTotalSupply);\n\n        uint256 r = (underlyingBalance().mul(_shares)).div(_initialTotalSupply);\n        _burn(msg.sender, _shares);\n        uint256 _fee = r.mul(feeBPS).div(10000);\n        // If FeeTo == address(0) then the fee is effectively accrued by the pool\n        if (feeTo != address(0)) {\n            underlyingToken.transfer(feeTo, _fee);\n        }\n        amountWithdrawn = r.sub(_fee);\n        underlyingToken.transfer(receiver, amountWithdrawn);\n\n        emit LogWithdraw(\n            amountWithdrawn,\n            underlyingToken,\n            _shares,\n            msg.sender,\n            _fee,\n            feeTo,\n            underlyingBalance(),\n            outstandingAmount,\n            totalSupply\n        );\n        emit Withdraw(\n            msg.sender,\n            receiver,\n            msg.sender,\n            amountWithdrawn,\n            _shares\n        );\n    }\n\n    /// @notice Function to distibute non-underlyingToken Bath Token incentives to pool withdrawers\n    /// @dev Note that bonusTokens adhere to the same feeTo and feeBPS pattern. Fees sit on BathBuddy to act as effectively accrued to the pool.\n    function distributeBonusTokenRewards(\n        address receiver,\n        uint256 sharesWithdrawn,\n        uint256 initialTotalSupply\n    ) internal {\n        if (bonusTokens.length > 0) {\n            for (uint256 index = 0; index < bonusTokens.length; index++) {\n                IERC20 token = IERC20(bonusTokens[index]);\n                // Note: Shares already burned in Bath Token _withdraw\n\n                // Pair each bonus token with a lightly adapted OZ Vesting wallet. Each time a user withdraws, they\n                //  are released their relative share of this pool, of vested BathBuddy rewards\n                // The BathBuddy pool should accrue ERC-20 rewards just like OZ VestingWallet and simply just release the withdrawer's relative share of releaseable() tokens\n                if (rewardsVestingWallet != IBathBuddy(0)) {\n                    rewardsVestingWallet.release(\n                        (token),\n                        receiver,\n                        sharesWithdrawn,\n                        initialTotalSupply,\n                        feeBPS\n                    );\n                }\n            }\n        }\n    }\n\n    /// *** ERC - 20 Standard ***\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) {\n        if (allowance[from][msg.sender] != uint256(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"bathToken: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n\n    /// *** View Functions ***\n\n    /// @notice The underlying ERC-20 that this bathToken handles\n    function underlyingERC20() external view returns (address) {\n        return address(underlyingToken);\n    }\n\n    /// @notice The best-guess total claim on assets the Bath Token has\n    /// @dev returns the amount of underlying ERC20 tokens in this pool in addition to any tokens that are outstanding in the Rubicon order book seeking market-making yield (outstandingAmount)\n    function underlyingBalance() public view returns (uint256) {\n        uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n        return _pool.add(outstandingAmount);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-05-rubicon-findings.json",
                "Location": "BathToken.sol#_deposit()",
                "Type": "Reentrancy",
                "Description": "There is a risk of re-entrancy attack to mint more shares due to the lack of reentrancy guard on the _deposit() function.",
                "Repair": "Add reentrancy guards or break the CEI pattern for deposits and perform the interaction first"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IMIMOAutoRebalance.sol\";\nimport \"../interfaces/IMIMORebalance.sol\";\nimport \"./MIMOAutoAction.sol\";\nimport \"../MIMOFlashloan.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\n/**\n  Rebalance value is calculated by the formula below :\n\n        targetRatio * (vaultDebt + fixedFee) - collateralValue\n      ----------------------------------------------------------\n          targetRatio / mcrB - 1 - targetRatio * variableFee \n */\n\n/// @title A `SuperVault V2` action contract for configuring a vault to be autorebalanced.\n/// @notice This allows anyone to rebalance the vault, as long as the rebalance meets the `autoRebalance` configuration.\ncontract MIMOAutoRebalance is MIMOAutoAction, MIMOFlashloan, IMIMOAutoRebalance {\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  address public immutable mimoRebalance;\n\n  /**\n    @param _a The addressProvider for the MIMO protocol \n    @param _lendingPool The AAVE lending pool used for flashloans \n    @param _proxyRegistry The MIMOProxyRegistry used to verify access control \n    @param _mimoRebalance The MIMORebalance contract address that holds the logic for the rebalance call \n   */\n  constructor(\n    IAddressProvider _a,\n    IPool _lendingPool,\n    IMIMOProxyRegistry _proxyRegistry,\n    address _mimoRebalance\n  ) MIMOAutoAction(_a, _proxyRegistry) MIMOFlashloan(_lendingPool) {\n    if (_mimoRebalance == address(0)) {\n      revert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    mimoRebalance = _mimoRebalance;\n  }\n\n  /**\n    @notice Perform a rebalance on a vault on behalf of vault owner\n    @notice Vault must have been created though a MIMOProxy\n    @dev Reverts if operation results in vault value change above allowed variation or in vault ratio lower than min ratio\n    @param vaultId Vault id of the vault to rebalance\n    @param swapData SwapData struct containing aggegator swap parameters\n   */\n  function rebalance(uint256 vaultId, IMIMOSwap.SwapData calldata swapData) external override {\n    AutomatedVault memory autoVault = _automatedVaults[vaultId];\n\n    (uint256 vaultARatioBefore, VaultState memory vaultAState) = _getVaultStats(vaultId);\n\n    _preRebalanceChecks(autoVault, vaultId, vaultARatioBefore);\n\n    IVaultsDataProvider vaultsData = a.vaultsData();\n    address vaultOwner = vaultsData.vaultOwner(vaultId);\n    uint256 vaultBId = vaultsData.vaultId(address(autoVault.toCollateral), vaultOwner);\n    uint256 vaultBBalanceBefore = vaultsData.vaultCollateralBalance(vaultBId);\n\n    (IMIMORebalance.RebalanceData memory rbData, FlashLoanData memory flData, uint256 autoFee) = _getRebalanceParams(\n      autoVault,\n      vaultAState,\n      IERC20(autoVault.toCollateral),\n      vaultId\n    );\n\n    _takeFlashLoan(flData, abi.encode(vaultOwner, autoFee, rbData, swapData));\n    _postRebalanceChecks(autoVault, flData.amount, vaultBBalanceBefore, vaultId, vaultOwner, vaultsData);\n\n    _operationTracker[vaultId] = block.timestamp;\n\n    IERC20(a.stablex()).safeTransfer(msg.sender, autoFee);\n  }\n\n  /**\n    @notice Routes a call from a flashloan pool to a leverage or rebalance operation\n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the reblanced asset\n    @param amounts Uint array with one element corresponding to the amount of the rebalanced asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, RebalanceData struct and SwapData struct\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (\n      address mimoProxy,\n      uint256 managerFee,\n      IMIMORebalance.RebalanceData memory rbData,\n      IMIMOSwap.SwapData memory swapData\n    ) = abi.decode(params, (address, uint256, IMIMORebalance.RebalanceData, IMIMOSwap.SwapData));\n\n    if (initiator != address(this)) {\n      revert CustomErrors.INITIATOR_NOT_AUTHORIZED(initiator, address(this));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert CustomErrors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 fromCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    fromCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      mimoRebalance,\n      abi.encodeWithSignature(\n        \"rebalanceOperation(address,uint256,uint256,uint256,(address,uint256,uint256),(uint256,bytes))\",\n        fromCollateral,\n        amount,\n        flashloanRepayAmount,\n        managerFee,\n        rbData,\n        swapData\n      )\n    );\n\n    fromCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Getter function returning rebalance amounts for specific vault id\n    @param vaultId Vault id of the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @return rebalanceAmount Amount to rebalance\n    @return mintAmount Amount to mint on vault B\n    @return autoFee Automation fee\n   */\n  function getAmounts(uint256 vaultId, address toCollateral)\n    external\n    view\n    override\n    returns (\n      uint256 rebalanceAmount,\n      uint256 mintAmount,\n      uint256 autoFee\n    )\n  {\n    (, VaultState memory vaultState) = _getVaultStats(vaultId);\n    return _getAmounts(_automatedVaults[vaultId], vaultState, toCollateral);\n  }\n\n  /**\n    @notice Helper function calculating the amount to rebalance from vault A and to mint from vault B with rebalnce formula\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultState VaultState struct og the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @return rebalanceAmount Amount to rebalance\n    @return mintAmount Amount to mint on vault b\n    @return autoFee Automation fee\n   */\n  function _getAmounts(\n    AutomatedVault memory autoVault,\n    VaultState memory vaultState,\n    address toCollateral\n  )\n    internal\n    view\n    returns (\n      uint256 rebalanceAmount,\n      uint256 mintAmount,\n      uint256 autoFee\n    )\n  {\n    IAddressProvider _a = a;\n\n    uint256 targetRatio = autoVault.targetRatio + 1e15; // add 0.1% to account for rounding\n    uint256 toVaultMcr = _a.config().collateralMinCollateralRatio(address(toCollateral));\n\n    // The rebalanceValue is the PAR value of the amount of collateral we need to rebalance\n    uint256 rebalanceValue = (targetRatio.wadMul(vaultState.vaultDebt + autoVault.fixedFee) -\n      vaultState.collateralValue).wadDiv(\n        (targetRatio.wadDiv(toVaultMcr + autoVault.mcrBuffer) - targetRatio.wadMul(autoVault.varFee) - WadRayMath.WAD)\n      );\n\n    autoFee = autoVault.fixedFee + rebalanceValue.wadMul(autoVault.varFee);\n    rebalanceAmount = _a.priceFeed().convertTo(vaultState.collateralType, rebalanceValue);\n    mintAmount = rebalanceValue.wadDiv(toVaultMcr + autoVault.mcrBuffer) - autoFee;\n  }\n\n  /**\n    @notice Helper function formatting FlashloanData and RebalanceData parameters\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultState VaultState struct of the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @param vaultId Vault id of the vault to rebalance\n    @return rbData RebalanceData struct\n    @return flData FlashloanData struct\n    @return autoFee Automation fee\n   */\n  function _getRebalanceParams(\n    AutomatedVault memory autoVault,\n    VaultState memory vaultState,\n    IERC20 toCollateral,\n    uint256 vaultId\n  )\n    internal\n    view\n    returns (\n      IMIMORebalance.RebalanceData memory rbData,\n      FlashLoanData memory flData,\n      uint256 autoFee\n    )\n  {\n    (uint256 rebalanceAmount, uint256 mintAmount, uint256 _autoFee) = _getAmounts(\n      autoVault,\n      vaultState,\n      address(toCollateral)\n    );\n\n    autoFee = _autoFee;\n    rbData = IMIMORebalance.RebalanceData({ toCollateral: toCollateral, vaultId: vaultId, mintAmount: mintAmount });\n    flData = FlashLoanData({ asset: vaultState.collateralType, proxyAction: address(this), amount: rebalanceAmount });\n  }\n\n  /**\n    @notice Helper function performing pre rebalance operation sanity checks\n    @dev Checks that vault is automated, that maximum daily operation was not reached and that trigger ratio was reached\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultId Vault id of the vault to rebalance\n    @param vaultARatio Collateral to debt ratio of the vault to rebalance\n   */\n  function _preRebalanceChecks(\n    AutomatedVault memory autoVault,\n    uint256 vaultId,\n    uint256 vaultARatio\n  ) internal view {\n    if (!autoVault.isAutomated) {\n      revert CustomErrors.VAULT_NOT_AUTOMATED();\n    }\n    if (_operationTracker[vaultId] > block.timestamp - 1 days) {\n      revert CustomErrors.MAX_OPERATIONS_REACHED();\n    }\n    if (vaultARatio > autoVault.triggerRatio) {\n      revert CustomErrors.VAULT_TRIGGER_RATIO_NOT_REACHED(vaultARatio, autoVault.triggerRatio);\n    }\n  }\n\n  /**\n    @notice Helper function performing post rebalance operation sanity checks\n    @dev Checks that change in global vault value (vault A + B) is below allowedVaration and vault A ratio equal or above targetRatio\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param rebalanceAmount Rebalanced amount\n    @param vaultBBalanceBefore Collateral balance of the vault to be rebalanced to before the rebalance operation\n    @param vaultId Vault id of the vault to rebalance\n    @param vaultOwner Rebalanced vault owner\n    @param vaultsData Cached VaultsDataProvider interface for gas saving\n   */\n  function _postRebalanceChecks(\n    AutomatedVault memory autoVault,\n    uint256 rebalanceAmount,\n    uint256 vaultBBalanceBefore,\n    uint256 vaultId,\n    address vaultOwner,\n    IVaultsDataProvider vaultsData\n  ) internal view {\n    IPriceFeed priceFeed = a.priceFeed();\n    address fromCollateral = vaultsData.vaultCollateralType(vaultId);\n    uint256 rebalanceValue = priceFeed.convertFrom(fromCollateral, rebalanceAmount);\n    uint256 vaultBId = vaultsData.vaultId(autoVault.toCollateral, vaultOwner);\n    uint256 vaultBBalanceAfter = vaultsData.vaultCollateralBalance(vaultBId);\n    uint256 swapResultValue = priceFeed.convertFrom(autoVault.toCollateral, vaultBBalanceAfter - vaultBBalanceBefore);\n\n    if (!_isVaultVariationAllowed(autoVault, rebalanceValue, swapResultValue)) {\n      revert CustomErrors.VAULT_VALUE_CHANGE_TOO_HIGH();\n    }\n\n    (uint256 vaultARatio, ) = _getVaultStats(vaultId);\n\n    if (vaultARatio < autoVault.targetRatio) {\n      revert CustomErrors.FINAL_VAULT_RATIO_TOO_LOW(autoVault.targetRatio, vaultARatio);\n    }\n  }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-08-mimo-findings.json",
                "Location": "MIMOAutoRebalance.sol#rebalance",
                "Type": "Reentrancy",
                "Description": "An attacker can exploit the vulnerability to steal funds by swapping through a malicious token that transfers control to the caller.",
                "Repair": "Add nonReentrant modifier to the function"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n\n// WARNING!!!\n// Combining BoringBatchable with msg.value can cause double spending issues\n// https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/\n\ncontract BoringBatchable {\n  error BatchError(bytes innerError);\n\n  /// @dev Helper function to extract a useful revert message from a failed call.\n  /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n  function _getRevertMsg(bytes memory _returnData) internal pure {\n    // If the _res length is less than 68, then\n    // the transaction failed with custom error or silently (without a revert message)\n    if (_returnData.length < 68) revert BatchError(_returnData);\n\n    assembly {\n      // Slice the sighash.\n      _returnData := add(_returnData, 0x04)\n    }\n    revert(abi.decode(_returnData, (string))); // All that remains is the revert string\n  }\n\n  /// @notice Allows batched call to self (this contract).\n  /// @param calls An array of inputs for each call.\n  /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n  // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n  // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n  // C3: The length of the loop is fully under user control, so can't be exploited\n  // C7: Delegatecall is only used on the same contract, so it's safe\n  function batch(bytes[] calldata calls, bool revertOnFail) external payable {\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n      if (!success && revertOnFail) {\n        _getRevertMsg(result);\n      }\n    }\n  }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-08-mimo-findings.json",
                "Location": "BoringBatchable contract",
                "Type": "Reentrancy",
                "Description": "Persisted msg.value in a loop of delegate calls can be used to drain ETH from your proxy",
                "Repair": "Remove payable from batch() function in BoringBatchable contract"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.6;\n\nimport {IHomeFi} from \"./interfaces/IHomeFi.sol\";\nimport {IProject} from \"./interfaces/IProject.sol\";\nimport {ICommunity, IDebtToken} from \"./interfaces/ICommunity.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {ContextUpgradeable, ERC2771ContextUpgradeable} from \"@openzeppelin/contracts-upgradeable/metatx/ERC2771ContextUpgradeable.sol\";\nimport {SafeERC20Upgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport {SignatureDecoder} from \"./libraries/SignatureDecoder.sol\";\n\n/* solhint-disable not-rely-on-time */\n\n/**\n * @title Community Contract for HomeFi v2.5.0\n \n * @notice Module for coordinating lending groups on HomeFi protocol\n */\ncontract Community is\n    ICommunity,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    ERC2771ContextUpgradeable\n{\n    // Using SafeERC20Upgradeable library for IDebtToken\n    using SafeERC20Upgradeable for IDebtToken;\n\n    /*******************************************************************************\n     * ---------------------FIXED INTERNAL STORED PROPERTIES---------------------- *\n     *******************************************************************************/\n    address internal tokenCurrency1;\n    address internal tokenCurrency2;\n    address internal tokenCurrency3;\n\n    /*******************************************************************************\n     * --------------------VARIABLE INTERNAL STORED PROPERTIES-------------------- *\n     *******************************************************************************/\n\n    mapping(uint256 => CommunityStruct) internal _communities;\n\n    /*******************************************************************************\n     * ----------------------FIXED PUBLIC STORED PROPERTIES----------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    IHomeFi public override homeFi;\n\n    /*******************************************************************************\n     * ---------------------VARIABLE PUBLIC STORED PROPERTIES--------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    bool public override restrictedToAdmin;\n    /// @inheritdoc ICommunity\n    uint256 public override communityCount;\n    /// @inheritdoc ICommunity\n    mapping(address => uint256) public override projectPublished;\n    /// @inheritdoc ICommunity\n    mapping(address => mapping(bytes32 => bool)) public override approvedHashes;\n\n    /*******************************************************************************\n     * ---------------------------------MODIFIERS--------------------------------- *\n     *******************************************************************************/\n\n    modifier nonZero(address _address) {\n        // Revert if _address zero address (0x00) (invalid)\n        require(_address != address(0), \"Community::0 address\");\n        _;\n    }\n\n    modifier onlyHomeFiAdmin() {\n        // Revert if sender is not homeFi admin\n        require(_msgSender() == homeFi.admin(), \"Community::!admin\");\n        _;\n    }\n\n    modifier isPublishedToCommunity(uint256 _communityID, address _project) {\n        // Revert if _project is not published to _communityID\n        require(\n            projectPublished[_project] == _communityID,\n            \"Community::!published\"\n        );\n        _;\n    }\n\n    modifier onlyProjectBuilder(address _project) {\n        // Revert if sender is not _project builder\n        require(\n            _msgSender() == IProject(_project).builder(),\n            \"Community::!Builder\"\n        );\n        _;\n    }\n\n    /*******************************************************************************\n     * ---------------------------EXTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function initialize(address _homeFi)\n        external\n        override\n        initializer\n        nonZero(_homeFi)\n    {\n        // Initialize pausable. Set pause to false;\n        __Pausable_init();\n\n        // Initialize variables\n        homeFi = IHomeFi(_homeFi);\n        tokenCurrency1 = homeFi.tokenCurrency1();\n        tokenCurrency2 = homeFi.tokenCurrency2();\n        tokenCurrency3 = homeFi.tokenCurrency3();\n\n        // Community creation is paused for non admin by default paused\n        restrictedToAdmin = true;\n    }\n\n    /// @inheritdoc ICommunity\n    function createCommunity(bytes calldata _hash, address _currency)\n        external\n        override\n        whenNotPaused\n    {\n        // Local variable for sender. For gas saving.\n        address _sender = _msgSender();\n\n        // Revert if community creation is paused or sender is not HomeFi admin\n        require(\n            !restrictedToAdmin || _sender == homeFi.admin(),\n            \"Community::!admin\"\n        );\n\n        // Revert if currency is not supported by HomeFi\n        homeFi.validCurrency(_currency);\n\n        // Increment community counter\n        communityCount++;\n\n        // Store community details\n        CommunityStruct storage _community = _communities[communityCount];\n        _community.owner = _sender;\n        _community.currency = IDebtToken(_currency);\n        _community.memberCount = 1;\n        _community.members[0] = _sender;\n        _community.isMember[_sender] = true;\n\n        emit CommunityAdded(communityCount, _sender, _currency, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function updateCommunityHash(uint256 _communityID, bytes calldata _hash)\n        external\n        override\n    {\n        // Revert if sender is not _communityID owner\n        require(\n            _communities[_communityID].owner == _msgSender(),\n            \"Community::!owner\"\n        );\n\n        // Emit event if _hash. This way this hash needs not be stored in memory.\n        emit UpdateCommunityHash(_communityID, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function addMember(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _newMemberAddr,\n            bytes memory _messageHash\n        ) = abi.decode(_data, (uint256, address, bytes));\n\n        CommunityStruct storage _community = _communities[_communityID];\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_newMemberAddr, _hash, _signature, 1); // must be new member\n\n        // Revert if new member already exists\n        require(\n            !_community.isMember[_newMemberAddr],\n            \"Community::Member Exists\"\n        );\n\n        // Store updated community details\n        uint256 _memberCount = _community.memberCount;\n        _community.memberCount = _memberCount + 1;\n        _community.members[_memberCount] = _newMemberAddr;\n        _community.isMember[_newMemberAddr] = true;\n\n        emit MemberAdded(_communityID, _newMemberAddr, _messageHash);\n    }\n\n    /// @inheritdoc ICommunity\n    function publishProject(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _project,\n            uint256 _apr,\n            uint256 _publishFee,\n            uint256 _publishNonce,\n            bytes memory _messageHash\n        ) = abi.decode(\n                _data,\n                (uint256, address, uint256, uint256, uint256, bytes)\n            );\n\n        // Local instance of community and community  project details. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if decoded nonce is incorrect. This indicates wrong _data.\n        require(\n            _publishNonce == _community.publishNonce,\n            \"Community::invalid publishNonce\"\n        );\n\n        // Reverts if _project not originated from HomeFi\n        require(homeFi.isProjectExist(_project), \"Community::Project !Exists\");\n\n        // Local instance of variables. For saving gas.\n        IProject _projectInstance = IProject(_project);\n        address _builder = _projectInstance.builder();\n\n        // Revert if project builder is not community member\n        require(_community.isMember[_builder], \"Community::!Member\");\n\n        // Revert if project currency does not match community currency\n        require(\n            _projectInstance.currency() == _community.currency,\n            \"Community::!Currency\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_community.owner, _hash, _signature, 0); // must be community owner\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be project builder\n\n        // If already published then unpublish first\n        if (projectPublished[_project] > 0) {\n            _unpublishProject(_project);\n        }\n\n        // Store updated details\n        _community.publishNonce = ++_community.publishNonce;\n        _communityProject.apr = _apr;\n        _communityProject.publishFee = _publishFee;\n        projectPublished[_project] = _communityID;\n\n        // If _publishFee is zero than mark publish fee as paid\n        if (_publishFee == 0) _communityProject.publishFeePaid = true;\n\n        emit ProjectPublished(\n            _communityID,\n            _project,\n            _apr,\n            _publishFee,\n            _communityProject.publishFeePaid,\n            _messageHash\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function unpublishProject(uint256 _communityID, address _project)\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Call internal function to unpublish project\n        _unpublishProject(_project);\n    }\n\n    /// @inheritdoc ICommunity\n    function payPublishFee(uint256 _communityID, address _project)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n\n        // Revert if publish fee already paid\n        require(\n            !_communityProject.publishFeePaid,\n            \"Community::publish fee paid\"\n        );\n\n        // Store updated detail\n        _communityProject.publishFeePaid = true;\n\n        // Transfer publishFee to community owner (lender)\n        _community.currency.safeTransferFrom(\n            _msgSender(),\n            _community.owner,\n            _communityProject.publishFee\n        );\n\n        emit PublishFeePaid(_communityID, _project);\n    }\n\n    /// @inheritdoc ICommunity\n    function toggleLendingNeeded(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingNeeded\n    )\n        external\n        override\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n        onlyProjectBuilder(_project)\n    {\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        // Revert if publish fee not paid\n        require(\n            _communityProject.publishFeePaid,\n            \"Community::publish fee !paid\"\n        );\n\n        // Revert if _lendingNeeded is more than projectCost or less than what is already lent\n        require(\n            _lendingNeeded >= _communityProject.totalLent &&\n                _lendingNeeded <= IProject(_project).projectCost(),\n            \"Community::invalid lending\"\n        );\n\n        // Store updated detail\n        _communityProject.lendingNeeded = _lendingNeeded;\n\n        emit ToggleLendingNeeded(_communityID, _project, _lendingNeeded);\n    }\n\n    /// @inheritdoc ICommunity\n    function lendToProject(\n        uint256 _communityID,\n        address _project,\n        uint256 _lendingAmount,\n        bytes calldata _hash\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        isPublishedToCommunity(_communityID, _project)\n    {\n        // Local instance of variable. For saving gas.\n        address _sender = _msgSender();\n\n        // Revert if sender is not community owner.\n        // Only community owner can lend.\n        require(\n            _sender == _communities[_communityID].owner,\n            \"Community::!owner\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Calculate lenderFee\n        uint256 _lenderFee = (_lendingAmount * _projectInstance.lenderFee()) /\n            (_projectInstance.lenderFee() + 1000);\n\n        // Calculate amount going to project. Lending amount - lending fee.\n        uint256 _amountToProject = _lendingAmount - _lenderFee;\n\n        // Revert if _amountToProject is not within further investment needed.\n        require(\n            _amountToProject <=\n                _communities[_communityID]\n                    .projectDetails[_project]\n                    .lendingNeeded -\n                    _communities[_communityID]\n                        .projectDetails[_project]\n                        .totalLent,\n            \"Community::lending>needed\"\n        );\n\n        // Local instance of variable. For saving gas.\n        IDebtToken _currency = _communities[_communityID].currency;\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_currency))\n        );\n\n        // Update investment in Project\n        _projectInstance.lendToProject(_amountToProject);\n\n        // Update total lent by lender\n        _communities[_communityID]\n            .projectDetails[_project]\n            .totalLent += _amountToProject;\n\n        // First claim interest if principal lent > 0\n        if (\n            _communities[_communityID].projectDetails[_project].lentAmount > 0\n        ) {\n            claimInterest(_communityID, _project, _wrappedToken);\n        }\n\n        // Increment lent principal\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lentAmount += _lendingAmount;\n\n        // Update lastTimestamp\n        _communities[_communityID]\n            .projectDetails[_project]\n            .lastTimestamp = block.timestamp;\n\n        // Transfer _lenderFee to HomeFi treasury from lender account\n        _currency.safeTransferFrom(_msgSender(), homeFi.treasury(), _lenderFee);\n\n        // Transfer _amountToProject to _project from lender account\n        _currency.safeTransferFrom(_msgSender(), _project, _amountToProject);\n\n        // Mint new _lendingAmount amount wrapped token to lender\n        _wrappedToken.mint(_sender, _lendingAmount);\n\n        emit LenderLent(_communityID, _project, _sender, _lendingAmount, _hash);\n    }\n\n    /// @inheritdoc ICommunity\n    function repayLender(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount\n    )\n        external\n        virtual\n        override\n        nonReentrant\n        whenNotPaused\n        onlyProjectBuilder(_project)\n    {\n        // Internally call reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, \"0x\");\n\n        // Local instance of variable. For saving gas.\n        address _lender = _communities[_communityID].owner;\n\n        // Transfer repayment to lender\n        _communities[_communityID].currency.safeTransferFrom(\n            _msgSender(),\n            _lender,\n            _repayAmount\n        );\n\n        emit RepayLender(_communityID, _project, _lender, _repayAmount);\n    }\n\n    /// @inheritdoc ICommunity\n    function reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) external virtual override whenNotPaused {\n        // Revert if sender is not _communityID owner (lender)\n        require(\n            _msgSender() == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n    }\n\n    /// @inheritdoc ICommunity\n    function approveHash(bytes32 _hash) external virtual override {\n        // allowing anyone to sign, as its hard to add restrictions here\n        approvedHashes[_msgSender()][_hash] = true;\n\n        emit ApproveHash(_hash, _msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function escrow(bytes calldata _data, bytes calldata _signature)\n        external\n        virtual\n        override\n        whenNotPaused\n    {\n        // Decode params from _data\n        (\n            uint256 _communityID,\n            address _builder,\n            address _lender,\n            address _agent,\n            address _project,\n            uint256 _repayAmount,\n            bytes memory _details\n        ) = abi.decode(\n                _data,\n                (uint256, address, address, address, address, uint256, bytes)\n            );\n\n        // Compute hash from bytes\n        bytes32 _hash = keccak256(_data);\n\n        // Local instance of variable. For saving gas.\n        IProject _projectInstance = IProject(_project);\n\n        // Revert if decoded builder is not decoded project's builder\n        require(_builder == _projectInstance.builder(), \"Community::!Builder\");\n\n        // Revert if decoded _communityID's owner is not decoded _lender\n        require(\n            _lender == _communities[_communityID].owner,\n            \"Community::!Owner\"\n        );\n\n        // check signatures\n        checkSignatureValidity(_lender, _hash, _signature, 0); // must be lender\n        checkSignatureValidity(_builder, _hash, _signature, 1); // must be builder\n        checkSignatureValidity(_agent, _hash, _signature, 2); // must be agent or escrow\n\n        // Internal call to reduce debt\n        _reduceDebt(_communityID, _project, _repayAmount, _details);\n        emit DebtReducedByEscrow(_agent);\n    }\n\n    /// @inheritdoc ICommunity\n    function restrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already restricted to admin\n        require(!restrictedToAdmin, \"Community::restricted\");\n\n        // Disable community creation for non admins\n        restrictedToAdmin = true;\n\n        emit RestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function unrestrictToAdmin() external override onlyHomeFiAdmin {\n        // Revert if already unrestricted to admin\n        require(restrictedToAdmin, \"Community::!restricted\");\n\n        // Allow community creation for all\n        restrictedToAdmin = false;\n\n        emit UnrestrictedToAdmin(_msgSender());\n    }\n\n    /// @inheritdoc ICommunity\n    function pause() external override onlyHomeFiAdmin {\n        _pause();\n    }\n\n    /// @inheritdoc ICommunity\n    function unpause() external override onlyHomeFiAdmin {\n        _unpause();\n    }\n\n    /*******************************************************************************\n     * ------------------------------EXTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function communities(uint256 _communityID)\n        external\n        view\n        override\n        returns (\n            address owner,\n            address currency,\n            uint256 memberCount,\n            uint256 publishNonce\n        )\n    {\n        CommunityStruct storage _community = _communities[_communityID];\n\n        owner = _community.owner;\n        currency = address(_community.currency);\n        memberCount = _community.memberCount;\n        publishNonce = _community.publishNonce;\n    }\n\n    /// @inheritdoc ICommunity\n    function members(uint256 _communityID)\n        external\n        view\n        virtual\n        override\n        returns (address[] memory)\n    {\n        // Initiate empty equal equal to member count length\n        address[] memory _members = new address[](\n            _communities[_communityID].memberCount\n        );\n\n        // Append member addresses in _members array\n        for (uint256 i = 0; i < _communities[_communityID].memberCount; i++) {\n            _members[i] = _communities[_communityID].members[i];\n        }\n\n        return _members;\n    }\n\n    /// @inheritdoc ICommunity\n    function projectDetails(uint256 _communityID, address _project)\n        external\n        view\n        virtual\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        return (\n            _communityProject.apr,\n            _communityProject.lendingNeeded,\n            _communityProject.totalLent,\n            _communityProject.publishFee,\n            _communityProject.publishFeePaid,\n            _communityProject.lentAmount,\n            _communityProject.interest,\n            _communityProject.lastTimestamp\n        );\n    }\n\n    /*******************************************************************************\n     * -------------------------------PUBLIC VIEWS-------------------------------- *\n     *******************************************************************************/\n\n    /// @inheritdoc ICommunity\n    function returnToLender(uint256 _communityID, address _project)\n        public\n        view\n        override\n        returns (\n            uint256, // principal + interest\n            uint256, // principal\n            uint256, // total interest\n            uint256 // unclaimedInterest\n        )\n    {\n        // Local instance of variables. For saving gas.\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n        uint256 _lentAmount = _communityProject.lentAmount;\n\n        // Calculate number of days difference current and last timestamp\n        uint256 _noOfDays = (block.timestamp -\n            _communityProject.lastTimestamp) / 86400; // 24*60*60\n\n        /// Interest formula = (principal * APR * days) / (365 * 1000)\n        // prettier-ignore\n        uint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                _noOfDays /\n                365000;\n\n        // Old (already rTokens claimed) + new interest\n        uint256 _totalInterest = _unclaimedInterest +\n            _communityProject.interest;\n\n        return (\n            _lentAmount + _totalInterest,\n            _lentAmount,\n            _totalInterest,\n            _unclaimedInterest\n        );\n    }\n\n    /// @inheritdoc ICommunity\n    function isTrustedForwarder(address _forwarder)\n        public\n        view\n        override(ERC2771ContextUpgradeable, ICommunity)\n        returns (bool)\n    {\n        return homeFi.isTrustedForwarder(_forwarder);\n    }\n\n    /*******************************************************************************\n     * ---------------------------INTERNAL TRANSACTIONS--------------------------- *\n     *******************************************************************************/\n\n    /**\n     * @dev internal function for `unpublishProject`\n     * @param _project address - project address to unpublish\n     */\n    function _unpublishProject(address _project) internal {\n        // Locally store old community of published project\n        uint256 formerCommunityId = projectPublished[_project];\n\n        // Local instance of variable. For saving gas.\n        ProjectDetails storage _communityProject = _communities[\n            formerCommunityId\n        ].projectDetails[_project];\n\n        // Reduce lending needed to total lent. So no more investment can be made to this project.\n        _communityProject.lendingNeeded = _communityProject.totalLent;\n\n        // Mark project as unpublished.\n        delete projectPublished[_project];\n\n        // Set public fee paid to false.\n        // So if this project is published again to this community,\n        // then this fee will be required to be paid again.\n        _communityProject.publishFeePaid = false;\n\n        emit ProjectUnpublished(formerCommunityId, _project);\n    }\n\n    /**\n     * @dev Internal function for reducing debt\n\n     * @param _communityID uint256 - the the uuid of the community\n     * @param _project address - the address of the deployed project contract\n     * @param _repayAmount uint256 - the amount of funds repaid to the lender, in the project currency\n     * @param _details bytes - some details on why debt is reduced (off chain documents or images)\n     */\n    function _reduceDebt(\n        uint256 _communityID,\n        address _project,\n        uint256 _repayAmount,\n        bytes memory _details\n    ) internal virtual {\n        // Revert if repayment amount is zero.\n        require(_repayAmount > 0, \"Community::!repay\");\n\n        // Local instance of variables. For saving gas.\n        CommunityStruct storage _community = _communities[_communityID];\n        ProjectDetails storage _communityProject = _community.projectDetails[\n            _project\n        ];\n        address _lender = _community.owner;\n\n        // Find wrapped token for community currency\n        IDebtToken _wrappedToken = IDebtToken(\n            homeFi.wrappedToken(address(_community.currency))\n        );\n\n        // Claim interest on existing investments\n        claimInterest(_communityID, _project, _wrappedToken);\n\n        // Local instance of variables. For saving gas.\n        uint256 _lentAmount = _communityProject.lentAmount;\n        uint256 _interest = _communityProject.interest;\n\n        if (_repayAmount > _interest) {\n            // If repayment amount is greater than interest then\n            // set lent = lent + interest - repayment.\n            // And set interest = 0.\n            uint256 _lentAndInterest = _lentAmount + _interest;\n\n            // Revert if repayment amount is greater than sum of lent and interest.\n            require(_lentAndInterest >= _repayAmount, \"Community::!Liquid\");\n            _interest = 0;\n            _lentAmount = _lentAndInterest - _repayAmount;\n        } else {\n            // If repayment amount is lesser than interest, then set\n            // interest = interest - repayment\n            _interest -= _repayAmount;\n        }\n\n        // Update community  project details\n        _communityProject.lentAmount = _lentAmount;\n        _communityProject.interest = _interest;\n\n        // Burn _repayAmount amount wrapped token from lender\n        _wrappedToken.burn(_lender, _repayAmount);\n\n        emit DebtReduced(\n            _communityID,\n            _project,\n            _lender,\n            _repayAmount,\n            _details\n        );\n    }\n\n    /**\n     * @dev claim interest of lender\n\n     * @param _communityID uint256 - uuid of community the project is held in\n     * @param _project address - address of project where debt/ loan is held\n     * @param _wrappedToken address - debt token lender is claiming\n     */\n    function claimInterest(\n        uint256 _communityID,\n        address _project,\n        IDebtToken _wrappedToken\n    ) internal {\n        // Calculate new interest\n        (, , uint256 _interest, uint256 _interestEarned) = returnToLender(\n            _communityID,\n            _project\n        );\n\n        // Local instance of variables. For saving gas.\n        address _lender = _communities[_communityID].owner;\n        ProjectDetails storage _communityProject = _communities[_communityID]\n            .projectDetails[_project];\n\n        if (_interestEarned > 0) {\n            // If any new interest is to be claimed.\n\n            // Increase total interest with new interest to be claimed.\n            _communityProject.interest = _interest;\n\n            // Update lastTimestamp to current time.\n            _communityProject.lastTimestamp = block.timestamp;\n\n            // Burn _interestEarned amount wrapped token to lender\n            _wrappedToken.mint(_lender, _interestEarned);\n\n            emit ClaimedInterest(\n                _communityID,\n                _project,\n                _lender,\n                _interestEarned\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function for checking signature validity\n     * @dev checks if the signature is approved or recovered, if not it reverts.\n\n\n     * @param _address address - address checked for validity\n     * @param _hash bytes32 - hash for which the signature is recovered\n     * @param _signature bytes - signatures\n     * @param _signatureIndex uint256 - index at which the signature should be present\n     */\n    function checkSignatureValidity(\n        address _address,\n        bytes32 _hash,\n        bytes memory _signature,\n        uint256 _signatureIndex\n    ) internal virtual {\n        // Decode signer\n        address _recoveredSignature = SignatureDecoder.recoverKey(\n            _hash,\n            _signature,\n            _signatureIndex\n        );\n\n        // Revert if decoded signer does not match expected address\n        // Or if hash is not approved by the expected address.\n        require(\n            _recoveredSignature == _address || approvedHashes[_address][_hash],\n            \"Community::invalid signature\"\n        );\n\n        // Delete from approvedHash. So that signature cannot be reused.\n        delete approvedHashes[_address][_hash];\n    }\n\n    /*******************************************************************************\n     * ------------------------------INTERNAL VIEWS------------------------------- *\n     *******************************************************************************/\n    /// @dev This is same as ERC2771ContextUpgradeable._msgSender()\n    function _msgSender()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (address sender)\n    {\n        // We want to use the _msgSender() implementation of ERC2771ContextUpgradeable\n        return super._msgSender();\n    }\n\n    /// @dev This is same as ERC2771ContextUpgradeable._msgData()\n    function _msgData()\n        internal\n        view\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\n        returns (bytes calldata)\n    {\n        // We want to use the _msgData() implementation of ERC2771ContextUpgradeable\n        return super._msgData();\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-08-rigor-findings.json",
                "Location": "Community.sol#L509",
                "Type": "Reentrancy",
                "Description": "Builder can call Community.escrow again to reduce debt further using same signatures.",
                "Repair": "Add a new field into the ProjectDetails struct called escrowNonce and modify function escrow to check this nonce and update it after the debt has been reduced."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Caution. We assume all failed transfers cause reverts and ignore the returned bool.\ninterface IERC20 {\n    function transfer(address,uint) external returns (bool);\n    function transferFrom(address,address,uint) external returns (bool);\n    function balanceOf(address) external view returns (uint);\n}\n\ninterface IOracle {\n    function getPrice(address,uint) external returns (uint);\n    function viewPrice(address,uint) external view returns (uint);\n}\n\ninterface IEscrow {\n    function initialize(IERC20 _token, address beneficiary) external;\n    function onDeposit() external;\n    function pay(address recipient, uint amount) external;\n    function balance() external view returns (uint);\n}\n\ninterface IDolaBorrowingRights {\n    function onBorrow(address user, uint additionalDebt) external;\n    function onRepay(address user, uint repaidDebt) external;\n    function onForceReplenish(address user, uint amount) external;\n    function balanceOf(address user) external view returns (uint);\n    function deficitOf(address user) external view returns (uint);\n    function replenishmentPriceBps() external view returns (uint);\n}\n\ninterface IBorrowController {\n    function borrowAllowed(address msgSender, address borrower, uint amount) external returns (bool);\n}\n\ncontract Market {\n\n    address public gov;\n    address public lender;\n    address public pauseGuardian;\n    address public immutable escrowImplementation;\n    IDolaBorrowingRights public immutable dbr;\n    IBorrowController public borrowController;\n    IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n    IERC20 public immutable collateral;\n    IOracle public oracle;\n    uint public collateralFactorBps;\n    uint public replenishmentIncentiveBps;\n    uint public liquidationIncentiveBps;\n    uint public liquidationFeeBps;\n    uint public liquidationFactorBps = 5000; // 50% by default\n    bool immutable callOnDepositCallback;\n    bool public borrowPaused;\n    uint public totalDebt;\n    uint256 internal immutable INITIAL_CHAIN_ID;\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n    mapping (address => IEscrow) public escrows; // user => escrow\n    mapping (address => uint) public debts; // user => debt\n    mapping(address => uint256) public nonces; // user => nonce\n\n    constructor (\n        address _gov,\n        address _lender,\n        address _pauseGuardian,\n        address _escrowImplementation,\n        IDolaBorrowingRights _dbr,\n        IERC20 _collateral,\n        IOracle _oracle,\n        uint _collateralFactorBps,\n        uint _replenishmentIncentiveBps,\n        uint _liquidationIncentiveBps,\n        bool _callOnDepositCallback\n    ) {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n        require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n        gov = _gov;\n        lender = _lender;\n        pauseGuardian = _pauseGuardian;\n        escrowImplementation = _escrowImplementation;\n        dbr = _dbr;\n        collateral = _collateral;\n        oracle = _oracle;\n        collateralFactorBps = _collateralFactorBps;\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n        callOnDepositCallback = _callOnDepositCallback;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n    \n    modifier onlyGov {\n        require(msg.sender == gov, \"Only gov can call this function\");\n        _;\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(\"DBR MARKET\")),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n    @notice sets the oracle to a new oracle. Only callable by governance.\n    @param _oracle The new oracle conforming to the IOracle interface.\n    */\n    function setOracle(IOracle _oracle) public onlyGov { oracle = _oracle; }\n\n    /**\n    @notice sets the borrow controller to a new borrow controller. Only callable by governance.\n    @param _borrowController The new borrow controller conforming to the IBorrowController interface.\n    */\n    function setBorrowController(IBorrowController _borrowController) public onlyGov { borrowController = _borrowController; }\n\n    /**\n    @notice sets the address of governance. Only callable by governance.\n    @param _gov Address of the new governance.\n    */\n    function setGov(address _gov) public onlyGov { gov = _gov; }\n\n    /**\n    @notice sets the lender to a new lender. The lender is allowed to recall dola from the contract. Only callable by governance.\n    @param _lender Address of the new lender.\n    */\n    function setLender(address _lender) public onlyGov { lender = _lender; }\n\n    /**\n    @notice sets the pause guardian. The pause guardian can pause borrowing. Only callable by governance.\n    @param _pauseGuardian Address of the new pauseGuardian.\n    */\n    function setPauseGuardian(address _pauseGuardian) public onlyGov { pauseGuardian = _pauseGuardian; }\n    \n    /**\n    @notice sets the Collateral Factor requirement of the market as measured in basis points. 1 = 0.01%. Only callable by governance.\n    @dev Collateral factor mus be set below 100%\n    @param _collateralFactorBps The new collateral factor as measured in basis points. \n    */\n    function setCollateralFactorBps(uint _collateralFactorBps) public onlyGov {\n        require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n        collateralFactorBps = _collateralFactorBps;\n    }\n    \n    /**\n    @notice sets the Liquidation Factor of the market as denoted in basis points.\n     The liquidation Factor denotes the maximum amount of debt that can be liquidated in basis points.\n     At 5000, 50% of of a borrower's underwater debt can be liquidated. Only callable by governance.\n    @dev Must be set between 1 and 10000.\n    @param _liquidationFactorBps The new liquidation factor in basis points. 1 = 0.01%/\n    */\n    function setLiquidationFactorBps(uint _liquidationFactorBps) public onlyGov {\n        require(_liquidationFactorBps > 0 && _liquidationFactorBps <= 10000, \"Invalid liquidation factor\");\n        liquidationFactorBps = _liquidationFactorBps;\n    }\n\n    /**\n    @notice sets the Replenishment Incentive of the market as denoted in basis points.\n     The Replenishment Incentive is the percentage paid out to replenishers on a successful forceReplenish call, denoted in basis points.\n    @dev Must be set between 1 and 10000.\n    @param _replenishmentIncentiveBps The new replenishment incentive set in basis points. 1 = 0.01%\n    */\n    function setReplenismentIncentiveBps(uint _replenishmentIncentiveBps) public onlyGov {\n        require(_replenishmentIncentiveBps > 0 && _replenishmentIncentiveBps < 10000, \"Invalid replenishment incentive\");\n        replenishmentIncentiveBps = _replenishmentIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Incentive of the market as denoted in basis points.\n     The Liquidation Incentive is the percentage paid out to liquidators of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation fee.\n    @param _liquidationIncentiveBps The new liqudation incentive set in basis points. 1 = 0.01% \n    */\n    function setLiquidationIncentiveBps(uint _liquidationIncentiveBps) public onlyGov {\n        require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps + liquidationFeeBps < 10000, \"Invalid liquidation incentive\");\n        liquidationIncentiveBps = _liquidationIncentiveBps;\n    }\n\n    /**\n    @notice sets the Liquidation Fee of the market as denoted in basis points.\n     The Liquidation Fee is the percentage paid out to governance of a borrower's debt when successfully liquidated.\n    @dev Must be set between 0 and 10000 - liquidation factor.\n    @param _liquidationFeeBps The new liquidation fee set in basis points. 1 = 0.01%\n    */\n    function setLiquidationFeeBps(uint _liquidationFeeBps) public onlyGov {\n        require(_liquidationFeeBps > 0 && _liquidationFeeBps + liquidationIncentiveBps < 10000, \"Invalid liquidation fee\");\n        liquidationFeeBps = _liquidationFeeBps;\n    }\n\n    /**\n    @notice Recalls amount of DOLA to the lender.\n    @param amount The amount od DOLA to recall to the the lender.\n    */\n    function recall(uint amount) public {\n        require(msg.sender == lender, \"Only lender can recall\");\n        dola.transfer(msg.sender, amount);\n    }\n\n    /**\n    @notice Pauses or unpauses borrowing for the market. Only gov can unpause a market, while gov and pauseGuardian can pause it.\n    @param _value Boolean representing the state pause state of borrows. true = paused, false = unpaused.\n    */\n    function pauseBorrows(bool _value) public {\n        if(_value) {\n            require(msg.sender == pauseGuardian || msg.sender == gov, \"Only pause guardian or governance can pause\");\n        } else {\n            require(msg.sender == gov, \"Only governance can unpause\");\n        }\n        borrowPaused = _value;\n    }\n\n    /**\n    @notice Internal function for creating an escrow for users to deposit collateral in.\n    @dev Uses create2 and minimal proxies to create the escrow at a deterministic address\n    @param user The address of the user to create an escrow for.\n    */\n    function createEscrow(address user) internal returns (IEscrow instance) {\n        address implementation = escrowImplementation;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, user)\n        }\n        require(instance != IEscrow(address(0)), \"ERC1167: create2 failed\");\n        emit CreateEscrow(user, address(instance));\n    }\n\n    /**\n    @notice Internal function for getting the escrow of a user.\n    @dev If the escrow doesn't exist, an escrow contract is deployed.\n    @param user The address of the user owning the escrow.\n    */\n    function getEscrow(address user) internal returns (IEscrow) {\n        if(escrows[user] != IEscrow(address(0))) return escrows[user];\n        IEscrow escrow = createEscrow(user);\n        escrow.initialize(collateral, user);\n        escrows[user] = escrow;\n        return escrow;\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow\n    @dev Will deposit the amount into the escrow contract.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(uint amount) public {\n        deposit(msg.sender, amount);\n    }\n\n    /**\n    @notice Deposit and borrow in a single transaction.\n    @param amountDeposit Amount of collateral token to deposit into escrow.\n    @param amountBorrow Amount of DOLA to borrow.\n    */\n    function depositAndBorrow(uint amountDeposit, uint amountBorrow) public {\n        deposit(amountDeposit);\n        borrow(amountBorrow);\n    }\n\n    /**\n    @notice Deposit amount of collateral into escrow on behalf of msg.sender\n    @dev Will deposit the amount into the escrow contract.\n    @param user User to deposit on behalf of.\n    @param amount Amount of collateral token to deposit.\n    */\n    function deposit(address user, uint amount) public {\n        IEscrow escrow = getEscrow(user);\n        collateral.transferFrom(msg.sender, address(escrow), amount);\n        if(callOnDepositCallback) {\n            escrow.onDeposit();\n        }\n        emit Deposit(user, amount);\n    }\n\n    /**\n    @notice View function for predicting the deterministic escrow address of a user.\n    @dev Only use deposit() function for deposits and NOT the predicted escrow address unless you know what you're doing\n    @param user Address of the user owning the escrow.\n    */\n    function predictEscrow(address user) public view returns (IEscrow predicted) {\n        address implementation = escrowImplementation;\n        address deployer = address(this);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), user)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n    @notice View function for getting the dollar value of the user's collateral in escrow for the market.\n    @param user Address of the user.\n    */\n    function getCollateralValue(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.viewPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice Internal function for getting the dollar value of the user's collateral in escrow for the market.\n    @dev Updates the lowest price comparisons of the pessimistic oracle\n    @param user Address of the user.\n    */\n    function getCollateralValueInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        return collateralBalance * oracle.getPrice(address(collateral), collateralFactorBps) / 1 ether;\n    }\n\n    /**\n    @notice View function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit.\n    @param user Address of the user.\n    */\n    function getCreditLimit(address user) public view returns (uint) {\n        uint collateralValue = getCollateralValue(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n\n    /**\n    @notice Internal function for getting the credit limit of a user.\n    @dev To calculate the available credit, subtract user debt from credit limit. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getCreditLimitInternal(address user) internal returns (uint) {\n        uint collateralValue = getCollateralValueInternal(user);\n        return collateralValue * collateralFactorBps / 10000;\n    }\n    /**\n    @notice Internal function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater. Updates the pessimistic oracle.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimitInternal(address user) internal returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.getPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice View function for getting the withdrawal limit of a user.\n     The withdrawal limit is how much collateral a user can withdraw before their loan would be underwater.\n    @param user Address of the user.\n    */\n    function getWithdrawalLimit(address user) public view returns (uint) {\n        IEscrow escrow = predictEscrow(user);\n        uint collateralBalance = escrow.balance();\n        if(collateralBalance == 0) return 0;\n        uint debt = debts[user];\n        if(debt == 0) return collateralBalance;\n        if(collateralFactorBps == 0) return 0;\n        uint minimumCollateral = debt * 1 ether / oracle.viewPrice(address(collateral), collateralFactorBps) * 10000 / collateralFactorBps;\n        if(collateralBalance <= minimumCollateral) return 0;\n        return collateralBalance - minimumCollateral;\n    }\n\n    /**\n    @notice Internal function for borrowing DOLA against collateral.\n    @dev This internal function is shared between the borrow and borrowOnBehalf function\n    @param borrower The address of the borrower that debt will be accrued to.\n    @param to The address that will receive the borrowed DOLA\n    @param amount The amount of DOLA to be borrowed\n    */\n    function borrowInternal(address borrower, address to, uint amount) internal {\n        require(!borrowPaused, \"Borrowing is paused\");\n        if(borrowController != IBorrowController(address(0))) {\n            require(borrowController.borrowAllowed(msg.sender, borrower, amount), \"Denied by borrow controller\");\n        }\n        uint credit = getCreditLimitInternal(borrower);\n        debts[borrower] += amount;\n        require(credit >= debts[borrower], \"Exceeded credit limit\");\n        totalDebt += amount;\n        dbr.onBorrow(borrower, amount);\n        dola.transfer(to, amount);\n        emit Borrow(borrower, amount);\n    }\n\n    /**\n    @notice Function for borrowing DOLA.\n    @dev Will borrow to msg.sender\n    @param amount The amount of DOLA to be borrowed.\n    */\n    function borrow(uint amount) public {\n        borrowInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to borrow on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always borrow to the msg.sender.\n    @param from The address of the user being borrowed from\n    @param amount The amount to be borrowed\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function borrowOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            borrowInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Internal function for withdrawing from the escrow\n    @dev The internal function is shared by the withdraw function and withdrawOnBehalf function\n    @param from The address owning the escrow to withdraw from.\n    @param to The address receiving the tokens\n    @param amount The amount being withdrawn.\n    */\n    function withdrawInternal(address from, address to, uint amount) internal {\n        uint limit = getWithdrawalLimitInternal(from);\n        require(limit >= amount, \"Insufficient withdrawal limit\");\n        IEscrow escrow = getEscrow(from);\n        escrow.pay(to, amount);\n        emit Withdraw(from, to, amount);\n    }\n\n    /**\n    @notice Function for withdrawing to msg.sender.\n    @param amount Amount to withdraw.\n    */\n    function withdraw(uint amount) public {\n        withdrawInternal(msg.sender, msg.sender, amount);\n    }\n\n    /**\n    @notice Function for using a signed message to withdraw on behalf of an address owning an escrow with collateral.\n    @dev Signed messaged can be invalidated by incrementing the nonce. Will always withdraw to the msg.sender.\n    @param from The address of the user owning the escrow being withdrawn from\n    @param amount The amount to be withdrawn\n    @param deadline Timestamp after which the signed message will be invalid\n    @param v The v param of the ECDSA signature\n    @param r The r param of the ECDSA signature\n    @param s The s param of the ECDSA signature\n    */\n    function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                msg.sender,\n                                from,\n                                amount,\n                                nonces[from]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n            require(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\n            withdrawInternal(from, msg.sender, amount);\n        }\n    }\n\n    /**\n    @notice Function for incrementing the nonce of the msg.sender, making their latest signed message unusable.\n    */\n    function invalidateNonce() public {\n        nonces[msg.sender]++;\n    }\n    \n    /**\n    @notice Function for repaying debt on behalf of user. Debt must be repaid in DOLA.\n    @dev Querying debts[user] and using it for amount to be repaid will always result in full repayment, unless the user has a DBR deficit.\n     If the user has a DBR deficit, they risk initial debt being accrued by forced replenishments.\n    @param user Address of the user whose debt is being repaid\n    @param amount DOLA amount to be repaid\n    */\n    function repay(address user, uint amount) public {\n        uint debt = debts[user];\n        require(debt >= amount, \"Insufficient debt\");\n        debts[user] -= amount;\n        totalDebt -= amount;\n        dbr.onRepay(user, amount);\n        dola.transferFrom(msg.sender, address(this), amount);\n        emit Repay(user, msg.sender, amount);\n    }\n\n    /**\n    @notice Bundles repayment and withdrawal into a single function call.\n    @param repayAmount Amount of DOLA to be repaid\n    @param withdrawAmount Amount of underlying to be withdrawn from the escrow\n    */\n    function repayAndWithdraw(uint repayAmount, uint withdrawAmount) public {\n        repay(msg.sender, repayAmount);\n        withdraw(withdrawAmount);\n    }\n\n    /**\n    @notice Function for forcing a user to replenish their DBR deficit at a pre-determined price.\n     The replenishment will accrue additional DOLA debt.\n     On a successful call, the caller will be paid a replenishment incentive.\n    @dev The function will only top the user back up to 0, meaning that the user will have a DBR deficit again in the next block.\n    @param user The address of the user being forced to replenish DBR\n    @param amount The amount of DBR the user will be replenished.\n    */\n    function forceReplenish(address user, uint amount) public {\n        uint deficit = dbr.deficitOf(user);\n        require(deficit > 0, \"No DBR deficit\");\n        require(deficit >= amount, \"Amount > deficit\");\n        uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n        uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n        debts[user] += replenishmentCost;\n        uint collateralValue = getCollateralValueInternal(user);\n        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n        totalDebt += replenishmentCost;\n        dbr.onForceReplenish(user, amount);\n        dola.transfer(msg.sender, replenisherReward);\n        emit ForceReplenish(user, msg.sender, amount, replenishmentCost, replenisherReward);\n    }\n\n    /**\n    @notice View function for getting the amount of liquidateable debt a user holds.\n    @param user The address of the user.\n    */\n    function getLiquidatableDebt(address user) public view returns (uint) {\n        uint debt = debts[user];\n        if (debt == 0) return 0;\n        uint credit = getCreditLimit(user);\n        if(credit >= debt) return 0;\n        return debt * liquidationFactorBps / 10000;\n    }\n\n    /**\n    @notice Function for liquidating a user's under water debt. Debt is under water when the value of a user's debt is above their collateral factor.\n    @param user The user to be liquidated\n    @param repaidDebt Th amount of user user debt to liquidate.\n    */\n    function liquidate(address user, uint repaidDebt) public {\n        require(repaidDebt > 0, \"Must repay positive debt\");\n        uint debt = debts[user];\n        require(getCreditLimitInternal(user) < debt, \"User debt is healthy\");\n        require(repaidDebt <= debt * liquidationFactorBps / 10000, \"Exceeded liquidation factor\");\n        uint price = oracle.getPrice(address(collateral), collateralFactorBps);\n        uint liquidatorReward = repaidDebt * 1 ether / price;\n        liquidatorReward += liquidatorReward * liquidationIncentiveBps / 10000;\n        debts[user] -= repaidDebt;\n        totalDebt -= repaidDebt;\n        dbr.onRepay(user, repaidDebt);\n        dola.transferFrom(msg.sender, address(this), repaidDebt);\n        IEscrow escrow = predictEscrow(user);\n        escrow.pay(msg.sender, liquidatorReward);\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            }\n        }\n        emit Liquidate(user, msg.sender, repaidDebt, liquidatorReward);\n    }\n    \n    event Deposit(address indexed account, uint amount);\n    event Borrow(address indexed account, uint amount);\n    event Withdraw(address indexed account, address indexed to, uint amount);\n    event Repay(address indexed account, address indexed repayer, uint amount);\n    event ForceReplenish(address indexed account, address indexed replenisher, uint deficit, uint replenishmentCost, uint replenisherReward);\n    event Liquidate(address indexed account, address indexed liquidator, uint repaidDebt, uint liquidatorReward);\n    event CreateEscrow(address indexed user, address escrow);\n}\n\n\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"forge-std/Test.sol\";\nimport \"./FiRMTest.sol\";\nimport \"../BorrowController.sol\";\nimport \"../DBR.sol\";\nimport \"../Fed.sol\";\nimport {SimpleERC20Escrow} from \"../escrows/SimpleERC20Escrow.sol\";\nimport \"../Market.sol\";\nimport \"../Oracle.sol\";\n\nimport \"./mocks/ERC20.sol\";\nimport \"./mocks/WETH9.sol\";\nimport \"./mocks/BorrowContract.sol\";\nimport {EthFeed} from \"./mocks/EthFeed.sol\";\n\ncontract MarketTest is FiRMTest {\n    bytes onlyGovUnpause = \"Only governance can unpause\";\n    bytes onlyPauseGuardianOrGov = \"Only pause guardian or governance can pause\";\n\n    BorrowContract borrowContract;\n\n    function setUp() public {\n        initialize(replenishmentPriceBps, collateralFactorBps, replenishmentIncentiveBps, liquidationBonusBps, callOnDepositCallback);\n\n        vm.startPrank(chair);\n        fed.expansion(IMarket(address(market)), 1_000_000e18);\n        vm.stopPrank();\n\n        borrowContract = new BorrowContract(address(market), payable(address(WETH)));\n    }\n\n    function testDeposit() public {\n        gibWeth(user, wethTestAmount);\n        uint balanceUserBefore = WETH.balanceOf(user); \n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        assertEq(WETH.balanceOf(address(market.predictEscrow(user))), wethTestAmount, \"Escrow balance did not increase\");\n        assertEq(WETH.balanceOf(user), balanceUserBefore - wethTestAmount, \"User balance did not decrease\");\n    }\n\n    function testDeposit2() public {\n        gibWeth(user, wethTestAmount);\n        uint balanceUserBefore = WETH.balanceOf(user); \n\n        vm.startPrank(user);\n        WETH.approve(address(market), wethTestAmount);\n        market.deposit(user2, wethTestAmount);\n        assertEq(WETH.balanceOf(address(market.predictEscrow(user))), 0, \"User balance not 0\");\n        assertEq(WETH.balanceOf(address(market.predictEscrow(user2))), wethTestAmount, \"User2 escrow balance did not increase \");\n        assertEq(WETH.balanceOf(user), balanceUserBefore - wethTestAmount, \"User balance did not decrease\");\n        assertEq(WETH.balanceOf(user2), 0, \"User2 not 0\");\n    }\n\n    function testBorrow() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n        uint initialDolaBalance = DOLA.balanceOf(user);\n        deposit(wethTestAmount);\n\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        assertEq(DOLA.balanceOf(user), initialDolaBalance + borrowAmount, \"User balance did not increase by borrowAmount\");\n    }\n\n    function testDepositAndBorrow() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        uint initialDolaBalance = DOLA.balanceOf(user);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        uint balanceUserBefore = WETH.balanceOf(user); \n        WETH.approve(address(market), wethTestAmount);\n        market.depositAndBorrow(wethTestAmount, borrowAmount);\n\n        assertEq(DOLA.balanceOf(user), initialDolaBalance + borrowAmount, \"User balance did not increase by borrowAmount\");\n        assertEq(WETH.balanceOf(address(market.predictEscrow(user))), wethTestAmount, \"Escrow balance did not increase\");\n        assertEq(WETH.balanceOf(user), balanceUserBefore - wethTestAmount, \"User balance did not decrease\");\n    }\n\n    function testBorrowOnBehalf() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n        \n        vm.startPrank(userPk);\n        uint maxBorrowAmount = getMaxBorrowAmount(wethTestAmount);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                maxBorrowAmount,\n                                0,\n                                block.timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        vm.stopPrank();\n\n        assertEq(WETH.balanceOf(address(market.escrows(userPk))), wethTestAmount, \"failed to deposit WETH\");\n        assertEq(WETH.balanceOf(userPk), 0, \"failed to deposit WETH\");\n\n        vm.startPrank(user2);\n        market.borrowOnBehalf(userPk, maxBorrowAmount, block.timestamp, v, r, s);\n\n        assertEq(DOLA.balanceOf(userPk), 0, \"borrowed DOLA went to the wrong user\");\n        assertEq(DOLA.balanceOf(user2), maxBorrowAmount, \"failed to borrow DOLA\");\n    }\n\n    function testBorrowOnBehalf_Fails_When_InvalidateNonceCalledPrior() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n        \n        vm.startPrank(userPk);\n        uint maxBorrowAmount = getMaxBorrowAmount(wethTestAmount);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                maxBorrowAmount,\n                                0,\n                                block.timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        market.invalidateNonce();\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        vm.expectRevert(\"INVALID_SIGNER\");\n        market.borrowOnBehalf(userPk, maxBorrowAmount, block.timestamp, v, r, s);\n    }\n\n    function testBorrowOnBehalf_Fails_When_DeadlineHasPassed() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n\n        uint timestamp = block.timestamp;\n        \n        vm.startPrank(userPk);\n        uint maxBorrowAmount = getMaxBorrowAmount(wethTestAmount);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"BorrowOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                maxBorrowAmount,\n                                0,\n                                timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        market.invalidateNonce();\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        vm.warp(block.timestamp + 1);\n        vm.expectRevert(\"DEADLINE_EXPIRED\");\n        market.borrowOnBehalf(userPk, maxBorrowAmount, timestamp, v, r, s);\n    }\n\n    function testBorrow_Fails_When_BorrowingPaused() public {\n        vm.startPrank(gov);\n        market.pauseBorrows(true);\n        vm.stopPrank();\n\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        vm.expectRevert(\"Borrowing is paused\");\n        market.borrow(borrowAmount);\n    }\n\n    function testBorrow_Fails_When_DeniedByBorrowController() public {\n        vm.startPrank(gov);\n        market.setBorrowController(IBorrowController(address(borrowController)));\n        vm.stopPrank();\n\n        gibWeth(address(borrowContract), wethTestAmount);\n        gibDBR(address(borrowContract), wethTestAmount);\n        vm.startPrank(user);\n\n        borrowContract.deposit(wethTestAmount);\n\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        vm.expectRevert(\"Denied by borrow controller\");\n        borrowContract.borrow(borrowAmount);\n    }\n\n    function testBorrow_Fails_When_AmountGTCreditLimit() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n\n        uint borrowAmount = convertWethToDola(wethTestAmount);\n        vm.expectRevert(\"Exceeded credit limit\");\n        market.borrow(borrowAmount);\n    }\n\n    function testBorrow_Fails_When_NotEnoughDolaInMarket() public {\n        vm.startPrank(market.lender());\n        market.recall(DOLA.balanceOf(address(market)));\n        vm.stopPrank();\n\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        \n        deposit(wethTestAmount);\n\n        vm.expectRevert(\"SafeMath: subtraction underflow\");\n        market.borrow(1 ether);\n    }\n\n    function testLiquidate_NoLiquidationFee(uint depositAmount, uint liqAmount, uint16 borrowMulti_) public {\n        depositAmount = bound(depositAmount, 1e18, 100_000e18);\n        liqAmount = bound(liqAmount, 500e18, 200_000_000e18);\n        uint borrowMulti = bound(borrowMulti_, 0, 100);\n\n        uint maxBorrowAmount = convertWethToDola(depositAmount) * market.collateralFactorBps() / 10_000;\n        uint borrowAmount = maxBorrowAmount * borrowMulti / 100;\n\n        gibWeth(user, depositAmount);\n        gibDBR(user, depositAmount);\n\n        vm.startPrank(chair);\n        fed.expansion(IMarket(address(market)), convertWethToDola(depositAmount));\n        vm.stopPrank();\n\n        vm.startPrank(user);\n        deposit(depositAmount);\n        market.borrow(borrowAmount);\n        vm.stopPrank();\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 9 / 10);\n\n        vm.startPrank(user2);\n        gibDOLA(user2, liqAmount);\n        DOLA.approve(address(market), type(uint).max);\n\n        uint marketDolaBal = DOLA.balanceOf(address(market));\n        uint govDolaBal = DOLA.balanceOf(gov);\n        uint repayAmount = market.debts(user) * market.liquidationFactorBps() / 10_000;\n\n        if (market.debts(user) <= market.getCreditLimit(user)) {\n            vm.expectRevert(\"User debt is healthy\");\n            market.liquidate(user, liqAmount);\n        } else if (repayAmount < liqAmount) {\n            vm.expectRevert(\"Exceeded liquidation factor\");\n            market.liquidate(user, liqAmount);\n        } else {\n            //Successful liquidation\n            market.liquidate(user, liqAmount);\n\n            uint expectedReward = convertDolaToWeth(liqAmount);\n            expectedReward += expectedReward * market.liquidationIncentiveBps() / 10_000;\n            assertEq(expectedReward, WETH.balanceOf(user2), \"user2 didn't receive proper liquidation reward\");\n            assertEq(DOLA.balanceOf(address(market)), marketDolaBal + liqAmount, \"market didn't receive repaid DOLA\");\n            assertEq(DOLA.balanceOf(gov), govDolaBal, \"gov should not receive liquidation fee when it's set to 0\");\n        }\n    }\n\n    function testLiquidate_WithLiquidationFee(uint depositAmount, uint liqAmount, uint256 liquidationFeeBps, uint16 borrowMulti_) public {\n        depositAmount = bound(depositAmount, 1e18, 100_000e18);\n        liqAmount = bound(liqAmount, 500e18, 200_000_000e18);\n        uint borrowMulti = bound(borrowMulti_, 0, 100);\n\n        gibWeth(user, depositAmount);\n        gibDBR(user, depositAmount);\n\n        vm.startPrank(chair);\n        fed.expansion(IMarket(address(market)), convertWethToDola(depositAmount));\n        vm.stopPrank();\n\n        vm.startPrank(gov);\n        liquidationFeeBps = bound(liquidationFeeBps, 1, 10_000);\n        vm.assume(liquidationFeeBps > 0 && liquidationFeeBps + market.liquidationIncentiveBps() < 10000);\n        market.setLiquidationFeeBps(liquidationFeeBps);\n        vm.stopPrank();\n\n        vm.startPrank(user);\n        deposit(depositAmount);\n        uint maxBorrowAmount = convertWethToDola(depositAmount) * market.collateralFactorBps() / 10_000;\n        uint borrowAmount = maxBorrowAmount * borrowMulti / 100;\n        market.borrow(borrowAmount);\n        vm.stopPrank();\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 9 / 10);\n\n        vm.startPrank(user2);\n        gibDOLA(user2, liqAmount);\n        DOLA.approve(address(market), type(uint).max);\n\n        uint marketDolaBal = DOLA.balanceOf(address(market));\n        uint govWethBal = WETH.balanceOf(gov);\n        uint repayAmount = market.debts(user) * market.liquidationFactorBps() / 10_000;\n\n        if (market.debts(user) <= market.getCreditLimit(user)) {\n            vm.expectRevert(\"User debt is healthy\");\n            market.liquidate(user, liqAmount);\n        } else if (repayAmount < liqAmount) {\n            vm.expectRevert(\"Exceeded liquidation factor\");\n            market.liquidate(user, liqAmount);\n        } else {\n            //Successful liquidation\n            market.liquidate(user, liqAmount);\n\n            uint expectedReward = convertDolaToWeth(liqAmount);\n            expectedReward += expectedReward * market.liquidationIncentiveBps() / 10_000;\n            uint expectedLiquidationFee = convertDolaToWeth(liqAmount) * market.liquidationFeeBps() / 10_000;\n            assertEq(expectedReward, WETH.balanceOf(user2), \"user2 didn't receive proper liquidation reward\");\n            assertEq(DOLA.balanceOf(address(market)), marketDolaBal + liqAmount, \"market didn't receive repaid DOLA\");\n            assertEq(WETH.balanceOf(gov), govWethBal + expectedLiquidationFee, \"gov didn't receive proper liquidation fee\");\n        }\n    }\n\n    function testLiquidate_Fails_When_repaidDebtIs0() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.stopPrank();\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 9 / 10);\n\n        vm.startPrank(user2);\n        gibDOLA(user2, 5_000 ether);\n        DOLA.approve(address(market), type(uint).max);\n        vm.expectRevert(\"Must repay positive debt\");\n        market.liquidate(user, 0);\n    }\n\n    function testLiquidate_Fails_When_repaidDebtGtLiquidatableDebt() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.stopPrank();\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 9 / 10);\n\n        vm.startPrank(user2);\n        gibDOLA(user2, 5_000 ether);\n        DOLA.approve(address(market), type(uint).max);\n\n        uint liquidationAmount = (market.debts(user) * market.liquidationFactorBps() / 10_000) + 1;\n        vm.expectRevert(\"Exceeded liquidation factor\");\n        market.liquidate(user, liquidationAmount);\n    }\n\n    function testLiquidate_Fails_When_UserDebtIsHealthy() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        gibDOLA(user2, 5_000 ether);\n        DOLA.approve(address(market), type(uint).max);\n\n        uint liquidationAmount = market.debts(user);\n        vm.expectRevert(\"User debt is healthy\");\n        market.liquidate(user, liquidationAmount);\n    }\n\n    function testRepay_Successful_OwnBorrow_FullAmount() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n        \n        uint initialMarketBal = DOLA.balanceOf(address(market));\n        uint initialUserDebt = market.debts(user);\n        uint initialDolaBal = DOLA.balanceOf(user);\n\n        market.repay(user, market.debts(user));\n\n        assertEq(market.debts(user), 0, \"user's debt was not paid\");\n        assertEq(initialDolaBal - initialUserDebt, DOLA.balanceOf(user), \"DOLA was not subtracted from user\");\n        assertEq(initialMarketBal + initialUserDebt, DOLA.balanceOf(address(market)), \"Market DOLA balance did not increase\");\n    }\n\n    function testRepay_Successful_OtherUserBorrow_FullAmount() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.stopPrank();\n        vm.startPrank(user2);\n\n        uint initialUserDebt = market.debts(user);\n        uint initialDolaBal = initialUserDebt * 2;\n        gibDOLA(user2, initialDolaBal);\n\n        market.repay(user, market.debts(user));\n\n        assertEq(market.debts(user), 0, \"user's debt was not paid\");\n        assertEq(initialDolaBal - initialUserDebt, DOLA.balanceOf(user2), \"DOLA was not subtracted from user2\");\n    }\n\n    function testRepay_Fails_WhenAmountGtDebt() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        gibDOLA(user, 500e18);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.expectRevert(\"Insufficient debt\");\n        market.repay(user, borrowAmount + 1);\n    }\n\n    function testForceReplenish() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount / 14);\n        uint initialReplenisherDola = DOLA.balanceOf(replenisher);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n        uint initialUserDebt = market.debts(user);\n        uint initialMarketDola = DOLA.balanceOf(address(market));\n        vm.stopPrank();\n\n        vm.warp(block.timestamp + 5 days);\n        uint deficitBefore = dbr.deficitOf(user);\n        vm.startPrank(replenisher);\n\n        market.forceReplenish(user, deficitBefore);\n        assertGt(DOLA.balanceOf(replenisher), initialReplenisherDola, \"DOLA balance of replenisher did not increase\");\n        assertLt(DOLA.balanceOf(address(market)), initialMarketDola, \"DOLA balance of market did not decrease\");\n        assertEq(DOLA.balanceOf(replenisher) - initialReplenisherDola, initialMarketDola - DOLA.balanceOf(address(market)), \"DOLA balance of market did not decrease by amount paid to replenisher\");\n        assertEq(dbr.deficitOf(user), 0, \"Deficit of borrower was not fully replenished\");\n        assertEq(market.debts(user) - initialUserDebt, deficitBefore * replenishmentPriceBps / 10000, \"Debt of borrower did not increase by replenishment price\");\n    }\n\n    function testForceReplenish_Fails_When_UserHasNoDbrDeficit() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount * 100);\n\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n        uint deficit = dbr.deficitOf(user);\n\n        vm.stopPrank();\n        vm.startPrank(user2);\n\n        vm.expectRevert(\"No DBR deficit\");\n        market.forceReplenish(user, deficit);\n    }\n\n    function testForceReplenish_Fails_When_NotEnoughDolaInMarket() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount / 14);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.warp(block.timestamp + 5 days);\n        vm.stopPrank();\n        vm.startPrank(market.lender());\n        market.recall(DOLA.balanceOf(address(market)));\n        uint deficit = dbr.deficitOf(user);\n        vm.stopPrank();\n        vm.startPrank(replenisher);   \n        vm.expectRevert(\"SafeMath: subtraction underflow\");\n        market.forceReplenish(user, deficit);   \n    }\n\n    function testForceReplenish_Fails_When_DebtWouldExceedCollateralValue() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount / 14);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        vm.warp(block.timestamp + 10000 days);\n        uint deficit = dbr.deficitOf(user);\n        vm.stopPrank();\n\n        vm.startPrank(replenisher);   \n        vm.expectRevert(\"Exceeded collateral value\");\n        market.forceReplenish(user, deficit);   \n    }\n\n    function testGetWithdrawalLimit_Returns_CollateralBalance() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n\n        uint collateralBalance = market.escrows(user).balance();\n        assertEq(collateralBalance, wethTestAmount);\n        assertEq(market.getWithdrawalLimit(user), collateralBalance, \"Should return collateralBalance when user's escrow balance > 0 & debts = 0\");\n    }\n\n    function testGetWithdrawalLimit_Returns_CollateralBalanceAdjustedForDebts() public {\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        market.borrow(borrowAmount);\n        uint collateralBalance = market.escrows(user).balance();\n        uint collateralFactor = market.collateralFactorBps();\n        uint minimumCollateral = borrowAmount * 1 ether / oracle.viewPrice(address(WETH), collateralFactor) * 10000 / collateralFactor;\n        assertEq(market.getWithdrawalLimit(user), collateralBalance - minimumCollateral, \"Should return collateral balance adjusted for debt\");\n    }\n\n    function testGetWithdrawalLimit_Returns_0_WhenEscrowBalanceIs0() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n\n        uint collateralBalance = market.escrows(user).balance();\n        assertEq(collateralBalance, wethTestAmount);\n\n        market.withdraw(wethTestAmount);\n        assertEq(market.getWithdrawalLimit(user), 0, \"Should return 0 when user's escrow balance is 0\");\n    }\n\n    function testGetWithdrawalLimit_Returns_0_WhenCollateralValueLtDebts() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n\n        uint collateralBalance = market.escrows(user).balance();\n        assertEq(collateralBalance, wethTestAmount);\n        market.withdraw(wethTestAmount);\n\n        uint ethPrice = ethFeed.latestAnswer();\n        ethFeed.changeAnswer(ethPrice * 6 / 10);\n        assertEq(market.getWithdrawalLimit(user), 0, \"Should return 0 when user's collateral value is less than debts\");\n        ethFeed.changeAnswer(ethPrice);\n    }\n\n    function testGetWithdrawalLimit_Returns_0_WhenMarketCollateralFactoris0() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        market.borrow(1);\n        vm.stopPrank();\n\n        vm.startPrank(gov);\n        market.setCollateralFactorBps(0);\n        assertEq(market.getWithdrawalLimit(user), 0, \"Should return 0 when user has non-zero debt & collateralFactorBps = 0\");\n    }\n\n    function testGetLiquidatableDebt_Returns_0_WhenUserHasNoDebt() public {\n        assertEq(market.getLiquidatableDebt(user), 0, \"Should return 0 when user has no debt\");\n    }\n\n    function testGetLiquidatableDebt_Returns_0_WhenUserCreditEqualsDebt() public {\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        assertEq(market.getLiquidatableDebt(user), 0, \"Should return 0 when user credit = debt\");\n    }\n\n    function testGetLiquidatableDebt_Returns_LiquidatableDebt_WhenUserDebtGtCredit() public {\n        uint borrowAmount = getMaxBorrowAmount(wethTestAmount);\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n\n        vm.startPrank(user);\n        deposit(wethTestAmount);\n        market.borrow(borrowAmount);\n\n        ethFeed.changeAnswer(ethFeed.latestAnswer() * 5 / 10);\n\n        assertGt(market.getLiquidatableDebt(user), 0, \"Should return liquidatable debt when user debt > credit\");\n    }\n\n    function testPauseBorrows() public {\n        vm.startPrank(gov);\n\n        market.pauseBorrows(true);\n        assertEq(market.borrowPaused(), true, \"Market wasn't paused\");\n        market.pauseBorrows(false);\n        assertEq(market.borrowPaused(), false, \"Market wasn't unpaused\");\n\n        vm.stopPrank();\n        vm.startPrank(pauseGuardian);\n        market.pauseBorrows(true);\n        assertEq(market.borrowPaused(), true, \"Market wasn't paused\");\n        vm.expectRevert(onlyGovUnpause);\n        market.pauseBorrows(false);\n        vm.stopPrank();\n\n        vm.startPrank(user);\n        vm.expectRevert(onlyPauseGuardianOrGov);\n        market.pauseBorrows(true);\n\n        vm.expectRevert(onlyGovUnpause);\n        market.pauseBorrows(false);\n    }\n\n    function testWithdraw() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n\n        assertEq(WETH.balanceOf(address(market.escrows(user))), wethTestAmount, \"failed to deposit WETH\");\n        assertEq(WETH.balanceOf(user), 0, \"failed to deposit WETH\");\n\n        market.withdraw(wethTestAmount);\n\n        assertEq(WETH.balanceOf(address(market.escrows(user))), 0, \"failed to withdraw WETH\");\n        assertEq(WETH.balanceOf(user), wethTestAmount, \"failed to withdraw WETH\");\n    }\n\n    function testWithdraw_Fail_When_WithdrawingCollateralBelowCF() public {\n        gibWeth(user, wethTestAmount);\n        gibDBR(user, wethTestAmount);\n        vm.startPrank(user);\n\n        deposit(wethTestAmount);\n\n        assertEq(WETH.balanceOf(address(market.escrows(user))), wethTestAmount, \"failed to deposit WETH\");\n        assertEq(WETH.balanceOf(user), 0, \"failed to deposit WETH\");\n\n        market.borrow(1 ether);\n\n        vm.expectRevert(\"Insufficient withdrawal limit\");\n        market.withdraw(wethTestAmount);\n\n        assertEq(WETH.balanceOf(address(market.escrows(user))), wethTestAmount, \"successfully withdrew WETH\");\n        assertEq(WETH.balanceOf(user), 0, \"successfully withdrew WETH\");\n    }\n\n    function testWithdrawOnBehalf() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n        \n        vm.startPrank(userPk);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                wethTestAmount,\n                                0,\n                                block.timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        vm.stopPrank();\n\n        assertEq(WETH.balanceOf(address(market.escrows(userPk))), wethTestAmount, \"failed to deposit WETH\");\n        assertEq(WETH.balanceOf(userPk), 0, \"failed to deposit WETH\");\n\n        vm.startPrank(user2);\n        market.withdrawOnBehalf(userPk, wethTestAmount, block.timestamp, v, r, s);\n\n        assertEq(WETH.balanceOf(address(market.escrows(userPk))), 0, \"failed to withdraw WETH\");\n        assertEq(WETH.balanceOf(user2), wethTestAmount, \"failed to withdraw WETH\");\n    }\n\n    function testWithdrawOnBehalf_When_InvalidateNonceCalledPrior() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n        \n        vm.startPrank(userPk);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                wethTestAmount,\n                                0,\n                                block.timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        market.invalidateNonce();\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        vm.expectRevert(\"INVALID_SIGNER\");\n        market.withdrawOnBehalf(userPk, wethTestAmount, block.timestamp, v, r, s);\n    }\n\n    function testWithdrawOnBehalf_When_DeadlineHasPassed() public {\n        address userPk = vm.addr(1);\n        gibWeth(userPk, wethTestAmount);\n        gibDBR(userPk, wethTestAmount);\n\n        uint timestamp = block.timestamp;\n        \n        vm.startPrank(userPk);\n        bytes32 hash = keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        market.DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n                                ),\n                                user2,\n                                userPk,\n                                wethTestAmount,\n                                0,\n                                timestamp\n                            )\n                        )\n                    )\n                );\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        deposit(wethTestAmount);\n        market.invalidateNonce();\n        vm.stopPrank();\n\n        vm.startPrank(user2);\n        vm.warp(block.timestamp + 1);\n        vm.expectRevert(\"DEADLINE_EXPIRED\");\n        market.withdrawOnBehalf(userPk, wethTestAmount, timestamp, v, r, s);\n    }\n\n    //Access Control Tests\n\n    function test_accessControl_setOracle() public {\n        vm.startPrank(gov);\n        market.setOracle(IOracle(address(0)));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setOracle(IOracle(address(0)));\n    }\n\n    function test_accessControl_setBorrowController() public {\n        vm.startPrank(gov);\n        market.setBorrowController(IBorrowController(address(0)));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setBorrowController(IBorrowController(address(0)));\n    }\n\n    function test_accessControl_setGov() public {\n        vm.startPrank(gov);\n        market.setGov(address(0));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setGov(address(0));\n    }\n\n    function test_accessControl_setLender() public {\n        vm.startPrank(gov);\n        market.setLender(address(0));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setLender(address(0));\n    }\n\n    function test_accessControl_setPauseGuardian() public {\n        vm.startPrank(gov);\n        market.setPauseGuardian(address(0));\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setPauseGuardian(address(0));\n    }\n\n    function test_accessControl_setCollateralFactorBps() public {\n        vm.startPrank(gov);\n        market.setCollateralFactorBps(100);\n\n        vm.expectRevert(\"Invalid collateral factor\");\n        market.setCollateralFactorBps(10001);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setCollateralFactorBps(100);\n    }\n\n    function test_accessControl_setReplenismentIncentiveBps() public {\n        vm.startPrank(gov);\n        market.setReplenismentIncentiveBps(100);\n\n        vm.expectRevert(\"Invalid replenishment incentive\");\n        market.setReplenismentIncentiveBps(10001);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setReplenismentIncentiveBps(100);\n    }\n\n    function test_accessControl_setLiquidationIncentiveBps() public {\n        vm.startPrank(gov);\n        market.setLiquidationIncentiveBps(100);\n\n        vm.expectRevert(\"Invalid liquidation incentive\");\n        market.setLiquidationIncentiveBps(0);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setLiquidationIncentiveBps(100);\n    }\n\n    function test_accessControl_setLiquidationFactorBps() public {\n        vm.startPrank(gov);\n        market.setLiquidationFactorBps(100);\n\n        vm.expectRevert(\"Invalid liquidation factor\");\n        market.setLiquidationFactorBps(0);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setLiquidationFactorBps(100);\n    }\n\n    function test_accessControl_setLiquidationFeeBps() public {\n        vm.startPrank(gov);\n        market.setLiquidationFeeBps(100);\n\n        vm.expectRevert(\"Invalid liquidation fee\");\n        market.setLiquidationFeeBps(0);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyGov);\n        market.setLiquidationFeeBps(100);\n    }\n\n    function test_accessControl_recall() public {\n        vm.startPrank(address(fed));\n        market.recall(100e18);\n        vm.stopPrank();\n\n        vm.expectRevert(onlyLender);\n        market.recall(100e18);\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-10-inverse-findings.json",
                "Location": "withdrawInternal function in Market.sol",
                "Type": "Reentrancy",
                "Description": "ERC777 reentrancy when withdrawing can be used to withdraw all collateral",
                "Repair": "Mark the affected functions as nonReentrant"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { SyndicateRewardsProcessor } from \"./SyndicateRewardsProcessor.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { ITransferHookProcessor } from \"../interfaces/ITransferHookProcessor.sol\";\n\n/// @notice A giant pool that can provide liquidity to any liquid staking network's staking funds vault\ncontract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, SyndicateRewardsProcessor {\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(this), \"GiantETHLP\", \"gMevETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Stake ETH against multiple BLS keys within multiple LSDNs and specify the amount of ETH being supplied for each key\n    /// @dev Uses contract balance for funding and get Staking Funds Vault LP in exchange for ETH\n    /// @param _stakingFundsVault List of mev and fees vaults being interacted with\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeyOfKnots For every staking funds vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _amounts List of amounts of ETH being staked per BLS public key\n    function batchDepositETHForStaking(\n        address[] calldata _stakingFundsVault,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeyOfKnots,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVault.length;\n        require(numOfVaults > 0, \"Zero vaults\");\n        require(numOfVaults == _blsPublicKeyOfKnots.length, \"Inconsistent lengths\");\n        require(numOfVaults == _amounts.length, \"Inconsistent lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            // As ETH is being deployed to a staking funds vault, it is no longer idle\n            idleETH -= _ETHTransactionAmounts[i];\n\n            StakingFundsVault sfv = StakingFundsVault(payable(_stakingFundsVault[i]));\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(sfv.liquidStakingNetworkManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            sfv.batchDepositETHForStaking{ value: _ETHTransactionAmounts[i] }(\n                _blsPublicKeyOfKnots[i],\n                _amounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a giant LP to claim a % of the revenue received by the MEV and Fees Pool\n    function claimRewards(\n        address _recipient,\n        address[] calldata _stakingFundsVaults,\n        bytes[][] calldata _blsPublicKeysForKnots\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty array\");\n        require(numOfVaults == _blsPublicKeysForKnots.length, \"Inconsistent array lengths\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).claimRewards(\n                address(this),\n                _blsPublicKeysForKnots[i]\n            );\n        }\n\n        updateAccumulatedETHPerLP();\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            _recipient\n        );\n    }\n\n    /// @notice Preview total ETH accumulated by an address\n    function previewAccumulatedETH(\n        address _user,\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens\n    ) external view returns (uint256) {\n        require(_stakingFundsVaults.length == _lpTokens.length, \"Inconsistent array lengths\");\n\n        uint256 accumulated;\n        for (uint256 i; i < _stakingFundsVaults.length; ++i) {\n            accumulated = StakingFundsVault(payable(_stakingFundsVaults[i])).batchPreviewAccumulatedETH(\n                address(this),\n                _lpTokens[i]\n            );\n        }\n\n        return _previewAccumulatedETH(_user, address(lpTokenETH), lpTokenETH.balanceOf(_user), lpTokenETH.totalSupply(), accumulated);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _stakingFundsVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a Staking Funds vault can be brought back into the giant pool\n    /// @param _stakingFundsVaults List of staking funds vaults this contract will contact\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a staking funds vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _stakingFundsVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _stakingFundsVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            StakingFundsVault(payable(_stakingFundsVaults[i])).burnLPTokensForETH(_lpTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Distribute any new ETH received to LP holders\n    function updateAccumulatedETHPerLP() public {\n        _updateAccumulatedETHPerLP(lpTokenETH.totalSupply());\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function beforeTokenTransfer(address _from, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        updateAccumulatedETHPerLP();\n\n        // Make sure that `_from` gets total accrued before transfer as post transferred anything owed will be wiped\n        if (_from != address(0)) {\n            _distributeETHRewardsToUserForToken(\n                _from,\n                address(lpTokenETH),\n                lpTokenETH.balanceOf(_from),\n                _from\n            );\n        }\n\n        // Make sure that `_to` gets total accrued before transfer as post transferred anything owed will be wiped\n        _distributeETHRewardsToUserForToken(\n            _to,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(_to),\n            _to\n        );\n    }\n\n    /// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed\n    function afterTokenTransfer(address, address _to, uint256) external {\n        require(msg.sender == address(lpTokenETH), \"Caller is not giant LP\");\n        _setClaimedToMax(_to);\n    }\n\n    /// @notice Total rewards received by this contract from the syndicate excluding idle ETH from LP depositors\n    function totalRewardsReceived() public view override returns (uint256) {\n        return address(this).balance + totalClaimed - idleETH;\n    }\n\n    /// @dev On withdrawing LP in exchange for burning giant LP, claim rewards\n    function _onWithdraw(LPToken[] calldata _lpTokens) internal override {\n        // Use the transfer hook of LPToken to trigger the claiming accrued ETH\n        for (uint256 i; i < _lpTokens.length; ++i) {\n            _lpTokens[i].transfer(address(this), _lpTokens[i].balanceOf(address(this)));\n        }\n\n        _distributeETHRewardsToUserForToken(\n            msg.sender,\n            address(lpTokenETH),\n            lpTokenETH.balanceOf(msg.sender),\n            msg.sender\n        );\n    }\n\n    /// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accrued\n    function _onDepositETH() internal override {\n        _setClaimedToMax(msg.sender);\n    }\n\n    /// @dev Internal re-usable method for setting claimed to max for msg.sender\n    function _setClaimedToMax(address _user) internal {\n        // New ETH stakers are not entitled to ETH earned by\n        claimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-11-stakehouse-findings.json",
                "Location": "GiantMevAndFeesPool.withdrawETH()",
                "Type": "Reentrancy",
                "Description": "GiantMevAndFeesPool.withdrawETH() is vulnerable to reentrancy attack as GiantMevAndFeesPool.claimRewards() does not have the nonReentrant modifier. This allows the user to call any function in the fallback.",
                "Repair": "Add 'idleETH -= _amount' before sending ETH to the user"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { GiantLP } from \"./GiantLP.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { GiantPoolBase } from \"./GiantPoolBase.sol\";\nimport { LSDNFactory } from \"./LSDNFactory.sol\";\n\n/// @notice A giant pool that can provide protected deposit liquidity to any liquid staking network\ncontract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {\n\n    /// @notice Emitted when giant LP is burnt to receive dETH\n    event LPBurnedForDETH(address indexed savETHVaultLPToken, address indexed sender, uint256 amount);\n\n    constructor(LSDNFactory _factory) {\n        lpTokenETH = new GiantLP(address(this), address(0), \"GiantETHLP\", \"gETH\");\n        liquidStakingDerivativeFactory = _factory;\n    }\n\n    /// @notice Given the liquidity of the giant pool, stake ETH to receive protected deposits from many liquid staking networks (LSDNs)\n    /// @dev Take ETH from the contract balance in order to send money to the individual vaults\n    /// @param _savETHVaults List of savETH vaults that belong to individual liquid staking derivative networks\n    /// @param _ETHTransactionAmounts ETH being attached to each savETH vault in the list\n    /// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding\n    /// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in funding\n    function batchDepositETHForStaking(\n        address[] calldata _savETHVaults,\n        uint256[] calldata _ETHTransactionAmounts,\n        bytes[][] calldata _blsPublicKeys,\n        uint256[][] calldata _stakeAmounts\n    ) public {\n        uint256 numOfSavETHVaults = _savETHVaults.length;\n        require(numOfSavETHVaults > 0, \"Empty arrays\");\n        require(numOfSavETHVaults == _ETHTransactionAmounts.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _blsPublicKeys.length, \"Inconsistent array lengths\");\n        require(numOfSavETHVaults == _stakeAmounts.length, \"Inconsistent array lengths\");\n\n        // For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validator\n        for (uint256 i; i < numOfSavETHVaults; ++i) {\n            uint256 transactionAmount = _ETHTransactionAmounts[i];\n\n            // As ETH is being deployed to a savETH pool vault, it is no longer idle\n            idleETH -= transactionAmount;\n\n            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);\n            require(\n                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),\n                \"Invalid liquid staking manager\"\n            );\n\n            // Deposit ETH for staking of BLS key\n            savETHPool.batchDepositETHForStaking{ value: transactionAmount }(\n                _blsPublicKeys[i],\n                _stakeAmounts[i]\n            );\n        }\n    }\n\n    /// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults\n    /// @param _savETHVaults List of savETH vaults being interacted with\n    /// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH\n    /// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETH\n    function withdrawDETH(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n\n        // Firstly capture current dETH balance and see how much has been deposited after the loop\n        uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n\n            // Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the user\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                LPToken token = _lpTokens[i][j];\n                uint256 amount = _amounts[i][j];\n\n                // Check the user has enough giant LP to burn and that the pool has enough savETH vault LP\n                _assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);\n\n                require(vault.isDETHReadyForWithdrawal(address(token)), \"dETH is not ready for withdrawal\");\n\n                // Giant LP is burned 1:1 with LPs from sub-networks\n                require(lpTokenETH.balanceOf(msg.sender) >= amount, \"User does not own enough LP\");\n\n                // Burn giant LP from user before sending them dETH\n                lpTokenETH.burn(msg.sender, amount);\n\n                emit LPBurnedForDETH(address(token), msg.sender, amount);\n            }\n\n            // Ask\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n\n        // Calculate how much dETH has been received from burning\n        dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;\n\n        // Send giant LP holder dETH owed\n        getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);\n    }\n\n    /// @notice Any ETH supplied to a BLS key registered with a liquid staking network can be rotated to another key if it never gets staked\n    /// @param _savETHVaults List of savETH vaults this contract will contact\n    /// @param _oldLPTokens List of savETH vault LP tokens that the vault has\n    /// @param _oldLPTokens List of new savETH vault LP tokens that the vault wants to receive in exchange for moving ETH to a new KNOT\n    /// @param _amounts Amount of old being swapped for new per LP token\n    function batchRotateLPTokens(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _oldLPTokens,\n        LPToken[][] calldata _newLPTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfRotations = _savETHVaults.length;\n        require(numOfRotations > 0, \"Empty arrays\");\n        require(numOfRotations == _oldLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _newLPTokens.length, \"Inconsistent arrays\");\n        require(numOfRotations == _amounts.length, \"Inconsistent arrays\");\n        require(lpTokenETH.balanceOf(msg.sender) >= 0.5 ether, \"No common interest\");\n        for (uint256 i; i < numOfRotations; ++i) {\n            SavETHVault(_savETHVaults[i]).batchRotateLPTokens(_oldLPTokens[i], _newLPTokens[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Any ETH that has not been utilized by a savETH vault can be brought back into the giant pool\n    /// @param _savETHVaults List of savETH vaults where ETH is staked\n    /// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a savETH vault\n    /// @param _amounts Amounts of LP within the giant pool being burnt\n    function bringUnusedETHBackIntoGiantPool(\n        address[] calldata _savETHVaults,\n        LPToken[][] calldata _lpTokens,\n        uint256[][] calldata _amounts\n    ) external {\n        uint256 numOfVaults = _savETHVaults.length;\n        require(numOfVaults > 0, \"Empty arrays\");\n        require(numOfVaults == _lpTokens.length, \"Inconsistent arrays\");\n        require(numOfVaults == _amounts.length, \"Inconsistent arrays\");\n        for (uint256 i; i < numOfVaults; ++i) {\n            SavETHVault vault = SavETHVault(_savETHVaults[i]);\n            for (uint256 j; j < _lpTokens[i].length; ++j) {\n                require(\n                    vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,\n                    \"ETH is either staked or derivatives minted\"\n                );\n            }\n\n            vault.burnLPTokens(_lpTokens[i], _amounts[i]);\n        }\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-11-stakehouse-findings.json",
                "Location": "function withdrawDETH in GiantSavETHVaultPool",
                "Type": "Reentrancy",
                "Description": "Possible reentrancy and fund theft in withdrawDETH() of GiantSavETHVaultPool because there is no whitelist check for user provided Vaults and there is no reentrancy defense.",
                "Repair": "Check the provided addresses and have some reentrancy defense mechanism"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\nimport \"forge-std/console.sol\";\n\nimport { TestUtils } from \"../utils/TestUtils.sol\";\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { MockSlotRegistry } from \"../../contracts/testing/stakehouse/MockSlotRegistry.sol\";\nimport { MockSavETHRegistry } from \"../../contracts/testing/stakehouse/MockSavETHRegistry.sol\";\n\ncontract LiquidStakingManagerTests is TestUtils {\n\n    function setUp() public {\n        vm.startPrank(accountFive); // this will mean it gets dETH initial supply\n        factory = createMockLSDNFactory();\n        vm.stopPrank();\n\n        // Deploy 1 network and get default dependencies\n        manager = deployNewLiquidStakingNetwork(\n            factory,\n            admin,\n            true,\n            \"LSDN\"\n        );\n\n        savETHVault = getSavETHVaultFromManager(manager);\n        stakingFundsVault = getStakingFundsVaultFromManager(manager);\n\n        // make 'admin' the 'DAO'\n        vm.prank(address(factory));\n        manager.updateDAOAddress(admin);\n    }\n\n    // todo - test for multiple knots\n    function testDAOCanCoordinateRageQuitOfOnlyKnotInNetwork() public {\n        // Set up users and ETH\n        address nodeRunner = accountOne; vm.deal(nodeRunner, 4 ether);\n        address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);\n        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);\n\n        // Do everything from funding a validator within default LSDN to minting derivatives\n        depositStakeAndMintDerivativesForDefaultNetwork(\n            nodeRunner,\n            feesAndMevUser,\n            savETHUser,\n            blsPubKeyFour\n        );\n\n        // Send syndicate some EIP1559 rewards\n        uint256 eip1559Tips = 0.6743 ether;\n        sendEIP1559RewardsToSyndicateAtAddress(eip1559Tips, manager.syndicate());\n\n        // Claim dETH as savETH user\n        IERC20 dETHToken = savETHVault.dETHToken();\n        vm.startPrank(accountFive);\n        dETHToken.transfer(address(savETHVault.saveETHRegistry()), 24 ether * 2);\n        vm.stopPrank();\n\n        vm.startPrank(savETHUser);\n        savETHVault.burnLPTokensByBLS(getBytesArrayFromBytes(blsPubKeyFour), getUint256ArrayFromValues(24 ether));\n        vm.stopPrank();\n        assertEq(dETHToken.balanceOf(savETHUser), 24 ether);\n\n        // Check there are some rewards to claim by staking funds vault\n        assertEq(\n            manager.stakingFundsVault().previewAccumulatedETH(feesAndMevUser, stakingFundsVault.lpTokenForKnot(blsPubKeyFour)),\n            (eip1559Tips / 2) - 1\n        );\n\n        // now de-register knot from syndicate to send sETH back to smart wallet\n        IERC20 sETH = IERC20(MockSlotRegistry(factory.slot()).stakeHouseShareTokens(manager.stakehouse()));\n        uint256 sETHBalanceBefore = sETH.balanceOf(manager.smartWalletOfNodeRunner(nodeRunner));\n        vm.startPrank(admin);\n        manager.deRegisterKnotFromSyndicate(getBytesArrayFromBytes(blsPubKeyFour));\n        manager.restoreFreeFloatingSharesToSmartWalletForRageQuit(\n            manager.smartWalletOfNodeRunner(nodeRunner),\n            getBytesArrayFromBytes(blsPubKeyFour),\n            getUint256ArrayFromValues(12 ether)\n        );\n        vm.stopPrank();\n\n        assertEq(\n            sETH.balanceOf(manager.smartWalletOfNodeRunner(nodeRunner)) - sETHBalanceBefore,\n            12 ether\n        );\n\n        // As long as the smart wallet has free floating and collateralized SLOT + dETH isolated, then we assume rage quit will work at stakehouse level\n        // We execute an arbitrary transaction here to confirm `executeAsSmartWallet` is working as if rage quit took place\n        assertEq(savETHVault.saveETHRegistry().knotDETHBalanceInIndex(1, blsPubKeyFour), 24 ether);\n        savETHVault.saveETHRegistry().setBalInIndex(1, blsPubKeyFour, 1);\n        vm.startPrank(admin);\n        manager.executeAsSmartWallet(\n            nodeRunner,\n            address(savETHVault.saveETHRegistry()),\n            abi.encodeWithSelector(\n                MockSavETHRegistry.setBalInIndex.selector,\n                1,\n                blsPubKeyFour,\n                1\n            ),\n            0\n        );\n        vm.stopPrank();\n        assertEq(savETHVault.saveETHRegistry().knotDETHBalanceInIndex(1, blsPubKeyFour), 1);\n\n        vm.warp(block.timestamp + 3 hours);\n\n        // Now, as Staking funds vault LP holder you should be able to claim rewards accrued up to point of pulling the plug\n        vm.startPrank(feesAndMevUser);\n        stakingFundsVault.claimRewards(feesAndMevUser, getBytesArrayFromBytes(blsPubKeyFour));\n        vm.stopPrank();\n        assertEq(feesAndMevUser.balance, (eip1559Tips / 2) - 1);\n\n        // As collateralized SLOT holder for BLS pub key four, you should be able to claim rewards accrued up to point of pulling the plug\n        vm.startPrank(nodeRunner);\n        manager.claimRewardsAsNodeRunner(nodeRunner, getBytesArrayFromBytes(blsPubKeyFour));\n        vm.stopPrank();\n        assertEq(nodeRunner.balance, (eip1559Tips / 2));\n    }\n}\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { ITransactionRouter } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/ITransactionRouter.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\nimport { IStakeHouseRegistry } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IStakeHouseRegistry.sol\";\n\nimport { SavETHVaultDeployer } from \"./SavETHVaultDeployer.sol\";\nimport { StakingFundsVaultDeployer } from \"./StakingFundsVaultDeployer.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { SyndicateFactory } from \"../syndicate/SyndicateFactory.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { OptionalHouseGatekeeper } from \"./OptionalHouseGatekeeper.sol\";\nimport { OptionalGatekeeperFactory } from \"./OptionalGatekeeperFactory.sol\";\nimport { OwnableSmartWalletFactory } from \"../smart-wallet/OwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWalletFactory } from \"../smart-wallet/interfaces/IOwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWallet } from \"../smart-wallet/interfaces/IOwnableSmartWallet.sol\";\nimport { ISyndicateFactory } from \"../interfaces/ISyndicateFactory.sol\";\nimport { ILiquidStakingManager } from \"../interfaces/ILiquidStakingManager.sol\";\nimport { IBrandNFT } from \"../interfaces/IBrandNFT.sol\";\n\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n\n    /// @notice signalize change in status of whitelisting\n    event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n\n    /// @notice signalize updated whitelist status of node runner\n    event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n\n    /// @notice signalize creation of a new smart wallet\n    event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n\n    /// @notice signalize appointing of a representative for a smart wallet by the node runner\n    event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize wallet being credited with ETH\n    event WalletCredited(address indexed smartWallet, uint256 amount);\n\n    /// @notice signalize staking of a KNOT\n    event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n\n    /// @notice signalize creation of stakehouse\n    event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n\n    /// @notice signalize joining a stakehouse\n    event StakehouseJoined(bytes blsPubKey);\n\n    ///@notice signalize removal of representative from smart wallet\n    event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize dormant representative\n    event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n\n    /// @notice signalize refund of withdrawal of 4 ETH for a BLS public key by the node runner\n    event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n\n    /// @notice signalize that the network has updated its ticker before its house was created\n    event NetworkTickerUpdated(string newTicker);\n\n    /// @notice signalize that the node runner has claimed rewards from the syndicate\n    event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n\n    /// @notice signalize that the node runner of the smart wallet has been rotated\n    event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n\n    /// @notice signalize banning of a node runner\n    event NodeRunnerBanned(address indexed nodeRunner);\n\n    /// @notice signalize that the dao management address has been moved\n    event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n\n    /// @notice signalize that the dao commission from network revenue has been updated\n    event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n\n    /// @notice signalize that a new BLS public key for an LSD validator has been registered\n    event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n\n    /// @notice Address of brand NFT\n    address public brand;\n\n    /// @notice stakehouse created by the LSD network\n    address public override stakehouse;\n\n    /// @notice Fees and MEV EIP1559 distribution contract for the LSD network\n    address public syndicate;\n\n    /// @notice address of the DAO deploying the contract\n    address public dao;\n\n    /// @notice address of optional gatekeeper for admiting new knots to the house created by the network\n    OptionalHouseGatekeeper public gatekeeper;\n\n    /// @notice instance of the syndicate factory that deploys the syndicates\n    ISyndicateFactory public syndicateFactory;\n\n    /// @notice instance of the smart wallet factory that deploys the smart wallets for node runners\n    IOwnableSmartWalletFactory public smartWalletFactory;\n\n    /// @notice string name for the stakehouse 3-5 characters long\n    string public stakehouseTicker;\n\n    /// @notice DAO staking funds vault\n    StakingFundsVault public stakingFundsVault;\n\n    /// @notice SavETH vault\n    SavETHVault public savETHVault;\n\n    /// @notice whitelisting indicator. true for enables and false for disabled\n    bool public enableWhitelisting;\n\n    /// @notice mapping to store if a node runner is whitelisted\n    mapping(address => bool) public isNodeRunnerWhitelisted;\n\n    /// @notice EOA representative appointed for a smart wallet\n    mapping(address => address) public smartWalletRepresentative;\n\n    /// @notice Smart wallet used to deploy KNOT\n    mapping(bytes => address) public smartWalletOfKnot;\n\n    /// @notice Smart wallet issued to the Node runner. Node runner address <> Smart wallet address\n    mapping(address => address) public smartWalletOfNodeRunner;\n\n    /// @notice Node runner issued to Smart wallet. Smart wallet address <> Node runner address\n    mapping(address => address) public nodeRunnerOfSmartWallet;\n\n    /// @notice Track number of staked KNOTs of a smart wallet\n    mapping(address => uint256) public stakedKnotsOfSmartWallet;\n\n    /// @notice smart wallet <> dormant rep.\n    mapping(address => address) public smartWalletDormantRepresentative;\n\n    /// @notice Track BLS public keys that have been banned. \n    /// If banned, the BLS public key will be mapped to its respective smart wallet\n    mapping(bytes => address) public bannedBLSPublicKeys;\n\n    /// @notice Track node runner addresses that are banned.\n    /// Malicious node runners can be banned by the DAO\n    mapping(address => bool) public bannedNodeRunners;\n\n    /// @notice count of KNOTs interacted with LSD network\n    uint256 public numberOfKnots;\n\n    /// @notice Commission percentage to 5 decimal places\n    uint256 public daoCommissionPercentage;\n\n    /// @notice 100% to 5 decimal places\n    uint256 public MODULO = 100_00000;\n\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Must be DAO\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc ILiquidStakingManager\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external virtual override initializer {\n        _init(\n            _dao,\n            _syndicateFactory,\n            _smartWalletFactory,\n            _lpTokenFactory,\n            _brand,\n            _savETHVaultDeployer,\n            _stakingFundsVaultDeployer,\n            _optionalGatekeeperDeployer,\n            _optionalCommission,\n            _deployOptionalGatekeeper,\n            _stakehouseTicker\n        );\n    }\n\n    /// @notice Enable operations proxied through DAO contract to another contract\n    /// @param _nodeRunner Address of the node runner that created the wallet\n    /// @param _to Address of the target contract\n    /// @param _data Encoded data of the function call\n    /// @param _value Total value attached to the transaction\n    function executeAsSmartWallet(\n        address _nodeRunner,\n        address _to,\n        bytes calldata _data,\n        uint256 _value\n    ) external payable onlyDAO {\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No wallet found\");\n        IOwnableSmartWallet(smartWallet).execute(\n            _to,\n            _data,\n            _value\n        );\n    }\n\n    /// @notice For knots no longer operational, DAO can de register the knot from the syndicate\n    function deRegisterKnotFromSyndicate(bytes[] calldata _blsPublicKeys) external onlyDAO {\n        Syndicate(payable(syndicate)).deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice In preparation of a rage quit, restore sETH to a smart wallet which are recoverable with the execution methods in the event this step does not go to plan\n    /// @param _smartWallet Address of the smart wallet that will undertake the rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function restoreFreeFloatingSharesToSmartWalletForRageQuit(\n        address _smartWallet,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyDAO {\n        stakingFundsVault.unstakeSyndicateSharesForRageQuit(\n            _smartWallet,\n            _blsPublicKeys,\n            _amounts\n        );\n    }\n\n    /// @notice Allow DAO to migrate to a new address\n    function updateDAOAddress(address _newAddress) external onlyDAO {\n        require(_newAddress != address(0), \"Zero address\");\n        require(_newAddress != dao, \"Same address\");\n\n        emit UpdateDAOAddress(dao, _newAddress);\n\n        dao = _newAddress;\n    }\n\n    /// @notice Allow DAO to take a commission of network revenue\n    function updateDAORevenueCommission(uint256 _commissionPercentage) external onlyDAO {\n        require(_commissionPercentage != daoCommissionPercentage, \"Same commission percentage\");\n        _updateDAORevenueCommission(_commissionPercentage);\n    }\n\n    /// @notice Allow the DAO to rotate the network ticker before the network house is created\n    function updateTicker(string calldata _newTicker) external onlyDAO {\n        require(bytes(_newTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_newTicker).length <= 5, \"String must be 3-5 characters long\");\n        require(numberOfKnots == 0, \"Cannot change ticker once house is created\");\n\n        stakehouseTicker = _newTicker;\n\n        emit NetworkTickerUpdated(_newTicker);\n    }\n\n    /// @notice function to change whether node runner whitelisting of node runners is required by the DAO\n    /// @param _changeWhitelist boolean value. true to enable and false to disable\n    function updateWhitelisting(bool _changeWhitelist) external onlyDAO returns (bool) {\n        require(_changeWhitelist != enableWhitelisting, \"Unnecessary update to same status\");\n        enableWhitelisting = _changeWhitelist;\n        emit WhitelistingStatusChanged(msg.sender, enableWhitelisting);\n\n        return enableWhitelisting;\n    }\n\n    /// @notice function to enable/disable whitelisting of a noderunner\n    /// @param _nodeRunner address of the node runner\n    /// @param isWhitelisted true if the node runner should be whitelisted. false otherwise.\n    function updateNodeRunnerWhitelistStatus(address _nodeRunner, bool isWhitelisted) external onlyDAO {\n        require(_nodeRunner != address(0), \"Zero address\");\n        require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], \"Unnecessary update to same status\");\n\n        isNodeRunnerWhitelisted[_nodeRunner] = isWhitelisted;\n        emit NodeRunnerWhitelistingStatusChanged(_nodeRunner, isWhitelisted);\n    }\n\n    /// @notice Allow a node runner to rotate the EOA representative they use for their smart wallet\n    /// @dev if any KNOT is staked for a smart wallet, no rep can be appointed or updated until the derivatives are minted\n    /// @param _newRepresentative address of the new representative to be appointed\n    function rotateEOARepresentative(address _newRepresentative) external {\n        require(_newRepresentative != address(0), \"Zero address\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow DAO to rotate representative in the case that node runner is not available (to facilitate staking)\n    /// @param _nodeRunner address of the node runner\n    /// @param _newRepresentative address of the new representative to be appointed for the node runner\n    function rotateEOARepresentativeOfNodeRunner(address _nodeRunner, address _newRepresentative) external onlyDAO {\n        require(_newRepresentative != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.\n    /// @dev A banned node runner cannot withdraw ETH for the KNOT. \n    /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n\n    /// @notice In the event the node runner coordinates with the DAO to sell their wallet, allow rotation\n    /// @dev EOA representative rotation done outside this method because there may be knots currently staked etc.\n    /// @param _current address of the present node runner of the smart wallet\n    /// @param _new address of the new node runner of the smart wallet\n    function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {\n        require(_new != address(0) && _current != _new, \"New is zero or current\");\n\n        address wallet = smartWalletOfNodeRunner[_current];\n        require(wallet != address(0), \"Wallet does not exist\");\n        require(_current == msg.sender || dao == msg.sender, \"Not current owner or DAO\");\n\n        address newRunnerCurrentWallet = smartWalletOfNodeRunner[_new];\n        require(newRunnerCurrentWallet == address(0), \"New runner has a wallet\");\n\n        smartWalletOfNodeRunner[_new] = wallet;\n        nodeRunnerOfSmartWallet[wallet] = _new;\n\n        delete smartWalletOfNodeRunner[_current];\n\n        if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {\n            bannedNodeRunners[_current] = true;\n            emit NodeRunnerBanned(_current);\n        }\n\n        emit NodeRunnerOfSmartWalletRotated(wallet, _current, _new);\n    }\n\n    /// @notice function to allow a node runner to claim ETH from the syndicate from their smart wallet\n    /// @param _recipient End recipient of ETH from syndicate rewards\n    /// @param _blsPubKeys list of BLS public keys to claim reward for\n    function claimRewardsAsNodeRunner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        require(_blsPubKeys.length > 0, \"No BLS keys specified\");\n        require(_recipient != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"Unknown node runner\");\n\n        for(uint256 i; i < _blsPubKeys.length; ++i) {\n            require(isBLSPublicKeyBanned(_blsPubKeys[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the node runner doesn't claim rewards for KNOTs from other smart wallets\n            require(smartWalletOfKnot[_blsPubKeys[i]] == smartWallet, \"BLS public key doesn't belong to the node runner\");\n        }\n\n        // Fetch ETH accrued\n        uint256 balBefore = address(this).balance;\n        IOwnableSmartWallet(smartWallet).execute(\n            syndicate,\n            abi.encodeWithSelector(\n                Syndicate.claimAsCollateralizedSLOTOwner.selector,\n                address(this),\n                _blsPubKeys\n            )\n        );\n\n        (uint256 nodeRunnerAmount, uint256 daoAmount) = _calculateCommission(address(this).balance - balBefore);\n        (bool transferResult, ) = _recipient.call{value: nodeRunnerAmount}(\"\");\n        require(transferResult, \"Failed to transfer\");\n\n        if (daoAmount > 0) {\n            (transferResult, ) = dao.call{value: daoAmount}(\"\");\n            require(transferResult, \"Failed to transfer\");\n        }\n\n        emit NodeRunnerRewardsClaimed(msg.sender, _recipient);\n    }\n\n    /// @notice register a node runner to LSD by creating a new smart wallet\n    /// @param _blsPublicKeys list of BLS public keys\n    /// @param _blsSignatures list of BLS signatures\n    /// @param _eoaRepresentative EOA representative of wallet\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable nonReentrant {\n        uint256 len = _blsPublicKeys.length;\n        require(len >= 1, \"No value provided\");\n        require(len == _blsSignatures.length, \"Unequal number of array values\");\n        require(msg.value == len * 4 ether, \"Insufficient ether provided\");\n        require(!Address.isContract(_eoaRepresentative), \"Only EOA representative permitted\");\n        require(_isNodeRunnerValid(msg.sender) == true, \"Unrecognised node runner\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n\n        if(smartWallet == address(0)) {\n            // create new wallet owned by liquid staking manager\n            smartWallet = smartWalletFactory.createWallet(address(this));\n            emit SmartWalletCreated(smartWallet, msg.sender);\n\n            // associate node runner with the newly created wallet\n            smartWalletOfNodeRunner[msg.sender] = smartWallet;\n            nodeRunnerOfSmartWallet[smartWallet] = msg.sender;\n\n            _authorizeRepresentative(smartWallet, _eoaRepresentative, true);\n        }\n\n        // Ensure that the node runner does not whitelist multiple EOA representatives - they can only have 1 active at a time\n        if(smartWalletRepresentative[smartWallet] != address(0)) {\n            require(smartWalletRepresentative[smartWallet] == _eoaRepresentative, \"Different EOA specified - rotate outside\");\n        }\n\n        {\n            // transfer ETH to smart wallet\n            (bool result,) = smartWallet.call{value: msg.value}(\"\");\n            require(result, \"Transfer failed\");\n            emit WalletCredited(smartWallet, msg.value);\n        }\n\n        for(uint256 i; i < len; ++i) {\n            bytes calldata _blsPublicKey = _blsPublicKeys[i];\n\n            // check if the BLS public key is part of LSD network and is not banned\n            require(isBLSPublicKeyPartOfLSDNetwork(_blsPublicKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKey) == IDataStructures.LifecycleStatus.UNBEGUN,\n                \"Lifecycle status must be zero\"\n            );\n\n            // register validtor initals for each of the KNOTs\n            IOwnableSmartWallet(smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.registerValidatorInitials.selector,\n                    smartWallet,\n                    _blsPublicKey,\n                    _blsSignatures[i]\n                )\n            );\n\n            // register the smart wallet with the BLS public key\n            smartWalletOfKnot[_blsPublicKey] = smartWallet;\n\n            emit NewLSDValidatorRegistered(msg.sender, _blsPublicKey);\n        }\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return smartWalletOfKnot[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return !isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot) || bannedBLSPublicKeys[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @notice function to check if a node runner address is banned\n    /// @param _nodeRunner address of the node runner\n    /// @return true if the node runner is banned, false otherwise\n    function isNodeRunnerBanned(address _nodeRunner) public view returns (bool) {\n        return bannedNodeRunners[_nodeRunner];\n    }\n\n    /// @notice function to check if a KNOT is deregistered\n    /// @param _blsPublicKey BLS public key of the KNOT\n    /// @return true if the KNOT is deregistered, false otherwise\n    function isKnotDeregistered(bytes calldata _blsPublicKey) public view returns (bool) {\n        return Syndicate(payable(syndicate)).isNoLongerPartOfSyndicate(_blsPublicKey);\n    }\n\n    /// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication\n    /// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network)\n    /// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain\n    /// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup\n    /// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature\n    /// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contract\n    function stake(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        bytes[] calldata _ciphertexts,\n        bytes[] calldata _aesEncryptorKeys,\n        IDataStructures.EIP712Signature[] calldata _encryptionSignatures,\n        bytes32[] calldata _dataRoots\n    ) external {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"No data\");\n        require(numOfValidators == _ciphertexts.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _aesEncryptorKeys.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _encryptionSignatures.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _dataRoots.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfValidators; ++i) {\n            bytes calldata blsPubKey = _blsPublicKeyOfKnots[i];\n            // check if BLS public key is registered with liquid staking derivative network and not banned\n            require(isBLSPublicKeyBanned(blsPubKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n            require(associatedSmartWallet != address(0), \"Unknown BLS public key\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Initials not registered\"\n            );\n\n            // check minimum balance of smart wallet, dao staking fund vault and savETH vault\n            _assertEtherIsReadyForValidatorStaking(blsPubKey);\n\n            _stake(\n                _blsPublicKeyOfKnots[i],\n                _ciphertexts[i],\n                _aesEncryptorKeys[i],\n                _encryptionSignatures[i],\n                _dataRoots[i]\n            );\n\n            address representative = smartWalletRepresentative[associatedSmartWallet];\n\n            if(representative != address(0)) {\n                // unauthorize the EOA representative on the Stakehouse\n                _authorizeRepresentative(associatedSmartWallet, representative, false);\n                // make the representative dormant before unauthorizing it\n                smartWalletDormantRepresentative[associatedSmartWallet] = representative;\n                emit DormantRepresentative(associatedSmartWallet, representative);\n            }\n        }\n    }\n\n    /// @notice Anyone can call this to trigger creating a knot which will mint derivatives once the balance has been reported\n    /// @param _blsPublicKeyOfKnots List of BLS public keys registered with the network becoming knots and minting derivatives\n    /// @param _beaconChainBalanceReports List of beacon chain balance reports\n    /// @param _reportSignatures List of attestations for the beacon chain balance reports\n    function mintDerivatives(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,\n        IDataStructures.EIP712Signature[] calldata _reportSignatures\n    ) external {\n        uint256 numOfKnotsToProcess = _blsPublicKeyOfKnots.length;\n        require(numOfKnotsToProcess > 0, \"Empty array\");\n        require(numOfKnotsToProcess == _beaconChainBalanceReports.length, \"Inconsistent array lengths\");\n        require(numOfKnotsToProcess == _reportSignatures.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfKnotsToProcess; ++i) {\n            // check if BLS public key is registered and not banned\n            require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the BLS pub key has deposited lifecycle\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.DEPOSIT_COMPLETED,\n                \"Lifecycle status must be two\"\n            );\n\n            // The first knot will create the Stakehouse\n            if(numberOfKnots == 0) {\n                _createLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n            else {\n                // join stakehouse\n                _joinLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n\n            address smartWallet = smartWalletOfKnot[_blsPublicKeyOfKnots[i]];\n            stakedKnotsOfSmartWallet[smartWallet] -= 1;\n\n            if(stakedKnotsOfSmartWallet[smartWallet] == 0) {\n                _authorizeRepresentative(smartWallet, smartWalletDormantRepresentative[smartWallet], true);\n\n                // delete the dormant representative as it is set active\n                delete smartWalletDormantRepresentative[smartWallet];\n            }\n\n            // Expand the staking funds vault shares that can claim rewards\n            stakingFundsVault.updateDerivativesMinted();\n        }\n    }\n\n    receive() external payable {}\n\n    /// @notice Every liquid staking derivative network has a single fee recipient determined by its syndicate contract\n    /// @dev The syndicate contract is only deployed after the first KNOT to mint derivatives creates the network Stakehouse\n    /// @dev Because the syndicate contract for the LSDN is deployed with CREATE2, we can predict the fee recipient ahead of time\n    /// @dev This is important because node runners need to configure their nodes before or immediately after staking\n    function getNetworkFeeRecipient() external view returns (address) {\n        // Always 1 knot initially registered to the syndicate because we expand it one by one\n        return syndicateFactory.calculateSyndicateDeploymentAddress(\n            address(this),\n            address(this),\n            1\n        );\n    }\n\n    /// @dev Internal method for managing the initialization of the staking manager contract\n    function _init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) internal {\n        require(_dao != address(0), \"Zero address\");\n        require(_syndicateFactory != address(0), \"Zero address\");\n        require(_smartWalletFactory != address(0), \"Zero address\");\n        require(_brand != address(0), \"Zero address\");\n        require(bytes(_stakehouseTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_stakehouseTicker).length <= 5, \"String must be 3-5 characters long\");\n\n        brand = _brand;\n        dao = _dao;\n        syndicateFactory = ISyndicateFactory(_syndicateFactory);\n        smartWalletFactory = IOwnableSmartWalletFactory(_smartWalletFactory);\n        stakehouseTicker = _stakehouseTicker;\n\n        _updateDAORevenueCommission(_optionalCommission);\n\n        _initStakingFundsVault(_stakingFundsVaultDeployer, _lpTokenFactory);\n        _initSavETHVault(_savETHVaultDeployer, _lpTokenFactory);\n\n        if (_deployOptionalGatekeeper) {\n            gatekeeper = OptionalGatekeeperFactory(_optionalGatekeeperDeployer).deploy(address(this));\n        }\n    }\n\n    /// @dev function checks if a node runner is valid depending upon whitelisting status\n    /// @param _nodeRunner address of the user requesting to become node runner\n    /// @return true if eligible. reverts with message if not eligible\n    function _isNodeRunnerValid(address _nodeRunner) internal view returns (bool) {\n        require(_nodeRunner != address(0), \"Zero address\");\n\n        if(enableWhitelisting) {\n            require(isNodeRunnerWhitelisted[_nodeRunner] == true, \"Invalid node runner\");\n        }\n\n        return true;\n    }\n\n    /// @dev Manage the removal and appointing of smart wallet representatives including managing state\n    function _authorizeRepresentative(\n        address _smartWallet, \n        address _eoaRepresentative, \n        bool _isEnabled\n    ) internal {\n        if(!_isEnabled && smartWalletRepresentative[_smartWallet] != address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // delete the mapping\n            delete smartWalletRepresentative[_smartWallet];\n\n            emit RepresentativeRemoved(_smartWallet, _eoaRepresentative);\n        }\n        else if(_isEnabled && smartWalletRepresentative[_smartWallet] == address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // store EOA to the wallet mapping\n            smartWalletRepresentative[_smartWallet] = _eoaRepresentative;\n\n            emit RepresentativeAppointed(_smartWallet, _eoaRepresentative);\n        } else {\n            revert(\"Unexpected state\");\n        }\n    }\n\n    /// @dev Internal method for doing just staking - pre-checks done outside this method to avoid stack too deep\n    function _stake(\n        bytes calldata _blsPublicKey,\n        bytes calldata _cipherText,\n        bytes calldata _aesEncryptorKey,\n        IDataStructures.EIP712Signature calldata _encryptionSignature,\n        bytes32 dataRoot\n    ) internal {\n        address smartWallet = smartWalletOfKnot[_blsPublicKey];\n\n        // send 24 ether from savETH vault to smart wallet\n        savETHVault.withdrawETHForStaking(smartWallet, 24 ether);\n\n        // send 4 ether from DAO staking funds vault\n        stakingFundsVault.withdrawETH(smartWallet, 4 ether);\n\n        // interact with transaction router using smart wallet to deposit 32 ETH\n        IOwnableSmartWallet(smartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.registerValidator.selector,\n                smartWallet,\n                _blsPublicKey,\n                _cipherText,\n                _aesEncryptorKey,\n                _encryptionSignature,\n                dataRoot\n            ),\n            32 ether\n        );\n\n        // increment number of staked KNOTs in the wallet\n        stakedKnotsOfSmartWallet[smartWallet] += 1;\n\n        emit KnotStaked(_blsPublicKey, msg.sender);\n    }\n\n    /// @dev The second knot onwards will join the LSDN stakehouse and expand the registered syndicate knots\n    function _joinLSDNStakehouse(\n        bytes calldata _blsPubKey,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // total number of knots created with the syndicate increases\n        numberOfKnots += 1;\n\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPubKey];\n\n        // Join the LSDN stakehouse\n        string memory lowerTicker = IBrandNFT(brand).toLowerCase(stakehouseTicker);\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.joinStakehouse.selector,\n                associatedSmartWallet,\n                _blsPubKey,\n                stakehouse,\n                IBrandNFT(brand).lowercaseBrandTickerToTokenId(lowerTicker),\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Register the knot to the syndicate\n        bytes[] memory _blsPublicKeyOfKnots = new bytes[](1);\n        _blsPublicKeyOfKnots[0] = _blsPubKey;\n        Syndicate(payable(syndicate)).registerKnotsToSyndicate(_blsPublicKeyOfKnots);\n\n        // Autostake DAO sETH with the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPubKey);\n\n        emit StakehouseJoined(_blsPubKey);\n    }\n\n    /// @dev Perform all the steps required to create the LSDN stakehouse that other knots will join\n    function _createLSDNStakehouse(\n        bytes calldata _blsPublicKeyOfKnot,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // create stakehouse and mint derivative for first bls key - the others are just used to create the syndicate\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.createStakehouse.selector,\n                associatedSmartWallet,\n                _blsPublicKeyOfKnot,\n                stakehouseTicker,\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Number of knots has increased\n        numberOfKnots += 1;\n\n        // Capture the address of the Stakehouse for future knots to join\n        stakehouse = getStakeHouseUniverse().memberKnotToStakeHouse(_blsPublicKeyOfKnot);\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        // Give liquid staking manager ability to manage keepers and set a house keeper if decided by the network\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            stakehouse,\n            abi.encodeWithSelector(\n                Ownable.transferOwnership.selector,\n                address(this)\n            )\n        );\n\n        if (address(gatekeeper) != address(0)) {\n            IStakeHouseRegistry(stakehouse).setGateKeeper(address(gatekeeper));\n        }\n\n        // Deploy the EIP1559 transaction reward sharing contract but no priority required because sETH will be auto staked\n        address[] memory priorityStakers = new address[](0);\n        bytes[] memory initialKnots = new bytes[](1);\n        initialKnots[0] = _blsPublicKeyOfKnot;\n        syndicate = syndicateFactory.deploySyndicate(\n            address(this),\n            0,\n            priorityStakers,\n            initialKnots\n        );\n\n        // Contract approves syndicate to take sETH on behalf of the DAO\n        sETH.approve(syndicate, (2 ** 256) - 1);\n\n        // Auto-stake sETH by pulling sETH out the smart wallet and staking in the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPublicKeyOfKnot);\n\n        emit StakehouseCreated(stakehouseTicker, stakehouse);\n    }\n\n    /// @dev Remove the sETH from the node runner smart wallet in order to auto-stake the sETH in the syndicate\n    function _autoStakeWithSyndicate(address _associatedSmartWallet, bytes memory _blsPubKey) internal {\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        uint256 stakeAmount = 12 ether;\n        IOwnableSmartWallet(_associatedSmartWallet).execute(\n            address(sETH),\n            abi.encodeWithSelector(\n                IERC20.transfer.selector,\n                address(this),\n                stakeAmount\n            )\n        );\n\n        // Create the payload for staking\n        bytes[] memory stakingKeys = new bytes[](1);\n        stakingKeys[0] = _blsPubKey;\n\n        uint256[] memory stakeAmounts = new uint256[](1);\n        stakeAmounts[0] = stakeAmount;\n\n        // Stake the sETH to be received by the LPs of the Staking Funds Vault (fees and mev)\n        Syndicate(payable(syndicate)).stake(stakingKeys, stakeAmounts, address(stakingFundsVault));\n    }\n\n    /// @dev Something that can be overriden during testing\n    function _initSavETHVault(address _savETHVaultDeployer, address _lpTokenFactory) internal virtual {\n        // Use an external deployer to reduce the size of the liquid staking manager\n        savETHVault = SavETHVault(\n            SavETHVaultDeployer(_savETHVaultDeployer).deploySavETHVault(address(this), _lpTokenFactory)\n        );\n    }\n\n    function _initStakingFundsVault(address _stakingFundsVaultDeployer, address _tokenFactory) internal virtual {\n        stakingFundsVault = StakingFundsVault(\n            payable(StakingFundsVaultDeployer(_stakingFundsVaultDeployer).deployStakingFundsVault(\n                address(this),\n                _tokenFactory\n            ))\n        );\n    }\n\n    /// @dev This can be overriden to customise fee percentages\n    function _calculateCommission(uint256 _received) internal virtual view returns (uint256 _nodeRunner, uint256 _dao) {\n        require(_received > 0, \"Nothing received\");\n\n        if (daoCommissionPercentage > 0) {\n            uint256 daoAmount = (_received * daoCommissionPercentage) / MODULO;\n            uint256 rest = _received - daoAmount;\n            return (rest, daoAmount);\n        }\n\n        return (_received, 0);\n    }\n\n    /// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved\n    function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {\n        address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n        require(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");\n\n        LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);\n        require(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");\n        require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n\n        LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);\n        require(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");\n        require(savETHVaultLP.totalSupply() == 24 ether, \"KNOT must have 24 ETH in savETH vault\");\n    }\n\n    /// @dev Internal method for dao to trigger updating commission it takes of node runner revenue\n    function _updateDAORevenueCommission(uint256 _commissionPercentage) internal {\n        require(_commissionPercentage <= MODULO, \"Invalid commission\");\n\n        emit DAOCommissionUpdated(daoCommissionPercentage, _commissionPercentage);\n\n        daoCommissionPercentage = _commissionPercentage;\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-11-stakehouse-findings.json",
                "Location": "withdrawETHForKnot function in LiquidStakingManager.sol",
                "Type": "Reentrancy",
                "Description": "The reentrancy bug in the withdrawETHForKnot function allows a node runner to reenter the LiquidStakingManager and stake deposited funds from the vaults before the BLS key is banned, causing a permanent freeze of user funds and making the protocol insolvent.",
                "Repair": "Use mutex locks to prevent reentrancy or use the Checks-Effects-Interactions pattern to ensure that all state changes are made before any external calls are made"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.13;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport { StakehouseAPI } from \"@blockswaplab/stakehouse-solidity-api/contracts/StakehouseAPI.sol\";\nimport { ITransactionRouter } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/ITransactionRouter.sol\";\nimport { IDataStructures } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol\";\nimport { IStakeHouseRegistry } from \"@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IStakeHouseRegistry.sol\";\n\nimport { SavETHVaultDeployer } from \"./SavETHVaultDeployer.sol\";\nimport { StakingFundsVaultDeployer } from \"./StakingFundsVaultDeployer.sol\";\nimport { StakingFundsVault } from \"./StakingFundsVault.sol\";\nimport { SavETHVault } from \"./SavETHVault.sol\";\nimport { LPToken } from \"./LPToken.sol\";\nimport { LPTokenFactory } from \"./LPTokenFactory.sol\";\nimport { SyndicateFactory } from \"../syndicate/SyndicateFactory.sol\";\nimport { Syndicate } from \"../syndicate/Syndicate.sol\";\nimport { OptionalHouseGatekeeper } from \"./OptionalHouseGatekeeper.sol\";\nimport { OptionalGatekeeperFactory } from \"./OptionalGatekeeperFactory.sol\";\nimport { OwnableSmartWalletFactory } from \"../smart-wallet/OwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWalletFactory } from \"../smart-wallet/interfaces/IOwnableSmartWalletFactory.sol\";\nimport { IOwnableSmartWallet } from \"../smart-wallet/interfaces/IOwnableSmartWallet.sol\";\nimport { ISyndicateFactory } from \"../interfaces/ISyndicateFactory.sol\";\nimport { ILiquidStakingManager } from \"../interfaces/ILiquidStakingManager.sol\";\nimport { IBrandNFT } from \"../interfaces/IBrandNFT.sol\";\n\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n\n    /// @notice signalize change in status of whitelisting\n    event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n\n    /// @notice signalize updated whitelist status of node runner\n    event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n\n    /// @notice signalize creation of a new smart wallet\n    event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n\n    /// @notice signalize appointing of a representative for a smart wallet by the node runner\n    event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize wallet being credited with ETH\n    event WalletCredited(address indexed smartWallet, uint256 amount);\n\n    /// @notice signalize staking of a KNOT\n    event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n\n    /// @notice signalize creation of stakehouse\n    event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n\n    /// @notice signalize joining a stakehouse\n    event StakehouseJoined(bytes blsPubKey);\n\n    ///@notice signalize removal of representative from smart wallet\n    event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n\n    /// @notice signalize dormant representative\n    event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n\n    /// @notice signalize refund of withdrawal of 4 ETH for a BLS public key by the node runner\n    event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n\n    /// @notice signalize that the network has updated its ticker before its house was created\n    event NetworkTickerUpdated(string newTicker);\n\n    /// @notice signalize that the node runner has claimed rewards from the syndicate\n    event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n\n    /// @notice signalize that the node runner of the smart wallet has been rotated\n    event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n\n    /// @notice signalize banning of a node runner\n    event NodeRunnerBanned(address indexed nodeRunner);\n\n    /// @notice signalize that the dao management address has been moved\n    event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n\n    /// @notice signalize that the dao commission from network revenue has been updated\n    event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n\n    /// @notice signalize that a new BLS public key for an LSD validator has been registered\n    event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n\n    /// @notice Address of brand NFT\n    address public brand;\n\n    /// @notice stakehouse created by the LSD network\n    address public override stakehouse;\n\n    /// @notice Fees and MEV EIP1559 distribution contract for the LSD network\n    address public syndicate;\n\n    /// @notice address of the DAO deploying the contract\n    address public dao;\n\n    /// @notice address of optional gatekeeper for admiting new knots to the house created by the network\n    OptionalHouseGatekeeper public gatekeeper;\n\n    /// @notice instance of the syndicate factory that deploys the syndicates\n    ISyndicateFactory public syndicateFactory;\n\n    /// @notice instance of the smart wallet factory that deploys the smart wallets for node runners\n    IOwnableSmartWalletFactory public smartWalletFactory;\n\n    /// @notice string name for the stakehouse 3-5 characters long\n    string public stakehouseTicker;\n\n    /// @notice DAO staking funds vault\n    StakingFundsVault public stakingFundsVault;\n\n    /// @notice SavETH vault\n    SavETHVault public savETHVault;\n\n    /// @notice whitelisting indicator. true for enables and false for disabled\n    bool public enableWhitelisting;\n\n    /// @notice mapping to store if a node runner is whitelisted\n    mapping(address => bool) public isNodeRunnerWhitelisted;\n\n    /// @notice EOA representative appointed for a smart wallet\n    mapping(address => address) public smartWalletRepresentative;\n\n    /// @notice Smart wallet used to deploy KNOT\n    mapping(bytes => address) public smartWalletOfKnot;\n\n    /// @notice Smart wallet issued to the Node runner. Node runner address <> Smart wallet address\n    mapping(address => address) public smartWalletOfNodeRunner;\n\n    /// @notice Node runner issued to Smart wallet. Smart wallet address <> Node runner address\n    mapping(address => address) public nodeRunnerOfSmartWallet;\n\n    /// @notice Track number of staked KNOTs of a smart wallet\n    mapping(address => uint256) public stakedKnotsOfSmartWallet;\n\n    /// @notice smart wallet <> dormant rep.\n    mapping(address => address) public smartWalletDormantRepresentative;\n\n    /// @notice Track BLS public keys that have been banned. \n    /// If banned, the BLS public key will be mapped to its respective smart wallet\n    mapping(bytes => address) public bannedBLSPublicKeys;\n\n    /// @notice Track node runner addresses that are banned.\n    /// Malicious node runners can be banned by the DAO\n    mapping(address => bool) public bannedNodeRunners;\n\n    /// @notice count of KNOTs interacted with LSD network\n    uint256 public numberOfKnots;\n\n    /// @notice Commission percentage to 5 decimal places\n    uint256 public daoCommissionPercentage;\n\n    /// @notice 100% to 5 decimal places\n    uint256 public MODULO = 100_00000;\n\n    modifier onlyDAO() {\n        require(msg.sender == dao, \"Must be DAO\");\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer {}\n\n    /// @inheritdoc ILiquidStakingManager\n    function init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) external virtual override initializer {\n        _init(\n            _dao,\n            _syndicateFactory,\n            _smartWalletFactory,\n            _lpTokenFactory,\n            _brand,\n            _savETHVaultDeployer,\n            _stakingFundsVaultDeployer,\n            _optionalGatekeeperDeployer,\n            _optionalCommission,\n            _deployOptionalGatekeeper,\n            _stakehouseTicker\n        );\n    }\n\n    /// @notice Enable operations proxied through DAO contract to another contract\n    /// @param _nodeRunner Address of the node runner that created the wallet\n    /// @param _to Address of the target contract\n    /// @param _data Encoded data of the function call\n    /// @param _value Total value attached to the transaction\n    function executeAsSmartWallet(\n        address _nodeRunner,\n        address _to,\n        bytes calldata _data,\n        uint256 _value\n    ) external payable onlyDAO {\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No wallet found\");\n        IOwnableSmartWallet(smartWallet).execute(\n            _to,\n            _data,\n            _value\n        );\n    }\n\n    /// @notice For knots no longer operational, DAO can de register the knot from the syndicate\n    function deRegisterKnotFromSyndicate(bytes[] calldata _blsPublicKeys) external onlyDAO {\n        Syndicate(payable(syndicate)).deRegisterKnots(_blsPublicKeys);\n    }\n\n    /// @notice In preparation of a rage quit, restore sETH to a smart wallet which are recoverable with the execution methods in the event this step does not go to plan\n    /// @param _smartWallet Address of the smart wallet that will undertake the rage quit\n    /// @param _blsPublicKeys List of BLS public keys being processed (assuming DAO only has BLS pub keys from correct smart wallet)\n    /// @param _amounts Amounts of free floating sETH that will be unstaked\n    function restoreFreeFloatingSharesToSmartWalletForRageQuit(\n        address _smartWallet,\n        bytes[] calldata _blsPublicKeys,\n        uint256[] calldata _amounts\n    ) external onlyDAO {\n        stakingFundsVault.unstakeSyndicateSharesForRageQuit(\n            _smartWallet,\n            _blsPublicKeys,\n            _amounts\n        );\n    }\n\n    /// @notice Allow DAO to migrate to a new address\n    function updateDAOAddress(address _newAddress) external onlyDAO {\n        require(_newAddress != address(0), \"Zero address\");\n        require(_newAddress != dao, \"Same address\");\n\n        emit UpdateDAOAddress(dao, _newAddress);\n\n        dao = _newAddress;\n    }\n\n    /// @notice Allow DAO to take a commission of network revenue\n    function updateDAORevenueCommission(uint256 _commissionPercentage) external onlyDAO {\n        require(_commissionPercentage != daoCommissionPercentage, \"Same commission percentage\");\n        _updateDAORevenueCommission(_commissionPercentage);\n    }\n\n    /// @notice Allow the DAO to rotate the network ticker before the network house is created\n    function updateTicker(string calldata _newTicker) external onlyDAO {\n        require(bytes(_newTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_newTicker).length <= 5, \"String must be 3-5 characters long\");\n        require(numberOfKnots == 0, \"Cannot change ticker once house is created\");\n\n        stakehouseTicker = _newTicker;\n\n        emit NetworkTickerUpdated(_newTicker);\n    }\n\n    /// @notice function to change whether node runner whitelisting of node runners is required by the DAO\n    /// @param _changeWhitelist boolean value. true to enable and false to disable\n    function updateWhitelisting(bool _changeWhitelist) external onlyDAO returns (bool) {\n        require(_changeWhitelist != enableWhitelisting, \"Unnecessary update to same status\");\n        enableWhitelisting = _changeWhitelist;\n        emit WhitelistingStatusChanged(msg.sender, enableWhitelisting);\n\n        return enableWhitelisting;\n    }\n\n    /// @notice function to enable/disable whitelisting of a noderunner\n    /// @param _nodeRunner address of the node runner\n    /// @param isWhitelisted true if the node runner should be whitelisted. false otherwise.\n    function updateNodeRunnerWhitelistStatus(address _nodeRunner, bool isWhitelisted) external onlyDAO {\n        require(_nodeRunner != address(0), \"Zero address\");\n        require(isNodeRunnerWhitelisted[_nodeRunner] != isNodeRunnerWhitelisted[_nodeRunner], \"Unnecessary update to same status\");\n\n        isNodeRunnerWhitelisted[_nodeRunner] = isWhitelisted;\n        emit NodeRunnerWhitelistingStatusChanged(_nodeRunner, isWhitelisted);\n    }\n\n    /// @notice Allow a node runner to rotate the EOA representative they use for their smart wallet\n    /// @dev if any KNOT is staked for a smart wallet, no rep can be appointed or updated until the derivatives are minted\n    /// @param _newRepresentative address of the new representative to be appointed\n    function rotateEOARepresentative(address _newRepresentative) external {\n        require(_newRepresentative != address(0), \"Zero address\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow DAO to rotate representative in the case that node runner is not available (to facilitate staking)\n    /// @param _nodeRunner address of the node runner\n    /// @param _newRepresentative address of the new representative to be appointed for the node runner\n    function rotateEOARepresentativeOfNodeRunner(address _nodeRunner, address _newRepresentative) external onlyDAO {\n        require(_newRepresentative != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[_nodeRunner];\n        require(smartWallet != address(0), \"No smart wallet\");\n        require(stakedKnotsOfSmartWallet[smartWallet] == 0, \"Not all KNOTs are minted\");\n        require(smartWalletRepresentative[smartWallet] != _newRepresentative, \"Invalid rotation to same EOA\");\n\n        // unauthorize old representative\n        _authorizeRepresentative(smartWallet, smartWalletRepresentative[smartWallet], false);\n\n        // authorize new representative\n        _authorizeRepresentative(smartWallet, _newRepresentative, true);\n    }\n\n    /// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked.\n    /// @dev A banned node runner cannot withdraw ETH for the KNOT. \n    /// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawn\n    function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n        require(_recipient != address(0), \"Zero address\");\n        require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n        require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n        require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n        require(\n            getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n            \"Initials not registered\"\n        );\n\n        // refund 4 ether from smart wallet to node runner's EOA\n        IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n            _recipient,\n            \"\",\n            4 ether\n        );\n\n        // update the mapping\n        bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n        emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n    }\n\n    /// @notice In the event the node runner coordinates with the DAO to sell their wallet, allow rotation\n    /// @dev EOA representative rotation done outside this method because there may be knots currently staked etc.\n    /// @param _current address of the present node runner of the smart wallet\n    /// @param _new address of the new node runner of the smart wallet\n    function rotateNodeRunnerOfSmartWallet(address _current, address _new, bool _wasPreviousNodeRunnerMalicious) external {\n        require(_new != address(0) && _current != _new, \"New is zero or current\");\n\n        address wallet = smartWalletOfNodeRunner[_current];\n        require(wallet != address(0), \"Wallet does not exist\");\n        require(_current == msg.sender || dao == msg.sender, \"Not current owner or DAO\");\n\n        address newRunnerCurrentWallet = smartWalletOfNodeRunner[_new];\n        require(newRunnerCurrentWallet == address(0), \"New runner has a wallet\");\n\n        smartWalletOfNodeRunner[_new] = wallet;\n        nodeRunnerOfSmartWallet[wallet] = _new;\n\n        delete smartWalletOfNodeRunner[_current];\n\n        if (msg.sender == dao && _wasPreviousNodeRunnerMalicious) {\n            bannedNodeRunners[_current] = true;\n            emit NodeRunnerBanned(_current);\n        }\n\n        emit NodeRunnerOfSmartWalletRotated(wallet, _current, _new);\n    }\n\n    /// @notice function to allow a node runner to claim ETH from the syndicate from their smart wallet\n    /// @param _recipient End recipient of ETH from syndicate rewards\n    /// @param _blsPubKeys list of BLS public keys to claim reward for\n    function claimRewardsAsNodeRunner(\n        address _recipient,\n        bytes[] calldata _blsPubKeys\n    ) external nonReentrant {\n        require(_blsPubKeys.length > 0, \"No BLS keys specified\");\n        require(_recipient != address(0), \"Zero address\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n        require(smartWallet != address(0), \"Unknown node runner\");\n\n        for(uint256 i; i < _blsPubKeys.length; ++i) {\n            require(isBLSPublicKeyBanned(_blsPubKeys[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the node runner doesn't claim rewards for KNOTs from other smart wallets\n            require(smartWalletOfKnot[_blsPubKeys[i]] == smartWallet, \"BLS public key doesn't belong to the node runner\");\n        }\n\n        // Fetch ETH accrued\n        uint256 balBefore = address(this).balance;\n        IOwnableSmartWallet(smartWallet).execute(\n            syndicate,\n            abi.encodeWithSelector(\n                Syndicate.claimAsCollateralizedSLOTOwner.selector,\n                address(this),\n                _blsPubKeys\n            )\n        );\n\n        (uint256 nodeRunnerAmount, uint256 daoAmount) = _calculateCommission(address(this).balance - balBefore);\n        (bool transferResult, ) = _recipient.call{value: nodeRunnerAmount}(\"\");\n        require(transferResult, \"Failed to transfer\");\n\n        if (daoAmount > 0) {\n            (transferResult, ) = dao.call{value: daoAmount}(\"\");\n            require(transferResult, \"Failed to transfer\");\n        }\n\n        emit NodeRunnerRewardsClaimed(msg.sender, _recipient);\n    }\n\n    /// @notice register a node runner to LSD by creating a new smart wallet\n    /// @param _blsPublicKeys list of BLS public keys\n    /// @param _blsSignatures list of BLS signatures\n    /// @param _eoaRepresentative EOA representative of wallet\n    function registerBLSPublicKeys(\n        bytes[] calldata _blsPublicKeys,\n        bytes[] calldata _blsSignatures,\n        address _eoaRepresentative\n    ) external payable nonReentrant {\n        uint256 len = _blsPublicKeys.length;\n        require(len >= 1, \"No value provided\");\n        require(len == _blsSignatures.length, \"Unequal number of array values\");\n        require(msg.value == len * 4 ether, \"Insufficient ether provided\");\n        require(!Address.isContract(_eoaRepresentative), \"Only EOA representative permitted\");\n        require(_isNodeRunnerValid(msg.sender) == true, \"Unrecognised node runner\");\n        require(isNodeRunnerBanned(msg.sender) == false, \"Node runner is banned from LSD network\");\n\n        address smartWallet = smartWalletOfNodeRunner[msg.sender];\n\n        if(smartWallet == address(0)) {\n            // create new wallet owned by liquid staking manager\n            smartWallet = smartWalletFactory.createWallet(address(this));\n            emit SmartWalletCreated(smartWallet, msg.sender);\n\n            // associate node runner with the newly created wallet\n            smartWalletOfNodeRunner[msg.sender] = smartWallet;\n            nodeRunnerOfSmartWallet[smartWallet] = msg.sender;\n\n            _authorizeRepresentative(smartWallet, _eoaRepresentative, true);\n        }\n\n        // Ensure that the node runner does not whitelist multiple EOA representatives - they can only have 1 active at a time\n        if(smartWalletRepresentative[smartWallet] != address(0)) {\n            require(smartWalletRepresentative[smartWallet] == _eoaRepresentative, \"Different EOA specified - rotate outside\");\n        }\n\n        {\n            // transfer ETH to smart wallet\n            (bool result,) = smartWallet.call{value: msg.value}(\"\");\n            require(result, \"Transfer failed\");\n            emit WalletCredited(smartWallet, msg.value);\n        }\n\n        for(uint256 i; i < len; ++i) {\n            bytes calldata _blsPublicKey = _blsPublicKeys[i];\n\n            // check if the BLS public key is part of LSD network and is not banned\n            require(isBLSPublicKeyPartOfLSDNetwork(_blsPublicKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKey) == IDataStructures.LifecycleStatus.UNBEGUN,\n                \"Lifecycle status must be zero\"\n            );\n\n            // register validtor initals for each of the KNOTs\n            IOwnableSmartWallet(smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.registerValidatorInitials.selector,\n                    smartWallet,\n                    _blsPublicKey,\n                    _blsSignatures[i]\n                )\n            );\n\n            // register the smart wallet with the BLS public key\n            smartWalletOfKnot[_blsPublicKey] = smartWallet;\n\n            emit NewLSDValidatorRegistered(msg.sender, _blsPublicKey);\n        }\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyPartOfLSDNetwork(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return smartWalletOfKnot[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @inheritdoc ILiquidStakingManager\n    function isBLSPublicKeyBanned(bytes calldata _blsPublicKeyOfKnot) public virtual view returns (bool) {\n        return !isBLSPublicKeyPartOfLSDNetwork(_blsPublicKeyOfKnot) || bannedBLSPublicKeys[_blsPublicKeyOfKnot] != address(0);\n    }\n\n    /// @notice function to check if a node runner address is banned\n    /// @param _nodeRunner address of the node runner\n    /// @return true if the node runner is banned, false otherwise\n    function isNodeRunnerBanned(address _nodeRunner) public view returns (bool) {\n        return bannedNodeRunners[_nodeRunner];\n    }\n\n    /// @notice function to check if a KNOT is deregistered\n    /// @param _blsPublicKey BLS public key of the KNOT\n    /// @return true if the KNOT is deregistered, false otherwise\n    function isKnotDeregistered(bytes calldata _blsPublicKey) public view returns (bool) {\n        return Syndicate(payable(syndicate)).isNoLongerPartOfSyndicate(_blsPublicKey);\n    }\n\n    /// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication\n    /// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network)\n    /// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain\n    /// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup\n    /// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature\n    /// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contract\n    function stake(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        bytes[] calldata _ciphertexts,\n        bytes[] calldata _aesEncryptorKeys,\n        IDataStructures.EIP712Signature[] calldata _encryptionSignatures,\n        bytes32[] calldata _dataRoots\n    ) external {\n        uint256 numOfValidators = _blsPublicKeyOfKnots.length;\n        require(numOfValidators > 0, \"No data\");\n        require(numOfValidators == _ciphertexts.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _aesEncryptorKeys.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _encryptionSignatures.length, \"Inconsistent array lengths\");\n        require(numOfValidators == _dataRoots.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfValidators; ++i) {\n            bytes calldata blsPubKey = _blsPublicKeyOfKnots[i];\n            // check if BLS public key is registered with liquid staking derivative network and not banned\n            require(isBLSPublicKeyBanned(blsPubKey) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n            require(associatedSmartWallet != address(0), \"Unknown BLS public key\");\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n                \"Initials not registered\"\n            );\n\n            // check minimum balance of smart wallet, dao staking fund vault and savETH vault\n            _assertEtherIsReadyForValidatorStaking(blsPubKey);\n\n            _stake(\n                _blsPublicKeyOfKnots[i],\n                _ciphertexts[i],\n                _aesEncryptorKeys[i],\n                _encryptionSignatures[i],\n                _dataRoots[i]\n            );\n\n            address representative = smartWalletRepresentative[associatedSmartWallet];\n\n            if(representative != address(0)) {\n                // unauthorize the EOA representative on the Stakehouse\n                _authorizeRepresentative(associatedSmartWallet, representative, false);\n                // make the representative dormant before unauthorizing it\n                smartWalletDormantRepresentative[associatedSmartWallet] = representative;\n                emit DormantRepresentative(associatedSmartWallet, representative);\n            }\n        }\n    }\n\n    /// @notice Anyone can call this to trigger creating a knot which will mint derivatives once the balance has been reported\n    /// @param _blsPublicKeyOfKnots List of BLS public keys registered with the network becoming knots and minting derivatives\n    /// @param _beaconChainBalanceReports List of beacon chain balance reports\n    /// @param _reportSignatures List of attestations for the beacon chain balance reports\n    function mintDerivatives(\n        bytes[] calldata _blsPublicKeyOfKnots,\n        IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,\n        IDataStructures.EIP712Signature[] calldata _reportSignatures\n    ) external {\n        uint256 numOfKnotsToProcess = _blsPublicKeyOfKnots.length;\n        require(numOfKnotsToProcess > 0, \"Empty array\");\n        require(numOfKnotsToProcess == _beaconChainBalanceReports.length, \"Inconsistent array lengths\");\n        require(numOfKnotsToProcess == _reportSignatures.length, \"Inconsistent array lengths\");\n\n        for (uint256 i; i < numOfKnotsToProcess; ++i) {\n            // check if BLS public key is registered and not banned\n            require(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, \"BLS public key is banned or not a part of LSD network\");\n\n            // check that the BLS pub key has deposited lifecycle\n            require(\n                getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnots[i]) == IDataStructures.LifecycleStatus.DEPOSIT_COMPLETED,\n                \"Lifecycle status must be two\"\n            );\n\n            // The first knot will create the Stakehouse\n            if(numberOfKnots == 0) {\n                _createLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n            else {\n                // join stakehouse\n                _joinLSDNStakehouse(\n                    _blsPublicKeyOfKnots[i],\n                    _beaconChainBalanceReports[i],\n                    _reportSignatures[i]\n                );\n            }\n\n            address smartWallet = smartWalletOfKnot[_blsPublicKeyOfKnots[i]];\n            stakedKnotsOfSmartWallet[smartWallet] -= 1;\n\n            if(stakedKnotsOfSmartWallet[smartWallet] == 0) {\n                _authorizeRepresentative(smartWallet, smartWalletDormantRepresentative[smartWallet], true);\n\n                // delete the dormant representative as it is set active\n                delete smartWalletDormantRepresentative[smartWallet];\n            }\n\n            // Expand the staking funds vault shares that can claim rewards\n            stakingFundsVault.updateDerivativesMinted();\n        }\n    }\n\n    receive() external payable {}\n\n    /// @notice Every liquid staking derivative network has a single fee recipient determined by its syndicate contract\n    /// @dev The syndicate contract is only deployed after the first KNOT to mint derivatives creates the network Stakehouse\n    /// @dev Because the syndicate contract for the LSDN is deployed with CREATE2, we can predict the fee recipient ahead of time\n    /// @dev This is important because node runners need to configure their nodes before or immediately after staking\n    function getNetworkFeeRecipient() external view returns (address) {\n        // Always 1 knot initially registered to the syndicate because we expand it one by one\n        return syndicateFactory.calculateSyndicateDeploymentAddress(\n            address(this),\n            address(this),\n            1\n        );\n    }\n\n    /// @dev Internal method for managing the initialization of the staking manager contract\n    function _init(\n        address _dao,\n        address _syndicateFactory,\n        address _smartWalletFactory,\n        address _lpTokenFactory,\n        address _brand,\n        address _savETHVaultDeployer,\n        address _stakingFundsVaultDeployer,\n        address _optionalGatekeeperDeployer,\n        uint256 _optionalCommission,\n        bool _deployOptionalGatekeeper,\n        string calldata _stakehouseTicker\n    ) internal {\n        require(_dao != address(0), \"Zero address\");\n        require(_syndicateFactory != address(0), \"Zero address\");\n        require(_smartWalletFactory != address(0), \"Zero address\");\n        require(_brand != address(0), \"Zero address\");\n        require(bytes(_stakehouseTicker).length >= 3, \"String must be 3-5 characters long\");\n        require(bytes(_stakehouseTicker).length <= 5, \"String must be 3-5 characters long\");\n\n        brand = _brand;\n        dao = _dao;\n        syndicateFactory = ISyndicateFactory(_syndicateFactory);\n        smartWalletFactory = IOwnableSmartWalletFactory(_smartWalletFactory);\n        stakehouseTicker = _stakehouseTicker;\n\n        _updateDAORevenueCommission(_optionalCommission);\n\n        _initStakingFundsVault(_stakingFundsVaultDeployer, _lpTokenFactory);\n        _initSavETHVault(_savETHVaultDeployer, _lpTokenFactory);\n\n        if (_deployOptionalGatekeeper) {\n            gatekeeper = OptionalGatekeeperFactory(_optionalGatekeeperDeployer).deploy(address(this));\n        }\n    }\n\n    /// @dev function checks if a node runner is valid depending upon whitelisting status\n    /// @param _nodeRunner address of the user requesting to become node runner\n    /// @return true if eligible. reverts with message if not eligible\n    function _isNodeRunnerValid(address _nodeRunner) internal view returns (bool) {\n        require(_nodeRunner != address(0), \"Zero address\");\n\n        if(enableWhitelisting) {\n            require(isNodeRunnerWhitelisted[_nodeRunner] == true, \"Invalid node runner\");\n        }\n\n        return true;\n    }\n\n    /// @dev Manage the removal and appointing of smart wallet representatives including managing state\n    function _authorizeRepresentative(\n        address _smartWallet, \n        address _eoaRepresentative, \n        bool _isEnabled\n    ) internal {\n        if(!_isEnabled && smartWalletRepresentative[_smartWallet] != address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // delete the mapping\n            delete smartWalletRepresentative[_smartWallet];\n\n            emit RepresentativeRemoved(_smartWallet, _eoaRepresentative);\n        }\n        else if(_isEnabled && smartWalletRepresentative[_smartWallet] == address(0)) {\n\n            // authorize the EOA representative on the Stakehouse\n            IOwnableSmartWallet(_smartWallet).execute(\n                address(getTransactionRouter()),\n                abi.encodeWithSelector(\n                    ITransactionRouter.authorizeRepresentative.selector,\n                    _eoaRepresentative,\n                    _isEnabled\n                )\n            );\n\n            // store EOA to the wallet mapping\n            smartWalletRepresentative[_smartWallet] = _eoaRepresentative;\n\n            emit RepresentativeAppointed(_smartWallet, _eoaRepresentative);\n        } else {\n            revert(\"Unexpected state\");\n        }\n    }\n\n    /// @dev Internal method for doing just staking - pre-checks done outside this method to avoid stack too deep\n    function _stake(\n        bytes calldata _blsPublicKey,\n        bytes calldata _cipherText,\n        bytes calldata _aesEncryptorKey,\n        IDataStructures.EIP712Signature calldata _encryptionSignature,\n        bytes32 dataRoot\n    ) internal {\n        address smartWallet = smartWalletOfKnot[_blsPublicKey];\n\n        // send 24 ether from savETH vault to smart wallet\n        savETHVault.withdrawETHForStaking(smartWallet, 24 ether);\n\n        // send 4 ether from DAO staking funds vault\n        stakingFundsVault.withdrawETH(smartWallet, 4 ether);\n\n        // interact with transaction router using smart wallet to deposit 32 ETH\n        IOwnableSmartWallet(smartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.registerValidator.selector,\n                smartWallet,\n                _blsPublicKey,\n                _cipherText,\n                _aesEncryptorKey,\n                _encryptionSignature,\n                dataRoot\n            ),\n            32 ether\n        );\n\n        // increment number of staked KNOTs in the wallet\n        stakedKnotsOfSmartWallet[smartWallet] += 1;\n\n        emit KnotStaked(_blsPublicKey, msg.sender);\n    }\n\n    /// @dev The second knot onwards will join the LSDN stakehouse and expand the registered syndicate knots\n    function _joinLSDNStakehouse(\n        bytes calldata _blsPubKey,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // total number of knots created with the syndicate increases\n        numberOfKnots += 1;\n\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPubKey];\n\n        // Join the LSDN stakehouse\n        string memory lowerTicker = IBrandNFT(brand).toLowerCase(stakehouseTicker);\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.joinStakehouse.selector,\n                associatedSmartWallet,\n                _blsPubKey,\n                stakehouse,\n                IBrandNFT(brand).lowercaseBrandTickerToTokenId(lowerTicker),\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Register the knot to the syndicate\n        bytes[] memory _blsPublicKeyOfKnots = new bytes[](1);\n        _blsPublicKeyOfKnots[0] = _blsPubKey;\n        Syndicate(payable(syndicate)).registerKnotsToSyndicate(_blsPublicKeyOfKnots);\n\n        // Autostake DAO sETH with the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPubKey);\n\n        emit StakehouseJoined(_blsPubKey);\n    }\n\n    /// @dev Perform all the steps required to create the LSDN stakehouse that other knots will join\n    function _createLSDNStakehouse(\n        bytes calldata _blsPublicKeyOfKnot,\n        IDataStructures.ETH2DataReport calldata _beaconChainBalanceReport,\n        IDataStructures.EIP712Signature calldata _reportSignature\n    ) internal {\n        // create stakehouse and mint derivative for first bls key - the others are just used to create the syndicate\n        // The savETH will go to the savETH vault, the collateralized SLOT for syndication owned by the smart wallet\n        // sETH will also be minted in the smart wallet but will be moved out and distributed to the syndicate for claiming by the DAO\n        address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            address(getTransactionRouter()),\n            abi.encodeWithSelector(\n                ITransactionRouter.createStakehouse.selector,\n                associatedSmartWallet,\n                _blsPublicKeyOfKnot,\n                stakehouseTicker,\n                savETHVault.indexOwnedByTheVault(),\n                _beaconChainBalanceReport,\n                _reportSignature\n            )\n        );\n\n        // Number of knots has increased\n        numberOfKnots += 1;\n\n        // Capture the address of the Stakehouse for future knots to join\n        stakehouse = getStakeHouseUniverse().memberKnotToStakeHouse(_blsPublicKeyOfKnot);\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        // Give liquid staking manager ability to manage keepers and set a house keeper if decided by the network\n        IOwnableSmartWallet(associatedSmartWallet).execute(\n            stakehouse,\n            abi.encodeWithSelector(\n                Ownable.transferOwnership.selector,\n                address(this)\n            )\n        );\n\n        if (address(gatekeeper) != address(0)) {\n            IStakeHouseRegistry(stakehouse).setGateKeeper(address(gatekeeper));\n        }\n\n        // Deploy the EIP1559 transaction reward sharing contract but no priority required because sETH will be auto staked\n        address[] memory priorityStakers = new address[](0);\n        bytes[] memory initialKnots = new bytes[](1);\n        initialKnots[0] = _blsPublicKeyOfKnot;\n        syndicate = syndicateFactory.deploySyndicate(\n            address(this),\n            0,\n            priorityStakers,\n            initialKnots\n        );\n\n        // Contract approves syndicate to take sETH on behalf of the DAO\n        sETH.approve(syndicate, (2 ** 256) - 1);\n\n        // Auto-stake sETH by pulling sETH out the smart wallet and staking in the syndicate\n        _autoStakeWithSyndicate(associatedSmartWallet, _blsPublicKeyOfKnot);\n\n        emit StakehouseCreated(stakehouseTicker, stakehouse);\n    }\n\n    /// @dev Remove the sETH from the node runner smart wallet in order to auto-stake the sETH in the syndicate\n    function _autoStakeWithSyndicate(address _associatedSmartWallet, bytes memory _blsPubKey) internal {\n        IERC20 sETH = IERC20(getSlotRegistry().stakeHouseShareTokens(stakehouse));\n\n        uint256 stakeAmount = 12 ether;\n        IOwnableSmartWallet(_associatedSmartWallet).execute(\n            address(sETH),\n            abi.encodeWithSelector(\n                IERC20.transfer.selector,\n                address(this),\n                stakeAmount\n            )\n        );\n\n        // Create the payload for staking\n        bytes[] memory stakingKeys = new bytes[](1);\n        stakingKeys[0] = _blsPubKey;\n\n        uint256[] memory stakeAmounts = new uint256[](1);\n        stakeAmounts[0] = stakeAmount;\n\n        // Stake the sETH to be received by the LPs of the Staking Funds Vault (fees and mev)\n        Syndicate(payable(syndicate)).stake(stakingKeys, stakeAmounts, address(stakingFundsVault));\n    }\n\n    /// @dev Something that can be overriden during testing\n    function _initSavETHVault(address _savETHVaultDeployer, address _lpTokenFactory) internal virtual {\n        // Use an external deployer to reduce the size of the liquid staking manager\n        savETHVault = SavETHVault(\n            SavETHVaultDeployer(_savETHVaultDeployer).deploySavETHVault(address(this), _lpTokenFactory)\n        );\n    }\n\n    function _initStakingFundsVault(address _stakingFundsVaultDeployer, address _tokenFactory) internal virtual {\n        stakingFundsVault = StakingFundsVault(\n            payable(StakingFundsVaultDeployer(_stakingFundsVaultDeployer).deployStakingFundsVault(\n                address(this),\n                _tokenFactory\n            ))\n        );\n    }\n\n    /// @dev This can be overriden to customise fee percentages\n    function _calculateCommission(uint256 _received) internal virtual view returns (uint256 _nodeRunner, uint256 _dao) {\n        require(_received > 0, \"Nothing received\");\n\n        if (daoCommissionPercentage > 0) {\n            uint256 daoAmount = (_received * daoCommissionPercentage) / MODULO;\n            uint256 rest = _received - daoAmount;\n            return (rest, daoAmount);\n        }\n\n        return (_received, 0);\n    }\n\n    /// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achieved\n    function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {\n        address associatedSmartWallet = smartWalletOfKnot[blsPubKey];\n        require(associatedSmartWallet.balance >= 4 ether, \"Smart wallet balance must be at least 4 ether\");\n\n        LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);\n        require(address(stakingFundsLP) != address(0), \"No funds staked in staking funds vault\");\n        require(stakingFundsLP.totalSupply() == 4 ether, \"DAO staking funds vault balance must be at least 4 ether\");\n\n        LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);\n        require(address(savETHVaultLP) != address(0), \"No funds staked in savETH vault\");\n        require(savETHVaultLP.totalSupply() == 24 ether, \"KNOT must have 24 ETH in savETH vault\");\n    }\n\n    /// @dev Internal method for dao to trigger updating commission it takes of node runner revenue\n    function _updateDAORevenueCommission(uint256 _commissionPercentage) internal {\n        require(_commissionPercentage <= MODULO, \"Invalid commission\");\n\n        emit DAOCommissionUpdated(daoCommissionPercentage, _commissionPercentage);\n\n        daoCommissionPercentage = _commissionPercentage;\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-11-stakehouse-findings.json",
                "Location": "LiquidStakingManager.sol#withdrawETHForKnow",
                "Type": "Reentrancy",
                "Description": "The _recipient is a smart contract, it can re-enter the withdraw function to withdraw another 4 ETH multiple times before the public key is banned.",
                "Repair": "Ban the public key first then send the fund out, and use openzeppelin nonReentrant modifier to avoid reentrancy."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"solmate/tokens/ERC20.sol\";\nimport \"solmate/tokens/ERC721.sol\";\nimport \"solmate/utils/MerkleProofLib.sol\";\nimport \"solmate/utils/SafeTransferLib.sol\";\nimport \"openzeppelin/utils/math/Math.sol\";\n\nimport \"./LpToken.sol\";\nimport \"./Caviar.sol\";\n\n/// @title Pair\n/// @author out.eth (@outdoteth)\n/// @notice A pair of an NFT and a base token that can be used to create and trade fractionalized NFTs.\ncontract Pair is ERC20, ERC721TokenReceiver {\n    using SafeTransferLib for address;\n    using SafeTransferLib for ERC20;\n\n    uint256 public constant ONE = 1e18;\n    uint256 public constant CLOSE_GRACE_PERIOD = 7 days;\n\n    address public immutable nft;\n    address public immutable baseToken; // address(0) for ETH\n    bytes32 public immutable merkleRoot;\n    LpToken public immutable lpToken;\n    Caviar public immutable caviar;\n    uint256 public closeTimestamp;\n\n    event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n    event Buy(uint256 inputAmount, uint256 outputAmount);\n    event Sell(uint256 inputAmount, uint256 outputAmount);\n    event Wrap(uint256[] tokenIds);\n    event Unwrap(uint256[] tokenIds);\n    event Close(uint256 closeTimestamp);\n    event Withdraw(uint256 tokenId);\n\n    constructor(\n        address _nft,\n        address _baseToken,\n        bytes32 _merkleRoot,\n        string memory pairSymbol,\n        string memory nftName,\n        string memory nftSymbol\n    ) ERC20(string.concat(nftName, \" fractional token\"), string.concat(\"f\", nftSymbol), 18) {\n        nft = _nft;\n        baseToken = _baseToken; // use address(0) for native ETH\n        merkleRoot = _merkleRoot;\n        lpToken = new LpToken(pairSymbol);\n        caviar = Caviar(msg.sender);\n    }\n\n    // ************************ //\n    //      Core AMM logic      //\n    // ***********************  //\n\n    /// @notice Adds liquidity to the pair.\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param fractionalTokenAmount The amount of fractional tokens to add.\n    /// @param minLpTokenAmount The minimum amount of LP tokens to mint.\n    /// @return lpTokenAmount The amount of LP tokens minted.\n    function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)\n        public\n        payable\n        returns (uint256 lpTokenAmount)\n    {\n        // *** Checks *** //\n\n        // check the token amount inputs are not zero\n        require(baseTokenAmount > 0 && fractionalTokenAmount > 0, \"Input token amount is zero\");\n\n        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\n        require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, \"Invalid ether input\");\n\n        // calculate the lp token shares to mint\n        lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);\n\n        // check that the amount of lp tokens outputted is greater than the min amount\n        require(lpTokenAmount >= minLpTokenAmount, \"Slippage: lp token amount out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens in\n        _transferFrom(msg.sender, address(this), fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // mint lp tokens to sender\n        lpToken.mint(msg.sender, lpTokenAmount);\n\n        // transfer base tokens in if the base token is not ETH\n        if (baseToken != address(0)) {\n            // transfer base tokens in\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n        }\n\n        emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);\n    }\n\n    /// @notice Removes liquidity from the pair.\n    /// @param lpTokenAmount The amount of LP tokens to burn.\n    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.\n    /// @param minFractionalTokenOutputAmount The minimum amount of fractional tokens to receive.\n    /// @return baseTokenOutputAmount The amount of base tokens received.\n    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.\n    function remove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256 minFractionalTokenOutputAmount)\n        public\n        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)\n    {\n        // *** Checks *** //\n\n        // calculate the output amounts\n        (baseTokenOutputAmount, fractionalTokenOutputAmount) = removeQuote(lpTokenAmount);\n\n        // check that the base token output amount is greater than the min amount\n        require(baseTokenOutputAmount >= minBaseTokenOutputAmount, \"Slippage: base token amount out\");\n\n        // check that the fractional token output amount is greater than the min amount\n        require(fractionalTokenOutputAmount >= minFractionalTokenOutputAmount, \"Slippage: fractional token out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens to sender\n        _transferFrom(address(this), msg.sender, fractionalTokenOutputAmount);\n\n        // *** Interactions *** //\n\n        // burn lp tokens from sender\n        lpToken.burn(msg.sender, lpTokenAmount);\n\n        if (baseToken == address(0)) {\n            // if base token is native ETH then send ether to sender\n            msg.sender.safeTransferETH(baseTokenOutputAmount);\n        } else {\n            // transfer base tokens to sender\n            ERC20(baseToken).safeTransfer(msg.sender, baseTokenOutputAmount);\n        }\n\n        emit Remove(baseTokenOutputAmount, fractionalTokenOutputAmount, lpTokenAmount);\n    }\n\n    /// @notice Buys fractional tokens from the pair.\n    /// @param outputAmount The amount of fractional tokens to buy.\n    /// @param maxInputAmount The maximum amount of base tokens to spend.\n    /// @return inputAmount The amount of base tokens spent.\n    function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n        // *** Checks *** //\n\n        // check that correct eth input was sent - if the baseToken equals address(0) then native ETH is used\n        require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\n\n        // calculate required input amount using xyk invariant\n        inputAmount = buyQuote(outputAmount);\n\n        // check that the required amount of base tokens is less than the max amount\n        require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens to sender\n        _transferFrom(address(this), msg.sender, outputAmount);\n\n        // *** Interactions *** //\n\n        if (baseToken == address(0)) {\n            // refund surplus eth\n            uint256 refundAmount = maxInputAmount - inputAmount;\n            if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);\n        } else {\n            // transfer base tokens in\n            ERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n        }\n\n        emit Buy(inputAmount, outputAmount);\n    }\n\n    /// @notice Sells fractional tokens to the pair.\n    /// @param inputAmount The amount of fractional tokens to sell.\n    /// @param minOutputAmount The minimum amount of base tokens to receive.\n    /// @return outputAmount The amount of base tokens received.\n    function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {\n        // *** Checks *** //\n\n        // calculate output amount using xyk invariant\n        outputAmount = sellQuote(inputAmount);\n\n        // check that the outputted amount of fractional tokens is greater than the min amount\n        require(outputAmount >= minOutputAmount, \"Slippage: amount out\");\n\n        // *** Effects *** //\n\n        // transfer fractional tokens from sender\n        _transferFrom(msg.sender, address(this), inputAmount);\n\n        // *** Interactions *** //\n\n        if (baseToken == address(0)) {\n            // transfer ether out\n            msg.sender.safeTransferETH(outputAmount);\n        } else {\n            // transfer base tokens out\n            ERC20(baseToken).safeTransfer(msg.sender, outputAmount);\n        }\n\n        emit Sell(inputAmount, outputAmount);\n    }\n\n    // ******************** //\n    //      Wrap logic      //\n    // ******************** //\n\n    /// @notice Wraps NFTs into fractional tokens.\n    /// @param tokenIds The ids of the NFTs to wrap.\n    /// @param proofs The merkle proofs for the NFTs proving that they can be used in the pair.\n    /// @return fractionalTokenAmount The amount of fractional tokens minted.\n    function wrap(uint256[] calldata tokenIds, bytes32[][] calldata proofs)\n        public\n        returns (uint256 fractionalTokenAmount)\n    {\n        // *** Checks *** //\n\n        // check that wrapping is not closed\n        require(closeTimestamp == 0, \"Wrap: closed\");\n\n        // check the tokens exist in the merkle root\n        _validateTokenIds(tokenIds, proofs);\n\n        // *** Effects *** //\n\n        // mint fractional tokens to sender\n        fractionalTokenAmount = tokenIds.length * ONE;\n        _mint(msg.sender, fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // transfer nfts from sender\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        emit Wrap(tokenIds);\n    }\n\n    /// @notice Unwraps fractional tokens into NFTs.\n    /// @param tokenIds The ids of the NFTs to unwrap.\n    /// @return fractionalTokenAmount The amount of fractional tokens burned.\n    function unwrap(uint256[] calldata tokenIds) public returns (uint256 fractionalTokenAmount) {\n        // *** Effects *** //\n\n        // burn fractional tokens from sender\n        fractionalTokenAmount = tokenIds.length * ONE;\n        _burn(msg.sender, fractionalTokenAmount);\n\n        // *** Interactions *** //\n\n        // transfer nfts to sender\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenIds[i]);\n        }\n\n        emit Unwrap(tokenIds);\n    }\n\n    // *********************** //\n    //      NFT AMM logic      //\n    // *********************** //\n\n    /// @notice nftAdd Adds liquidity to the pair using NFTs.\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param tokenIds The ids of the NFTs to add.\n    /// @param minLpTokenAmount The minimum amount of lp tokens to receive.\n    /// @param proofs The merkle proofs for the NFTs.\n    /// @return lpTokenAmount The amount of lp tokens minted.\n    function nftAdd(\n        uint256 baseTokenAmount,\n        uint256[] calldata tokenIds,\n        uint256 minLpTokenAmount,\n        bytes32[][] calldata proofs\n    ) public payable returns (uint256 lpTokenAmount) {\n        // wrap the incoming NFTs into fractional tokens\n        uint256 fractionalTokenAmount = wrap(tokenIds, proofs);\n\n        // add liquidity using the fractional tokens and base tokens\n        lpTokenAmount = add(baseTokenAmount, fractionalTokenAmount, minLpTokenAmount);\n    }\n\n    /// @notice Removes liquidity from the pair using NFTs.\n    /// @param lpTokenAmount The amount of lp tokens to remove.\n    /// @param minBaseTokenOutputAmount The minimum amount of base tokens to receive.\n    /// @param tokenIds The ids of the NFTs to remove.\n    /// @return baseTokenOutputAmount The amount of base tokens received.\n    /// @return fractionalTokenOutputAmount The amount of fractional tokens received.\n    function nftRemove(uint256 lpTokenAmount, uint256 minBaseTokenOutputAmount, uint256[] calldata tokenIds)\n        public\n        returns (uint256 baseTokenOutputAmount, uint256 fractionalTokenOutputAmount)\n    {\n        // remove liquidity and send fractional tokens and base tokens to sender\n        (baseTokenOutputAmount, fractionalTokenOutputAmount) =\n            remove(lpTokenAmount, minBaseTokenOutputAmount, tokenIds.length * ONE);\n\n        // unwrap the fractional tokens into NFTs and send to sender\n        unwrap(tokenIds);\n    }\n\n    /// @notice Buys NFTs from the pair using base tokens.\n    /// @param tokenIds The ids of the NFTs to buy.\n    /// @param maxInputAmount The maximum amount of base tokens to spend.\n    /// @return inputAmount The amount of base tokens spent.\n    function nftBuy(uint256[] calldata tokenIds, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n        // buy fractional tokens using base tokens\n        inputAmount = buy(tokenIds.length * ONE, maxInputAmount);\n\n        // unwrap the fractional tokens into NFTs and send to sender\n        unwrap(tokenIds);\n    }\n\n    /// @notice Sells NFTs to the pair for base tokens.\n    /// @param tokenIds The ids of the NFTs to sell.\n    /// @param minOutputAmount The minimum amount of base tokens to receive.\n    /// @param proofs The merkle proofs for the NFTs.\n    /// @return outputAmount The amount of base tokens received.\n    function nftSell(uint256[] calldata tokenIds, uint256 minOutputAmount, bytes32[][] calldata proofs)\n        public\n        returns (uint256 outputAmount)\n    {\n        // wrap the incoming NFTs into fractional tokens\n        uint256 inputAmount = wrap(tokenIds, proofs);\n\n        // sell fractional tokens for base tokens\n        outputAmount = sell(inputAmount, minOutputAmount);\n    }\n\n    // ****************************** //\n    //      Emergency exit logic      //\n    // ****************************** //\n\n    /// @notice Closes the pair to new wraps.\n    /// @dev Can only be called by the caviar owner. This is used as an emergency exit in case\n    ///      the caviar owner suspects that the pair has been compromised.\n    function close() public {\n        // check that the sender is the caviar owner\n        require(caviar.owner() == msg.sender, \"Close: not owner\");\n\n        // set the close timestamp with a grace period\n        closeTimestamp = block.timestamp + CLOSE_GRACE_PERIOD;\n\n        // remove the pair from the Caviar contract\n        caviar.destroy(nft, baseToken, merkleRoot);\n\n        emit Close(closeTimestamp);\n    }\n\n    /// @notice Withdraws a particular NFT from the pair.\n    /// @dev Can only be called by the caviar owner after the close grace period has passed. This\n    ///      is used to auction off the NFTs in the pair in case NFTs get stuck due to liquidity\n    ///      imbalances. Proceeds from the auction should be distributed pro rata to fractional\n    ///      token holders. See documentation for more details.\n    function withdraw(uint256 tokenId) public {\n        // check that the sender is the caviar owner\n        require(caviar.owner() == msg.sender, \"Withdraw: not owner\");\n\n        // check that the close period has been set\n        require(closeTimestamp != 0, \"Withdraw not initiated\");\n\n        // check that the close grace period has passed\n        require(block.timestamp >= closeTimestamp, \"Not withdrawable yet\");\n\n        // transfer the nft to the caviar owner\n        ERC721(nft).safeTransferFrom(address(this), msg.sender, tokenId);\n\n        emit Withdraw(tokenId);\n    }\n\n    // ***************** //\n    //      Getters      //\n    // ***************** //\n\n    function baseTokenReserves() public view returns (uint256) {\n        return _baseTokenReserves();\n    }\n\n    function fractionalTokenReserves() public view returns (uint256) {\n        return balanceOf[address(this)];\n    }\n\n    /// @notice The current price of one fractional token in base tokens with 18 decimals of precision.\n    /// @dev Calculated by dividing the base token reserves by the fractional token reserves.\n    /// @return price The price of one fractional token in base tokens * 1e18.\n    function price() public view returns (uint256) {\n        return (_baseTokenReserves() * ONE) / fractionalTokenReserves();\n    }\n\n    /// @notice The amount of base tokens required to buy a given amount of fractional tokens.\n    /// @dev Calculated using the xyk invariant and a 30bps fee.\n    /// @param outputAmount The amount of fractional tokens to buy.\n    /// @return inputAmount The amount of base tokens required.\n    function buyQuote(uint256 outputAmount) public view returns (uint256) {\n        return (outputAmount * 1000 * baseTokenReserves()) / ((fractionalTokenReserves() - outputAmount) * 997);\n    }\n\n    /// @notice The amount of base tokens received for selling a given amount of fractional tokens.\n    /// @dev Calculated using the xyk invariant and a 30bps fee.\n    /// @param inputAmount The amount of fractional tokens to sell.\n    /// @return outputAmount The amount of base tokens received.\n    function sellQuote(uint256 inputAmount) public view returns (uint256) {\n        uint256 inputAmountWithFee = inputAmount * 997;\n        return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);\n    }\n\n    /// @notice The amount of lp tokens received for adding a given amount of base tokens and fractional tokens.\n    /// @dev Calculated as a share of existing deposits. If there are no existing deposits, then initializes to\n    ///      sqrt(baseTokenAmount * fractionalTokenAmount).\n    /// @param baseTokenAmount The amount of base tokens to add.\n    /// @param fractionalTokenAmount The amount of fractional tokens to add.\n    /// @return lpTokenAmount The amount of lp tokens received.\n    function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {\n        uint256 lpTokenSupply = lpToken.totalSupply();\n        if (lpTokenSupply > 0) {\n            // calculate amount of lp tokens as a fraction of existing reserves\n            uint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) / baseTokenReserves();\n            uint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) / fractionalTokenReserves();\n            return Math.min(baseTokenShare, fractionalTokenShare);\n        } else {\n            // if there is no liquidity then init\n            return Math.sqrt(baseTokenAmount * fractionalTokenAmount);\n        }\n    }\n\n    /// @notice The amount of base tokens and fractional tokens received for burning a given amount of lp tokens.\n    /// @dev Calculated as a share of existing deposits.\n    /// @param lpTokenAmount The amount of lp tokens to burn.\n    /// @return baseTokenAmount The amount of base tokens received.\n    /// @return fractionalTokenAmount The amount of fractional tokens received.\n    function removeQuote(uint256 lpTokenAmount) public view returns (uint256, uint256) {\n        uint256 lpTokenSupply = lpToken.totalSupply();\n        uint256 baseTokenOutputAmount = (baseTokenReserves() * lpTokenAmount) / lpTokenSupply;\n        uint256 fractionalTokenOutputAmount = (fractionalTokenReserves() * lpTokenAmount) / lpTokenSupply;\n\n        return (baseTokenOutputAmount, fractionalTokenOutputAmount);\n    }\n\n    // ************************ //\n    //      Internal utils      //\n    // ************************ //\n\n    function _transferFrom(address from, address to, uint256 amount) internal returns (bool) {\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /// @dev Validates that the given tokenIds are valid for the contract's merkle root. Reverts\n    ///      if any of the tokenId proofs are invalid.\n    function _validateTokenIds(uint256[] calldata tokenIds, bytes32[][] calldata proofs) internal view {\n        // if merkle root is not set then all tokens are valid\n        if (merkleRoot == bytes23(0)) return;\n\n        // validate merkle proofs against merkle root\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            bool isValid = MerkleProofLib.verify(proofs[i], merkleRoot, keccak256(abi.encodePacked(tokenIds[i])));\n            require(isValid, \"Invalid merkle proof\");\n        }\n    }\n\n    /// @dev Returns the current base token reserves. If the base token is ETH then it ignores\n    ///      the msg.value that is being sent in the current call context - this is to ensure the\n    ///      xyk math is correct in the buy() and add() functions.\n    function _baseTokenReserves() internal view returns (uint256) {\n        return baseToken == address(0)\n            ? address(this).balance - msg.value // subtract the msg.value if the base token is ETH\n            : ERC20(baseToken).balanceOf(address(this));\n    }\n}\n\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-12-caviar-findings.json",
                "Location": "buy and sell functions in Pair.sol",
                "Type": "Reentrancy",
                "Description": "Current implementation of functions add, remove, buy and sell first transfer fractional tokens, and then base tokens. Allows to drain funds of a pairs which implements an ERC-777 token.",
                "Repair": "Add OpenZeppelin nonReentrant modifier to mentioned functions, or state clear in the documentation that this protocol should not be used with ERC777 tokens."
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"./utils/MetaContext.sol\";\nimport \"./interfaces/IPosition.sol\";\n\ncontract Position is ERC721Enumerable, MetaContext, IPosition {\n\n    function ownerOf(uint _id) public view override(ERC721, IERC721, IPosition) returns (address) {\n        return ERC721.ownerOf(_id);\n    }\n\n    using Counters for Counters.Counter;\n    uint constant public DIVISION_CONSTANT = 1e10; // 100%\n\n    mapping(uint => mapping(address => uint)) public vaultFundingPercent;\n\n    mapping(address => bool) private _isMinter; // Trading contract should be minter\n    mapping(uint256 => Trade) private _trades; // NFT id to Trade\n\n    uint256[] private _openPositions;\n    mapping(uint256 => uint256) private _openPositionsIndexes;\n\n    mapping(uint256 => uint256[]) private _assetOpenPositions;\n    mapping(uint256 => mapping(uint256 => uint256)) private _assetOpenPositionsIndexes;\n\n    mapping(uint256 => uint256[]) private _limitOrders; // List of limit order nft ids per asset\n    mapping(uint256 => mapping(uint256 => uint256)) private _limitOrderIndexes; // Keeps track of asset -> id -> array index\n\n    // Funding\n    mapping(uint256 => mapping(address => int256)) public fundingDeltaPerSec;\n    mapping(uint256 => mapping(address => mapping(bool => int256))) private accInterestPerOi;\n    mapping(uint256 => mapping(address => uint256)) private lastUpdate;\n    mapping(uint256 => int256) private initId;\n    mapping(uint256 => mapping(address => uint256)) private longOi;\n    mapping(uint256 => mapping(address => uint256)) private shortOi;\n\n    function isMinter(address _address) public view returns (bool) { return _isMinter[_address]; }\n    function trades(uint _id) public view returns (Trade memory) {\n        Trade memory _trade = _trades[_id];\n        _trade.trader = ownerOf(_id);\n        if (_trade.orderType > 0) return _trade;\n        \n        int256 _pendingFunding;\n        if (_trade.direction && longOi[_trade.asset][_trade.tigAsset] > 0) {\n            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(longOi[_trade.asset][_trade.tigAsset]);\n            if (longOi[_trade.asset][_trade.tigAsset] > shortOi[_trade.asset][_trade.tigAsset]) {\n                _pendingFunding = -_pendingFunding;\n            } else {\n                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;\n            }\n        } else if (shortOi[_trade.asset][_trade.tigAsset] > 0) {\n            _pendingFunding = (int256(block.timestamp-lastUpdate[_trade.asset][_trade.tigAsset])*fundingDeltaPerSec[_trade.asset][_trade.tigAsset])*1e18/int256(shortOi[_trade.asset][_trade.tigAsset]);\n            if (shortOi[_trade.asset][_trade.tigAsset] > longOi[_trade.asset][_trade.tigAsset]) {\n                _pendingFunding = -_pendingFunding;\n            } else {\n                _pendingFunding = _pendingFunding*int256(1e10-vaultFundingPercent[_trade.asset][_trade.tigAsset])/1e10;\n            }\n        }\n        _trade.accInterest += (int256(_trade.margin*_trade.leverage/1e18)*(accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]+_pendingFunding)/1e18)-initId[_id];\n        \n        return _trade;\n    }\n    function openPositions() public view returns (uint256[] memory) { return _openPositions; }\n    function openPositionsIndexes(uint _id) public view returns (uint256) { return _openPositionsIndexes[_id]; }\n    function assetOpenPositions(uint _asset) public view returns (uint256[] memory) { return _assetOpenPositions[_asset]; }\n    function assetOpenPositionsIndexes(uint _asset, uint _id) public view returns (uint256) { return _assetOpenPositionsIndexes[_asset][_id]; }\n    function limitOrders(uint _asset) public view returns (uint256[] memory) { return _limitOrders[_asset]; }\n    function limitOrderIndexes(uint _asset, uint _id) public view returns (uint256) { return _limitOrderIndexes[_asset][_id]; }\n\n    Counters.Counter private _tokenIds;\n    string public baseURI;\n\n    constructor(string memory _setBaseURI, string memory _name, string memory _symbol) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n        _tokenIds.increment();\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    /**\n    * @notice Update funding rate after open interest change\n    * @dev only callable by minter\n    * @param _asset pair id\n    * @param _tigAsset tigAsset token address\n    * @param _longOi long open interest\n    * @param _shortOi short open interest\n    * @param _baseFundingRate base funding rate of a pair\n    * @param _vaultFundingPercent percent of earned funding going to the stablevault\n    */\n    function updateFunding(uint256 _asset, address _tigAsset, uint256 _longOi, uint256 _shortOi, uint256 _baseFundingRate, uint _vaultFundingPercent) external onlyMinter {\n        if(longOi[_asset][_tigAsset] < shortOi[_asset][_tigAsset]) {\n            if (longOi[_asset][_tigAsset] > 0) {\n                accInterestPerOi[_asset][_tigAsset][true] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;\n            }\n            accInterestPerOi[_asset][_tigAsset][false] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]);\n\n        } else if(longOi[_asset][_tigAsset] > shortOi[_asset][_tigAsset]) {\n            accInterestPerOi[_asset][_tigAsset][true] -= (int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(longOi[_asset][_tigAsset]);\n            if (shortOi[_asset][_tigAsset] > 0) {\n                accInterestPerOi[_asset][_tigAsset][false] += ((int256(block.timestamp-lastUpdate[_asset][_tigAsset])*fundingDeltaPerSec[_asset][_tigAsset])*1e18/int256(shortOi[_asset][_tigAsset]))*int256(1e10-vaultFundingPercent[_asset][_tigAsset])/1e10;\n            }\n        }\n        lastUpdate[_asset][_tigAsset] = block.timestamp;\n        int256 _oiDelta;\n        if (_longOi > _shortOi) {\n            _oiDelta = int256(_longOi)-int256(_shortOi);\n        } else {\n            _oiDelta = int256(_shortOi)-int256(_longOi);\n        }\n        \n        fundingDeltaPerSec[_asset][_tigAsset] = (_oiDelta*int256(_baseFundingRate)/int256(DIVISION_CONSTANT))/31536000;\n        longOi[_asset][_tigAsset] = _longOi;\n        shortOi[_asset][_tigAsset] = _shortOi;\n        vaultFundingPercent[_asset][_tigAsset] = _vaultFundingPercent;\n    }\n\n    /**\n    * @notice mint a new position nft\n    * @dev only callable by minter\n    * @param _mintTrade New trade params in struct\n    */\n    function mint(\n        MintTrade memory _mintTrade\n    ) external onlyMinter {\n        uint newTokenID = _tokenIds.current();\n\n        Trade storage newTrade = _trades[newTokenID];\n        newTrade.margin = _mintTrade.margin;\n        newTrade.leverage = _mintTrade.leverage;\n        newTrade.asset = _mintTrade.asset;\n        newTrade.direction = _mintTrade.direction;\n        newTrade.price = _mintTrade.price;\n        newTrade.tpPrice = _mintTrade.tp;\n        newTrade.slPrice = _mintTrade.sl;\n        newTrade.orderType = _mintTrade.orderType;\n        newTrade.id = newTokenID;\n        newTrade.tigAsset = _mintTrade.tigAsset;\n\n        _safeMint(_mintTrade.account, newTokenID);\n        if (_mintTrade.orderType > 0) {\n            _limitOrders[_mintTrade.asset].push(newTokenID);\n            _limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;\n        } else {\n            initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;\n            _openPositions.push(newTokenID);\n            _openPositionsIndexes[newTokenID] = _openPositions.length-1;\n\n            _assetOpenPositions[_mintTrade.asset].push(newTokenID);\n            _assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;\n        }\n        _tokenIds.increment();\n    }\n\n    /**\n     * @param _id id of the position NFT\n     * @param _price price used for execution\n     * @param _newMargin margin after fees\n     */\n    function executeLimitOrder(uint256 _id, uint256 _price, uint256 _newMargin) external onlyMinter {\n        Trade storage _trade = _trades[_id];\n        if (_trade.orderType == 0) {\n            return;\n        }\n        _trade.orderType = 0;\n        _trade.price = _price;\n        _trade.margin = _newMargin;\n        uint _asset = _trade.asset;\n        _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];\n        _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n        delete _limitOrderIndexes[_asset][_id];\n        _limitOrders[_asset].pop();\n\n        _openPositions.push(_id);\n        _openPositionsIndexes[_id] = _openPositions.length-1;\n        _assetOpenPositions[_asset].push(_id);\n        _assetOpenPositionsIndexes[_asset][_id] = _assetOpenPositions[_asset].length-1;\n\n        initId[_id] = accInterestPerOi[_trade.asset][_trade.tigAsset][_trade.direction]*int256(_trade.margin*_trade.leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice modifies margin and leverage\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _newMargin new margin amount\n    * @param _newLeverage new leverage amount\n    */\n    function modifyMargin(uint256 _id, uint256 _newMargin, uint256 _newLeverage) external onlyMinter {\n        _trades[_id].margin = _newMargin;\n        _trades[_id].leverage = _newLeverage;\n    }\n\n    /**\n    * @notice modifies margin and entry price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _newMargin new margin amount\n    * @param _newPrice new entry price\n    */\n    function addToPosition(uint256 _id, uint256 _newMargin, uint256 _newPrice) external onlyMinter {\n        _trades[_id].margin = _newMargin;\n        _trades[_id].price = _newPrice;\n        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_newMargin*_trades[_id].leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice Called before updateFunding for reducing position or adding to position, to store accumulated funding\n    * @dev only callable by minter\n    * @param _id position id\n    */\n    function setAccInterest(uint256 _id) external onlyMinter {\n        _trades[_id].accInterest = trades(_id).accInterest;\n    }\n\n    /**\n    * @notice Reduces position size by %\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _percent percent of a position being closed\n    */\n    function reducePosition(uint256 _id, uint256 _percent) external onlyMinter {\n        _trades[_id].accInterest -= _trades[_id].accInterest*int256(_percent)/int256(DIVISION_CONSTANT);\n        _trades[_id].margin -= _trades[_id].margin*_percent/DIVISION_CONSTANT;\n        initId[_id] = accInterestPerOi[_trades[_id].asset][_trades[_id].tigAsset][_trades[_id].direction]*int256(_trades[_id].margin*_trades[_id].leverage/1e18)/1e18;\n    }\n\n    /**\n    * @notice change a position tp price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _tpPrice tp price\n    */\n    function modifyTp(uint _id, uint _tpPrice) external onlyMinter {\n        _trades[_id].tpPrice = _tpPrice;\n    }\n\n    /**\n    * @notice change a position sl price\n    * @dev only callable by minter\n    * @param _id position id\n    * @param _slPrice sl price\n    */\n    function modifySl(uint _id, uint _slPrice) external onlyMinter {\n        _trades[_id].slPrice = _slPrice;\n    }\n\n    /**\n    * @dev Burns an NFT and it's data\n    * @param _id ID of the trade\n    */\n    function burn(uint _id) external onlyMinter {\n        _burn(_id);\n        uint _asset = _trades[_id].asset;\n        if (_trades[_id].orderType > 0) {\n            _limitOrderIndexes[_asset][_limitOrders[_asset][_limitOrders[_asset].length-1]] = _limitOrderIndexes[_asset][_id];\n            _limitOrders[_asset][_limitOrderIndexes[_asset][_id]] = _limitOrders[_asset][_limitOrders[_asset].length-1];\n            delete _limitOrderIndexes[_asset][_id];\n            _limitOrders[_asset].pop();            \n        } else {\n            _assetOpenPositionsIndexes[_asset][_assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1]] = _assetOpenPositionsIndexes[_asset][_id];\n            _assetOpenPositions[_asset][_assetOpenPositionsIndexes[_asset][_id]] = _assetOpenPositions[_asset][_assetOpenPositions[_asset].length-1];\n            delete _assetOpenPositionsIndexes[_asset][_id];\n            _assetOpenPositions[_asset].pop();  \n\n            _openPositionsIndexes[_openPositions[_openPositions.length-1]] = _openPositionsIndexes[_id];\n            _openPositions[_openPositionsIndexes[_id]] = _openPositions[_openPositions.length-1];\n            delete _openPositionsIndexes[_id];\n            _openPositions.pop();              \n        }\n        delete _trades[_id];\n    }\n\n    function assetOpenPositionsLength(uint _asset) external view returns (uint256) {\n        return _assetOpenPositions[_asset].length;\n    }\n\n    function limitOrdersLength(uint _asset) external view returns (uint256) {\n        return _limitOrders[_asset].length;\n    }\n\n    function getCount() external view returns (uint) {\n        return _tokenIds.current();\n    }\n\n    function userTrades(address _user) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = tokenOfOwnerByIndex(_user, i);\n        }\n        return _ids;\n    }\n\n    function openPositionsSelection(uint _from, uint _to) external view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](_to-_from);\n        for (uint i=0; i<_ids.length; i++) {\n            _ids[i] = _openPositions[i+_from];\n        }\n        return _ids;\n    }\n\n    function setMinter(address _minter, bool _bool) external onlyOwner {\n        _isMinter[_minter] = _bool;\n    }    \n\n    modifier onlyMinter() {\n        require(_isMinter[_msgSender()], \"!Minter\");\n        _;\n    }\n\n    // META-TX\n    function _msgSender() internal view override(Context, MetaContext) returns (address sender) {\n        return MetaContext._msgSender();\n    }\n    function _msgData() internal view override(Context, MetaContext) returns (bytes calldata) {\n        return MetaContext._msgData();\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-12-tigris-findings.json",
                "Location": "Position contract's mint() function",
                "Type": "Reentrancy",
                "Description": "The mint() function in the Position contract doesn't follow check-effect-interaction pattern and it's possible to perform reentrancy attack during mint() function which can lead to removing of the other user's limit orders or stealing contract funds because initId is set low value.",
                "Repair": "Follow the check-effect-interaction pattern"
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BondNFT is ERC721Enumerable, Ownable {\n    \n    uint constant private DAY = 24 * 60 * 60;\n\n    struct Bond {\n        uint id;\n        address owner;\n        address asset;\n        uint amount;\n        uint mintEpoch;\n        uint mintTime;\n        uint expireEpoch;\n        uint pending;\n        uint shares;\n        uint period;\n        bool expired;\n    }\n\n    mapping(address => uint256) public epoch;\n    uint private totalBonds;\n    string public baseURI;\n    address public manager;\n    address[] public assets;\n\n    mapping(address => bool) public allowedAsset;\n    mapping(address => uint) private assetsIndex;\n    mapping(uint256 => mapping(address => uint256)) private bondPaid;\n    mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare\n    mapping(uint => Bond) private _idToBond;\n    mapping(address => uint) public totalShares;\n    mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount\n\n    constructor(\n        string memory _setBaseURI,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) {\n        baseURI = _setBaseURI;\n    }\n\n    /**\n     * @notice Create a bond\n     * @dev Should only be called by a manager contract\n     * @param _asset tigAsset token to lock\n     * @param _amount tigAsset amount\n     * @param _period time to lock for in days\n     * @param _owner address to receive the bond\n     * @return id ID of the minted bond\n     */\n    function createLock(\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _owner\n    ) external onlyManager() returns(uint id) {\n        require(allowedAsset[_asset], \"!Asset\");\n        unchecked {\n            uint shares = _amount * _period / 365;\n            uint expireEpoch = epoch[_asset] + _period;\n            id = ++totalBonds;\n            totalShares[_asset] += shares;\n            Bond memory _bond = Bond(\n                id,             // id\n                address(0),     // owner\n                _asset,         // tigAsset token\n                _amount,        // tigAsset amount\n                epoch[_asset],  // mint epoch\n                block.timestamp,// mint timestamp\n                expireEpoch,    // expire epoch\n                0,              // pending\n                shares,         // linearly scaling share of rewards\n                _period,        // lock period\n                false           // is expired boolean\n            );\n            _idToBond[id] = _bond;\n            _mint(_owner, _bond);\n        }\n        emit Lock(_asset, _amount, _period, _owner, id);\n    }\n\n    /** \n     * @notice Extend the lock period and/or amount of a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _asset tigAsset token address\n     * @param _amount amount of tigAsset being added\n     * @param _period days being added to the bond\n     * @param _sender address extending the bond\n     */\n    function extendLock(\n        uint _id,\n        address _asset,\n        uint _amount,\n        uint _period,\n        address _sender\n    ) external onlyManager() {\n        Bond memory bond = idToBond(_id);\n        Bond storage _bond = _idToBond[_id];\n        require(bond.owner == _sender, \"!owner\");\n        require(!bond.expired, \"Expired\");\n        require(bond.asset == _asset, \"!BondAsset\");\n        require(bond.pending == 0);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(bond.period+_period <= 365, \"MAX PERIOD\");\n        unchecked {\n            uint shares = (bond.amount + _amount) * (bond.period + _period) / 365;\n            uint expireEpoch = block.timestamp/DAY + bond.period + _period;\n            totalShares[bond.asset] += shares-bond.shares;\n            _bond.shares = shares;\n            _bond.amount += _amount;\n            _bond.expireEpoch = expireEpoch;\n            _bond.period += _period;\n            _bond.mintTime = block.timestamp;\n            _bond.mintEpoch = epoch[bond.asset];\n            bondPaid[_id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * _bond.shares / 1e18;\n        }\n        emit ExtendLock(_period, _amount, _sender,  _id);\n    }\n\n    /**\n     * @notice Release a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond\n     * @param _releaser address initiating the release of the bond\n     * @return amount amount of tigAsset returned\n     * @return lockAmount amount of tigAsset locked in the bond\n     * @return asset tigAsset token released\n     * @return _owner bond owner\n     */\n    function release(\n        uint _id,\n        address _releaser\n    ) external onlyManager() returns(uint amount, uint lockAmount, address asset, address _owner) {\n        Bond memory bond = idToBond(_id);\n        require(bond.expired, \"!expire\");\n        if (_releaser != bond.owner) {\n            unchecked {\n                require(bond.expireEpoch + 7 < epoch[bond.asset], \"Bond owner priority\");\n            }\n        }\n        amount = bond.amount;\n        unchecked {\n            totalShares[bond.asset] -= bond.shares;\n            (uint256 _claimAmount,) = claim(_id, bond.owner);\n            amount += _claimAmount;\n        }\n        asset = bond.asset;\n        lockAmount = bond.amount;\n        _owner = bond.owner;\n        _burn(_id);\n        emit Release(asset, lockAmount, _owner, _id);\n    }\n    /**\n     * @notice Claim rewards from a bond\n     * @dev Should only be called by a manager contract\n     * @param _id ID of the bond to claim rewards from\n     * @param _claimer address claiming rewards\n     * @return amount amount of tigAsset claimed\n     * @return tigAsset tigAsset token address\n     */\n    function claim(\n        uint _id,\n        address _claimer\n    ) public onlyManager() returns(uint amount, address tigAsset) {\n        Bond memory bond = idToBond(_id);\n        require(_claimer == bond.owner, \"!owner\");\n        amount = bond.pending;\n        tigAsset = bond.asset;\n        unchecked {\n            if (bond.expired) {\n                uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]);\n                if (totalShares[bond.asset] > 0) {\n                    accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset];\n                }\n            }\n            bondPaid[_id][bond.asset] += amount;\n        }\n        IERC20(tigAsset).transfer(manager, amount);\n        emit ClaimFees(tigAsset, amount, _claimer, _id);\n    }\n\n    /**\n     * @notice Claim user debt left from bond transfer\n     * @dev Should only be called by a manager contract\n     * @param _user user address\n     * @param _tigAsset tigAsset token address\n     * @return amount amount of tigAsset claimed\n     */\n    function claimDebt(\n        address _user,\n        address _tigAsset\n    ) public onlyManager() returns(uint amount) {\n        amount = userDebt[_user][_tigAsset];\n        userDebt[_user][_tigAsset] = 0;\n        IERC20(_tigAsset).transfer(manager, amount);\n        emit ClaimDebt(_tigAsset, amount, _user);\n    }\n\n    /**\n     * @notice Distribute rewards to bonds\n     * @param _tigAsset tigAsset token address\n     * @param _amount tigAsset amount\n     */\n    function distribute(\n        address _tigAsset,\n        uint _amount\n    ) external {\n        if (totalShares[_tigAsset] == 0 || !allowedAsset[_tigAsset]) return;\n        IERC20(_tigAsset).transferFrom(_msgSender(), address(this), _amount);\n        unchecked {\n            uint aEpoch = block.timestamp / DAY;\n            if (aEpoch > epoch[_tigAsset]) {\n                for (uint i=epoch[_tigAsset]; i<aEpoch; i++) {\n                    epoch[_tigAsset] += 1;\n                    accRewardsPerShare[_tigAsset][i+1] = accRewardsPerShare[_tigAsset][i];\n                }\n            }\n            accRewardsPerShare[_tigAsset][aEpoch] += _amount * 1e18 / totalShares[_tigAsset];\n        }\n        emit Distribution(_tigAsset, _amount);\n    }\n\n    /**\n     * @notice Get all data for a bond\n     * @param _id ID of the bond\n     * @return bond Bond object\n     */\n    function idToBond(uint256 _id) public view returns (Bond memory bond) {\n        bond = _idToBond[_id];\n        bond.owner = ownerOf(_id);\n        bond.expired = bond.expireEpoch <= epoch[bond.asset] ? true : false;\n        unchecked {\n            uint _accRewardsPerShare = accRewardsPerShare[bond.asset][bond.expired ? bond.expireEpoch-1 : epoch[bond.asset]];\n            bond.pending = bond.shares * _accRewardsPerShare / 1e18 - bondPaid[_id][bond.asset];\n        }\n    }\n\n    /*\n     * @notice Get expired boolean for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function isExpired(uint256 _id) public view returns (bool) {\n        Bond memory bond = _idToBond[_id];\n        return bond.expireEpoch <= epoch[bond.asset] ? true : false;\n    }\n\n    /*\n     * @notice Get pending rewards for a bond\n     * @param _id ID of the bond\n     * @return bool true if bond is expired\n     */\n    function pending(\n        uint256 _id\n    ) public view returns (uint256) {\n        return idToBond(_id).pending;\n    }\n\n    function totalAssets() public view returns (uint256) {\n        return assets.length;\n    }\n\n    /*\n     * @notice Gets an array of all whitelisted token addresses\n     * @return address array of addresses\n     */\n    function getAssets() public view returns (address[] memory) {\n        return assets;\n    }\n\n    function _baseURI() internal override view returns (string memory) {\n        return baseURI;\n    }\n\n    function safeTransferMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _transfer(_msgSender(), _to, _ids[i]);\n            }\n        }\n    }\n\n    function safeTransferFromMany(address _from, address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                safeTransferFrom(_from, _to, _ids[i]);\n            }\n        }\n    }\n\n    function approveMany(address _to, uint[] calldata _ids) external {\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                approve(_to, _ids[i]);\n            }\n        }\n    }\n\n    function _mint(\n        address to,\n        Bond memory bond\n    ) internal {\n        unchecked {\n            bondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18;\n        }\n        _mint(to, bond.id);\n    }\n\n    function _burn(\n        uint256 _id\n    ) internal override {\n        delete _idToBond[_id];\n        super._burn(_id);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 _id\n    ) internal override {\n        Bond memory bond = idToBond(_id);\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(!bond.expired, \"Expired!\");\n        unchecked {\n            require(block.timestamp > bond.mintTime + 300, \"Recent update\");\n            userDebt[from][bond.asset] += bond.pending;\n            bondPaid[_id][bond.asset] += bond.pending;\n        }\n        super._transfer(from, to, _id);\n    }\n\n    function balanceIds(address _user) public view returns (uint[] memory) {\n        uint[] memory _ids = new uint[](balanceOf(_user));\n        unchecked {\n            for (uint i=0; i<_ids.length; i++) {\n                _ids[i] = tokenOfOwnerByIndex(_user, i);\n            }\n        }\n        return _ids;\n    }\n\n    function addAsset(address _asset) external onlyOwner {\n        require(assets.length == 0 || assets[assetsIndex[_asset]] != _asset, \"Already added\");\n        assetsIndex[_asset] = assets.length;\n        assets.push(_asset);\n        allowedAsset[_asset] = true;\n        epoch[_asset] = block.timestamp/DAY;\n    }\n\n    function setAllowedAsset(address _asset, bool _bool) external onlyOwner {\n        require(assets[assetsIndex[_asset]] == _asset, \"Not added\");\n        allowedAsset[_asset] = _bool;\n    }\n\n    function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n        baseURI = _newBaseURI;\n    }\n\n    function setManager(\n        address _manager\n    ) public onlyOwner() {\n        manager = _manager;\n    }\n\n    modifier onlyManager() {\n        require(msg.sender == manager, \"!manager\");\n        _;\n    }\n\n    event Distribution(address _tigAsset, uint256 _amount);\n    event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id);\n    event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id);\n    event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id);\n    event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id);\n    event ClaimDebt(address _tigAsset, uint256 _amount, address _owner);\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "code4rena2\\2022-12-tigris-findings.json",
                "Location": "BondNFT.claim() function",
                "Type": "Reentrancy",
                "Description": "A malicious user can exploit this vulnerability to steal all assets in BondNFT contract by repeatedly calling claim() function of an expired bond, which updates accRewardsPerShare and increases pending rewards of all other users.",
                "Repair": "Forcing an expired bond to release() and adding a check to claim() function to revert if an expired bond is claimed"
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RealEstatePlatform {\n\n    mapping(address => uint) public propertyPrices;\n    mapping(address => uint) public ownerBalances;\n\n    function listProperty(uint price) public {\n        propertyPrices[msg.sender] = price;\n    }\n\n    function buyProperty(address payable propertyOwner) public payable {\n        require(msg.value >= propertyPrices[propertyOwner], 'Insufficient funds to buy this property.');\n\n        ownerBalances[propertyOwner] += msg.value;\n\n        (bool success,) = propertyOwner.call{value: ownerBalances[propertyOwner]}('');\n        require(success, 'Transfer failed.');\n\n        ownerBalances[propertyOwner] = 0;\n        propertyPrices[propertyOwner] = 0;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "1",
            "Location": "(bool success,) = propertyOwner.call{value: ownerBalances[propertyOwner]}('');\nrequire(success, 'Transfer failed.');",
            "Type": "Reentrancy",
            "Description": "The function buyProperty has a reentrancy vulnerability because it uses a low-level call to transfer ether to propertyOwner, which can potentially trigger the fallback function in the recipient's contract. If the recipient contract's fallback function in turn calls back into buyProperty, it could potentially withdraw more ether than intended.",
            "Repair": "The best practice is to apply the Checks-Effects-Interactions pattern. This can be done by moving the ether transfer to the end of the function, after all the internal state has been updated. Additionally, use the transfer() function instead of call.value() to prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CryptoExchange {\n\n    mapping(address => uint) public tokenBalances;\n    mapping(address => mapping(address => uint)) public tokenAllowances;\n\n    event Deposit(address indexed user, uint amount);\n    event Withdraw(address indexed user, uint amount);\n\n    function depositTokens(address token, uint amount) public {\n        require(tokenBalances[msg.sender] >= amount, 'Insufficient token balance.');\n        tokenBalances[msg.sender] -= amount;\n        tokenAllowances[token][msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdrawTokens(address token, uint amount) public {\n        require(tokenAllowances[token][msg.sender] >= amount, 'Insufficient allowance.');\n\n        tokenAllowances[token][msg.sender] -= amount;\n        tokenBalances[msg.sender] += amount;\n\n        (bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Transfer failed.');\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "2",
            "Location": "(bool success,) = msg.sender.call{value: amount}('');\nrequire(success, 'Transfer failed.');",
            "Type": "Reentrancy",
            "Description": "In the function withdrawTokens, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to msg.sender, which can potentially trigger the fallback function in the recipient's contract. If the recipient contract's fallback function in turn calls back into withdrawTokens, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineMarketplace {\n\n    struct Product {\n        string name;\n        uint price;\n        address payable owner;\n    }\n\n    mapping(uint => Product) public products;\n\n    event ProductPurchased(uint productId, address buyer, uint price);\n\n    function addProduct(string memory name, uint price) public {\n        uint newProductId = uint(keccak256(abi.encodePacked(name, msg.sender)));\n        products[newProductId] = Product(name, price, payable(msg.sender));\n    }\n\n    function buyProduct(uint productId) public payable {\n        Product storage product = products[productId];\n\n        require(msg.value >= product.price, 'Insufficient funds to buy this product.');\n\n        (bool transferSucceeded,) = product.owner.call{value: msg.value}('');\n        require(transferSucceeded, 'Failed to transfer funds to the product owner.');\n\n        emit ProductPurchased(productId, msg.sender, msg.value);\n\n        delete products[productId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "3",
            "Location": "(bool transferSucceeded,) = product.owner.call{value: msg.value}('');\nrequire(transferSucceeded, 'Failed to transfer funds to the product owner.');",
            "Type": "Reentrancy",
            "Description": "In the function buyProduct, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the product owner, which can potentially trigger the fallback function in the owner's contract. If the owner's contract's fallback function in turn calls back into buyProduct, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DigitalBank {\n    mapping(address => uint) public accountBalances;\n    event Withdrawal(address indexed accountHolder, uint amount);\n\n    function deposit() public payable {\n        accountBalances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint amount) public {\n        require(accountBalances[msg.sender] >= amount, 'Insufficient funds.');\n\n        (bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Failed to transfer Ether.');\n\n        accountBalances[msg.sender] -= amount;\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    function balance() public view returns (uint) {\n        return accountBalances[msg.sender];\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "4",
            "Location": "(bool success,) = msg.sender.call{value: amount}('');\nrequire(success, 'Failed to transfer Ether.');",
            "Type": "Reentrancy",
            "Description": "In the function withdraw, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to msg.sender, which can potentially trigger the fallback function in the recipient's contract. If the recipient contract's fallback function in turn calls back into withdraw, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CrowdfundingCampaign {\n\n    struct Contribution {\n        uint amount;\n        address payable contributor;\n    }\n\n    mapping(uint => Contribution) public contributions;\n    uint public contributionsCount = 0;\n    uint public totalFunds = 0;\n\n    function contribute() public payable {\n        uint newContributionId = contributionsCount++;\n        contributions[newContributionId] = Contribution(msg.value, payable(msg.sender));\n        totalFunds += msg.value;\n    }\n\n    function refund(uint contributionId) public {\n        Contribution storage contrib = contributions[contributionId];\n\n        require(contrib.contributor == msg.sender, 'Not the contributor.');\n\n        (bool success,) = contrib.contributor.call{value: contrib.amount}('');\n        require(success, 'Failed to refund.');\n\n        totalFunds -= contrib.amount;\n        delete contributions[contributionId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "5",
            "Location": "(bool success,) = contrib.contributor.call{value: contrib.amount}('');\nrequire(success, 'Failed to refund.');",
            "Type": "Reentrancy",
            "Description": "In the function refund, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the contributor, which can potentially trigger the fallback function in the contributor's contract. If the contributor's contract's fallback function in turn calls back into refund, it could potentially withdraw more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineMarket {\n\n    struct Item {\n        uint price;\n        address payable seller;\n    }\n\n    mapping(uint => Item) public items;\n    uint public itemCount = 0;\n\n    function addItem(uint price) public {\n        uint newItemId = itemCount++;\n        items[newItemId] = Item(price, payable(msg.sender));\n    }\n\n    function buyItem(uint itemId) public payable {\n        Item storage item = items[itemId];\n\n        require(msg.value >= item.price, 'Not enough Ether sent.');\n\n        (bool success,) = item.seller.call{value: item.price}('');\n        require(success, 'Failed to transfer Ether to seller.');\n\n        delete items[itemId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "6",
            "Location": "(bool success,) = item.seller.call{value: item.price}('');\nrequire(success, 'Failed to transfer Ether to seller.');",
            "Type": "Reentrancy",
            "Description": "In the function buyItem, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the seller, which can potentially trigger the fallback function in the seller's contract. If the seller's contract's fallback function in turn calls back into buyItem, it could potentially purchase more items than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RealEstateAgency {\n\n    struct Property {\n        uint price;\n        address payable owner;\n    }\n\n    mapping(uint => Property) public properties;\n    uint public propertyCount = 0;\n\n    function listProperty(uint price) public {\n        uint newPropertyId = propertyCount++;\n        properties[newPropertyId] = Property(price, payable(msg.sender));\n    }\n\n    function purchaseProperty(uint propertyId) public payable {\n        Property storage property = properties[propertyId];\n\n        require(msg.value >= property.price, 'Not enough Ether sent.');\n\n        (bool success,) = property.owner.call{value: property.price}('');\n        require(success, 'Failed to transfer Ether to owner.');\n\n        delete properties[propertyId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "7",
            "Location": "(bool success,) = property.owner.call{value: property.price}('');\nrequire(success, 'Failed to transfer Ether to owner.');",
            "Type": "Reentrancy",
            "Description": "In the function purchaseProperty, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the property owner, which can potentially trigger the fallback function in the owner's contract. If the owner's contract's fallback function in turn calls back into purchaseProperty, it could potentially purchase more properties than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineAuction {\n\n    struct Bid {\n        uint amount;\n        address payable bidder;\n    }\n\n    mapping(uint => Bid) public bids;\n    uint public bidCount = 0;\n\n    function makeBid(uint amount) public payable {\n        uint newBidId = bidCount++;\n        bids[newBidId] = Bid(amount, payable(msg.sender));\n    }\n\n    function acceptBid(uint bidId) public {\n        Bid storage bid = bids[bidId];\n\n        (bool success,) = bid.bidder.call{value: bid.amount}('');\n        require(success, 'Failed to transfer Ether to bidder.');\n\n        delete bids[bidId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "8",
            "Location": "(bool success,) = bid.bidder.call{value: bid.amount}('');\nrequire(success, 'Failed to transfer Ether to bidder.');",
            "Type": "Reentrancy",
            "Description": "In the function acceptBid, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the bidder, which can potentially trigger the fallback function in the bidder's contract. If the bidder's contract's fallback function in turn calls back into acceptBid, it could potentially cause unexpected behavior.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract OnlineMarketplace {\n\n    struct Product {\n        uint price;\n        address payable seller;\n    }\n\n    mapping(uint => Product) public products;\n    uint public productCount = 0;\n\n    function listProduct(uint price) public {\n        uint newProductId = productCount++;\n        products[newProductId] = Product(price, payable(msg.sender));\n    }\n\n    function purchaseProduct(uint productId) public payable {\n        Product storage product = products[productId];\n\n        require(msg.value >= product.price, 'Not enough Ether sent.');\n\n        (bool success,) = product.seller.call{value: product.price}('');\n        require(success, 'Failed to transfer Ether to seller.');\n\n        delete products[productId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "9",
            "Location": "(bool success,) = product.seller.call{value: product.price}('');\nrequire(success, 'Failed to transfer Ether to seller.');",
            "Type": "Reentrancy",
            "Description": "In the function purchaseProduct, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the product seller, which can potentially trigger the fallback function in the seller's contract. If the seller's contract's fallback function in turn calls back into purchaseProduct, it could potentially purchase more products than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DigitalExchange {\n\n    struct Share {\n        uint price;\n        address payable owner;\n    }\n\n    mapping(uint => Share) public shares;\n    uint public shareCount = 0;\n\n    function listShare(uint price) public {\n        uint newShareId = shareCount++;\n        shares[newShareId] = Share(price, payable(msg.sender));\n    }\n\n    function buyShare(uint shareId) public payable {\n        Share storage share = shares[shareId];\n\n        require(msg.value >= share.price, 'Not enough Ether sent.');\n\n        (bool success,) = share.owner.call{value: share.price}('');\n        require(success, 'Failed to transfer Ether to owner.');\n\n        delete shares[shareId];\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "10",
            "Location": "(bool success,) = share.owner.call{value: share.price}('');\nrequire(success, 'Failed to transfer Ether to owner.');",
            "Type": "Reentrancy",
            "Description": "In the function buyShare, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the share owner, which can potentially trigger the fallback function in the owner's contract. If the owner's contract's fallback function in turn calls back into buyShare, it could potentially buy more shares than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract FineArtAuction {\n\n    struct Artwork {\n        uint bid;\n        address payable artist;\n    }\n\n    mapping(uint => Artwork) public artworks;\n    uint public artworkCount = 0;\n\n    function listArtwork() public {\n        uint newArtworkId = artworkCount++;\n        artworks[newArtworkId] = Artwork(0, payable(msg.sender));\n    }\n\n    function placeBid(uint artworkId) public payable {\n        Artwork storage artwork = artworks[artworkId];\n\n        require(msg.value > artwork.bid, 'Bid is not high enough.');\n\n        (bool success,) = artwork.artist.call{value: msg.value}('');\n        require(success, 'Failed to transfer Ether to artist.');\n\n        artwork.bid = msg.value;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "11",
            "Location": "(bool success,) = artwork.artist.call{value: msg.value}('');\nrequire(success, 'Failed to transfer Ether to artist.');",
            "Type": "Reentrancy",
            "Description": "In the function placeBid, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the artist, which can potentially trigger the fallback function in the artist's contract. If the artist's contract's fallback function in turn calls back into placeBid, it could potentially place more bids than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CrowdfundingCampaign {\n\n    struct Project {\n        uint fundingGoal;\n        uint amountRaised;\n        address payable creator;\n    }\n\n    mapping(uint => Project) public projects;\n    uint public projectCount = 0;\n\n    function createProject(uint fundingGoal) public {\n        uint newProjectId = projectCount++;\n        projects[newProjectId] = Project(fundingGoal, 0, payable(msg.sender));\n    }\n\n    function contribute(uint projectId) public payable {\n        Project storage project = projects[projectId];\n\n        require(msg.value + project.amountRaised <= project.fundingGoal, 'Funding goal exceeded.');\n\n        (bool success,) = project.creator.call{value: msg.value}('');\n        require(success, 'Failed to transfer Ether to project creator.');\n\n        project.amountRaised += msg.value;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "12",
            "Location": "(bool success,) = project.creator.call{value: msg.value}('');\nrequire(success, 'Failed to transfer Ether to project creator.');",
            "Type": "Reentrancy",
            "Description": "In the function contribute, there is a reentrancy vulnerability because it uses a low-level call to transfer ether to the project creator, which can potentially trigger the fallback function in the creator's contract. If the creator's contract's fallback function in turn calls back into contribute, it could potentially contribute more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CapitalVenture {\n\n    struct Investor {\n        uint invested;\n        uint lastInvest;\n        address payable addr;\n    }\n\n    mapping(address => Investor) public investors;\n\n    function invest() public payable {\n        Investor storage investor = investors[msg.sender];\n        investor.addr = payable(msg.sender);\n        investor.invested += msg.value;\n        investor.lastInvest = block.timestamp;\n\n        (bool success,) = investor.addr.call{value: msg.value}('');\n        require(success, 'Failed to transfer Ether.');\n    }\n\n    function getInvestedAmount(address addr) public view returns (uint) {\n        return investors[addr].invested;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "13",
            "Location": "(bool success,) = investor.addr.call{value: msg.value}('');\nrequire(success, 'Failed to transfer Ether.');",
            "Type": "Reentrancy",
            "Description": "In the invest function, there is a reentrancy vulnerability because it uses a low-level call to transfer ether back to the investor, potentially triggering the fallback function of the investor's contract. If the investor's contract's fallback function in turn calls back into invest, it could potentially invest more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract FundRaiser {\n\n    struct Donor {\n        uint amount;\n        address payable addr;\n    }\n\n    mapping(address => Donor) public donors;\n\n    function donate() public payable {\n        Donor storage donor = donors[msg.sender];\n        donor.addr = payable(msg.sender);\n        donor.amount += msg.value;\n\n        (bool success,) = donor.addr.call{value: msg.value / 10}('');\n        require(success, 'Failed to transfer Ether.');\n    }\n\n    function getDonationAmount(address addr) public view returns (uint) {\n        return donors[addr].amount;\n    }\n\n}",
        "VulnerabilityDesc": {
            "Name": "14",
            "Location": "(bool success,) = donor.addr.call{value: msg.value / 10}('');\nrequire(success, 'Failed to transfer Ether.');",
            "Type": "Reentrancy",
            "Description": "In the donate function, there is a reentrancy vulnerability because it uses a low-level call to transfer a portion of the donated ether back to the donor, potentially triggering the fallback function of the donor's contract. If the donor's contract's fallback function in turn calls back into donate, it could potentially donate more ether than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract MembershipClub {\n    mapping(address => uint) public memberFees;\n\n    function joinClub() public payable {\n        memberFees[msg.sender] += msg.value;\n        require(memberFees[msg.sender] >= 1 ether, 'Membership fee is at least 1 Ether');\n\n        (bool sent,) = msg.sender.call{value: msg.value / 10}('');\n        require(sent, 'Failed to send Ether');\n    }\n\n    function getFee(address member) public view returns (uint) {\n        return memberFees[member];\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "15",
            "Location": "(bool sent,) = msg.sender.call{value: msg.value / 10}('');\n        require(sent, 'Failed to send Ether');",
            "Type": "Reentrancy",
            "Description": "In the joinClub function, there is a reentrancy vulnerability because it uses a low-level call to refund part of the membership fee to the caller, potentially triggering the fallback function of the caller's contract. If the caller's contract's fallback function in turn calls back into joinClub, it could potentially join the club with less fee than intended.",
            "Repair": "Apply the Checks-Effects-Interactions pattern by moving the ether transfer to the end of the function, after all internal state has been updated. Additionally, use the transfer() function instead of call.value() to limit the gas available to the recipient and prevent the recipient contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract AssetPortfolio {\n    mapping(address => uint) public investments;\n\n    function invest() public payable {\n        investments[msg.sender] += msg.value;\n    }\n\n    function divest(uint amount) public {\n        require(investments[msg.sender] >= amount, 'Insufficient investment');\n        investments[msg.sender] -= amount;\n        (bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Transfer failed');\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "16",
            "Location": "(bool success,) = msg.sender.call{value: amount}('');\n        require(success, 'Transfer failed');",
            "Type": "Reentrancy",
            "Description": "In the divest function, there is a reentrancy vulnerability. Before updating the internal state (i.e., the investor's investment amount), transferring money to the investor may trigger the fallback function of his contract, which may cause the investor to withdraw more than his original investment amount if the function calls divest again.",
            "Repair": "Adopt the Checks-Effects-Interactions pattern, move the ether transfer to the end of the function, and execute it after all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the gas available to the payee and prevent the payee's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract WealthManager {\n    mapping(address => uint) public deposits;\n\n    function makeDeposit() public payable {\n        deposits[msg.sender] += msg.value;\n    }\n\n    function makeWithdrawal(uint _amount) public {\n        require(deposits[msg.sender] >= _amount, 'Insufficient deposit');\n        deposits[msg.sender] -= _amount;\n        (bool success,) = msg.sender.call{value: _amount}('');\n        require(success, 'Transfer failed');\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "17",
            "Location": "(bool success,) = msg.sender.call{value: _amount}('');\n        require(success, 'Transfer failed');",
            "Type": "Reentrancy",
            "Description": "In the makeWithdrawal function, there is a reentrancy vulnerability. Before updating the internal state (i.e. the user's deposit), transferring funds to the user may trigger the fallback function of their contract, which may cause the user to withdraw more than their original deposit if the function calls makeWithdrawal again.",
            "Repair": "The way to fix it is to use the Checks-Effects-Interactions pattern, move the ether transfer to the end of the function, and execute it after all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the gas available to the payee and prevent the payee's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract AssetLocker {\n    mapping(address => uint256) public assetBalance;\n\n    event AssetDeposited(address indexed depositor, uint256 amount);\n    event AssetWithdrawn(address indexed withdrawer, uint256 amount);\n\n    function depositAsset() public payable {\n        assetBalance[msg.sender] += msg.value;\n        emit AssetDeposited(msg.sender, msg.value);\n    }\n\n    function withdrawAsset(uint256 amount) public {\n        require(assetBalance[msg.sender] >= amount, 'Not enough asset to withdraw');\n        (bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Asset transfer failed');\n        assetBalance[msg.sender] -= amount;\n        emit AssetWithdrawn(msg.sender, amount);\n    }\n\n    function getBalance() public view returns(uint256) {\n        return assetBalance[msg.sender];\n    }\n\n    function totalAssets() public view returns(uint256) {\n        return address(this).balance;\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "18",
            "Location": "(bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Asset transfer failed');\n        assetBalance[msg.sender] -= amount;",
            "Type": "Reentrancy",
            "Description": "In the withdrawAsset function, there is a reentrancy vulnerability. Before updating the internal state (i.e. the user's asset balance), transferring money to the user may trigger the fallback function of their contract, which may allow the user to withdraw more than their original deposit if the function calls withdrawAsset again.",
            "Repair": "The way to fix it is to use the Checks-Effects-Interactions pattern, move the ether transfer to the end of the function, and execute it after all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the gas available to the payee and prevent the payee's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract PropertyRegistry {\n    mapping(address => uint256) public propertyBalance;\n    address payable public registryOwner;\n\n    constructor() {\n        registryOwner = payable(msg.sender);\n    }\n\n    function deposit() public payable {\n        propertyBalance[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(propertyBalance[msg.sender] >= amount, 'Insufficient balance');\n        (bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Failed to send ether');\n        propertyBalance[msg.sender] -= amount;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return propertyBalance[msg.sender];\n    }\n\n    function contractBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function closeRegistry() public {\n        require(msg.sender == registryOwner, 'Only owner can close the registry');\n        selfdestruct(registryOwner);\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "19",
            "Location": "(bool sent, ) = msg.sender.call{value: amount}('');\n        require(sent, 'Failed to send ether');\n        propertyBalance[msg.sender] -= amount;",
            "Type": "Reentrancy",
            "Description": "In the withdraw function, there is a reentrancy vulnerability. Before updating the internal state (i.e., the user's property balance), sending ether to the user could trigger their contract's fallback function. If that function calls withdraw again, it could allow the user to withdraw more than their original deposit.",
            "Repair": "The way to fix it is to use the Checks-Effects-Interactions pattern, moving the ether transfer to the end of the function when all internal states have been updated. Also, use the transfer() function instead of call.value() to limit the amount of gas available to the recipient, preventing the recipient's contract from executing a lot of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CashbackLoyaltyProgram {\n    mapping(address => uint256) public loyaltyPoints;\n    mapping(address => uint256) public etherBalance;\n    address payable public companyWallet;\n\n    constructor() {\n        companyWallet = payable(msg.sender);\n    }\n\n    function purchaseItem() public payable {\n        companyWallet.transfer(msg.value);\n        loyaltyPoints[msg.sender] += msg.value / 100;\n    }\n\n    function redeemPoints(uint256 points) public {\n        require(loyaltyPoints[msg.sender] >= points, 'Not enough loyalty points');\n        uint256 etherToRedeem = points / 100;\n        require(etherBalance[companyWallet] >= etherToRedeem, 'Not enough funds in the company wallet');\n        (bool sent, ) = msg.sender.call{value: etherToRedeem}('');\n        require(sent, 'Failed to send Ether');\n        loyaltyPoints[msg.sender] -= points;\n        etherBalance[companyWallet] -= etherToRedeem;\n    }\n\n    function getPoints() public view returns (uint256) {\n        return loyaltyPoints[msg.sender];\n    }\n\n    function getCompanyBalance() public view returns (uint256) {\n        return etherBalance[companyWallet];\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "20",
            "Location": "(bool sent, ) = msg.sender.call{value: etherToRedeem}('');\n        require(sent, 'Failed to send Ether');\n        loyaltyPoints[msg.sender] -= points;\n        etherBalance[companyWallet] -= etherToRedeem;",
            "Type": "Reentrancy",
            "Description": "In the redeemPoints function, a reentrancy vulnerability is present. Before the internal state (i.e., the user's loyalty points and the company's ether balance) is updated, ether is sent to the user. If the user's contract's fallback function is triggered and calls redeemPoints again, it could allow the user to redeem more than their original loyalty points for ether.",
            "Repair": "To fix it, the Checks-Effects-Interactions pattern should be used, moving the ether transfer to the end of the function after all internal states have been updated. It would be safer to use the transfer() function instead of call.value() to limit the amount of gas available to the recipient, thus preventing the recipient's contract from executing a large amount of code."
        }
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract VentureCapital {\n    mapping(address => uint) public investments;\n    address payable public entrepreneur;\n\n    constructor() {\n        entrepreneur = payable(msg.sender);\n    }\n\n    function invest() public payable {\n        investments[msg.sender] += msg.value;\n    }\n\n    function profitDistribution() public {\n        require(msg.sender == entrepreneur, 'Only the entrepreneur can distribute profits');\n        for (address investor: getInvestors()) {\n            uint profitShare = investments[investor] / 10;\n            (bool sent, ) = investor.call{value: profitShare}('');\n            require(sent, 'Failed to send Ether');\n        }\n    }\n\n    function getInvestors() public view returns (address[] memory) {\n        address[] memory investors = new address[](address(this).balance);\n        uint count = 0;\n        for (uint i = 0; i < investors.length; i++) {\n            if (investments[investors[i]] > 0) {\n                investors[count] = investors[i];\n                count++;\n            }\n        }\n        return investors;\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}",
        "VulnerabilityDesc": {
            "Name": "21",
            "Location": "(bool sent, ) = investor.call{value: profitShare}('');\n        require(sent, 'Failed to send Ether');",
            "Type": "Reentrancy",
            "Description": "In the profitDistribution function, there is a reentrancy vulnerability. Ether is being sent to investors before the state (i.e., the balance of this contract) is updated. This allows the investor's fallback function to be triggered and call profitDistribution again, possibly leading to a withdrawal of more profits than intended.",
            "Repair": "To mitigate this, one should apply the Checks-Effects-Interactions pattern, ensuring state changes happen prior to calling external contracts. In addition, Solidity's transfer function could be used instead of call.value() to limit the gas provided to the external call, which could limit the potential for reentrancy by preventing the called contract from performing other operations."
        }
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
]