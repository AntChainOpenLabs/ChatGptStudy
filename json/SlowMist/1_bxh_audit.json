[    
    {
    "Code": "function mint(address to) external lock returns (uint liquidity) {\n    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); \n    uint balance0 = IERC20Uniswap(token0).balanceOf(address(this));\n    uint balance1 = IERC20Uniswap(token1).balanceOf(address(this));\n    uint amount0 = balance0.sub(_reserve0);\n    uint amount1 = balance1.sub(_reserve1);\n    bool feeOn = _mintFee(_reserve0, _reserve1);\n    uint _totalSupply = totalSupply; \n    if (_totalSupply == 0) {\n    address migrator = IUniswapV2Factory(factory).migrator();\n    if (msg.sender == migrator) {\n    liquidity = IMigrator(migrator).desiredLiquidity();\n    require(liquidity > 0 && liquidity != uint256(-1), "Bad desired liquidity");\n    } else {\n    require(migrator == address(0), "Must not have migrator");\n    liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n    _mint(address(0), MINIMUM_LIQUIDITY);\n    }\n    } else {\n    liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n    }\n    require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n    _mint(to, liquidity);\n    _update(balance0, balance1, _reserve0, _reserve1);\n    if (feeOn) kLast = uint(reserve0).mul(reserve1); \n    emit Mint(msg.sender, amount0, amount1);\n    }",
    "VulnerabilityDesc": [
        {
            "Name": "Access_Controls",
            "Location": "if (msg.sender == migrator) {\n    liquidity = IMigrator(migrator).desiredLiquidity();\n    require(liquidity > 0 && liquidity != uint256(-1), "Bad desired liquidity");\n",
            "Type": "Access Controls",
            "Description": "Excessive administrator privileges",
            "Repair": "The project party has set the migrator to address 0 (destroy permission), and the owner permission will be transferred through DAO community autonomy in the future"
            }
        ]
    },
    {
    "Code": "function sweepToken(address token,address to) public onlyOwner {\n     uint256 bal = IERC20(token).balanceOf(address(this));\n    require(bal>0,"not enough balance");\n    TransferHelper.safeTransfer(token,to, bal);\n    }\n",
    "VulnerabilityDesc": [
        {
            "Name": "Access_Controls",
            "Location": "function sweepToken(address token,address to) public onlyOwner {\n     uint256 bal = IERC20(token).balanceOf(address(this));\n    require(bal>0,"not enough balance");\n    TransferHelper.safeTransfer(token,to, bal);\n    }\n",
            "Type": "Access Controls",
            "Description": "Airdrop owner permissions are too large",
            "Repair": "Removed the sweepToken function"
            }
        ]
    },
    {
    "Code": "function mint(address _to, uint256 _amount) public onlyMinter override returns (bool) {\n    if (_amount.add(totalSupply()) > maxSupply) {\n    return false;\n    }\n    _mint(_to, _amount);\n    return true;\n    }\n",
    "VulnerabilityDesc": [
        {
            "Name": "Excessive_Gas_Consumption",
            "Location": "if (_amount.add(totalSupply()) > maxSupply) {\n    return false;\n    }\n",
            "Type": "Excessive Gas Consumption Problem",
            "Description": "Excessive Gas Consumption Problem",
            "Repair": "The project team has modified the if else logic check to require"
            }
        ]
    }
]