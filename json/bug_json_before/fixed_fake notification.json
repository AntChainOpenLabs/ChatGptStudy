[
    {
        "Code": "contract SevenToken is ERC20Interface, Owned, SafeMath {\n string public symbol;\n string public name;\n uint8 public decimals;\n uint public _totalSupply;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n constructor() public payable {\n symbol = \"SEVEN\";\n name = \"Satoshi Nakamoto\";\n decimals = 8;\n _totalSupply = 21000000 * 10 ** uint(decimals);\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n balances[from] = safeSub(balances[from], tokens);\n allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n ITokenReceiver(spender).receiveApproval(msg.sender, tokens, address(this), data);\n return true;\n }\n function () external payable {\n }\n function transferOut () public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_1_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract ICO is ERC20,usingOraclize\n{\n address[] public addresses ;\n// Name of the token\n    string public constant name = \"ROC\";\n// Symbol of token\n    string public constant symbol = \"ROC\"; \n    uint8 public constant decimals = 10;  // decimal places\n    \n      mapping(address => address) public userStructs;\n\n    bytes32 myid_;\n    \n    mapping(bytes32=>bytes32) myidList;\n    \n      uint public totalSupply = 5000000 *10000000000 ;  \n      \n       mapping(address => uint) balances;\n\n      mapping (address => mapping (address => uint)) allowed;\n      \n      address owner;\n      \n      \n      uint one_ether_usd_price;\n      \n        enum State {created , gotapidata,wait}\n          State state;\n          \n          uint256 ether_profit;\n      \n      uint256 profit_per_token;\n      \n      uint256 holder_token_balance;\n      \n      uint256 holder_profit;\n      \n       event Message(uint256 holder_profit);\n\n      \n        // Functions with this modifier can only be executed by the owner\n    modifier onlyOwner() {\n       if (msg.sender != owner) {\n         throw;\n        }\n       _;\n     }\n     \n \n      mapping (bytes32 => address)userAddress;\n    mapping (address => uint)uservalue;\n    mapping (bytes32 => bytes32)userqueryID;\n      \n     \n       event TRANS(address accountAddress, uint amount);\n       event Message(string message,address to_,uint token_amount);\n       \n         event Price(string ethh);\n         event valuee(uint price);\n       \n       function ICO()\n       {\n           owner = msg.sender;\n           balances[owner] = totalSupply;\n          \n       }\n\n         \n       function() payable {\n           \n           \n            TRANS(msg.sender, msg.value); // fire event\n            \n            if(msg.sender != owner)\n            {\n                // kraken api\n          //   oraclize_query(5, \"URL\", \"json(https://api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0\");        \n   \n      bytes32 ID = oraclize_query(\"URL\",\"json(https://min-api.cryptocompare.com/data/price?fsym=ETH&tsyms=USD).USD\");\n   \n             \n              userAddress[ID]=msg.sender;\n              uservalue[msg.sender]=msg.value;\n              userqueryID[ID]=ID;\n            }\n            \n            else if(msg.sender ==owner){\n                \n                  ether_profit = msg.value;\n        \n        profit_per_token = (ether_profit)*(10000000000)/(totalSupply);\n        \n        Message(ether_profit);\n        \n         Message(profit_per_token);\n            \n        if(addresses.length >0)\n        {\n             for (uint i = 0; i < addresses.length; i++) {\n\n                if(addresses[i] !=owner)\n                {\n                 request_dividend(addresses[i]);\n                }\n\n               }\n                }\nfunction request_dividend(address token_holder) payable\n {\n holder_token_balance = balanceOf(token_holder)/10000000000;\n Message(holder_token_balance);\n holder_profit = holder_token_balance * profit_per_token;\n Message(holder_profit);\n Transfer(owner, token_holder , holder_profit); // 1eth = 10 power 18 wei\n token_holder.send(holder_profit); \n }           }",
        "VulnerabilityDesc": [
            {
                "Name": "fake_2_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract HBToken is UnboundedRegularToken {\n uint public totalSupply = 5*10**26;\n uint8 constant public decimals = 18;\n string constant public name = \"Huobi Airdrop HuobiAirdrop.com\";\n string constant public symbol = \"HuobiAirdrop.com\";\n\n function HBToken() {\n balances[msg.sender] = totalSupply;\n Transfer(address(0), msg.sender, totalSupply);\n }\n\n function sendFromContract(address _to, uint _value) returns (bool) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n if (balances[this] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[this] -= _value;\n balances[_to] += _value;\n Transfer(this, _to, _value);\n return true;\n } else { return false; }\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_3_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract DQCoin is ERC20 {\n\n using SafeMath for uint256;\n\n address public owner;\n\n mapping (address => uint256) balances;\n\n mapping (address => mapping (address => uint256)) allowed;\n\n string public name = \"DaQianCoin\";\n string public constant symbol = \"DQC\";\n uint public constant decimals = 18;\n bool public stopped;\n \n modifier stoppable {\n assert(!stopped);\n _;\n }\n \n uint256 public totalSupply = 24000000000*(10**18);\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n event LOCK(address indexed _owner, uint256 _value);\n\n mapping (address => uint256) public lockAddress;\n \n modifier lock(address _add){\n require(_add != address(0));\n uint256 releaseTime = lockAddress[_add];\n if(releaseTime > 0){\n require(block.timestamp >= releaseTime);\n _;\n }else{\n _;\n }\n }\n \n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n \n function DQCoin() public {\n owner = msg.sender;\n balances[msg.sender] = totalSupply;\n }\n\n function stop() onlyOwner public {\n stopped = true;\n }\n function start() onlyOwner public {\n stopped = false;\n }\n \n function lockTime(address _to,uint256 _value) onlyOwner public {\n if(_value > block.timestamp){\n lockAddress[_to] = _value;\n emit LOCK(_to, _value);\n }\n }\n \n function lockOf(address _owner) constant public returns (uint256) {\n return lockAddress[_owner];\n }\n \n function transferOwnership(address _newOwner) onlyOwner public {\n if (_newOwner != address(0)) {\n owner = _newOwner;\n }\n }\n \n function () public payable {\n address myAddress = this;\n }\n\n function balanceOf(address _owner) constant public returns (uint256) {\n return balances[_owner];\n }\n \n function transfer(address _to, uint256 _amount) stoppable lock(msg.sender) public returns (bool success) {\n require(_to != address(0));\n require(_amount <= balances[msg.sender]);\n \n balances[msg.sender] = balances[msg.sender].sub(_amount);\n balances[_to] = balances[_to].add(_amount);\n emit Transfer(msg.sender, _to, _amount);\n return true;\n }\n \n function transferFrom(address _from, uint256 _amount) stoppable lock(_from) public returns (bool success) {\n require(_amount <= balances[_from]);\n require(_amount <= allowed[_from][msg.sender]);\n \n balances[_from] = balances[_from].sub(_amount);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n balances[msg.sender] = balances[msg.sender].add(_amount);\n emit Transfer(_from, msg.sender, _amount);\n return true;\n }\n \n function approve(address _spender, uint256 _value) stoppable lock(_spender) public returns (bool success) {\n if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n \n function allowance(address _owner, address _spender) constant public returns (uint256) {\n return allowed[_owner][_spender];\n }\n \n function withdraw() onlyOwner public {\n address myAddress = this;\n uint256 etherBalance = myAddress.balance;\n owner.transfer(etherBalance);\n }\n \n function kill() onlyOwner public {\n selfdestruct(msg.sender);\n }\n \n function setName(string _name) onlyOwner public {\n name = _name;\n }\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_4_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract OceanToken is ERC20Interface, Owned, SafeMath {\n string public symbol;\n string public name;\n uint8 public decimals;\n uint public _totalSupply;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n constructor() public payable {\n symbol = \"OCEAN\";\n name = \"Ocean Token\";\n decimals = 18;\n _totalSupply = 50000000 * 10 ** uint(decimals);\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n balances[from] = safeSub(balances[from], tokens);\n allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function airDrop(address[] memory recipients, uint tokens) public onlyOwner {\n uint totalDropped = 0;\n require(balances[msg.sender] >= tokens * recipients.length);\n for(uint i = 0; i < recipients.length; i++) {\n balances[msg.sender] -= tokens;\n balances[recipients[i]] += tokens;\n emit Transfer(msg.sender, recipients[i], tokens);\n totalDropped += tokens;\n }\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_5_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract MyToken is Token(\"TANT\",\"Talent Token\",18,50000000000000000000000000),ERC20,ERC223,admined\n{ \n uint256 public sellPrice;\n uint256 public buyPrice;\n function MyToken() public\n {\n _balanceOf[msg.sender] = _totalSupply;\n }\n\n function totalSupply() public constant returns (uint256){\n return _totalSupply; \n }\n \n function findBalance(address _addr) public constant returns (uint) {\n return _balanceOf[_addr];\n }\n\n function _transfer(address _from, address _to, uint256 _value) internal {\n require(_to != 0x0);\n require(_balanceOf[_from] >= _value);\n uint previousBalances = _balanceOf[_from] + _balanceOf[_to];\n _balanceOf[_from] -= _value;\n _balanceOf[_to]+=_value;\n Transfer(_from, _to, _value);\n assert(_balanceOf[_from] +_balanceOf[_to] == previousBalances);\n }\n \n function transfer(address _to, uint256 _value)public{\n if(!isContract(_to))\n {\n _transfer(msg.sender, _to, _value); \n }\n }\n \n function transferFrom(address _from, address _to, uint256 _value)public returns(bool){\n require(_allowances[_from][msg.sender] >= _value);\n {\n _allowances[_from][msg.sender] -= _value;\n _balanceOf[_from]-= _value;\n _balanceOf[_to]+=_value;\n Transfer(_from, _to, _value); \n return true;\n }\n return false;\n }\n\n function transfer(address _to, uint _value, bytes _data)public returns(bool)\n {\n require(_value>0 && _value <= _balanceOf[msg.sender]);\n if(isContract(_to))\n {\n _balanceOf[msg.sender]-= _value;\n _balanceOf[_to]+=_value;\n ERC223ReceivingContract _contract = ERC223ReceivingContract(_to);\n _contract.tokenFallBack(msg.sender,_value,_data);\n Transfer(msg.sender, _to, _value, _data); \n return true;\n }\n return false;\n }\n\n function isContract(address _addr) internal view returns(bool){\n uint codeLength;\n assembly\n {\n codeLength := extcodesize(_addr)\n }\n return codeLength > 0;\n } \n \n function approve(address _spender, uint _value) public returns (bool)\n {\n _allowances[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value); \n return true;\n }\n \n function allowance(address _owner, address _spender) public constant returns(uint)\n {\n return _allowances[_owner][_spender];\n }\n \n function setPrices(uint256 newSellPrice, uint256 newBuyPrice){\n sellPrice = newSellPrice;\n buyPrice = newBuyPrice;\n }\n \n function buy () public payable\n {\n uint256 amount = (msg.value/(1 ether))/ buyPrice;\n require(_balanceOf[this]< amount);\n _balanceOf[msg.sender]+=amount;\n _balanceOf[this]-=amount;\n Transfer(this,msg.sender,amount);\n }\n\n function sell(uint256 amount) public\n {\n require(_balanceOf[msg.sender]<amount);\n _balanceOf[this]+= amount;\n _balanceOf[msg.sender]-=amount;\n require(!msg.sender.send(amount*sellPrice * 1 ether));\n Transfer(msg.sender,this,amount);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_6_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract BTNYToken is Ownable, ERC20 {\n\n using SafeMath for uint256;\n\n // Token properties\n string public name = \"Bitney\"; //Token name\n string public symbol = \"BTNY\"; //Token symbol\n uint256 public decimals = 18;\n\n uint256 public _totalSupply = 1000000000e18;\n\n // Balances for each account\n mapping (address => uint256) balances;\n\n // Owner of account approves the transfer of an amount to another account\n mapping (address => mapping(address => uint256)) allowed;\n\n // Wallet Address of Token\n address public multisig;\n\n constructor () public payable {\n // Initial Owner Wallet Address\n multisig = msg.sender;\n\n balances[multisig] = _totalSupply;\n\n owner = msg.sender;\n }\n\n function withdraw(address to, uint256 value) public onlyOwner {\n require(to != 0x0);\n uint256 transferValue = value.mul(10e18);\n balances[owner] -= transferValue;\n balances[to] += transferValue;\n emit Transfer(owner, to, transferValue);\n }\n\n function () external payable {\n tokensale(msg.sender);\n }\n\n function tokensale(address recipient) public payable {\n require(recipient != 0x0);\n }\n\n function totalSupply() public returns (uint256) {\n return _totalSupply;\n }\n\n function balanceOf(address who) public returns (uint256) {\n return balances[who];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n uint256 transferValue = value.mul(1e18);\n require (balances[msg.sender] >= transferValue && transferValue > 0);\n\n balances[msg.sender] = balances[msg.sender].sub(transferValue);\n balances[to] = balances[to].add(transferValue);\n emit Transfer(msg.sender, to, transferValue);\n return true;\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_7_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract MyToken is Token(\"TLT\",\"Talent Agency Coin\",8,50000000),ERC20,ERC223,admined\n{ \n uint256 public sellPrice;\n uint256 public buyPrice;\n function MyToken() public\n {\n _balanceOf[msg.sender] = _totalSupply;\n }\n\n function totalSupply() public constant returns (uint256){\n return _totalSupply; \n }\n \n function findBalance(address _addr) public constant returns (uint) {\n return _balanceOf[_addr];\n }\n\n function _transfer(address _from, address _to, uint256 _value) internal {\n require(_to != 0x0);\n require(_balanceOf[_from] >= _value);\n uint previousBalances = _balanceOf[_from] + _balanceOf[_to];\n _balanceOf[_from] -= _value;\n _balanceOf[_to]+=_value;\n Transfer(_from, _to, _value);\n assert(_balanceOf[_from] +_balanceOf[_to] == previousBalances);\n }\n \n function transfer(address _to, uint256 _value)public{\n if(!isContract(_to))\n {\n _transfer(msg.sender, _to, _value); \n }\n }\n \n function transferFrom(address _from, address _to, uint256 _value)public returns(bool){\n require(_allowances[_from][msg.sender] >= _value);\n {\n _allowances[_from][msg.sender] -= _value;\n _transfer(_from, _to, _value); \n Transfer(_from, _to, _value); \n return true;\n }\n return false;\n }\n\n function transfer(address _to, uint _value, bytes _data)public returns(bool)\n {\n require(_value>0 && _value <= _balanceOf[msg.sender]);\n if(isContract(_to))\n {\n _balanceOf[msg.sender]-= _value;\n _balanceOf[_to]+=_value;\n ERC223ReceivingContract _contract = ERC223ReceivingContract(_to);\n _contract.tokenFallBack(msg.sender,_value,_data);\n Transfer(msg.sender, _to, _value, _data); \n return true;\n }\n return false;\n }\n\n function isContract(address _addr) internal view returns(bool){\n uint codeLength;\n assembly\n {\n codeLength := extcodesize(_addr)\n }\n return codeLength > 0;\n } \n \n function approve(address _spender, uint _value) public returns (bool)\n {\n _allowances[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value); \n return true;\n }\n \n function allowance(address _owner, address _spender) public constant returns(uint)\n {\n return _allowances[_owner][_spender];\n }\n \n function setPrices(uint256 newSellPrice, uint256 newBuyPrice){\n sellPrice = newSellPrice;\n buyPrice = newBuyPrice;\n }\n \n function buy () public payable\n {\n uint256 amount = (msg.value/(1 ether))/ buyPrice;\n require(_balanceOf[this]< amount);\n _balanceOf[msg.sender]+=amount;\n _balanceOf[this]-=amount;\n Transfer(this,msg.sender,amount);\n }\n\n function sell(uint256 amount) public\n {\n require(_balanceOf[msg.sender]<amount);\n _balanceOf[this]+= amount;\n _balanceOf[msg.sender]-=amount;\n require(!msg.sender.send(amount*sellPrice * 1 ether));\n Transfer(msg.sender,this,amount);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_8_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract ZEROCoin is ERC20\n{ using SafeMath for uint256;\n string public constant name = \"ZEROCoin\";\n string public constant symbol = \"ZERO\";\n uint8 public constant decimals = 18;\n uint public _totalsupply = 1295000000 * 10 ** 18; \n address public owner;\n uint256 public _price_tokn_PRE = 38000;\n uint256 public _price_tokn_ICO= 24000;\n uint256 no_of_tokens;\n uint256 bonus_token;\n uint256 total_token;\n bool stopped = false;\n uint256 public pre_startdate;\n uint256 public ico1_startdate;\n uint256 ico_first;\n uint256 ico_second;\n uint256 ico_third;\n uint256 ico_fourth;\n uint256 pre_enddate;\n \n uint256 public eth_received; \n uint256 maxCap_public = 777000000 * 10 **18; \n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n\n \n enum Stages {\n NOTSTARTED,\n PREICO,\n ICO,\n PAUSED,\n ENDED\n }\n Stages public stage;\n \n modifier atStage(Stages _stage) {\n if (stage != _stage)\n revert();\n _;\n }\n \n modifier onlyOwner() {\n if (msg.sender != owner) {\n revert();\n }\n _;\n }\n\n function ZEROCoin() public\n {\n owner = msg.sender;\n balances[owner] = 518000000 * 10 **18; \n stage = Stages.NOTSTARTED;\n Transfer(0, owner, balances[owner]);\n }\n \n function () public payable \n {\n require(stage != Stages.ENDED);\n require(!stopped && msg.sender != owner);\n if( stage == Stages.PREICO && now <= pre_enddate )\n { \n require (eth_received <= 1500 ether);\n eth_received = (eth_received).add(msg.value);\n no_of_tokens =((msg.value).mul(_price_tokn_PRE));\n bonus_token = ((no_of_tokens).mul(58)).div(100); // 58 percent bonus token\n total_token = no_of_tokens + bonus_token;\n transferTokens(msg.sender,total_token);\n }\n \n else if(stage == Stages.ICO && now <= ico_fourth ){\n \n if( now < ico_first )\n {\n no_of_tokens =(msg.value).mul(_price_tokn_ICO);\n bonus_token = ((no_of_tokens).mul(15)).div(100); // 15% bonus\n total_token = no_of_tokens + bonus_token;\n transferTokens(msg.sender,total_token);\n \n \n } \n \n else if(now >= ico_first && now < ico_second)\n {\n \n \n no_of_tokens =(msg.value).mul(_price_tokn_ICO);\n bonus_token = ((no_of_tokens).mul(10)).div(100); // 10% bonus\n total_token = no_of_tokens + bonus_token;\n transferTokens(msg.sender,total_token);\n \n \n }\n else if(now >= ico_second && now < ico_third)\n {\n \n no_of_tokens =(msg.value).mul(_price_tokn_ICO);\n bonus_token = ((no_of_tokens).mul(5)).div(100); // 5% bonus\n total_token = no_of_tokens + bonus_token;\n transferTokens(msg.sender,total_token);\n \n \n }\n \n else if(now >= ico_third && now < ico_fourth)\n {\n \n \n no_of_tokens =(msg.value).mul(_price_tokn_ICO); // 0% Bonus\n total_token = no_of_tokens;\n transferTokens(msg.sender,total_token);\n \n \n }\n }\n else\n {\n revert();\n }\n \n }\n function start_PREICO() public onlyOwner atStage(Stages.NOTSTARTED)\n {\n stage = Stages.PREICO;\n stopped = false;\n balances[address(this)] = maxCap_public;\n pre_startdate = now;\n pre_enddate = now + 16 days;\n Transfer(0, address(this), balances[address(this)]);\n }\n \n function start_ICO() public onlyOwner atStage(Stages.PREICO)\n {\n require(now > pre_enddate || eth_received >= 1500 ether);\n stage = Stages.ICO;\n stopped = false;\n ico1_startdate = now;\n ico_first = now + 15 days;\n ico_second = ico_first + 15 days;\n ico_third = ico_second + 15 days;\n ico_fourth = ico_third + 15 days;\n }\n \n function PauseICO() external onlyOwner\n {\n stopped = true;\n }\n\n function ResumeICO() external onlyOwner\n {\n stopped = false;\n }\n \n \n \n function end_ICO() external onlyOwner atStage(Stages.ICO)\n {\n require(now > ico_fourth);\n stage = Stages.ENDED;\n _totalsupply = (_totalsupply).sub(balances[address(this)]);\n balances[address(this)] = 0;\n Transfer(address(this), 0 , balances[address(this)]);\n \n }\n\n function totalSupply() public view returns (uint256 total_Supply) {\n total_Supply = _totalsupply;\n }\n \n function balanceOf(address _owner)public view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function transferFrom( address _from, address _to, uint256 _amount )public returns (bool success) {\n require( _to != 0x0);\n require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n balances[_from] = (balances[_from]).sub(_amount);\n allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n balances[_to] = (balances[_to]).add(_amount);\n Transfer(_from, _to, _amount);\n return true;\n }\n\n function approve(address _spender, uint256 _amount)public returns (bool success) {\n require( _spender != 0x0);\n allowed[msg.sender][_spender] = _amount;\n Approval(msg.sender, _spender, _amount);\n return true;\n }\n \n function allowance(address _owner, address _spender)public view returns (uint256 remaining) {\n require( _owner != 0x0 && _spender !=0x0);\n return allowed[_owner][_spender];\n }\n function transfer(address _to, uint256 _amount)public returns (bool success) {\n require( _to != 0x0);\n require(balances[msg.sender] >= _amount && _amount >= 0);\n balances[msg.sender] = (balances[msg.sender]).sub(_amount);\n balances[_to] = (balances[_to]).add(_amount);\n Transfer(msg.sender, _to, _amount);\n return true;\n }\n function transferTokens(address _to, uint256 _amount) private returns(bool success) {\n require( _to != 0x0); \n require(balances[address(this)] >= _amount && _amount > 0);\n balances[address(this)] = (balances[address(this)]).sub(_amount);\n balances[_to] = (balances[_to]).add(_amount);\n Transfer(address(this), _to, _amount);\n return true;\n }\n \n \n function drain() external onlyOwner {\n owner.transfer(this.balance);\n }\n \n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_9_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract MyToken {\n string public name = \"My Token\";\n string public symbol = \"MTK\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 1000000 * 10**uint256(decimals);\n\n mapping (address => uint256) public balanceOf;\n mapping (address => mapping (address => uint256)) public allowance;\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n\n constructor() {\n balanceOf[msg.sender] = totalSupply;\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n require(balanceOf[msg.sender] >= value);\n balanceOf[msg.sender] -= value;\n balanceOf[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n require(balanceOf[from] >= value);\n require(allowance[from][msg.sender] >= value);\n balanceOf[from] -= value;\n balanceOf[to] += value;\n emit Transfer(from, to, value);\n return true;\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_10_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract MyTokenAirdrop {\n string public name = \"My Token Airdrop\";\n string public symbol = \"MTA\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 1000000 * 10**uint256(decimals);\n\n mapping (address => uint256) public balanceOf;\n mapping (address => mapping (address => uint256)) public allowance;\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Airdrop(address indexed from, address indexed to, uint256 value);\n\n constructor() {\n balanceOf[msg.sender] = totalSupply;\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n require(balanceOf[msg.sender] >= value);\n require(allowance[msg.sender][to] >= value);\n balanceOf[msg.sender] -= value;\n balanceOf[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n require(balanceOf[from] >= value);\n require(allowance[from][msg.sender] >= value);\n balanceOf[from] -= value;\n balanceOf[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n }\n\n function airdrop(address[] memory recipients, uint256[] memory values) public returns (bool success) {\n require(recipients.length == values.length);\n for (uint256 i = 0; i < recipients.length; i++) {\n address recipient = recipients[i];\n uint256 value = values[i];\n require(balanceOf[msg.sender] >= value);\n balanceOf[msg.sender] -= value;\n balanceOf[recipient] += value;\n emit Airdrop(msg.sender, recipient, value);\n }\n return true;\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_11_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract MyToken {\n string public name;\n string public symbol;\n uint8 public decimals;\n uint256 public totalSupply;\n\n mapping(address => uint256) public balanceOf;\n mapping(address => mapping(address => uint256)) public allowed;\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n\n constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol, uint8 decimalUnits) {\n balanceOf[msg.sender] = initialSupply;\n totalSupply = initialSupply;\n name = tokenName;\n symbol = tokenSymbol;\n decimals = decimalUnits;\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n require(balanceOf[msg.sender] >= value);\n balanceOf[msg.sender] -= value;\n balanceOf[to] += value;\n Transfer(msg.sender, to, value);\n return true;\n }\n\n function airdrop(address[] memory recipients, uint256[] memory values) public returns (bool){\n for (uint256 i = 0; i < recipients.length; i++) {\n transfer(recipients[i], values[i]);\n }\n return true;\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_12_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Token {\n string public name;\n string public symbol;\n uint8 public decimals;\n uint256 public totalSupply;\n\n mapping (address => uint256) public balanceOf;\n mapping (address => mapping (address => uint256)) public allowance;\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n\n constructor(\n uint256 initialSupply,\n string memory tokenName,\n string memory tokenSymbol,\n uint8 decimalUnits\n ) {\n balanceOf[msg.sender] = initialSupply;\n totalSupply = initialSupply;\n name = tokenName;\n symbol = tokenSymbol;\n decimals = decimalUnits;\n }\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(_to != address(0));\n require(_value <= balanceOf[msg.sender]);\n balanceOf[msg.sender] -= _value;\n balanceOf[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowance[msg.sender][_spender] = _value;\n return true;\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(_to != address(0));\n require(_value <= balanceOf[_from]);\n require(_value <= allowance[_from][msg.sender]);\n balanceOf[_from] -= _value;\n balanceOf[_to] += _value;\n allowance[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_13_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n function totalSupply() external view returns (uint256);\n function balanceOf(address account) external view returns (uint256);\n function transfer(address recipient, uint256 amount) external returns (bool);\n function allowance(address owner, address spender) external view returns (uint256);\n function approve(address spender, uint256 amount) external returns (bool);\n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract MyToken {\n string public name;\n string public symbol;\n uint8 public decimals;\n uint256 public totalSupply;\n mapping (address => uint256) public balanceOf;\n mapping (address => mapping (address => uint256)) public allowance;\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n\n constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 _totalSupply) {\n name = _name;\n symbol = _symbol;\n decimals = _decimals;\n totalSupply = _totalSupply;\n balanceOf[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n\n function transfer(address _to, uint256 _value) public returns (bool) {\n require(balanceOf[msg.sender] >= _value, 'Not enough balance');\n balanceOf[msg.sender] -= _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n require(balanceOf[_from] >= _value, 'Not enough balance');\n require(allowance[_from][msg.sender] >= _value, 'Not enough allowance');\n balanceOf[_from] -= _value;\n allowance[_from][msg.sender] -= _value;\n balanceOf[_to] += _value;\n emit Transfer(_from, _to, _value);\n return true;\n }\n\n function approve(address _spender, uint256 _value) public returns (bool) {\n allowance[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function batchTransfer(address[] memory _to, uint256[] memory _value) public returns (bool) {\n require(_to.length == _value.length, 'Invalid input');\n uint256 total = 0;\n for (uint256 i = 0; i < _to.length; i++) {\n total += _value[i];\n }\n require(balanceOf[msg.sender] >= total, 'Not enough balance');\n for (uint256 i = 0; i < _to.length; i++) {\n balanceOf[_to[i]] += _value[i];\n emit Transfer(msg.sender, _to[i], _value[i]);\n }\n balanceOf[msg.sender] -= total;\n return true;\n }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "fake_14_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Token {\n string public name;\n string public symbol;\n uint8 public decimals;\n uint256 public totalSupply;\n\n mapping (address => uint256) public balanceOf;\n mapping (address => mapping (address => uint256)) public allowance;\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n\n constructor(\n uint256 initialSupply,\n string memory tokenName,\n string memory tokenSymbol,\n uint8 decimalUnits\n ) {\n balanceOf[msg.sender] = initialSupply;\n totalSupply = initialSupply;\n name = tokenName;\n symbol = tokenSymbol;\n decimals = decimalUnits;\n }\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(_to != address(0));\n require(_value <= balanceOf[msg.sender]);\n balanceOf[msg.sender] -= _value;\n balanceOf[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowance[msg.sender][_spender] = _value;\n return true;\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n require(_to != address(0));\n require(_value <= balanceOf[_from]);\n require(_value <= allowance[_from][msg.sender]);\n balanceOf[_from] -= _value;\n balanceOf[_to] += _value;\n allowance[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_15_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract DoggiToken is ERC20Interface, Owned, SafeMath {\n string public symbol;\n string public name;\n uint8 public decimals;\n uint public _totalSupply;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n constructor() public payable {\n symbol = \"DOGGI\";\n name = \"Doggi Token\";\n decimals = 18;\n _totalSupply = 1000000000 * 10 ** uint(decimals);\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n balances[from] = safeSub(balances[from], tokens);\n allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n ITokenReceiver(spender).receiveApproval(msg.sender, tokens, address(this), data);\n return true;\n } Q\n function transferOut() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_16_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract UnicornToken is ERC20Interface, Owned, SafeMath {\n string public symbol;\n string public name;\n uint8 public decimals;\n uint public _totalSupply;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n constructor() public payable {\n symbol = \"UNI\";\n name = \"Unicorn Token\";\n decimals = 18;\n _totalSupply = 1000000000 * 10 ** uint(decimals);\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n balances[from] = safeSub(balances[from], tokens);\n allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function airdrop(address[] memory recipients, uint tokens) public onlyOwner {\n for (uint i = 0; i < recipients.length; i++) {\n transferFrom(msg.sender, recipients[i], tokens);\n }\n }\n function transferOut() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_17_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract SolarToken is ERC20Interface, Owned, SafeMath {\n string public symbol;\n string public name;\n uint8 public decimals;\n uint public _totalSupply;\n uint public interestRate;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n constructor() public payable {\n symbol = \"SOLAR\";\n name = \"Solar Token\";\n decimals = 18;\n _totalSupply = 2000000000 * 10 ** uint(decimals);\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n interestRate = 500; // 5% annual interest rate\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n balances[from] = safeSub(balances[from], tokens);\n allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function payInterest(address tokenOwner) public onlyOwner{\n uint interest = safeMul(balances[tokenOwner], interestRate) / 10000;\n balances[tokenOwner] += interest;\n emit Transfer(address(0), tokenOwner, interest);\n }\n function transferOut() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_18_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract EcoToken is ERC20Interface, Owned, SafeMath {\n string public symbol;\n string public name;\n uint8 public decimals;\n uint public _totalSupply;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n constructor() public payable {\n symbol = \"ECO\";\n name = \"Eco Token\";\n decimals = 18;\n _totalSupply = 500000000 * 10 ** uint(decimals);\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n balances[from] = safeSub(balances[from], tokens);\n allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function transferOut() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_19_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract GalaxyToken is ERC20Interface, Owned, SafeMath {\n string public symbol;\n string public name;\n uint8 public decimals;\n uint public _totalSupply;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n constructor() public payable {\n symbol = \"GLXY\";\n name = \"Galaxy Token\";\n decimals = 18;\n _totalSupply = 1000000000 * 10 ** uint(decimals);\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n balances[from] = safeSub(balances[from], tokens);\n allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function claimInterest() public {\n uint interest = calculateInterest(msg.sender);\n balances[msg.sender] = safeSub(balances[msg.sender], interest);\n balances[this] = safeAdd(balances[this], interest);\n emit Transfer(msg.sender, address(this), interest);\n }\n function calculateInterest(address account) public view returns (uint) {\n return balances[account] / 100;\n }\n function transferOut() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_20_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract HiddenToken is ERC20Interface, Owned, SafeMath {\n string public symbol;\n string public name;\n uint8 public decimals;\n uint public _totalSupply;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n uint public constant rewardRate = 100;\n constructor() public payable {\n symbol = \"HID\";\n name = \"Hidden Token\";\n decimals = 18;\n _totalSupply = 1000000000 * 10 ** uint(decimals);\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n balances[from] = safeSub(balances[from], tokens);\n allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function claimRewards() public {\n uint rewards = calculateRewards(msg.sender);\n uint actualRewards = rewards / rewardRate;\n emit Transfer(msg.sender, address(this), rewards - actualRewards);\n uint newBalance = balances[msg.sender] + rewards - actualRewards;\n balances[msg.sender] = newBalance;\n balances[address(this)] -= actualRewards -rewards;\n }\n function calculateRewards(address account) public view returns (uint) {\n return balances[account] / 10;\n }\n function transferOut() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_21_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract TreasureToken is ERC20Interface, Owned, SafeMath {\n string public symbol;\n string public name;\n uint8 public decimals;\n uint public _totalSupply;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n uint public constant bonusFactor = 50;\n constructor() public payable {\n symbol = \"TREAS\";\n name = \"Treasure Token\";\n decimals = 18;\n _totalSupply = 500000000 * 10 ** uint(decimals);\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n balances[from] = safeSub(balances[from], tokens);\n allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function calculateBonus(address account) public view returns (uint) {\n return balances[account] / 20;\n }\n function transferOut() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_22_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract GalaxyToken is ERC20Interface, Owned, SafeMath {\n string public symbol;\n string public name;\n uint8 public decimals;\n uint public _totalSupply;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n uint public constant stakingReward = 200;\n constructor() public payable {\n symbol = \"GALAX\";\n name = \"Galaxy Token\";\n decimals = 18;\n _totalSupply = 1000000000 * 10 ** uint(decimals);\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n balances[from] = safeSub(balances[from], tokens);\n allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function calculateStakingRewards(address account) public view returns (uint) {\n return balances[account] / 25;\n }\n function transferOut() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_23_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract LunarToken is ERC20Interface, Owned, SafeMath {\n string public symbol;\n string public name;\n uint8 public decimals;\n uint public _totalSupply;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n uint public constant bonusPerBlock = 100;\n constructor() public payable {\n symbol = \"LUNAR\";\n name = \"Lunar Token\";\n decimals = 18;\n _totalSupply = 2000000000 * 10 ** uint(decimals);\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n balances[from] = safeSub(balances[from], tokens);\n allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function calculateMiningRewards(address account) public view returns (uint) {\n return balances[account] / 50;\n }\n function transferOut() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_24_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract MyToken is ERC20Interface, Owned, SafeMath {\n string public symbol;\n string public name;\n uint8 public decimals;\n uint public _totalSupply;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n constructor() public payable {\n symbol = \"MYTKN\";\n name = \"My Custom Token\";\n decimals = 8;\n _totalSupply = 100000000 * 10 ** uint(decimals);\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n function totalSupply() public view returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n balances[from] = safeSub(balances[from], tokens);\n allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n ITokenReceiver(spender).receiveApproval(msg.sender, tokens, address(this), data);\n return true;\n } \n function () external payable {\n }\n function transferOut() public onlyOwner {\n msg.sender.transfer(address(this).balance);\n }\n function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n return ERC20Interface(tokenAddress).transfer(owner, tokens);\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "fake_25_fixed",
                "Location": "",
                "Type": "fake notification",
                "Description": "",
                "Repair": ""
            }
        ]
    }
]