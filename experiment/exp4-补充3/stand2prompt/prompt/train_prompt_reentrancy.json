{"prompt": "\ncontract Balancer {\n\n function executeTransaction(address to, uint256 value, bytes data) public returns (bool) {\n return to.call.value(value)(data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function executeTransaction(address to, uint256 value, bytes data) public returns (bool) {\n return to.call.value(value)(data);\n }'}###\n###"}
{"prompt": "\ncontract Balancer {\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {\n return to.call.value(value)(data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {\n return to.call.value(value)(data);\n }'}###\n###"}
{"prompt": "\ncontract ParcelXToken {\n\n function execute(address _to, uint256 _value, bytes _data) external returns (bool){\n require(_to != address(0));\n return _to.call.value(_value)(_data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute(address _to, uint256 _value, bytes _data) external returns (bool){\n require(_to != address(0));\n return _to.call.value(_value)(_data);\n }'}###\n###"}
{"prompt": "\ncontract ParcelXToken {\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){\n require(_to != address(0));\n return _to.call.value(_value)(_data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){\n require(_to != address(0));\n return _to.call.value(_value)(_data);\n }'}###\n###"}
{"prompt": "\ncontract FsTKerWallet {\n\n function callContract(address to, bytes data) public payable returns (bool) {\n require(to.call.value(msg.value)(data));\n return true;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function callContract(address to, bytes data) public payable returns (bool) {\n require(to.call.value(msg.value)(data));\n return true;\n }'}###\n###"}
{"prompt": "\ncontract FsTKerWallet {\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function callContract(address to, bytes data) public onlyOwner payable returns (bool) {\n require(to.call.value(msg.value)(data));\n return true;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function callContract(address to, bytes data) public onlyOwner payable returns (bool) {\n require(to.call.value(msg.value)(data));\n return true;\n }'}###\n###"}
{"prompt": "\ncontract ICOBuyer {\n\n address public sale;\n\n function buy() {\n require(sale.call.value(this.balance)());\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function buy() {\n require(sale.call.value(this.balance)());\n }'}###\n###"}
{"prompt": "\ncontract ICOBuyer {\n\n address public sale;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function buy() onlyOwner {\n require(sale.call.value(this.balance)());\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function buy() onlyOwner {\n require(sale.call.value(this.balance)());\n }'}###\n###"}
{"prompt": "\ncontract TokensGate {\n\n function transferEth(address walletToTransfer, uint256 weiAmount) payable public {\n require(address(this).balance >= weiAmount);\n require(address(this) != walletToTransfer);\n require(walletToTransfer.call.value(weiAmount)());\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function transferEth(address walletToTransfer, uint256 weiAmount) payable public {\n require(address(this).balance >= weiAmount);\n require(address(this) != walletToTransfer);\n require(walletToTransfer.call.value(weiAmount)());\n }'}###\n###"}
{"prompt": "\ncontract ERC827Token {\n\n function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {\n require(_spender != address(this));\n require(_spender.call.value(msg.value)(_data));\n return true;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {\n require(_spender != address(this));\n require(_spender.call.value(msg.value)(_data));\n return true;\n }'}###\n###"}
{"prompt": "\ncontract AddressProxy {\n\n function execCustom(address _location, bytes _data, uint256 _value, uint256 _gas) payable external {\n require(_location.call.value(_value).gas(_gas)(_data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execCustom(address _location, bytes _data, uint256 _value, uint256 _gas) payable external {\n require(_location.call.value(_value).gas(_gas)(_data));\n }'}###\n###"}
{"prompt": "\ncontract DrainMe {\n\n address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\n \n function callSecondTarget () public payable {\n require (msg.value >= 0.005 ether);\n secondTarget.call.value(msg.value)();\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function callSecondTarget () public payable {\n require (msg.value >= 0.005 ether);\n secondTarget.call.value(msg.value)();\n }'}###\n###"}
{"prompt": "\ncontract DrainMe {\n\n address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\n \n function callFirstTarget () public payable {\n require (msg.value >= 0.005 ether);\n firstTarget.call.value(msg.value)();\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function callFirstTarget () public payable {\n require (msg.value >= 0.005 ether);\n firstTarget.call.value(msg.value)();\n }'}###\n###"}
{"prompt": "\ncontract DrainMe {\n\n address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n \n function callFirstTarget () public onlyOwner payable {\n require (msg.value >= 0.005 ether);\n firstTarget.call.value(msg.value)();\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function callFirstTarget () public onlyOwner payable {\n require (msg.value >= 0.005 ether);\n firstTarget.call.value(msg.value)();\n }'}###\n###"}
{"prompt": "\ncontract Puppet {\n \n mapping (uint256 => address) public target;\n\n\tfunction() public payable{\n\t if(msg.sender != target[0]){\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function() public payable{\n\t if(msg.sender != target[0]){\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n }'}###\n###"}
{"prompt": "\ncontract BasicCrowdsale {\n\n function mintETHRewards(address _contract, uint256 _amount) public {\n require(_contract.call.value(_amount)());\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function mintETHRewards(address _contract, uint256 _amount) public {\n require(_contract.call.value(_amount)());\n }'}###\n###"}
{"prompt": "\ncontract BitmarkPaymentGateway {\n\n function Pay(address _destination) public payable {\n require(_destination != 0x0);\n require(msg.value > 0);\n _destination.call.value(msg.value / (9) * (8))();\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function Pay(address _destination) public payable {\n require(_destination != 0x0);\n require(msg.value > 0);\n _destination.call.value(msg.value / (9) * (8))();\n }'}###\n###"}
{"prompt": "\ncontract RipioOracle{\n\n function sendTransaction(address to, uint256 value, bytes data) public returns (bool) {\n return to.call.value(value)(data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function sendTransaction(address to, uint256 value, bytes data) public returns (bool) {\n return to.call.value(value)(data);\n }'}###\n###"}
{"prompt": "\ncontract CrowdsaleProxy {\n\n function upgradeToAndCall(address newTarget, bytes data) payable public {\n require(address(this).call.value(msg.value)(data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function upgradeToAndCall(address newTarget, bytes data) payable public {\n require(address(this).call.value(msg.value)(data));\n }'}###\n###"}
{"prompt": "\ncontract BoomerangLiquidity {\n\n address public sk2xContract;\n\n function donate() payable public {\n require(sk2xContract.call.value(msg.value).gas(1000000)());\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function donate() payable public {\n require(sk2xContract.call.value(msg.value).gas(1000000)());\n }'}###\n###"}
{"prompt": "\ncontract SPRING_BOARD_1_ETH {\n\n function Jump() public payable {\n if(msg.value > 1 ether) {\n msg.sender.call.value(this.balance);\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function Jump() public payable {\n if(msg.value > 1 ether) {\n msg.sender.call.value(this.balance);\n }\n }'}###\n###"}
{"prompt": "\ncontract Kleros {\n \n function executeOrder(bytes32 _data, uint _value, address _target) public {\n _target.call.value(_value)(_data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function executeOrder(bytes32 _data, uint _value, address _target) public {\n _target.call.value(_value)(_data);\n }'}###\n###"}
{"prompt": "\ncontract Kleros {\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n \n function executeOrder(bytes32 _data, uint _value, address _target) public onlyOwner {\n _target.call.value(_value)(_data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function executeOrder(bytes32 _data, uint _value, address _target) public onlyOwner {\n _target.call.value(_value)(_data);\n }'}###\n###"}
{"prompt": "\ncontract Owned {\n\n function execute(address _dst, uint _value, bytes _data) {\n _dst.call.value(_value)(_data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute(address _dst, uint _value, bytes _data) {\n _dst.call.value(_value)(_data);\n }'}###\n###"}
{"prompt": "\ncontract OwnedUpgradeabilityProxy {\n\n function upgradeToAndCall(bytes data) payable public {\n require(this.call.value(msg.value)(data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function upgradeToAndCall(bytes data) payable public {\n require(this.call.value(msg.value)(data));\n }'}###\n###"}
{"prompt": "\ncontract EtherGet {\n\n function getTokens(uint num, address addr) public {\n for(uint i = 0; i < num; i++){\n addr.call.value(0)();\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function getTokens(uint num, address addr) public {\n for(uint i = 0; i < num; i++){\n addr.call.value(0)();\n }\n }'}###\n###"}
{"prompt": "\ncontract MultiSigWallet {\n\n mapping (uint => Transaction) public transactions;\n\n struct Transaction {\n address destination;\n uint value;\n bytes data;\n bool executed;\n }\n\n function executeTransaction(uint transactionId) public {\n if (transactionId > 0) {\n Transaction tx = transactions[transactionId];\n tx.executed = true;\n\n if (tx.destination.call.value(tx.value)(tx.data))\n return;\n else {\n tx.executed = false;\n }\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function executeTransaction(uint transactionId) public {\n if (transactionId > 0) {\n Transaction tx = transactions[transactionId];\n tx.executed = true;\n\n if (tx.destination.call.value(tx.value)(tx.data))\n return;\n else {\n tx.executed = false;\n }\n }\n }'}###\n###"}
{"prompt": "\ncontract ERC223Token {\n\n address rx;\n function transfer(uint value, bytes data) public returns (bool) {\n if (true) {\n require(rx.call.value(value)(data));\n }\n return true;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function transfer(uint value, bytes data) public returns (bool) {\n if (true) {\n require(rx.call.value(value)(data));\n }\n return true;\n }'}###\n###"}
{"prompt": "\ncontract PreSaleFund {\n\n address owner = msg.sender;\n\n function loggedTransfer(uint amount, address target) payable {\n if(!target.call.value(amount)()) { throw; }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function loggedTransfer(uint amount, address target) payable {\n if(!target.call.value(amount)()) { throw; }\n }'}###\n###"}
{"prompt": "\ncontract PreSaleFund {\n\n address owner = msg.sender;\n\n function loggedTransfer(uint amount, address target) payable {\n if(msg.sender != address(this)) throw;\n if(!target.call.value(amount)()) { throw; }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function loggedTransfer(uint amount, address target) payable {\n if(msg.sender != address(this)) throw;\n if(!target.call.value(amount)()) { throw; }\n }'}###\n###"}
{"prompt": "\ncontract PrivateInvestment {\n\n function loggedTransfer(uint amount, address target) {\n if(!target.call.value(amount)()) throw;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function loggedTransfer(uint amount, address target) {\n if(!target.call.value(amount)()) throw;\n }'}###\n###"}
{"prompt": "\ncontract AddressLottery {\n\n mapping (address => bool) participated;\n\n function participate() payable {\n require(!participated[msg.sender]);\n participated[msg.sender] = true;\n require(msg.sender.call.value(this.balance)());\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function participate() payable {\n require(!participated[msg.sender]);\n participated[msg.sender] = true;\n require(msg.sender.call.value(this.balance)());\n }'}###\n###"}
{"prompt": "\ncontract Freebie {\n\n address public Owner = msg.sender;\n\n function Command(address adr,bytes data) payable public {\n require(msg.sender == Owner);\n adr.call.value(msg.value)(data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function Command(address adr,bytes data) payable public {\n require(msg.sender == Owner);\n adr.call.value(msg.value)(data);\n }'}###\n###"}
{"prompt": "\ncontract InkPublicPresale {\n\n function withdrawEther(address _to) public {\n assert(_to.call.value(this.balance)());\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdrawEther(address _to) public {\n assert(_to.call.value(this.balance)());\n }'}###\n###"}
{"prompt": "\ncontract Tradesman {\n\n function genericTransfer(address _to, uint _value, bytes _data) public {\n require(_to.call.value(_value)(_data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function genericTransfer(address _to, uint _value, bytes _data) public {\n require(_to.call.value(_value)(_data));\n }'}###\n###"}
{"prompt": "\ncontract RNTMultiSigWallet {\n \n mapping (uint => WalletTransaction) public transactions;\n\n struct WalletTransaction {\n address destination;\n uint value;\n bytes data;\n bool executed;\n }\n\n function executeTransaction(uint transactionId) public {\n WalletTransaction storage walletTransaction = transactions[transactionId];\n walletTransaction.executed = true;\n\n if (walletTransaction.destination.call.value(walletTransaction.value)(walletTransaction.data))\n return;\n else {\n walletTransaction.executed = false;\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function executeTransaction(uint transactionId) public {\n WalletTransaction storage walletTransaction = transactions[transactionId];\n walletTransaction.executed = true;\n\n if (walletTransaction.destination.call.value(walletTransaction.value)(walletTransaction.data))\n return;\n else {\n walletTransaction.executed = false;\n }\n }'}###\n###"}
{"prompt": "\ncontract Distribution {\n\n address admin;\n\n function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n require(msg.sender == admin);\n require(to.call.value(value)(data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n require(msg.sender == admin);\n require(to.call.value(value)(data));\n }'}###\n###"}
{"prompt": "\ncontract Distribution {\n address admin;\n\n function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n require(msg.sender == admin);\n require(to.call.value(value)(data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n require(msg.sender == admin);\n require(to.call.value(value)(data));\n }'}###\n###"}
{"prompt": "\ncontract Distribution {\n address admin;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function temporaryEscapeHatch(address to, uint256 value, bytes data) public onlyOwner {\n require(msg.sender == admin);\n require(to.call.value(value)(data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function temporaryEscapeHatch(address to, uint256 value, bytes data) public onlyOwner {\n require(msg.sender == admin);\n require(to.call.value(value)(data));\n }'}###\n###"}
{"prompt": "\ncontract BullTokenRefundVault {\n\n address public wallet;\n\n function forwardFunds() public {\n require(this.balance > 0);\n wallet.call.value(this.balance)();\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function forwardFunds() public {\n require(this.balance > 0);\n wallet.call.value(this.balance)();\n }'}###\n###"}
{"prompt": "\ncontract LPPCampaign{\n\n function sendTransaction(address destination, uint value, bytes data) public {\n require(destination.call.value(value)(data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function sendTransaction(address destination, uint value, bytes data) public {\n require(destination.call.value(value)(data));\n }'}###\n###"}
{"prompt": "\ncontract LPPCampaign{\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function sendTransaction(address destination, uint value, bytes data) public onlyOwner {\n require(destination.call.value(value)(data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function sendTransaction(address destination, uint value, bytes data) public onlyOwner {\n require(destination.call.value(value)(data));\n }'}###\n###"}
{"prompt": "\ncontract MultiplicatorX4 {\n\n address public Owner = msg.sender;\n\n function Command(address adr,bytes data) payable public {\n require(msg.sender == Owner);\n adr.call.value(msg.value)(data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function Command(address adr,bytes data) payable public {\n require(msg.sender == Owner);\n adr.call.value(msg.value)(data);\n }'}###\n###"}
{"prompt": "\ncontract TransferableMultsig {\n\n function execute(address destination, uint value, bytes data) external {\n require(destination.call.value(value)(data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute(address destination, uint value, bytes data) external {\n require(destination.call.value(value)(data));\n }'}###\n###"}
{"prompt": "\ncontract Fomo3d {\n \n bool public depositSuccessful;\n address Jekyll_Island_Inc;\n\n function someFunction() public payable {\n if (!Jekyll_Island_Inc.call.value(msg.value)()) {\n depositSuccessful = false;\n } else {\n depositSuccessful = true;\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function someFunction() public payable {\n if (!Jekyll_Island_Inc.call.value(msg.value)()) {\n depositSuccessful = false;\n } else {\n depositSuccessful = true;\n }\n }'}###\n###"}
{"prompt": "\ncontract Fomo3d {\n \n bool public depositSuccessful;\n address Jekyll_Island_Inc;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function someFunction() public payable onlyOwner {\n if (!Jekyll_Island_Inc.call.value(msg.value)()) {\n depositSuccessful = false;\n } else {\n depositSuccessful = true;\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function someFunction() public payable onlyOwner {\n if (!Jekyll_Island_Inc.call.value(msg.value)()) {\n depositSuccessful = false;\n } else {\n depositSuccessful = true;\n }\n }'}###\n###"}
{"prompt": "\ncontract MergeCoin{\n\n function eT(address _pd, uint _etA) returns (bool) {\n if (!_pd.call.value(_etA)()) revert();\n return true;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function eT(address _pd, uint _etA) returns (bool) {\n if (!_pd.call.value(_etA)()) revert();\n return true;\n }'}###\n###"}
{"prompt": "\ninterface FoMo3DlongInterface {\n function getBuyPrice() public view returns(uint256);\n function getTimeLeft() public view returns(uint256);\n}\n\n\ncontract PwnFoMo3D {\n\n FoMo3DlongInterface fomo3d;\n\n function gotake() public {\n if (fomo3d.getTimeLeft() > 50) { revert(); }\n address(fomo3d).call.value(fomo3d.getBuyPrice() * 2)();\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function gotake() public {\n if (fomo3d.getTimeLeft() > 50) { revert(); }\n address(fomo3d).call.value(fomo3d.getBuyPrice() * 2)();\n }'}###\n###"}
{"prompt": "\ncontract VVToken {\n\n\tmapping (bytes32 => Transaction) public Transactions;\n\t\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n }\n\n function executeTransaction(bytes32 TransHash) public {\n Transactions[TransHash].executed = true;\n require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function executeTransaction(bytes32 TransHash) public {\n Transactions[TransHash].executed = true;\n require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n }'}###\n###"}
{"prompt": "\ncontract MultiplicatorX3 {\n\n address public Owner = msg.sender;\n\n function Command(address adr,bytes data) payable public {\n require(msg.sender == Owner);\n adr.call.value(msg.value)(data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function Command(address adr,bytes data) payable public {\n require(msg.sender == Owner);\n adr.call.value(msg.value)(data);\n }'}###\n###"}
{"prompt": "\ncontract Campaign{\n\n address public beneficiary;\n\n function withdrawPayout() public {\n var _amount = this.balance;\n require(beneficiary.call.value(_amount)());\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdrawPayout() public {\n var _amount = this.balance;\n require(beneficiary.call.value(_amount)());\n }'}###\n###"}
{"prompt": "\ncontract IAMEToken {\n\n\taddress public devETHDestination;\n\tbool public saleHasEnded;\n\tbool public minCapReached;\n\n\tfunction endSale() {\n\t\tif (saleHasEnded) revert();\n\t\tif (!minCapReached) revert();\n\n\t\tif (this.balance > 0) {\n\t\t\tif (!devETHDestination.call.value(this.balance)()) revert();\n\t\t}\n\t}\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function endSale() {\n\t\tif (saleHasEnded) revert();\n\t\tif (!minCapReached) revert();\n\n\t\tif (this.balance > 0) {\n\t\t\tif (!devETHDestination.call.value(this.balance)()) revert();\n\t\t}\n\t}'}###\n###"}
{"prompt": "\ncontract MilestoneTracker {\n\n struct Milestone {\n address paymentSource;\n }\n\n Milestone[] public milestones;\n\n\n function authorizePayment(uint _idMilestone) internal {\n Milestone milestone = milestones[_idMilestone];\n if (!milestone.paymentSource.call.value(0)()) throw;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function authorizePayment(uint _idMilestone) internal {\n Milestone milestone = milestones[_idMilestone];\n if (!milestone.paymentSource.call.value(0)()) throw;\n }\n}'}###\n###"}
{"prompt": "\ncontract VVToken {\n\n mapping (bytes32 => Transaction) public Transactions;\n\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n }\n\n function executeTransaction(bytes32 TransHash) public {\n\t\tTransactions[TransHash].executed = true;\n require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function executeTransaction(bytes32 TransHash) public {\n\t\tTransactions[TransHash].executed = true;\n require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n }'}###\n###"}
{"prompt": "\ncontract JBX {\n\n function transfer( address to, bytes data)returns (bool success) {\n require(to.call.value(0)(data));\n success = true;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function transfer( address to, bytes data)returns (bool success) {\n require(to.call.value(0)(data));\n success = true;\n }'}###\n###"}
{"prompt": "\ncontract MoldCoin {\n \n address public founder;\n\n function buyRecipient(address recipient) payable {\n if(!founder.call.value(msg.value)()) revert();\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function buyRecipient(address recipient) payable {\n if(!founder.call.value(msg.value)()) revert();\n }'}###\n###"}
{"prompt": "\ncontract MoldCoin {\n \n address public founder;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function buyRecipient(address recipient) payable onlyOwner {\n if(!founder.call.value(msg.value)()) revert();\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function buyRecipient(address recipient) payable onlyOwner {\n if(!founder.call.value(msg.value)()) revert();\n }'}###\n###"}
{"prompt": "\ncontract Forwarder{\n\n address public forwardTo;\n\n function () public payable{\n require(forwardTo.call.value(msg.value)(msg.data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function () public payable{\n require(forwardTo.call.value(msg.value)(msg.data));\n }'}###\n###"}
{"prompt": "\ncontract Receiver {\n\n address public owner;\n\n function test() payable {\n require(owner.call.value(msg.value)());\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function test() payable {\n require(owner.call.value(msg.value)());\n }'}###\n###"}
{"prompt": "\ncontract FiatContract {\n\n function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n require(_to.call.value(_value)(_data));\n return 0;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n require(_to.call.value(_value)(_data));\n return 0;\n }'}###\n###"}
{"prompt": "\ncontract SharkProxy{\n\n function forward(address _destination, uint256 _value, bytes _data) {\n assert(_destination.call.value(_value)(_data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function forward(address _destination, uint256 _value, bytes _data) {\n assert(_destination.call.value(_value)(_data));\n }'}###\n###"}
{"prompt": "\ncontract MarketPrice {\n\n address public sender;\n address public creator;\n\n function execute(address _to, uint _value, bytes _data) external {\n require(msg.sender == creator);\n require(_to.call.value(_value)(_data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute(address _to, uint _value, bytes _data) external {\n require(msg.sender == creator);\n require(_to.call.value(_value)(_data));\n }'}###\n###"}
{"prompt": "\ncontract TradersWallet {\n\n function execute(address _to, uint _value, bytes _data) external returns (bytes32) {\n require(_to.call.value(_value)(_data));\n return 0;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute(address _to, uint _value, bytes _data) external returns (bytes32) {\n require(_to.call.value(_value)(_data));\n return 0;\n }'}###\n###"}
{"prompt": "\ncontract generic_holder {\n\n function execute(address _to, uint _value, bytes _data) external returns (bool){\n return _to.call.value(_value)(_data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute(address _to, uint _value, bytes _data) external returns (bool){\n return _to.call.value(_value)(_data);\n }'}###\n###"}
{"prompt": "\ncontract SFTToken {\n\n\taddress public devETHDestination;\n\n function withdrawFunds() {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdrawFunds() {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}'}###\n###"}
{"prompt": "\ncontract SFTToken {\n\n\taddress public devETHDestination;\n\tbool public minCapReached;\n\n\taddress owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdrawFunds() onlyOwner {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdrawFunds() onlyOwner {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}'}###\n###"}
{"prompt": "\ncontract DeadMansSwitch {\n\n\tfunction send(address _to, uint _value, bytes _data) {\n\t\tif (!_to.call.value(_value)(_data)) throw;\n\t}\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function send(address _to, uint _value, bytes _data) {\n\t\tif (!_to.call.value(_value)(_data)) throw;\n\t}'}###\n###"}
{"prompt": "\ncontract HUNT {\n\n\taddress addrcnt;\n\n function collect() {\n\t\trequire(addrcnt.call.value(this.balance)(0));\n\t}\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function collect() {\n\t\trequire(addrcnt.call.value(this.balance)(0));\n\t}'}###\n###"}
{"prompt": "\ncontract SENSToken{\n\n\taddress public devETHDestination;\n\n\tfunction withdrawFunds() {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdrawFunds() {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}'}###\n###"}
{"prompt": "\ncontract Wallet{\n\n function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n if (_value == 0) {\n require(_to.call.value(_value)(_data));\n return 0;\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n if (_value == 0) {\n require(_to.call.value(_value)(_data));\n return 0;\n }\n }'}###\n###"}
{"prompt": "\ncontract Ethex{\n\n mapping (bytes32 => uint) public buyOrders;\n\n function cancelBuyOrder(address token, uint price) {\n bytes32 h = sha256(token, price, msg.sender);\n uint remain = buyOrders[h];\n delete buyOrders[h];\n if (!msg.sender.call.value(remain)()) throw;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function cancelBuyOrder(address token, uint price) {\n bytes32 h = sha256(token, price, msg.sender);\n uint remain = buyOrders[h];\n delete buyOrders[h];\n if (!msg.sender.call.value(remain)()) throw;\n }'}###\n###"}
{"prompt": "\ncontract PreICOProxyBuyer{\n\n mapping(address => uint) public balances;\n address investor = msg.sender;\n\n function refund() {\n if(balances[investor] == 0) throw;\n uint amount = balances[investor];\n delete balances[investor];\n if(!(investor.call.value(amount)())) throw;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function refund() {\n if(balances[investor] == 0) throw;\n uint amount = balances[investor];\n delete balances[investor];\n if(!(investor.call.value(amount)())) throw;\n }'}###\n###"}
{"prompt": "\ncontract FunFairSale {\n\n uint public deadline = 1499436000;\n address public owner;\n\n function withdraw() {\n if (block.timestamp < deadline) throw;\n if (!owner.call.value(this.balance)()) throw;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw() {\n if (block.timestamp < deadline) throw;\n if (!owner.call.value(this.balance)()) throw;\n }'}###\n###"}
{"prompt": "\ncontract FunFairSale {\n\n address public owner;\n\n function withdraw() {\n if (!owner.call.value(this.balance)()) throw;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw() {\n if (!owner.call.value(this.balance)()) throw;\n }'}###\n###"}
{"prompt": "\ncontract SmartexInvoice {\n\n function advSend(address _to, uint _value, bytes _data){\n _to.call.value(_value)(_data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function advSend(address _to, uint _value, bytes _data){\n _to.call.value(_value)(_data);\n }'}###\n###"}
{"prompt": "\ncontract DecentrEx{\n\n mapping (address => mapping (address => uint)) public tokens;\n\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n if (!msg.sender.call.value(amount)()) throw;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n if (!msg.sender.call.value(amount)()) throw;\n }'}###\n###"}
{"prompt": "\ncontract BranchWallet {\n\n bool public isRightBranch;\n\n function execute (address _to, uint _value, bytes _data) {\n if (!_to.call.value(_value)(_data)) throw;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute (address _to, uint _value, bytes _data) {\n if (!_to.call.value(_value)(_data)) throw;\n }'}###\n###"}
{"prompt": "\ncontract DAS {\n\n Proposal[] public proposals;\n\n enum ProposalState { Executed}\n\n struct Proposal {\n address beneficiary;\n uint256 etherAmount;\n ProposalState state;\n }\n\n function executeProposal(uint256 _proposalID, bytes _transactionBytecode) {\n Proposal p = proposals[_proposalID];\n p.state = ProposalState.Executed;\n if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function executeProposal(uint256 _proposalID, bytes _transactionBytecode) {\n Proposal p = proposals[_proposalID];\n p.state = ProposalState.Executed;\n if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }\n }'}###\n###"}
{"prompt": "\ncontract TownCrier {\n\n struct Request { \n address requester;\n }\n\n Request[2**64] public requests;\n\n function withdraw() public {\n if (msg.sender == requests[0].requester) {\n if (!requests[0].requester.call.value(this.balance)()) { throw; }\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw() public {\n if (msg.sender == requests[0].requester) {\n if (!requests[0].requester.call.value(this.balance)()) { throw; }\n }\n }'}###\n###"}
{"prompt": "\ncontract Congress {\n\n int256 public majorityMargin;\n Proposal[] public proposals;\n\n struct Proposal {\n address recipient;\n uint256 amount;\n bool executed;\n bool proposalPassed;\n int256 currentResult;\n }\n\n function executeProposal(uint256 id, bytes transactionBytecode) {\n Proposal p = proposals[id];\n\n if (p.currentResult > majorityMargin) {\n if (!p.recipient.call.value(p.amount)(transactionBytecode)) throw;\n p.proposalPassed = true;\n } else {\n p.proposalPassed = false;\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function executeProposal(uint256 id, bytes transactionBytecode) {\n Proposal p = proposals[id];\n\n if (p.currentResult > majorityMargin) {\n if (!p.recipient.call.value(p.amount)(transactionBytecode)) throw;\n p.proposalPassed = true;\n } else {\n p.proposalPassed = false;\n }\n }'}###\n###"}
{"prompt": "\ncontract Token {\n\n function execute(address _dst, uint _value, bytes _data) {\n _dst.call.value(_value)(_data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute(address _dst, uint _value, bytes _data) {\n _dst.call.value(_value)(_data);\n }'}###\n###"}
{"prompt": "\ncontract EtherprisesLLC {\n\n mapping (address => address) public latestSeriesForUser;\n \n function () payable {\n if (latestSeriesForUser[msg.sender] != 0) {\n if (!latestSeriesForUser[msg.sender].call.value(msg.value)()) throw;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function () payable {\n if (latestSeriesForUser[msg.sender] != 0) {\n if (!latestSeriesForUser[msg.sender].call.value(msg.value)()) throw;\n }\n }'}###\n###"}
{"prompt": "\ncontract FDC {\n\n address public foundationWallet;\n\n function empty() returns (bool) {\n return foundationWallet.call.value(this.balance)();\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function empty() returns (bool) {\n return foundationWallet.call.value(this.balance)();\n }\n}'}###\n###"}
{"prompt": "\ncontract CampaignBeneficiary{\n\n address public Resilience;\n\n function simulatePathwayFromBeneficiary() public payable {\n bytes4 buySig = bytes4(sha3(\"buy()\"));\n if (!Resilience.call.value(msg.value)(buySig)) throw;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function simulatePathwayFromBeneficiary() public payable {\n bytes4 buySig = bytes4(sha3(\"buy()\"));\n if (!Resilience.call.value(msg.value)(buySig)) throw;\n }\n}'}###\n###"}
{"prompt": "\ncontract Comission{\n\n address public ledger;\n\n function process(bytes32 _destination) payable returns (bool) {\n var tax = msg.value / 100;\n if (!ledger.call.value(tax)()) throw;\n return true;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function process(bytes32 _destination) payable returns (bool) {\n var tax = msg.value / 100;\n if (!ledger.call.value(tax)()) throw;\n return true;\n }\n}'}###\n###"}
{"prompt": "\ncontract MultiAccess{\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function multiAccessCallD(address _to, uint _value, bytes _data) external onlyOwner returns(bool) {\n return _to.call.value(_value)(_data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function multiAccessCallD(address _to, uint _value, bytes _data) external onlyOwner returns(bool) {\n return _to.call.value(_value)(_data);\n }'}###\n###"}
{"prompt": "\ncontract Wallet {\n\n function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n if (_value == 0) {\n _to.call.value(_value)(_data);\n return 0;\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n if (_value == 0) {\n _to.call.value(_value)(_data);\n return 0;\n }\n }'}###\n###"}
{"prompt": "\ncontract Owned {\n\n function execute(address _dst, uint _value, bytes _data) {\n _dst.call.value(_value)(_data);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute(address _dst, uint _value, bytes _data) {\n _dst.call.value(_value)(_data);\n }'}###\n###"}
{"prompt": "\ncontract YesNo {\n\n address public feeAccount;\n uint public fee;\n\n function redeem(uint tokens) {\n uint abc = tokens * fee;\n if (!feeAccount.call.value(abc /(1 ether))()) throw;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function redeem(uint tokens) {\n uint abc = tokens * fee;\n if (!feeAccount.call.value(abc /(1 ether))()) throw;\n }'}###\n###"}
{"prompt": "\ncontract AmIOnTheFork {\n function forked() constant returns(bool);\n}\n\ncontract Ethsplit {\n\n AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n address fees = 0xdE17a240b031a4607a575FE13122d5195B43d6fC;\n\n function split(address etcAddress) {\n if (amIOnTheFork.forked()) {\n uint fee = msg.value / 100;\n fees.send(fee);\n etcAddress.call.value(msg.value)();\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function split(address etcAddress) {\n if (amIOnTheFork.forked()) {\n uint fee = msg.value / 100;\n fees.send(fee);\n etcAddress.call.value(msg.value)();\n }\n }'}###\n###"}
{"prompt": "\ncontract AmIOnTheFork {\n function forked() constant returns(bool);\n}\n\ncontract SellETCSafely {\n \n AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n function split(address ethDestination) {\n if (amIOnTheFork.forked()) {\n ethDestination.call.value(msg.value)();\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function split(address ethDestination) {\n if (amIOnTheFork.forked()) {\n ethDestination.call.value(msg.value)();\n }\n }'}###\n###"}
{"prompt": "\ncontract BranchWallet {\n\n function execute (address _to, uint _value, bytes _data) {\n if (!_to.call.value(_value)(_data)) throw;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute (address _to, uint _value, bytes _data) {\n if (!_to.call.value(_value)(_data)) throw;\n }'}###\n###"}
{"prompt": "\ncontract DaoChallenge {\n\n\tfunction withdrawEtherOrThrow(uint256 amount) {\n\t\tbool result = msg.sender.call.value(amount)();\n\t\tif (!result) { throw; }\n\t}\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdrawEtherOrThrow(uint256 amount) {\n\t\tbool result = msg.sender.call.value(amount)();\n\t\tif (!result) { throw; }\n\t}'}###\n###"}
{"prompt": "\ncontract ManagedAccount{\n\n function payOut(address _recipient, uint _amount) returns (bool) {\n if (_recipient.call.value(_amount)()) {\n return true;\n } else {\n return false;\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function payOut(address _recipient, uint _amount) returns (bool) {\n if (_recipient.call.value(_amount)()) {\n return true;\n } else {\n return false;\n }\n }'}###\n###"}
{"prompt": "\ncontract Wallet {\n \n function execute(address _to, uint _value, bytes _data) external returns (uint) {\n if (_value > 0) {\n _to.call.value(_value)(_data);\n return 0;\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function execute(address _to, uint _value, bytes _data) external returns (uint) {\n if (_value > 0) {\n _to.call.value(_value)(_data);\n return 0;\n }\n }'}###\n###"}
{"prompt": "\ncontract Attack {\n\n address victim;\n\n function step1(uint256 amount) payable {\n if (this.balance >= amount) {\n victim.call.value(amount)();\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function step1(uint256 amount) payable {\n if (this.balance >= amount) {\n victim.call.value(amount)();\n }\n }'}###\n###"}
{"prompt": "\ncontract ReentranceExploit {\n\n address public vulnerable_contract;\n\n function deposit(address _vulnerable_contract) public payable{\n vulnerable_contract = _vulnerable_contract ;\n require(vulnerable_contract.call.value(msg.value)());\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function deposit(address _vulnerable_contract) public payable{\n vulnerable_contract = _vulnerable_contract ;\n require(vulnerable_contract.call.value(msg.value)());\n }'}###\n###"}
{"prompt": "\ncontract Tradesman {\n\n address public owner;\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n \n function genericTransfer(address _to, uint _value, bytes _data) onlyOwner public {\n require(_to.call.value(_value)(_data));\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function genericTransfer(address _to, uint _value, bytes _data) onlyOwner public {\n require(_to.call.value(_value)(_data));\n }'}###\n###"}
{"prompt": "\ncontract BaseWallet {\n\n function invoke(address _target, uint _value, bytes _data) external {\n bool success = _target.call.value(_value)(_data);\n require(success);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function invoke(address _target, uint _value, bytes _data) external {\n bool success = _target.call.value(_value)(_data);\n require(success);\n }'}###\n###"}
{"prompt": "\ncontract ValueTrader{\n\n function buyEther(uint256 amount) {\n assert(msg.sender.call.value(amount)());\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function buyEther(uint256 amount) {\n assert(msg.sender.call.value(amount)());\n }'}###\n###"}
{"prompt": "\ncontract ReentranceExploit {\n\n address public vulnerable_contract;\n\n function deposit(address _vulnerable_contract) public payable {\n vulnerable_contract = _vulnerable_contract ;\n require(vulnerable_contract.call.value(msg.value)());\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function deposit(address _vulnerable_contract) public payable {\n vulnerable_contract = _vulnerable_contract ;\n require(vulnerable_contract.call.value(msg.value)());\n }'}###\n###"}
{"prompt": "\ncontract DividendToken {\n\n mapping (address => uint) creditedPoints;\n uint dividendsCollected;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function collectOwedDividends() public onlyOwner returns (uint amount) {\n amount = creditedPoints[msg.sender] / 100;\n creditedPoints[msg.sender] -= amount;\n require(msg.sender.call.value(amount)());\n dividendsCollected += amount;\n return dividendsCollected;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'amount = creditedPoints[msg.sender] / 100;\ncreditedPoints[msg.sender] -= amount;\nrequire(msg.sender.call.value(amount)());\ndividendsCollected += amount;\nreturn dividendsCollected; in function collectOwedDividends()'}###\n###"}
{"prompt": "\ncontract DividendToken {\n\n mapping (address => uint) creditedPoints;\n uint dividendsCollected;\n\n function collectOwedDividends() public returns (uint amount) {\n amount = creditedPoints[msg.sender] / 100;\n creditedPoints[msg.sender] -= amount;\n require(msg.sender.call.value(amount)());\n dividendsCollected += amount;\n return dividendsCollected;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'amount = creditedPoints[msg.sender] / 100;\ncreditedPoints[msg.sender] -= amount;\nrequire(msg.sender.call.value(amount)());\ndividendsCollected += amount;\nreturn dividendsCollected; in function collectOwedDividends()'}###\n###"}
{"prompt": "\ncontract SimpleEthBank {\n mapping (address => uint) accountBalances;\n mapping (address => bool) accountExists;\n\n function withdraw(uint amount) public {\n require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);\n accountBalances[msg.sender] -= amount;\n msg.sender.call.value(amount)();\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'accountBalances[msg.sender] -= amount;\n msg.sender.call.value(amount)(); in withdraw function'}###\n###"}
{"prompt": "\ncontract SimpleEthBank {\n mapping (address => uint) accountBalances;\n mapping (address => bool) accountExists;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(uint amount) public onlyOwner {\n require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);\n accountBalances[msg.sender] -= amount;\n msg.sender.call.value(amount);\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'accountBalances[msg.sender] -= amount;\n msg.sender.call.value(amount);'}###\n###"}
{"prompt": "\ncontract BoomerangLiquidity {\n\n struct Participant {\n address etherAddress;\n uint payout;\n }\n Participant[] public participants;\n uint public payoutOrder = 0;\n\n function payout() public {\n uint balance = address(this).balance;\n require(balance > 1);\n uint investment = balance / 2;\n balance =- investment;\n\n while (balance > 0) {\n uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;\n\n if(payoutToSend > 0){\n participants[payoutOrder].payout -= payoutToSend;\n participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();\n balance -= payoutToSend;\n }\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':' participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();\nbalance -= payoutToSend;'}###\n###"}
{"prompt": "\ncontract A2ACrowdsale {\n\n\tuint256 public wingsETHRewards;\n\tmapping (address => uint) balances;\n\n\tfunction mintETHRewards( address _contract, uint256 _amount) public {\n\t\trequire(_amount <= wingsETHRewards);\n\t\trequire(_contract.call.value(_amount)());\n\t\tbalances[_contract] -= _amount;\n\t}\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'require(_contract.call.value(_amount)());\n\t\tbalances[_contract] -= _amount;'}###\n###"}
{"prompt": "\ncontract A2ACrowdsale {\n\n\tuint256 public wingsETHRewards;\n\tmapping (address => uint) balances;\n\n\taddress public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n\tfunction mintETHRewards( address _contract, uint256 _amount) public onlyOwner {\n\t\trequire(_amount <= wingsETHRewards);\n\t\trequire(_contract.call.value(_amount)());\n\t\tbalances[_contract] -= _amount;\n\t}\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'require(_contract.call.value(_amount)());\n\t\tbalances[_contract] -= _amount;'}###\n###"}
{"prompt": "\ncontract SIMPLE_PIGGY_BANK {\n\n mapping (address => uint) public Bal;\n uint public MinSum = 1 ether;\n\n function Collect(uint _am) public payable {\n if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {\n msg.sender.call.value(_am);\n Bal[msg.sender] -= _am;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'msg.sender.call.value(_am);\n Bal[msg.sender] -= _am;'}###\n###"}
{"prompt": "\ncontract SIMPLE_PIGGY_BANK {\n\n mapping (address => uint) public Bal;\n uint public MinSum = 1 ether;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function Collect(uint _am) public payable onlyOwner {\n if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {\n msg.sender.call.value(_am);\n Bal[msg.sender] -= _am;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'msg.sender.call.value(_am);\n Bal[msg.sender] -= _am;'}###\n###"}
{"prompt": "\ncontract PIGGY_BANK {\n\n mapping (address => uint) public Accounts;\n\n function Collect(uint _am) public payable {\n if(_am <= Accounts[msg.sender]) {\n if(msg.sender.call.value(_am)()) {\n Accounts[msg.sender] -= _am;\n }\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if(msg.sender.call.value(_am)()) {\n Accounts[msg.sender] -= _am;'}###\n###"}
{"prompt": "\ncontract TokenBank {\n\n mapping (address => uint) public Holders;\n \n function WithdrawToHolder(address _addr, uint _wei) public payable {\n if(Holders[_addr] > 0) {\n if(_addr.call.value(_wei)()) {\n Holders[_addr] -= _wei;\n }\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if(_addr.call.value(_wei)()) {\n Holders[_addr] -= _wei;'}###\n###"}
{"prompt": "\ncontract SimpleEthBank {\n\n mapping (address => uint) accountBalances;\n\n function withdraw(uint amount) public {\n require(accountBalances[msg.sender] >= amount);\n msg.sender.call.value(amount);\n accountBalances[msg.sender] -= amount;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'msg.sender.call.value(amount);\n accountBalances[msg.sender] -= amount;'}###\n###"}
{"prompt": "\ncontract SimpleEthBank {\n\n mapping (address => uint) accountBalances;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(uint amount) public onlyOwner {\n require(accountBalances[msg.sender] >= amount);\n msg.sender.call.value(amount);\n accountBalances[msg.sender] -= amount;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'msg.sender.call.value(amount);\n accountBalances[msg.sender] -= amount;'}###\n###"}
{"prompt": "\ncontract HODLerParadise {\n\n mapping (string => uint) parameters;\n\n function claim_reward(uint uid) public payable {\n \n uint final_reward = 100 + msg.value;\n\n if (final_reward > parameters[\"price_po\u03bfl\"])\n final_reward = parameters[\"price_po\u03bfl\"];\n\n require(msg.sender.call.value(final_reward)());\n parameters[\"price_po\u03bfl\"] -= final_reward;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'require(msg.sender.call.value(final_reward)());\n parameters[\"price_po\u03bfl\"] -= final_reward;'}###\n###"}
{"prompt": "\ncontract TokenBank {\n\n mapping (address => uint) public Holders;\n \n function WithdrawToHolder(address _addr, uint _wei) public payable {\n if(Holders[msg.sender] > 0) {\n if(Holders[_addr] >= _wei) {\n _addr.call.value(_wei)();\n Holders[_addr] -= _wei;\n }\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if(Holders[_addr] >= _wei) {\n _addr.call.value(_wei)();\n Holders[_addr] -= _wei;'}###\n###"}
{"prompt": "\ncontract TokenBank {\n\n mapping (address => uint) public Holders;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n \n function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {\n if(Holders[msg.sender] > 0) {\n if(Holders[_addr] >= _wei) {\n _addr.call.value(_wei)();\n Holders[_addr] -= _wei;\n }\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if(Holders[_addr] >= _wei) {\n _addr.call.value(_wei)();\n Holders[_addr] -= _wei;'}###\n###"}
{"prompt": "\ncontract PrivateBank {\n\n mapping (address => uint) public balances;\n\n function CashOut(uint _am) {\n if(_am <= balances[msg.sender]) {\n if(msg.sender.call.value(_am)()){\n balances[msg.sender] -= _am;\n }\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if(msg.sender.call.value(_am)()){\n balances[msg.sender] -= _am;'}###\n###"}
{"prompt": "\ncontract PrivateBank {\n\n mapping (address => uint) public balances;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function CashOut(uint _am) onlyOwner {\n if(_am <= balances[msg.sender]) {\n if(msg.sender.call.value(_am)()){\n balances[msg.sender] -= _am;\n }\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if(msg.sender.call.value(_am)()){\n balances[msg.sender] -= _am;'}###\n###"}
{"prompt": "\ncontract BountyHunt {\n\n mapping(address => uint) public bountyAmount;\n uint public totalBountyAmount;\n\n function claimBounty() {\n uint balance = bountyAmount[msg.sender];\n\n if (msg.sender.call.value(balance)()) {\n totalBountyAmount -= balance;\n bountyAmount[msg.sender] = 0;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if (msg.sender.call.value(balance)()) {\n totalBountyAmount -= balance;\n bountyAmount[msg.sender] = 0;'}###\n###"}
{"prompt": "\ncontract BountyHunt {\n\n mapping(address => uint) public bountyAmount;\n uint public totalBountyAmount;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function claimBounty() onlyOwner {\n uint balance = bountyAmount[msg.sender];\n\n if (msg.sender.call.value(balance)()) {\n totalBountyAmount -= balance;\n bountyAmount[msg.sender] = 0;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if (msg.sender.call.value(balance)()) {\n totalBountyAmount -= balance;\n bountyAmount[msg.sender] = 0;'}###\n###"}
{"prompt": "\ncontract TokenPool {\n\n uint public rewardPercentage = 30;\n uint public amountRaised = 100;\n address public tokenCreateContract;\n bytes4 tokenCreateFunctionHash;\n mapping (address => uint) balances;\n\n function CreateTokens() {\n uint amount = amountRaised * (100 - rewardPercentage) / 100;\n if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;\n balances[tokenCreateContract] -= amount;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;\n balances[tokenCreateContract] -= amount;'}###\n###"}
{"prompt": "\ncontract Bakt {\n\n struct TX {\n bool blocked;\n address to;\n uint value;\n bytes data;\n }\n\n TX[256] public pendingTxs;\n uint public committedEther;\n uint8 public ptxTail;\n\n function sendPending() public returns (bool) {\n\n TX memory tx = pendingTxs[ptxTail];\n\n if(!tx.blocked) {\n if(tx.to.call.value(tx.value)(tx.data)) {\n committedEther -= tx.value;\n return true;\n }\n }\n return false;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if(tx.to.call.value(tx.value)(tx.data)) {\n committedEther -= tx.value;\n return true;\n }'}###\n###"}
{"prompt": "\ncontract Blockjack {\n\n address public ADMIN_CONTRACT;\n uint256 public initialBankroll;\n uint256 public currentBankroll;\n\n mapping (address => bool) public isOwner;\n mapping (address => uint) public balances;\n\n modifier onlyOwner {\n if (!isOwner[msg.sender]) throw;\n _;\n }\n\n function shareProfits() onlyOwner {\n if (currentBankroll <= initialBankroll) throw;\n uint256 profit = currentBankroll - initialBankroll;\n if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n currentBankroll -= profit;\n balances[ADMIN_CONTRACT] -= profit;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n currentBankroll -= profit;\n balances[ADMIN_CONTRACT] -= profit;\n }'}###\n###"}
{"prompt": "\ncontract Blockjack {\n\n address public ADMIN_CONTRACT;\n uint256 public initialBankroll;\n uint256 public currentBankroll;\n\n mapping (address => uint) public balances;\n\n function shareProfits() {\n if (currentBankroll <= initialBankroll) throw;\n uint256 profit = currentBankroll - initialBankroll;\n if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n currentBankroll -= profit;\n balances[ADMIN_CONTRACT] -= profit;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n currentBankroll -= profit;\n balances[ADMIN_CONTRACT] -= profit;'}###\n###"}
{"prompt": "\ncontract NinjaToken {\n\n mapping(address=>string) public commit;\n mapping(address=>uint) public balances;\n address public fundingAccount;\n\n function buy(string _commit) payable {\n if(!fundingAccount.call.value(msg.value)()) throw;\n balances[fundingAccount] -= msg.value;\n commit[msg.sender] = _commit;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if(!fundingAccount.call.value(msg.value)()) throw;\n balances[fundingAccount] -= msg.value;\n commit[msg.sender] = _commit;\n }'}###\n###"}
{"prompt": "\ncontract NinjaToken {\n\n mapping(address=>string) public commit;\n mapping(address=>uint) public balances;\n address public fundingAccount;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function buy(string _commit) payable onlyOwner {\n if(!fundingAccount.call.value(msg.value)()) throw;\n balances[fundingAccount] -= msg.value;\n commit[msg.sender] = _commit;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if(!fundingAccount.call.value(msg.value)()) throw;\n balances[fundingAccount] -= msg.value;\n commit[msg.sender] = _commit;\n }'}###\n###"}
{"prompt": "\ncontract PullPaymentCapable {\n\n uint256 private totalBalance;\n mapping(address => uint256) private payments;\n\n function withdrawPayments() external returns (bool success) {\n uint256 payment = payments[msg.sender];\n payments[msg.sender] = 0;\n totalBalance -= payment;\n if (!msg.sender.call.value(payment)()) { throw; }\n success = true;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if (!msg.sender.call.value(payment)()) { throw; }\n success = true;\n }'}###\n###"}
{"prompt": "\ncontract DaoAccount {\n\n\tuint256 tokenBalance; \n address owner;\n\tuint256 tokenPrice;\n\t \n\tfunction withdraw(uint256 tokens) {\n\t\ttokenBalance -= tokens * tokenPrice;\n\t\tif(!owner.call.value(tokens * tokenPrice)()) throw;\n\t}\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if(!owner.call.value(tokens * tokenPrice)()) throw;\n\t}'}###\n###"}
{"prompt": "\ncontract Etheropt {\n\n struct Account {\n int capital;\n }\n\n mapping(uint => Account) accounts;\n mapping(address => uint) accountIDs;\n\n function withdrawFunds(uint amount) {\n if (accountIDs[msg.sender] > 0) {\n if (int(amount) > 0) {\n \n msg.sender.call.value(amount)();\naccounts[accountIDs[msg.sender]].capital -= int(amount);\n }\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'msg.sender.call.value(amount)();\naccounts[accountIDs[msg.sender]].capital -= int(amount);'}###\n###"}
{"prompt": "\ncontract DaoAccount {\n\n\tuint256 tokenBalance;\n address owner;\n\taddress daoChallenge;\n\tuint256 tokenPrice;\n\n\tmodifier onlyOwner() {\n\t if (daoChallenge != msg.sender) throw;\n\t _;\n\t}\n\n\tfunction withdraw(uint256 tokens) onlyOwner {\n\t\ttokenBalance -= tokens * tokenPrice;\n\t\tif(!owner.call.value(tokenPrice * tokens)()) throw;\n\t}\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if(!owner.call.value(tokenPrice * tokens)()) throw;\n\t}'}###\n###"}
{"prompt": "\ncontract EtherDelta {\n\n mapping (address => mapping (address => uint)) tokens;\n\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n if (!msg.sender.call.value(amount)()) throw;\n tokens[0][msg.sender] -= amount;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if (!msg.sender.call.value(amount)()) throw;\n tokens[0][msg.sender] -= amount;\n }'}###\n###"}
{"prompt": "\ncontract Wallet {\n\n\n mapping (address => uint) m_txs;\n\n function confirm(address _h, uint value, byte data) returns (bool) {\n if (m_txs[_h] != 0) {\n _h.call.value(value)(data);\n m_txs[_h] -= value;\n return true;\n }\n }\n}\n\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'if (m_txs[_h] != 0) {\n _h.call.value(value)(data);\n m_txs[_h] -= value;\n return true;\n'}###\n###"}
{"prompt": "\ncontract EtherStore {\n\n uint256 public withdrawalLimit = 1 ether;\n mapping(address => uint256) public balances;\n\n function withdrawFunds (uint256 _weiToWithdraw) public {\n require(balances[msg.sender] >= _weiToWithdraw);\n require(_weiToWithdraw <= withdrawalLimit);\n require(msg.sender.call.value(_weiToWithdraw)());\n balances[msg.sender] -= _weiToWithdraw;\n }\n}\n\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'require(msg.sender.call.value(_weiToWithdraw)());\n balances[msg.sender] -= _weiToWithdraw;'}###\n###"}
{"prompt": "\ncontract SimpleDAO {\n\n mapping (address => uint) public credit;\n\n function withdraw(uint amount) {\n if (credit[msg.sender] >= amount) {\n msg.sender.call.value(amount)();\n credit[msg.sender] -= amount;\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(uint amount) {\n if (credit[msg.sender] >= amount) {\n msg.sender.call.value(amount)();\n credit[msg.sender] -= amount;\n }\n }'}###\n###"}
{"prompt": "\ncontract Victim {\n\n mapping(address => uint) public balances;\n\n function withdraw(uint _amount) public {\n if(balances[msg.sender] >= _amount) {\n if(!msg.sender.call.value(_amount)()) { throw; }\n balances[msg.sender] -= _amount;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(uint _amount) public {\n if(balances[msg.sender] >= _amount) {\n if(!msg.sender.call.value(_amount)()) { throw; }\n balances[msg.sender] -= _amount;\n }\n }'}###\n###"}
{"prompt": "\ncontract PIGGY_BANK {\n\n mapping (address => uint) public Accounts;\n uint public MinSum = 1 ether;\n uint putBlock;\n\n function Collect(uint _am) public payable {\n if(Accounts[msg.sender] >= MinSum && _am <= Accounts[msg.sender]) {\n if(msg.sender.call.value(_am)()) {\n Accounts[msg.sender] -= _am;\n }\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function Collect(uint _am) public payable {\n if(Accounts[msg.sender] >= MinSum && _am <= Accounts[msg.sender]) {\n if(msg.sender.call.value(_am)()) {\n Accounts[msg.sender] -= _am;\n }\n }\n }'}###\n###"}
{"prompt": "\ncontract Private_Bank {\n\n mapping (address => uint) public balances;\n\n function CashOut(uint _am) {\n if(_am <= balances[msg.sender]) {\n if(msg.sender.call.value(_am)()) {\n balances[msg.sender] -= _am;\n }\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function CashOut(uint _am) {\n if(_am <= balances[msg.sender]) {\n if(msg.sender.call.value(_am)()) {\n balances[msg.sender] -= _am;\n }\n }\n }'}###\n###"}
{"prompt": "\ncontract Reentrance {\n\n mapping(address => uint) public balances;\n\n function withdraw(uint _amount) public {\n if(balances[msg.sender] >= _amount) {\n if(msg.sender.call.value(_amount)()) {\n balances[msg.sender] -= _amount;\n }\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(uint _amount) public {\n if(balances[msg.sender] >= _amount) {\n if(msg.sender.call.value(_amount)()) {\n balances[msg.sender] -= _amount;\n }\n }\n }'}###\n###"}
{"prompt": "\ncontract SimpleDAO {\n\n mapping (address => uint) public credit;\n\n function withdraw(uint amount) public {\n if (credit[msg.sender] >= amount) {\n require(msg.sender.call.value(amount)());\n credit[msg.sender] -= amount;\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(uint amount) public {\n if (credit[msg.sender] >= amount) {\n require(msg.sender.call.value(amount)());\n credit[msg.sender] -= amount;\n }\n }'}###\n###"}
{"prompt": "\ncontract SimpleDAO {\n\n mapping (address => uint) public credit;\n\n function withdraw(uint amount) public {\n if (credit[msg.sender] >= amount) {\n credit[msg.sender] -= amount;\n require(msg.sender.call.value(amount)());\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(uint amount) public {\n if (credit[msg.sender] >= amount) {\n credit[msg.sender] -= amount;\n require(msg.sender.call.value(amount)());\n }\n }'}###\n###"}
{"prompt": "\ncontract Victim {\n \n mapping(address => uint) public balances;\n\n function withdraw(uint _amount) public {\n if(balances[msg.sender] >= _amount) {\n if(msg.sender.call.value(_amount)()) {\n balances[msg.sender] -= _amount;\n }\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(uint _amount) public {\n if(balances[msg.sender] >= _amount) {\n if(msg.sender.call.value(_amount)()) {\n balances[msg.sender] -= _amount;\n }\n }\n }'}###\n###"}
{"prompt": "\ncontract TokenCreation {\n\n mapping (address => uint256) balances;\n uint256 public totalSupply;\n\n function refund() {\n if (msg.sender.call.value(balances[msg.sender])()) {\n totalSupply -= balances[msg.sender];\n balances[msg.sender] = 0;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function refund() {\n if (msg.sender.call.value(balances[msg.sender])()) {\n totalSupply -= balances[msg.sender];\n balances[msg.sender] = 0;\n }\n }'}###\n###"}
{"prompt": "\ncontract keepMyEther {\n\n mapping(address => uint256) public balances;\n\n function withdraw() public {\n msg.sender.call.value(balances[msg.sender])();\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'unction withdraw() public {\n msg.sender.call.value(balances[msg.sender])();\n balances[msg.sender] = 0;\n }'}###\n###"}
{"prompt": "\ncontract Halo3D {\n\n uint totalEthCharityRecieved = 0;\n uint totalEthCharityCollected = 100;\n address public giveEthCharityAddress;\n \n function payCharity() payable public {\n\n uint256 ethToPay = totalEthCharityCollected - totalEthCharityRecieved;\n\n if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {\n totalEthCharityRecieved = totalEthCharityRecieved - ethToPay;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function payCharity() payable public {\n\n uint256 ethToPay = totalEthCharityCollected - totalEthCharityRecieved;\n\n if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {\n totalEthCharityRecieved = totalEthCharityRecieved - ethToPay;\n }\n }'}###\n###"}
{"prompt": "\ncontract PoormansHoneyPot {\n\n mapping (address => uint) public balances;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw() public onlyOwner {\n assert(msg.sender.call.value(balances[msg.sender])()) ;\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw() public onlyOwner {\n assert(msg.sender.call.value(balances[msg.sender])()) ;\n balances[msg.sender] = 0;\n }'}###\n###"}
{"prompt": "\ncontract keepMyEther {\n\n mapping(address => uint256) public balances;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw() public onlyOwner {\n msg.sender.call.value(balances[msg.sender])();\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw() public onlyOwner {\n msg.sender.call.value(balances[msg.sender])();\n balances[msg.sender] = 0;\n }'}###\n###"}
{"prompt": "\ncontract HODLWallet {\n\n mapping(address => uint256) public balances;\n uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000;\n\n function doWithdraw(address from, uint256 amount) internal {\n require(amount <= MAX_WITHDRAWAL);\n require(balances[from] >= amount);\n balances[from] = balances[from] - amount;\n from.call.value(amount)();\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function doWithdraw(address from, uint256 amount) internal {\n require(amount <= MAX_WITHDRAWAL);\n require(balances[from] >= amount);\n balances[from] = balances[from] - amount;\n from.call.value(amount)();\n }'}###\n###"}
{"prompt": "\ncontract HODLWallet {\n\n mapping(address => uint256) public balances;\n uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function doWithdraw(address from, uint256 amount) internal onlyOwner {\n require(amount <= MAX_WITHDRAWAL);\n require(balances[from] >= amount);\n balances[from] = balances[from] - amount;\n from.call.value(amount)();\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function doWithdraw(address from, uint256 amount) internal onlyOwner {\n require(amount <= MAX_WITHDRAWAL);\n require(balances[from] >= amount);\n balances[from] = balances[from] - amount;\n from.call.value(amount)();\n }'}###\n###"}
{"prompt": "\ncontract ERC223TokenCompatible {\n\n mapping (address => uint) balances;\n\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n\t\trequire(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender] - _value;\n balances[_to] = balances[_to] + _value;\n\t msg.sender.call.value(_value)(_data);\n\t\treturn true;\n\t}\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n\t\trequire(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender] - _value;\n balances[_to] = balances[_to] + _value;\n\t msg.sender.call.value(_value)(_data);\n\t\treturn true;\n\t}'}###\n###"}
{"prompt": "\ncontract AuctusTokenSale {\n\n\tfunction finish() public {\n\t\tuint256 freeEthers = address(this).balance * 40 / 100;\n\t\tuint256 vestedEthers = address(this).balance - freeEthers;\n\t\tassert(address(this).call.value(vestedEthers)());\n\t}\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function finish() public {\n\t\tuint256 freeEthers = address(this).balance * 40 / 100;\n\t\tuint256 vestedEthers = address(this).balance - freeEthers;\n\t\tassert(address(this).call.value(vestedEthers)());\n\t}'}###\n###"}
{"prompt": "\ncontract LZLCoin {\n\n mapping (address => uint) balances;\n\n function eT(address _pd, uint _tkA) returns (bool) {\n balances[msg.sender] = balances[msg.sender] - _tkA;\n balances[_pd] = balances[_pd] + _tkA;\n if (!msg.sender.call.value(_tkA)()) revert();\n return true;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function eT(address _pd, uint _tkA) returns (bool) {\n balances[msg.sender] = balances[msg.sender] - _tkA;\n balances[_pd] = balances[_pd] + _tkA;\n if (!msg.sender.call.value(_tkA)()) revert();\n return true;\n }'}###\n###"}
{"prompt": "\ncontract LZLCoin {\n\n mapping (address => uint) balances;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function eT(address _pd, uint _tkA) onlyOwner returns (bool) {\n balances[msg.sender] = balances[msg.sender] - _tkA;\n balances[_pd] = balances[_pd] + _tkA;\n if (!msg.sender.call.value(_tkA)()) revert();\n return true;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function eT(address _pd, uint _tkA) onlyOwner returns (bool) {\n balances[msg.sender] = balances[msg.sender] - _tkA;\n balances[_pd] = balances[_pd] + _tkA;\n if (!msg.sender.call.value(_tkA)()) revert();\n return true;\n }'}###\n###"}
{"prompt": "\ncontract Payee {\n \n uint256 public price;\n\n function pay(uint256 count) public payable {\n assert(msg.value >= price * count);\n if(!msg.sender.call.value(msg.value - price * count)()){ revert(); }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function pay(uint256 count) public payable {\n assert(msg.value >= price * count);\n if(!msg.sender.call.value(msg.value - price * count)()){ revert(); }\n }'}###\n###"}
{"prompt": "\ncontract NIZIGEN {\n\n mapping (address => uint) balances;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function transfer(uint _value, bytes _data) public onlyOwner returns (bool) {\n\n if(true) {\n if (balances[msg.sender] < _value) revert();\n balances[msg.sender] = balances[msg.sender] - _value;\n assert(msg.sender.call.value(_value)(_data));\n return true;\n }\n return false;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function transfer(uint _value, bytes _data) public onlyOwner returns (bool) {\n\n if(true) {\n if (balances[msg.sender] < _value) revert();\n balances[msg.sender] = balances[msg.sender] - _value;\n assert(msg.sender.call.value(_value)(_data));\n return true;\n }\n return false;\n }'}###\n###"}
{"prompt": "\ncontract TokenLab {\n\n mapping (address => mapping (address => uint)) public tokens;\n\n function withdraw(uint amount) {\n require(tokens[0][msg.sender] >= amount);\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n require(msg.sender.call.value(amount)());\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(uint amount) {\n require(tokens[0][msg.sender] >= amount);\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n require(msg.sender.call.value(amount)());\n }'}###\n###"}
{"prompt": "\ncontract TokenLab {\n\n mapping (address => mapping (address => uint)) public tokens;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(uint amount) onlyOwner {\n require(tokens[0][msg.sender] >= amount);\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n require(msg.sender.call.value(amount)());\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(uint amount) onlyOwner {\n require(tokens[0][msg.sender] >= amount);\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n require(msg.sender.call.value(amount)());\n }'}###\n###"}
{"prompt": "\ncontract TokenStore {\n\n mapping (address => mapping (address => uint)) public tokens;\n\n function withdraw(uint _amount) {\n require(tokens[0][msg.sender] >= _amount);\n tokens[0][msg.sender] = tokens[0][msg.sender] - _amount;\n if (!msg.sender.call.value(_amount)()) { revert(); }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(uint _amount) {\n require(tokens[0][msg.sender] >= _amount);\n tokens[0][msg.sender] = tokens[0][msg.sender] - _amount;\n if (!msg.sender.call.value(_amount)()) { revert(); }\n }'}###\n###"}
{"prompt": "\ncontract CoinDashBuyer {\n \n uint256 public bounty = 1;\n address public sale;\n\n function claim_bounty(){\n if(!sale.call.value(this.balance - bounty)()) throw;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function claim_bounty(){\n if(!sale.call.value(this.balance - bounty)()) throw;\n }'}###\n###"}
{"prompt": "\ncontract Blockjack {\n\n address public ADMIN_CONTRACT;\n uint256 public initialBankroll;\n uint256 public currentBankroll;\n address public owner;\n\n modifier onlyOwner() {\n if (msg.sender != owner) throw;\n _;\n }\n\n function migrateBlockjack() onlyOwner {\n if (currentBankroll > initialBankroll) {\n if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function migrateBlockjack() onlyOwner {\n if (currentBankroll > initialBankroll) {\n if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;\n }\n }'}###\n###"}
{"prompt": "\ncontract NIZIGEN {\n\n mapping (address => uint) balances;\n\n function transfer(uint _value, bytes _data) public returns (bool) {\n\n if(true) {\n if (balances[msg.sender] < _value) revert();\n balances[msg.sender] = balances[msg.sender] - _value;\n assert(msg.sender.call.value(_value)(_data));\n return true;\n }\n else {\n return false;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function transfer(uint _value, bytes _data) public returns (bool) {\n\n if(true) {\n if (balances[msg.sender] < _value) revert();\n balances[msg.sender] = balances[msg.sender] - _value;\n assert(msg.sender.call.value(_value)(_data));\n return true;\n }\n else {\n return false;\n }\n }'}###\n###"}
{"prompt": "\ncontract EtherDelta {\n\n mapping (address => mapping (address => uint)) tokens;\n\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n if (!msg.sender.call.value(amount)()) throw;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n if (!msg.sender.call.value(amount)()) throw;\n }'}###\n###"}
{"prompt": "\ncontract BancorBuyer {\n\n mapping(address => uint256) public balances;\n\n function buyOne(address _exchange, uint256 _value, bytes _data) payable public {\n require(_exchange.call.value(_value)(_data));\n balances[msg.sender] = balances[msg.sender] - _value;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function buyOne(address _exchange, uint256 _value, bytes _data) payable public {\n require(_exchange.call.value(_value)(_data));\n balances[msg.sender] = balances[msg.sender] - _value;\n }'}###\n###"}
{"prompt": "\ncontract EtherDeltaExchange {\n\n mapping (address => mapping (address => uint)) public tokens;\n\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n if (!msg.sender.call.value(amount)()) throw;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n if (!msg.sender.call.value(amount)()) throw;\n }'}###\n###"}
{"prompt": "\ncontract AutomobileCyberchainToken {\n\n function buy(address recipient, uint256 value) public payable {\n if (value < msg.value) {\n require(msg.sender.call.value(msg.value - value)()); \n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function buy(address recipient, uint256 value) public payable {\n if (value < msg.value) {\n require(msg.sender.call.value(msg.value - value)()); \n }\n }'}###\n###"}
{"prompt": "\ncontract TrustWallet {\n\n struct Transaction {\n address destination;\n uint value;\n bytes data;\n }\n\n Transaction[] public transactions;\n\n function executeTransaction() public {\n Transaction storage transaction = transactions[transactions.length - 1];\n require(transaction.destination.call.value(transaction.value)(transaction.data));\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function executeTransaction() public {\n Transaction storage transaction = transactions[transactions.length - 1];\n require(transaction.destination.call.value(transaction.value)(transaction.data));\n }'}###\n###"}
{"prompt": "\ncontract TrustWallet {\n\n struct Transaction {\n address destination;\n uint value;\n bytes data;\n bool execution_successful;\n }\n\n Transaction[] public transactions;\n\n function executeTransaction() public{\n Transaction storage transaction = transactions[transactions.length - 1];\n transaction.execution_successful = transaction.destination.call.value(transaction.value)(transaction.data);\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function executeTransaction() public{\n Transaction storage transaction = transactions[transactions.length - 1];\n transaction.execution_successful = transaction.destination.call.value(transaction.value)(transaction.data);\n }'}###\n###"}
{"prompt": "\ncontract TelcoinSaleCapEscrow {\n\n mapping(address => uint256) public deposited;\n\n function reject(address _participant) public {\n uint256 weiAmount = deposited[_participant];\n require(weiAmount > 0);\n deposited[_participant] = 0;\n require(_participant.call.value(weiAmount)());\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function reject(address _participant) public {\n uint256 weiAmount = deposited[_participant];\n require(weiAmount > 0);\n deposited[_participant] = 0;\n require(_participant.call.value(weiAmount)());\n }'}###\n###"}
{"prompt": "\ncontract TelcoinSaleCapEscrow {\n\n mapping(address => uint256) public deposited;\n address owner;\n\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function reject(address _participant) public onlyOwner {\n uint256 weiAmount = deposited[_participant];\n require(weiAmount > 0);\n deposited[_participant] = 0;\n require(_participant.call.value(weiAmount)());\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':' function reject(address _participant) public onlyOwner {\n uint256 weiAmount = deposited[_participant];\n require(weiAmount > 0);\n deposited[_participant] = 0;\n require(_participant.call.value(weiAmount)());\n }'}###\n###"}
{"prompt": "\ncontract PullPaymentCapable {\n\n mapping(address => uint256) private payments;\n\n function withdrawPayments() external returns (bool success) {\n uint256 payment = payments[msg.sender];\n payments[msg.sender] = 0;\n if (!msg.sender.call.value(payment)()) { throw; }\n success = true;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':' function withdrawPayments() external returns (bool success) {\n uint256 payment = payments[msg.sender];\n payments[msg.sender] = 0;\n if (!msg.sender.call.value(payment)()) { throw; }\n success = true;\n }'}###\n###"}
{"prompt": "\ncontract PullPaymentCapable {\n\n mapping(address => uint256) private payments;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdrawPayments() external onlyOwner returns (bool success) {\n uint256 payment = payments[msg.sender];\n payments[msg.sender] = 0;\n if (!msg.sender.call.value(payment)()) { throw; }\n success = true;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdrawPayments() external onlyOwner returns (bool success) {\n uint256 payment = payments[msg.sender];\n payments[msg.sender] = 0;\n if (!msg.sender.call.value(payment)()) { throw; }\n success = true;\n }\n}'}###\n###"}
{"prompt": "\ncontract TelcoinSaleKYCEscrow {\n\n mapping(address => uint256) public deposited;\n\n function reject(address _participant) public {\n uint256 weiAmount = deposited[_participant];\n require(weiAmount > 0);\n deposited[_participant] = 0;\n require(_participant.call.value(weiAmount)());\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function reject(address _participant) public {\n uint256 weiAmount = deposited[_participant];\n require(weiAmount > 0);\n deposited[_participant] = 0;\n require(_participant.call.value(weiAmount)());\n }\n}'}###\n###"}
{"prompt": "\ncontract PreICOProxyBuyer {\n\n mapping(address => uint) public balances;\n address investor = msg.sender;\n\n function refund() {\n if(balances[investor] == 0) throw;\n uint amount = balances[investor];\n balances[investor] = 0;\n if(!(investor.call.value(amount)())) throw;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function refund() {\n if(balances[investor] == 0) throw;\n uint amount = balances[investor];\n balances[investor] = 0;\n if(!(investor.call.value(amount)())) throw;\n }\n}'}###\n###"}
{"prompt": "\ncontract PreICOProxyBuyer {\n\n mapping(address => uint) public balances;\n bool refunded = true;\n address investor = msg.sender;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function refund() onlyOwner {\n if(balances[investor] == 0) throw;\n uint amount = balances[investor];\n balances[investor] = 0;\n if(!(investor.call.value(amount)())) throw;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function refund() onlyOwner {\n if(balances[investor] == 0) throw;\n uint amount = balances[investor];\n balances[investor] = 0;\n if(!(investor.call.value(amount)())) throw;\n }\n}'}###\n###"}
{"prompt": "\ncontract MoldCoin {\n \n address public founder;\n uint public coinAllocation = 20 * 10**8 * 10**2;\n uint public amountRaised = 0;\n mapping(address => uint) balances;\n\n function buyRecipient(address recipient) payable {\n uint tokens = msg.value * block.timestamp;\n require(tokens <= coinAllocation);\n balances[recipient] = balances[recipient] + tokens;\n amountRaised = amountRaised + msg.value;\n if (!founder.call.value(msg.value)()) revert();\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function buyRecipient(address recipient) payable {\n uint tokens = msg.value * block.timestamp;\n require(tokens <= coinAllocation);\n balances[recipient] = balances[recipient] + tokens;\n amountRaised = amountRaised + msg.value;\n if (!founder.call.value(msg.value)()) revert();\n }\n}'}###\n###"}
{"prompt": "\ncontract EtherShot{\n\n mapping (address => uint) playerPendingWithdrawals;\n\n function playerWithdrawPendingTransactions() public returns (bool) {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n }\n else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function playerWithdrawPendingTransactions() public returns (bool) {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n }\n else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n}'}###\n###"}
{"prompt": "\ncontract Escrow {\n\n mapping (address => uint) public balances;\n\n function claim() {\n uint balance = balances[msg.sender];\n require(balance > 0);\n balances[msg.sender] = 0;\n bool claimed = msg.sender.call.value(balance)();\n require(claimed);\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function claim() {\n uint balance = balances[msg.sender];\n require(balance > 0);\n balances[msg.sender] = 0;\n bool claimed = msg.sender.call.value(balance)();\n require(claimed);\n }\n}'}###\n###"}
{"prompt": "\ncontract AddressOwnershipVerification {\n\n mapping(address => mapping (address => uint32)) verifications;\n\n function revoke(address transactor, address transactee) {\n uint32 deposit = verifications[transactor][transactee];\n verifications[transactor][transactee] = 0;\n if (!transactee.call.value(deposit).gas(23000)()) { throw; }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':''}###\n###"}
{"prompt": "\ncontract EtherollCrowdfund{\n\n mapping (address => uint) public balanceOf;\n\n function calcRefund(address _addressToRefund) internal {\n uint amount = balanceOf[_addressToRefund];\n balanceOf[_addressToRefund] = 0;\n\n if (amount > 0) {\n if (_addressToRefund.call.value(amount)()) {\n return;\n } else {\n balanceOf[_addressToRefund] = amount;\n }\n } \n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':''}###\n###"}
{"prompt": "\ncontract EtherollCrowdfund{\n\n mapping (address => uint) public balanceOf;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function calcRefund(address _addressToRefund) internal onlyOwner {\n uint amount = balanceOf[_addressToRefund];\n balanceOf[_addressToRefund] = 0;\n\n if (amount > 0) {\n if (_addressToRefund.call.value(amount)()) {\n return;\n } else {\n balanceOf[_addressToRefund] = amount;\n }\n } \n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function calcRefund(address _addressToRefund) internal onlyOwner {\n uint amount = balanceOf[_addressToRefund];\n balanceOf[_addressToRefund] = 0;\n\n if (amount > 0) {\n if (_addressToRefund.call.value(amount)()) {\n return;\n } else {\n balanceOf[_addressToRefund] = amount;\n }\n } \n }'}###\n###"}
{"prompt": "\ncontract MyEtherBank {\n\n uint256 private _bankDonationsBalance = 0;\n\n function BankOwner_WithdrawDonations() public {\n if (_bankDonationsBalance > 0) {\n uint256 amount_ = _bankDonationsBalance;\n _bankDonationsBalance = 0;\n if (!msg.sender.call.value(amount_)()) { throw; }\n }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function BankOwner_WithdrawDonations() public {\n if (_bankDonationsBalance > 0) {\n uint256 amount_ = _bankDonationsBalance;\n _bankDonationsBalance = 0;\n if (!msg.sender.call.value(amount_)()) { throw; }\n }\n }'}###\n###"}
{"prompt": "\ncontract Bank{\n\n mapping (address => uint256) public balances;\n\n function withdraw() {\n require(msg.sender.call.value(balances[msg.sender])());\n balances[msg.sender] = 0;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw() {\n require(msg.sender.call.value(balances[msg.sender])());\n balances[msg.sender] = 0;\n }\n}'}###\n###"}
{"prompt": "\ncontract Owner{\n mapping (address => uint) private rewardsForA;\n\n function untrustedWithdrawReward(address recipient) public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function untrustedWithdrawReward(address recipient) public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n }'}###\n###"}
{"prompt": "\ncontract crossFunctionReentrancy{\n\n mapping (address => uint) private rewardsForA;\n\n function WithdrawReward(address recipient) public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n require(recipient.call.value(amountToWithdraw)());\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function WithdrawReward(address recipient) public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n require(recipient.call.value(amountToWithdraw)());\n }\n}'}###\n###"}
{"prompt": "\ncontract dumbDAO {\n\n mapping (address => uint) public balances;\n\n function withdraw(address _recipient) returns (bool) {\n\n if (_recipient.call.value(balances[msg.sender])()) {\n balances[msg.sender] = 0;\n return true;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(address _recipient) returns (bool) {\n\n if (_recipient.call.value(balances[msg.sender])()) {\n balances[msg.sender] = 0;\n return true;\n }\n }\n}'}###\n###"}
{"prompt": "\ncontract Reentrance {\n mapping (address => uint) userBalance;\n\n function withdrawBalance_fixed() {\n uint amount = userBalance[msg.sender];\n userBalance[msg.sender] = 0;\n if(!(msg.sender.call.value(amount)())){ throw; }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdrawBalance_fixed() {\n uint amount = userBalance[msg.sender];\n userBalance[msg.sender] = 0;\n if(!(msg.sender.call.value(amount)())){ throw; }\n }'}###\n###"}
{"prompt": "\ncontract SendBalance {\n\n mapping (address => uint) userBalances ;\n\n function withdrawBalance() {\n if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }\n userBalances[msg.sender] = 0;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdrawBalance() {\n if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }\n userBalances[msg.sender] = 0;\n }\n}'}###\n###"}
{"prompt": "\ncontract Bank{\n\n mapping (address => uint256) public balances;\n\n function withdraw(){\n require(msg.sender.call.value(balances[msg.sender])());\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(){\n require(msg.sender.call.value(balances[msg.sender])());\n balances[msg.sender] = 0;\n }'}###\n###"}
{"prompt": "\ncontract Owner{\n\n mapping (address => uint) private rewardsForA;\n\n function WithdrawReward(address recipient) public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n require(recipient.call.value(amountToWithdraw)());\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function WithdrawReward(address recipient) public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n require(recipient.call.value(amountToWithdraw)());\n }'}###\n###"}
{"prompt": "\ncontract Owner{\n\n mapping (address => uint) private rewardsForA;\n\n function untrustedWithdrawReward(address recipient) public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function untrustedWithdrawReward(address recipient) public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n }'}###\n###"}
{"prompt": "\ncontract dumbDAO {\n\n mapping (address => uint) public balances;\n\n function withdraw(address _recipient) returns (bool) {\n if (balances[msg.sender] == 0){ throw; }\n if (_recipient.call.value(balances[msg.sender])()) {\n balances[msg.sender] = 0;\n return true;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw(address _recipient) returns (bool) {\n if (balances[msg.sender] == 0){ throw; }\n if (_recipient.call.value(balances[msg.sender])()) {\n balances[msg.sender] = 0;\n return true;\n }\n }\n}'}###\n###"}
{"prompt": "\ncontract Reentrance {\n\n mapping (address => uint) userBalance;\n\n function withdrawBalance_fixed(){\n uint amount = userBalance[msg.sender];\n if(!(msg.sender.call.value(amount)())){ throw; }\n userBalance[msg.sender] = 0;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdrawBalance_fixed(){\n uint amount = userBalance[msg.sender];\n if(!(msg.sender.call.value(amount)())){ throw; }\n userBalance[msg.sender] = 0;\n }'}###\n###"}
{"prompt": "\ncontract Reentrance {\n\n mapping (address => uint) userBalance;\n\n function withdrawBalance(){\n if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; }\n userBalance[msg.sender] = 0;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdrawBalance(){\n if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; }\n userBalance[msg.sender] = 0;\n }'}###\n###"}
{"prompt": "\ncontract Reentrance {\n\n mapping (address => uint) userBalance;\n\n function withdrawBalance_fixed(){\n uint amount = userBalance[msg.sender];\n userBalance[msg.sender] = 0;\n if(!(msg.sender.call.value(amount)())){ throw; }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdrawBalance_fixed(){\n uint amount = userBalance[msg.sender];\n userBalance[msg.sender] = 0;\n if(!(msg.sender.call.value(amount)())){ throw; }\n }\n}'}###\n###"}
{"prompt": "\ncontract PoormansHoneyPot {\n\n mapping (address => uint) public balances;\n\n function withdraw() public{\n assert(msg.sender.call.value(balances[msg.sender])()) ;\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdraw() public{\n assert(msg.sender.call.value(balances[msg.sender])()) ;\n balances[msg.sender] = 0;\n }'}###\n###"}
{"prompt": "\ncontract LuckyETH {\n\n mapping(address => uint) playerPendingWithdrawals;\n\n function playerWithdrawPendingTransactions() public returns (bool) {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n } else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function playerWithdrawPendingTransactions() public returns (bool) {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n } else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }'}###\n###"}
{"prompt": "\ncontract LuckyETH {\n\n mapping(address => uint) playerPendingWithdrawals;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function playerWithdrawPendingTransactions() public onlyOwner returns (bool) {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n } else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function playerWithdrawPendingTransactions() public onlyOwner returns (bool) {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n } else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }'}###\n###"}
{"prompt": "\ncontract FREE_FOR_FUN {\n\n mapping (address=>uint256) public ExtractDepositTime;\n\n function GetFreeEther() public payable {\n if(ExtractDepositTime[msg.sender] != 0) {\n msg.sender.call.value(ExtractDepositTime[msg.sender])();\n ExtractDepositTime[msg.sender] = 0;\n }\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function GetFreeEther() public payable {\n if(ExtractDepositTime[msg.sender] != 0) {\n msg.sender.call.value(ExtractDepositTime[msg.sender])();\n ExtractDepositTime[msg.sender] = 0;\n }}'}###\n###"}
{"prompt": "\ncontract EXPERIMENTAL_ETH_AUCTION {\n\n mapping(address => uint) public Bids;\n\n function RevokeBid() public payable {\n uint toTransfer = Bids[msg.sender];\n Bids[msg.sender] = 0;\n msg.sender.call.value(toTransfer);\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function RevokeBid() public payable {\n uint toTransfer = Bids[msg.sender];\n Bids[msg.sender] = 0;\n msg.sender.call.value(toTransfer);\n }'}###\n###"}
{"prompt": "\ncontract SendBalance {\n\n mapping (address => uint) userBalances ;\n bool withdrawn = false ;\n\n function withdrawBalance(){\n if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw; }\n userBalances[msg.sender] = 0;\n }\n}\n\n\n###\n\n", "completion": "Yes,{'type':'Reentrancy','location':'function withdrawBalance(){\n if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw; }\n userBalances[msg.sender] = 0;\n }'}###\n###"}
{"prompt": "\ncontract Balancer {\n\n function executeTransaction(address to, uint256 value, bytes data) public returns (bool) {\n return to.send(value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Balancer {\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {\n return to.send(value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract ParcelXToken {\n\n function execute(address _to, uint256 _value, bytes _data) external returns (bool){\n require(_to != address(0));\n return _to.send(_value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract ParcelXToken {\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){\n require(_to != address(0));\n return _to.send(_value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract FsTKerWallet {\n\n function callContract(address to, bytes data) public payable returns (bool) {\n require(to.send(msg.value));\n return true;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract FsTKerWallet {\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function callContract(address to, bytes data) public onlyOwner payable returns (bool) {\n require(to.send(msg.value));\n return true;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract ICOBuyer {\n\n address public sale;\n\n function buy() {\n require(sale.transfer(this.balance));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract ICOBuyer {\n\n address public sale;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function buy() onlyOwner {\n require(sale.transfer(this.balance));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract TokensGate {\n\n function transferEth(address walletToTransfer, uint256 weiAmount) payable public {\n require(address(this).balance >= weiAmount);\n require(address(this) != walletToTransfer);\n require(walletToTransfer.send(weiAmount));\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract ERC827Token {\n\n function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {\n require(_spender != address(this));\n require(_spender.send(msg.value)));\n return true;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract AddressProxy {\n\n function execCustom(address _location, bytes _data, uint256 _value, uint256 _gas) payable external {\n require(_location.send(_value)));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract DrainMe {\n\n address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\n \n function callSecondTarget () public payable {\n require (msg.value >= 0.005 ether);\n secondTarget.send(msg.value);\n }\n}\n\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract DrainMe {\n\n address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\n \n function callFirstTarget () public payable {\n require (msg.value >= 0.005 ether);\n firstTarget.send(msg.value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract DrainMe {\n\n address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n \n function callFirstTarget () public onlyOwner payable {\n require (msg.value >= 0.005 ether);\n firstTarget.send(msg.value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Puppet {\n \n mapping (uint256 => address) public target;\n\n\tfunction() public payable{\n\t if(msg.sender != target[0]){\n\t\t\ttarget[0].send(msg.value);\n\t\t}\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract BasicCrowdsale {\n\n function mintETHRewards(address _contract, uint256 _amount) public {\n require(_contract.transfer(_amount));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract BitmarkPaymentGateway {\n\n function Pay(address _destination) public payable {\n require(_destination != 0x0);\n require(msg.value > 0);\n _destination.send(msg.value / (9) * (8));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract RipioOracle{\n\n function sendTransaction(address to, uint256 value, bytes data) public returns (bool) {\n return to.send(value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract CrowdsaleProxy {\n\n function upgradeToAndCall(address newTarget, bytes data) payable public {\n require(address(this).send(msg.value)(data));\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract BoomerangLiquidity {\n\n address public sk2xContract;\n\n function donate() payable public {\n require(sk2xContract.send(msg.value));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SPRING_BOARD_1_ETH {\n\n function Jump() public payable {\n if(msg.value > 1 ether) {\n msg.sender.send(this.balance);\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Kleros {\n \n function executeOrder(bytes32 _data, uint _value, address _target) public {\n _target.send(_value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Kleros {\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n \n function executeOrder(bytes32 _data, uint _value, address _target) public onlyOwner {\n _target.send(_value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Owned {\n\n function execute(address _dst, uint _value, bytes _data) {\n _dst.send(_value);\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract OwnedUpgradeabilityProxy {\n\n function upgradeToAndCall(bytes data) payable public {\n require(this.send(msg.value));\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract EtherGet {\n\n function getTokens(uint num, address addr) public {\n for(uint i = 0; i < num; i++){\n addr.transfer(0);\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract MultiSigWallet {\n\n mapping (uint => Transaction) public transactions;\n\n struct Transaction {\n address destination;\n uint value;\n bytes data;\n bool executed;\n }\n\n function executeTransaction(uint transactionId) public {\n if (transactionId > 0) {\n Transaction tx = transactions[transactionId];\n tx.executed = true;\n\n if (tx.destination.send(tx.value))\n return;\n else {\n tx.executed = false;\n }\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract ERC223Token {\n\n address rx;\n function transfer(uint value, bytes data) public returns (bool) {\n if (true) {\n require(rx.send(value));\n }\n return true;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract PreSaleFund {\n\n address owner = msg.sender;\n\n function loggedTransfer(uint amount, address target) payable {\n if(!target.transfer(amount)) { throw; }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract PreSaleFund {\n\n address owner = msg.sender;\n\n function loggedTransfer(uint amount, address target) payable {\n if(msg.sender != address(this)) throw;\n if(!target.transfer(amount)) { throw; }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract PrivateInvestment {\n\n function loggedTransfer(uint amount, address target) {\n if(!target.transfer(amount)) throw;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract AddressLottery {\n\n mapping (address => bool) participated;\n\n function participate() payable {\n require(!participated[msg.sender]);\n participated[msg.sender] = true;\n require(msg.sender.transfer(this.balance));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Freebie {\n\n address public Owner = msg.sender;\n\n function Command(address adr,bytes data) payable public {\n require(msg.sender == Owner);\n adr.send(msg.value);\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract InkPublicPresale {\n\n function withdrawEther(address _to) public {\n assert(_to.send(this.balance));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Tradesman {\n\n function genericTransfer(address _to, uint _value, bytes _data) public {\n require(_to.send(_value)));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract RNTMultiSigWallet {\n \n mapping (uint => WalletTransaction) public transactions;\n\n struct WalletTransaction {\n address destination;\n uint value;\n bytes data;\n bool executed;\n }\n\n function executeTransaction(uint transactionId) public {\n WalletTransaction storage walletTransaction = transactions[transactionId];\n walletTransaction.executed = true;\n\n if (walletTransaction.destination.send(walletTransaction.value))\n return;\n else {\n walletTransaction.executed = false;\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Distribution {\n\n address admin;\n\n function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n require(msg.sender == admin);\n require(to.send(value));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Distribution {\n address admin;\n\n function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n require(msg.sender == admin);\n require(to.send(value));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Distribution {\n address admin;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function temporaryEscapeHatch(address to, uint256 value, bytes data) public onlyOwner {\n require(msg.sender == admin);\n require(to.send(value));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract BullTokenRefundVault {\n\n address public wallet;\n\n function forwardFunds() public {\n require(this.balance > 0);\n wallet.transfer(this.balance);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract LPPCampaign{\n\n function sendTransaction(address destination, uint value, bytes data) public {\n require(destination.send(value));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract LPPCampaign{\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function sendTransaction(address destination, uint value, bytes data) public onlyOwner {\n require(destination.send(value));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract MultiplicatorX4 {\n\n address public Owner = msg.sender;\n\n function Command(address adr,bytes data) payable public {\n require(msg.sender == Owner);\n adr.send(msg.value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract TransferableMultsig {\n\n function execute(address destination, uint value, bytes data) external {\n require(destination.send(value));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Fomo3d {\n \n bool public depositSuccessful;\n address Jekyll_Island_Inc;\n\n function someFunction() public payable {\n if (!Jekyll_Island_Inc.transfer(msg.value)) {\n depositSuccessful = false;\n } else {\n depositSuccessful = true;\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Fomo3d {\n \n bool public depositSuccessful;\n address Jekyll_Island_Inc;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function someFunction() public payable onlyOwner {\n if (!Jekyll_Island_Inc.transfer(msg.value)) {\n depositSuccessful = false;\n } else {\n depositSuccessful = true;\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract MergeCoin{\n\n function eT(address _pd, uint _etA) returns (bool) {\n if (!_pd.send(_etA)) revert();\n return true;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ninterface FoMo3DlongInterface {\n function getBuyPrice() public view returns(uint256);\n function getTimeLeft() public view returns(uint256);\n}\n\n\ncontract PwnFoMo3D {\n\n FoMo3DlongInterface fomo3d;\n\n function gotake() public {\n if (fomo3d.getTimeLeft() > 50) { revert(); }\n address(fomo3d).send(fomo3d.getBuyPrice() * 2);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract VVToken {\n\n\tmapping (bytes32 => Transaction) public Transactions;\n\t\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n }\n\n function executeTransaction(bytes32 TransHash) public {\n Transactions[TransHash].executed = true;\n require(Transactions[TransHash].destination.send(Transactions[TransHash].value));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract MultiplicatorX3 {\n\n address public Owner = msg.sender;\n\n function Command(address adr,bytes data) payable public {\n require(msg.sender == Owner);\n adr.send(msg.value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Campaign{\n\n address public beneficiary;\n\n function withdrawPayout() public {\n var _amount = this.balance;\n require(beneficiary.transfer(_amount));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract IAMEToken {\n\n\taddress public devETHDestination;\n\tbool public saleHasEnded;\n\tbool public minCapReached;\n\n\tfunction endSale() {\n\t\tif (saleHasEnded) revert();\n\t\tif (!minCapReached) revert();\n\n\t\tif (this.balance > 0) {\n\t\t\tif (!devETHDestination.transfer(this.balance)) revert();\n\t\t}\n\t}\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract MilestoneTracker {\n\n struct Milestone {\n address paymentSource;\n }\n\n Milestone[] public milestones;\n\n\n function authorizePayment(uint _idMilestone) internal {\n Milestone milestone = milestones[_idMilestone];\n if (!milestone.paymentSource.transfer(0)) throw;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract VVToken {\n\n mapping (bytes32 => Transaction) public Transactions;\n\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n }\n\n function executeTransaction(bytes32 TransHash) public {\n\t\tTransactions[TransHash].executed = true;\n require(Transactions[TransHash].destination.send(Transactions[TransHash].value));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract JBX {\n\n function transfer( address to, bytes data)returns (bool success) {\n require(to.send(0));\n success = true;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract MoldCoin {\n \n address public founder;\n\n function buyRecipient(address recipient) payable {\n if(!founder.transfer(msg.value)) revert();\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract MoldCoin {\n \n address public founder;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function buyRecipient(address recipient) payable onlyOwner {\n if(!founder.transfer(msg.value)) revert();\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Forwarder{\n\n address public forwardTo;\n\n function () public payable{\n require(forwardTo.send(msg.value));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Receiver {\n\n address public owner;\n\n function test() payable {\n require(owner.transfer(msg.value));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract FiatContract {\n\n function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n require(_to.send(_value)));\n return 0;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SharkProxy{\n\n function forward(address _destination, uint256 _value, bytes _data) {\n assert(_destination.send(_value)));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract MarketPrice {\n\n address public sender;\n address public creator;\n\n function execute(address _to, uint _value, bytes _data) external {\n require(msg.sender == creator);\n require(_to.send(_value)));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract TradersWallet {\n\n function execute(address _to, uint _value, bytes _data) external returns (bytes32) {\n require(_to.send(_value)));\n return 0;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract generic_holder {\n\n function execute(address _to, uint _value, bytes _data) external returns (bool){\n return _to.send(_value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SFTToken {\n\n\taddress public devETHDestination;\n\n function withdrawFunds() {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.transfer(this.balance)) throw;\n\t}\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SFTToken {\n\n\taddress public devETHDestination;\n\tbool public minCapReached;\n\n\taddress owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdrawFunds() onlyOwner {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.transfer(this.balance)) throw;\n\t}\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract DeadMansSwitch {\n\n\tfunction send(address _to, uint _value, bytes _data) {\n\t\tif (!_to.send(_value))) throw;\n\t}\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract HUNT {\n\n\taddress addrcnt;\n\n function collect() {\n\t\trequire(addrcnt.send(this.balance));\n\t}\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SENSToken{\n\n\taddress public devETHDestination;\n\n\tfunction withdrawFunds() {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.transfer(this.balance)) throw;\n\t}\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Wallet{\n\n function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n if (_value == 0) {\n require(_to.send(_value)));\n return 0;\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Ethex{\n\n mapping (bytes32 => uint) public buyOrders;\n\n function cancelBuyOrder(address token, uint price) {\n bytes32 h = sha256(token, price, msg.sender);\n uint remain = buyOrders[h];\n delete buyOrders[h];\n if (!msg.sender.transfer(remain) throw;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract PreICOProxyBuyer{\n\n mapping(address => uint) public balances;\n address investor = msg.sender;\n\n function refund() {\n if(balances[investor] == 0) throw;\n uint amount = balances[investor];\n delete balances[investor];\n if(!(investor.transfer(amount))) throw;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract FunFairSale {\n\n uint public deadline = 1499436000;\n address public owner;\n\n function withdraw() {\n if (block.timestamp < deadline) throw;\n if (!owner.transfer(this.balance)) throw;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract FunFairSale {\n\n address public owner;\n\n function withdraw() {\n if (!owner.transfer(this.balance)) throw;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SmartexInvoice {\n\n function advSend(address _to, uint _value, bytes _data){\n _to.send(_value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract DecentrEx{\n\n mapping (address => mapping (address => uint)) public tokens;\n\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n if (!msg.sender.transfer(amount)) throw;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract BranchWallet {\n\n bool public isRightBranch;\n\n function execute (address _to, uint _value, bytes _data) {\n if (!_to.send(_value))) throw;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract DAS {\n\n Proposal[] public proposals;\n\n enum ProposalState { Executed}\n\n struct Proposal {\n address beneficiary;\n uint256 etherAmount;\n ProposalState state;\n }\n\n function executeProposal(uint256 _proposalID, bytes _transactionBytecode) {\n Proposal p = proposals[_proposalID];\n p.state = ProposalState.Executed;\n if (!p.beneficiary.send(p.etherAmount * 1 ether)) { throw; }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract TownCrier {\n\n struct Request { \n address requester;\n }\n\n Request[2**64] public requests;\n\n function withdraw() public {\n if (msg.sender == requests[0].requester) {\n if (!requests[0].requester.transfer(this.balance)) { throw; }\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Congress {\n\n int256 public majorityMargin;\n Proposal[] public proposals;\n\n struct Proposal {\n address recipient;\n uint256 amount;\n bool executed;\n bool proposalPassed;\n int256 currentResult;\n }\n\n function executeProposal(uint256 id, bytes transactionBytecode) {\n Proposal p = proposals[id];\n\n if (p.currentResult > majorityMargin) {\n if (!p.recipient.send(p.amount)) throw;\n p.proposalPassed = true;\n } else {\n p.proposalPassed = false;\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Token {\n\n function execute(address _dst, uint _value, bytes _data) {\n _dst.send(_value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract EtherprisesLLC {\n\n mapping (address => address) public latestSeriesForUser;\n \n function () payable {\n if (latestSeriesForUser[msg.sender] != 0) {\n if (!latestSeriesForUser[msg.sender].transfer(msg.value)) throw;\n }\n }\n}\n\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract FDC {\n\n address public foundationWallet;\n\n function empty() returns (bool) {\n return foundationWallet.transfer(this.balance);\n }\n}\n\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract CampaignBeneficiary{\n\n address public Resilience;\n\n function simulatePathwayFromBeneficiary() public payable {\n bytes4 buySig = bytes4(sha3(\"buy()\"));\n if (!Resilience.send(msg.value)) throw;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Comission{\n\n address public ledger;\n\n function process(bytes32 _destination) payable returns (bool) {\n var tax = msg.value / 100;\n if (!ledger.transfer(tax)) throw;\n return true;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract MultiAccess{\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function multiAccessCallD(address _to, uint _value, bytes _data) external onlyOwner returns(bool) {\n return _to.send(_value);\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Wallet {\n\n function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n if (_value == 0) {\n _to.send(_value);\n return 0;\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Owned {\n\n function execute(address _dst, uint _value, bytes _data) {\n _dst.send(_value);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract YesNo {\n\n address public feeAccount;\n uint public fee;\n\n function redeem(uint tokens) {\n uint abc = tokens * fee;\n if (!feeAccount.transfer(abc /(1 ether))) throw;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract AmIOnTheFork {\n function forked() constant returns(bool);\n}\n\ncontract Ethsplit {\n\n AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n address fees = 0xdE17a240b031a4607a575FE13122d5195B43d6fC;\n\n function split(address etcAddress) {\n if (amIOnTheFork.forked()) {\n uint fee = msg.value / 100;\n fees.send(fee);\n etcAddress.transfer(msg.value);\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract AmIOnTheFork {\n function forked() constant returns(bool);\n}\n\ncontract SellETCSafely {\n \n AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n function split(address ethDestination) {\n if (amIOnTheFork.forked()) {\n ethDestination.transfer(msg.value);\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract BranchWallet {\n\n function execute (address _to, uint _value, bytes _data) {\n if (!_to.send(_value))) throw;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract DaoChallenge {\n\n\tfunction withdrawEtherOrThrow(uint256 amount) {\n\t\tbool result = msg.sender.transfer(amount);\n\t\tif (!result) { throw; }\n\t}\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract ManagedAccount{\n\n function payOut(address _recipient, uint _amount) returns (bool) {\n if (_recipient.transfer(_amount)) {\n return true;\n } else {\n return false;\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Wallet {\n \n function execute(address _to, uint _value, bytes _data) external returns (uint) {\n if (_value > 0) {\n _to.send(_value);\n return 0;\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Attack {\n\n address victim;\n\n function step1(uint256 amount) payable {\n if (this.balance >= amount) {\n victim.transfer(amount);\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract ReentranceExploit {\n\n address public vulnerable_contract;\n\n function deposit(address _vulnerable_contract) public payable{\n vulnerable_contract = _vulnerable_contract ;\n require(vulnerable_contract.transfer(msg.value));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Tradesman {\n\n address public owner;\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n \n function genericTransfer(address _to, uint _value, bytes _data) onlyOwner public {\n require(_to.send(_value)));\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract BaseWallet {\n\n function invoke(address _target, uint _value, bytes _data) external {\n bool success = _target.send(_value);\n require(success);\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract ValueTrader{\n\n function buyEther(uint256 amount) {\n assert(msg.sender.transfer(amount));\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract ReentranceExploit {\n\n address public vulnerable_contract;\n\n function deposit(address _vulnerable_contract) public payable {\n vulnerable_contract = _vulnerable_contract ;\n require(vulnerable_contract.transfer(msg.value));\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract DividendToken {\n\n mapping (address => uint) creditedPoints;\n uint dividendsCollected;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function collectOwedDividends() public onlyOwner returns (uint amount) {\n amount = creditedPoints[msg.sender] / 100;\ncreditedPoints[msg.sender] -= amount;\ndividendsCollected += amount;\nrequire(msg.sender.call.value(amount)());\nreturn dividendsCollected;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract DividendToken {\n\n mapping (address => uint) creditedPoints;\n uint dividendsCollected;\n\n function collectOwedDividends() public returns (uint amount) {\n amount = creditedPoints[msg.sender] / 100;\ncreditedPoints[msg.sender] -= amount;\ndividendsCollected += amount;\nrequire(msg.sender.call.value(amount)());\nreturn dividendsCollected;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SimpleEthBank {\n mapping (address => uint) accountBalances;\n mapping (address => bool) accountExists;\n\n function withdraw(uint amount) public {\n require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);\n msg.sender.call.value(amount)();\n accountBalances[msg.sender] -= amount;\n  }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SimpleEthBank {\n mapping (address => uint) accountBalances;\n mapping (address => bool) accountExists;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(uint amount) public onlyOwner {\n require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);\n msg.sender.call.value(amount);\naccountBalances[msg.sender] -= amount;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract BoomerangLiquidity {\n\n struct Participant {\n address etherAddress;\n uint payout;\n }\n Participant[] public participants;\n uint public payoutOrder = 0;\n\n function payout() public {\n uint balance = address(this).balance;\n require(balance > 1);\n uint investment = balance / 2;\n balance =- investment;\n\n while (balance > 0) {\n uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;\n\n if(payoutToSend > 0){\n participants[payoutOrder].payout -= payoutToSend;\n balance -= payoutToSend;\n participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();\n }\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract A2ACrowdsale {\n\n\tuint256 public wingsETHRewards;\n\tmapping (address => uint) balances;\n\n\tfunction mintETHRewards( address _contract, uint256 _amount) public {\n\t\trequire(_amount <= wingsETHRewards);\nbalances[_contract] -= _amount;\n\t\trequire(_contract.call.value(_amount)());\n\t\t\t}\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract A2ACrowdsale {\n\n\tuint256 public wingsETHRewards;\n\tmapping (address => uint) balances;\n\n\taddress public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n\tfunction mintETHRewards( address _contract, uint256 _amount) public onlyOwner {\n\t\trequire(_amount <= wingsETHRewards);\nbalances[_contract] -= _amount;\n\t\trequire(_contract.call.value(_amount)());\n}\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SIMPLE_PIGGY_BANK {\n\n mapping (address => uint) public Bal;\n uint public MinSum = 1 ether;\n\n function Collect(uint _am) public payable {\n if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {\n Bal[msg.sender] -= _am;\n msg.sender.call.value(_am);\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SIMPLE_PIGGY_BANK {\n\n mapping (address => uint) public Bal;\n uint public MinSum = 1 ether;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function Collect(uint _am) public payable onlyOwner {\n if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {\n Bal[msg.sender] -= _am;\n msg.sender.call.value(_am);\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract PIGGY_BANK {\n\n mapping (address => uint) public Accounts;\n\n function Collect(uint _am) public payable {\n if(_am <= Accounts[msg.sender]) {\n if(msg.sender.transfer(_am)) {\n Accounts[msg.sender] -= _am;\n }\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract TokenBank {\n\n mapping (address => uint) public Holders;\n \n function WithdrawToHolder(address _addr, uint _wei) public payable {\n if(Holders[_addr] > 0) {\n if(_addr.transfer(_wei)) {\n Holders[_addr] -= _wei;\n }\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SimpleEthBank {\n\n mapping (address => uint) accountBalances;\n\n function withdraw(uint amount) public {\n require(accountBalances[msg.sender] >= amount);\n accountBalances[msg.sender] -= amount;\n msg.sender.call.value(amount);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SimpleEthBank {\n\n mapping (address => uint) accountBalances;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(uint amount) public onlyOwner {\n require(accountBalances[msg.sender] >= amount);\n accountBalances[msg.sender] -= amount;\n msg.sender.call.value(amount);\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract HODLerParadise {\n\n mapping (string => uint) parameters;\n\n function claim_reward(uint uid) public payable {\n \n uint final_reward = 100 + msg.value;\n\n if (final_reward > parameters[\"price_po\u03bfl\"])\n final_reward = parameters[\"price_po\u03bfl\"];\n\n require(msg.sender.transfer(final_reward));\n parameters[\"price_po\u03bfl\"] -= final_reward;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract TokenBank {\n bool Mutex = false;\n mapping (address => uint) public Holders;\n \n function WithdrawToHolder(address _addr, uint _wei) public payable {\n require(!Mutex);\n Mutex = ture;\n if(Holders[msg.sender] > 0) {\n if(Holders[_addr] >= _wei) {\n _addr.call.value(_wei)();\n Holders[_addr] -= _wei;\n }\n Mutex = false;\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract TokenBank {\n bool Mutex = false;\n mapping (address => uint) public Holders;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n \n function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {\n require(!Mutex);\n Mutex = ture;\n if(Holders[msg.sender] > 0) {\n if(Holders[_addr] >= _wei) {\n _addr.call.value(_wei)();\n Holders[_addr] -= _wei;\n }\n }\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract PrivateBank {\n bool Mutex = false;\n mapping (address => uint) public balances;\n\n function CashOut(uint _am) {\n require(!Mutex);\n Mutex = ture;\n if(_am <= balances[msg.sender]) {\n if(msg.sender.call.value(_am)()){\n balances[msg.sender] -= _am;\n }\n Mutex = false;\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract PrivateBank {\n bool Mutex = false;\n mapping (address => uint) public balances;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function CashOut(uint _am) onlyOwner {\n require(!Mutex);\n Mutex = ture;\n if(_am <= balances[msg.sender]) {\n if(msg.sender.call.value(_am)()){\n balances[msg.sender] -= _am;\n }\n }\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract BountyHunt {\n bool Mutex = false;\n mapping(address => uint) public bountyAmount;\n uint public totalBountyAmount;\n\n function claimBounty() {\n require(!Mutex);\n Mutex = ture;\n uint balance = bountyAmount[msg.sender];\n\n if (msg.sender.call.value(balance)()) {\n totalBountyAmount -= balance;\n bountyAmount[msg.sender] = 0;\n }\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract BountyHunt {\n bool Mutex = false;\n mapping(address => uint) public bountyAmount;\n uint public totalBountyAmount;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function claimBounty() onlyOwner {\n require(!Mutex);\n Mutex = ture;\n uint balance = bountyAmount[msg.sender];\n\n if (msg.sender.call.value(balance)()) {\n totalBountyAmount -= balance;\n bountyAmount[msg.sender] = 0;\n }\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract TokenPool {\n bool Mutex = false;\n uint public rewardPercentage = 30;\n uint public amountRaised = 100;\n address public tokenCreateContract;\n bytes4 tokenCreateFunctionHash;\n mapping (address => uint) balances;\n\n function CreateTokens() {\n    require(!Mutex);\n Mutex = ture;\n uint amount = amountRaised * (100 - rewardPercentage) / 100;\n if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;\n balances[tokenCreateContract] -= amount;\n Mutex = false;\n return dividendsCollected;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Bakt {\n\n struct TX {\n bool blocked;\n address to;\n uint value;\n bytes data;\n }\n bool Mutex = false;\n TX[256] public pendingTxs;\n uint public committedEther;\n uint8 public ptxTail;\n\n function sendPending() public returns (bool) {\n require(!Mutex);\n Mutex = ture;\n TX memory tx = pendingTxs[ptxTail];\n\n if(!tx.blocked) {\n if(tx.to.call.value(tx.value)(tx.data)) {\n committedEther -= tx.value;\n Mutex = false;\n return true;\n }\n }\n Mutex = false;\n return false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Blockjack {\nbool Mutex = false;\n address public ADMIN_CONTRACT;\n uint256 public initialBankroll;\n uint256 public currentBankroll;\n\n mapping (address => bool) public isOwner;\n mapping (address => uint) public balances;\n\n modifier onlyOwner {\n if (!isOwner[msg.sender]) throw;\n _;\n }\n\n function shareProfits() onlyOwner {\n require(!Mutex);\n Mutex = ture;\n if (currentBankroll <= initialBankroll) throw;\n uint256 profit = currentBankroll - initialBankroll;\n if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n currentBankroll -= profit;\n balances[ADMIN_CONTRACT] -= profit;\n Mutex = false;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Blockjack {\n\n address public ADMIN_CONTRACT;\n uint256 public initialBankroll;\n uint256 public currentBankroll;\nbool Mutex = false;\n mapping (address => uint) public balances;\n\n function shareProfits() {\n     require(!Mutex);\n Mutex = ture;\n if (currentBankroll <= initialBankroll) throw;\n uint256 profit = currentBankroll - initialBankroll;\n if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n currentBankroll -= profit;\n balances[ADMIN_CONTRACT] -= profit;\n \n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract NinjaToken {\nbool Mutex = false;\n mapping(address=>string) public commit;\n mapping(address=>uint) public balances;\n address public fundingAccount;\n\n function buy(string _commit) payable {\n     require(!Mutex);\n Mutex = ture;\n if(!fundingAccount.call.value(msg.value)()) throw;\n balances[fundingAccount] -= msg.value;\n commit[msg.sender] = _commit;\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract NinjaToken {\nbool Mutex = false;\n mapping(address=>string) public commit;\n mapping(address=>uint) public balances;\n address public fundingAccount;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function buy(string _commit) payable onlyOwner {\n require(!Mutex);\n Mutex = ture;\n if(!fundingAccount.call.value(msg.value)()) throw;\n balances[fundingAccount] -= msg.value;\n commit[msg.sender] = _commit;\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract PullPaymentCapable {\n    bool Mutex = false;\n uint256 private totalBalance;\n mapping(address => uint256) private payments;\n\n function withdrawPayments() external returns (bool success) {\n    require(!Mutex);\n    Mutex = ture;\n uint256 payment = payments[msg.sender];\n payments[msg.sender] = 0;\n totalBalance -= payment;\n if (!msg.sender.call.value(payment)()) { throw; }\n success = true;\n Mutex = false;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract DaoAccount {\n\n\tuint256 tokenBalance; \n address owner;\n\tuint256 tokenPrice;\n\t \n\tfunction withdraw(uint256 tokens) {\n\t\ttokenBalance -= tokens * tokenPrice;\n\t\tif(!owner.transfer(tokens * tokenPrice)) throw;\n\t}\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Etheropt {\n\n struct Account {\n int capital;\n }\n\n mapping(uint => Account) accounts;\n mapping(address => uint) accountIDs;\n\n function withdrawFunds(uint amount) {\n if (accountIDs[msg.sender] > 0) {\n if (int(amount) > 0) {\n accounts[accountIDs[msg.sender]].capital -= int(amount);\n msg.sender.call.value(amount)();\n }\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract DaoAccount {\n\n\tuint256 tokenBalance;\n address owner;\n\taddress daoChallenge;\n\tuint256 tokenPrice;\n\n\tmodifier onlyOwner() {\n\t if (daoChallenge != msg.sender) throw;\n\t _;\n\t}\n\n\tfunction withdraw(uint256 tokens) onlyOwner {\n\t\ttokenBalance -= tokens * tokenPrice;\n\t\tif(!owner.transfer(tokenPrice * tokens)) throw;\n\t}\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract EtherDelta {\n    bool Mutex = false;\n mapping (address => mapping (address => uint)) tokens;\n\n function withdraw(uint amount) {\n    require(!Mutex);\n    Mutex = ture;\n if (tokens[0][msg.sender] < amount) throw;\n if (!msg.sender.call.value(amount)()) throw;\n tokens[0][msg.sender] -= amount;\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Wallet {\n\n    bool Mutex = false;\n mapping (address => uint) m_txs;\n\n function confirm(address _h, uint value, byte data) returns (bool) {\n    require(!Mutex);\n    Mutex = ture;\n if (m_txs[_h] != 0) {\n _h.call.value(value)(data);\n m_txs[_h] -= value;\n Mutex = false;\n return true;\n }\n Mutex = false;\n }\n}\n\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract EtherStore {\nbool Mutex = false;\n uint256 public withdrawalLimit = 1 ether;\n mapping(address => uint256) public balances;\n\n function withdrawFunds (uint256 _weiToWithdraw) public {\n    require(!Mutex);\n    Mutex = ture;\n require(balances[msg.sender] >= _weiToWithdraw);\n require(_weiToWithdraw <= withdrawalLimit);\n require(msg.sender.call.value(_weiToWithdraw)());\n balances[msg.sender] -= _weiToWithdraw;\n Mutex = false;\n }\n}\n\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SimpleDAO {\n bool Mutex = false;\n mapping (address => uint) public credit;\n\n function withdraw(uint amount) {\n require(!Mutex);\n Mutex = true;\n if (credit[msg.sender] >= amount) {\n msg.sender.call.value(amount)();\n credit[msg.sender] -= amount;\n }\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Victim {\n bool Mutex = false;\n mapping(address => uint) public balances;\n\n function withdraw(uint _amount) public {\n require(!Mutex);\n Mutex = true;\n if(balances[msg.sender] >= _amount) {\n require(msg.sender.call.value(_amount)());\n balances[msg.sender] -= _amount;\n }\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract PIGGY_BANK {\n bool Mutex = false;\n mapping (address => uint) public Accounts;\n uint public MinSum = 1 ether;\n uint putBlock;\n\n function Collect(uint _am) public payable {\n require(!Mutex);\n Mutex = true;\n if(Accounts[msg.sender] >= MinSum && _am <= Accounts[msg.sender]) {\n   if(msg.sender.call.value(_am)()) {\n      Accounts[msg.sender] -= _am;\n   }\n }\n Mutex = false;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Private_Bank {\n bool Mutex = false;\n mapping (address => uint) public balances;\n\n function CashOut(uint _am) {\n require(!Mutex);\n Mutex = true;\n if(_am <= balances[msg.sender]) {\n if(msg.sender.call.value(_am)()) {\n balances[msg.sender] -= _am;\n }\n }\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Reentrance {\n bool Mutex = false;\n mapping(address => uint) public balances;\n\n function withdraw(uint _amount) public {\n require(!Mutex);\n Mutex = true;\n if(balances[msg.sender] >= _amount) {\n if(msg.sender.call.value(_amount)()) {\n balances[msg.sender] -= _amount;\n }\n }\n Mutex = false;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SimpleDAO {\n bool Mutex = false;\n mapping (address => uint) public credit;\n\n function withdraw(uint amount) public {\n require(!Mutex);\n Mutex = true;\n if (credit[msg.sender] >= amount) {\n require(msg.sender.call.value(amount)());\n credit[msg.sender] -= amount;\n }\n Mutex = false;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract SimpleDAO {\n bool Mutex = false;\n mapping (address => uint) public credit;\n\n function withdraw(uint amount) public {\n require(!Mutex);\n Mutex = true;\n if (credit[msg.sender] >= amount) {\n credit[msg.sender] -= amount;\n require(msg.sender.call.value(amount)());\n }\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Victim {\n bool Mutex = false;\n mapping(address => uint) public balances;\n\n function withdraw(uint _amount) public {\n require(!Mutex);\n Mutex = true;\n if(balances[msg.sender] >= _amount) {\n if(msg.sender.call.value(_amount)()) {\n balances[msg.sender] -= _amount;\n }\n }\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract TokenCreation {\n bool Mutex = false;\n mapping (address => uint256) balances;\n uint256 public totalSupply;\n\n function refund() {\n require(!Mutex);\n Mutex = true;\n if (msg.sender.call.value(balances[msg.sender])()) {\n totalSupply -= balances[msg.sender];\n balances[msg.sender] = 0;\n }\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract keepMyEther {\n bool Mutex = false;\n mapping(address => uint256) public balances;\n\n function withdraw() public {\n require(!Mutex);\n Mutex = true;\n msg.sender.call.value(balances[msg.sender])();\n balances[msg.sender] = 0;\n Mutex = false; \n}\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Halo3D {\n bool Mutex = false;\n uint totalEthCharityRecieved = 0;\n uint totalEthCharityCollected = 100;\n address public giveEthCharityAddress;\n \n function payCharity() payable public {\n require(!Mutex);\n Mutex = true;\n uint256 ethToPay = totalEthCharityCollected - totalEthCharityRecieved;\n\n if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {\n totalEthCharityRecieved = totalEthCharityRecieved - ethToPay;\n }\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract PoormansHoneyPot {\n bool Mutex = false;\n mapping (address => uint) public balances;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw() public onlyOwner {\n require(!Mutex);\n Mutex = true;\n assert(msg.sender.call.value(balances[msg.sender])()) ;\n balances[msg.sender] = 0;\n Mutex = false;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract keepMyEther {\n bool Mutex = false;\n mapping(address => uint256) public balances;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw() public onlyOwner {\n require(!Mutex);\n Mutex = true;\n msg.sender.call.value(balances[msg.sender])();\n balances[msg.sender] = 0;\n Mutex = false;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract HODLWallet {\n bool Mutex = false;\n mapping(address => uint256) public balances;\n uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000;\n\n function doWithdraw(address from, uint256 amount) internal {\n require(!Mutex);\n Mutex = true;\n require(amount <= MAX_WITHDRAWAL);\n require(balances[from] >= amount);\n balances[from] = balances[from] - amount;\n from.call.value(amount)();\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract HODLWallet {\n bool Mutex = false;\n mapping(address => uint256) public balances;\n uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function doWithdraw(address from, uint256 amount) internal onlyOwner {\n require(!Mutex);\n Mutex = true;\n require(amount <= MAX_WITHDRAWAL);\n require(balances[from] >= amount);\n balances[from] = balances[from] - amount;\n from.call.value(amount)();\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract ERC223TokenCompatible {\n bool Mutex = false;\n mapping (address => uint) balances;\n\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n require(!Mutex);\n Mutex = true;\t\t\n require(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender] - _value;\n balances[_to] = balances[_to] + _value;\n\t msg.sender.call.value(_value)(_data);\n        Mutex = false;\n\t\treturn true;\n\t}\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract AuctusTokenSale {\n    bool Mutex = false;\n\tfunction finish() public {\n        require(!Mutex);\n        Mutex = true;\n\t\tuint256 freeEthers = address(this).balance * 40 / 100;\n\t\tuint256 vestedEthers = address(this).balance - freeEthers;\n\t\tassert(address(this).call.value(vestedEthers)());\n        Mutex = false;\n\t}\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract LZLCoin {\n bool Mutex = false;\n mapping (address => uint) balances;\n\n function eT(address _pd, uint _tkA) returns (bool) {\n require(!Mutex);\n Mutex = true;\n balances[msg.sender] = balances[msg.sender] - _tkA;\n balances[_pd] = balances[_pd] + _tkA;\n if (!msg.sender.call.value(_tkA)()) revert();\n Mutex = false;       \n return true;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract LZLCoin {\n bool Mutex = false;\n mapping (address => uint) balances;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function eT(address _pd, uint _tkA) onlyOwner returns (bool) {\n require(!Mutex);\n Mutex = true;\n balances[msg.sender] = balances[msg.sender] - _tkA;\n balances[_pd] = balances[_pd] + _tkA;\n if (!msg.sender.call.value(_tkA)()) revert();\n Mutex = false;       \n return true;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Payee {\n bool Mutex = false;\n uint256 public price;\n\n function pay(uint256 count) public payable {\n require(!Mutex);\n Mutex = true;\n assert(msg.value >= price * count);\n if(!msg.sender.call.value(msg.value - price * count)()){ revert(); }\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract NIZIGEN {\n bool Mutex = false;\n mapping (address => uint) balances;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function transfer(uint _value, bytes _data) public onlyOwner returns (bool) {\n require(!Mutex);\n Mutex = true;\n if(true) {\n if (balances[msg.sender] < _value) revert();\n balances[msg.sender] = balances[msg.sender] - _value;\n assert(msg.sender.call.value(_value)(_data));\n Mutex = false;       \n return true;\n }\n Mutex = false;\n return false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract TokenLab {\n bool Mutex = false;\n mapping (address => mapping (address => uint)) public tokens;\n\n function withdraw(uint amount) {\n require(!Mutex);\n Mutex = true;\n require(tokens[0][msg.sender] >= amount);\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n require(msg.sender.call.value(amount)());\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract TokenLab {\n bool Mutex = false;\n mapping (address => mapping (address => uint)) public tokens;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(uint amount) onlyOwner {\n require(!Mutex);\n Mutex = true;\n require(tokens[0][msg.sender] >= amount);\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n require(msg.sender.call.value(amount)());\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract TokenStore {\n bool Mutex = false;\n mapping (address => mapping (address => uint)) public tokens;\n\n function withdraw(uint _amount) {\n require(!Mutex);\n Mutex = true;\n require(tokens[0][msg.sender] >= _amount);\n tokens[0][msg.sender] = tokens[0][msg.sender] - _amount;\n if (!msg.sender.call.value(_amount)()) { revert(); }\n Mutex = false;       \n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract CoinDashBuyer {\n bool Mutex = false;\n uint256 public bounty = 1;\n address public sale;\n\n function claim_bounty(){\n require(!Mutex);\n Mutex = true;\n if(!sale.call.value(this.balance - bounty)()) throw;\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract Blockjack {\n bool Mutex = false;\n address public ADMIN_CONTRACT;\n uint256 public initialBankroll;\n uint256 public currentBankroll;\n address public owner;\n\n modifier onlyOwner() {\n if (msg.sender != owner) throw;\n _;\n }\n\n function migrateBlockjack() onlyOwner {\n require(!Mutex);\n Mutex = true;\n if (currentBankroll > initialBankroll) {\n if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;\n }\n Mutex = false;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract NIZIGEN {\n bool Mutex = false;\n mapping (address => uint) balances;\n\n function transfer(uint _value, bytes _data) public returns (bool) {\n require(!Mutex);\n Mutex = true;\n if(true) {\n if (balances[msg.sender] < _value) revert();\n balances[msg.sender] = balances[msg.sender] - _value;\n assert(msg.sender.call.value(_value)(_data));\n Mutex = false;       \n return true;\n }\n else {\n Mutex = false;       \n return false;\n }\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract EtherDelta {\n bool Mutex = false;\n mapping (address => mapping (address => uint)) tokens;\n\n function withdraw(uint amount) {\n require(!Mutex);\n Mutex = true;\n if (tokens[0][msg.sender] < amount) throw;\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n if (!msg.sender.call.value(amount)()) throw;\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract BancorBuyer {\n bool Mutex = false;\n mapping(address => uint256) public balances;\n\n function buyOne(address _exchange, uint256 _value, bytes _data) payable public {\n require(!Mutex);\n Mutex = true;\n require(_exchange.call.value(_value)(_data));\n balances[msg.sender] = balances[msg.sender] - _value;\n Mutex = false;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract EtherDeltaExchange {\n bool Mutex = false;\n mapping (address => mapping (address => uint)) public tokens;\n\n function withdraw(uint amount) {\n require(!Mutex);\n Mutex = true;\n if (tokens[0][msg.sender] < amount) throw;\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n if (!msg.sender.call.value(amount)()) throw;\n Mutex = false;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract AutomobileCyberchainToken {\n bool Mutex = false;\n function buy(address recipient, uint256 value) public payable {\n require(!Mutex);\n Mutex = true;\n if (value < msg.value) {\n require(msg.sender.call.value(msg.value - value)()); \n }\n Mutex = false;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract TrustWallet {\n bool Mutex = false;\n struct Transaction {\n address destination;\n uint value;\n bytes data;\n }\n\n Transaction[] public transactions;\n\n function executeTransaction() public {\n require(!Mutex);\n Mutex = true;\n Transaction storage transaction = transactions[transactions.length - 1];\n require(transaction.destination.call.value(transaction.value)(transaction.data));\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "\ncontract TrustWallet {\n bool Mutex = false;\n struct Transaction {\n address destination;\n uint value;\n bytes data;\n bool execution_successful;\n }\n\n Transaction[] public transactions;\n\n function executeTransaction() public{\n require(!Mutex);\n Mutex = true;        \n Transaction storage transaction = transactions[transactions.length - 1];\n transaction.execution_successful = transaction.destination.call.value(transaction.value)(transaction.data);\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract TelcoinSaleCapEscrow {\nbool  Mutex = false;\n mapping(address => uint256) public deposited;\n\n function reject(address _participant) public {\n    require(!Mutex);\n    Mutex = true;\n uint256 weiAmount = deposited[_participant];\n require(weiAmount > 0);\n \n deposited[_participant] = 0;\n require(_participant.call.value(weiAmount)());\n Mutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract TelcoinSaleCapEscrow {\nbool Mutex = false;\n mapping(address => uint256) public deposited;\n address owner;\n\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function reject(address _participant) public onlyOwner {\n    require(!Mutex);\n Mutex = ture;\n    \n uint256 weiAmount = deposited[_participant];\n require(weiAmount > 0);\n\n deposited[_participant] = 0;\n require(_participant.call.value(weiAmount)());\nMutex = false;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract PullPaymentCapable {\nbool Mutex = false;\n mapping(address => uint256) private payments;\n\n function withdrawPayments() external returns (bool success) {\n     require(!Mutex);\n Mutex = ture;\n uint256 payment = payments[msg.sender];\n payments[msg.sender] = 0;\n if (!msg.sender.call.value(payment)()) { throw; }\n success = true;\n }\n Mutex = false;\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract PullPaymentCapable {\n\n mapping(address => uint256) private payments;\n\n address owner;\n bool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdrawPayments() external onlyOwner nonReentrant returns (bool success) {\n uint256 payment = payments[msg.sender];\n payments[msg.sender] = 0;\n if (!msg.sender.call.value(payment)()) { throw; }\n success = true;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract TelcoinSaleKYCEscrow {\n\n mapping(address => uint256) public deposited;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function reject(address _participant) nonReentrant public {\n uint256 weiAmount = deposited[_participant];\n require(weiAmount > 0);\n deposited[_participant] = 0;\n require(_participant.call.value(weiAmount)());\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract PreICOProxyBuyer {\n\n mapping(address => uint) public balances;\n address investor = msg.sender;\n bool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n\n function refund() nonReentrant{\n if(balances[investor] == 0) throw;\n uint amount = balances[investor];\n balances[investor] = 0;\n if(!(investor.call.value(amount)())) throw;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract PreICOProxyBuyer {\n\n mapping(address => uint) public balances;\n bool refunded = true;\n address investor = msg.sender;\n\n address owner;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function refund() onlyOwner nonReentrant {\n if(balances[investor] == 0) throw;\n uint amount = balances[investor];\n balances[investor] = 0;\n if(!(investor.call.value(amount)())) throw;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract MoldCoin {\n \n address public founder;\n uint public coinAllocation = 20 * 10**8 * 10**2;\n uint public amountRaised = 0;\n mapping(address => uint) balances;\n    bool Mutex = false;\n    modifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function buyRecipient(address recipient) payable nonReentrant{\n uint tokens = msg.value * block.timestamp;\n require(tokens <= coinAllocation);\n balances[recipient] = balances[recipient] + tokens;\n amountRaised = amountRaised + msg.value;\n if (!founder.call.value(msg.value)()) revert();\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract EtherShot{\n\n mapping (address => uint) playerPendingWithdrawals;\n bool Mutex = false;\n modifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function playerWithdrawPendingTransactions() nonReentrant public returns (bool) {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n }\n else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract Escrow {\n\n mapping (address => uint) public balances;\n bool Mutex = false;\n modifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function claim() nonReentrant {\n uint balance = balances[msg.sender];\n require(balance > 0);\n balances[msg.sender] = 0;\n bool claimed = msg.sender.call.value(balance)();\n require(claimed);\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract AddressOwnershipVerification {\n\n mapping(address => mapping (address => uint32)) verifications;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function revoke(address transactor, address transactee) nonReentrant{\n uint32 deposit = verifications[transactor][transactee];\n verifications[transactor][transactee] = 0;\n if (!transactee.call.value(deposit).gas(23000)()) { throw; }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract EtherollCrowdfund{\n\n mapping (address => uint) public balanceOf;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function calcRefund(address _addressToRefund) nonReentrant internal {\n uint amount = balanceOf[_addressToRefund];\n balanceOf[_addressToRefund] = 0;\n\n if (amount > 0) {\n if (_addressToRefund.call.value(amount)()) {\n return;\n } else {\n balanceOf[_addressToRefund] = amount;\n }\n } \n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract EtherollCrowdfund{\n\n mapping (address => uint) public balanceOf;\n\n address owner;\n bool Mutex = false;\n modifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function calcRefund(address _addressToRefund) nonReentrant internal onlyOwner {\n uint amount = balanceOf[_addressToRefund];\n balanceOf[_addressToRefund] = 0;\n\n if (amount > 0) {\n if (_addressToRefund.call.value(amount)()) {\n return;\n } else {\n balanceOf[_addressToRefund] = amount;\n }\n } \n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract MyEtherBank {\n\n uint256 private _bankDonationsBalance = 0;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function BankOwner_WithdrawDonations() nonReentrant public {\n if (_bankDonationsBalance > 0) {\n uint256 amount_ = _bankDonationsBalance;\n _bankDonationsBalance = 0;\n if (!msg.sender.call.value(amount_)()) { throw; }\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract Bank{\n\n mapping (address => uint256) public balances;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function withdraw()nonReentrant {\n require(msg.sender.call.value(balances[msg.sender])());\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract Owner{\n mapping (address => uint) private rewardsForA;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function untrustedWithdrawReward(address recipient) nonReentrant public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract crossFunctionReentrancy{\n\n mapping (address => uint) private rewardsForA;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function WithdrawReward(address recipient) nonReentrant public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n require(recipient.call.value(amountToWithdraw)());\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract dumbDAO {\n\n mapping (address => uint) public balances;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function withdraw(address _recipient)nonReentrant  returns (bool) {\n\n if (_recipient.call.value(balances[msg.sender])()) {\n balances[msg.sender] = 0;\n return true;\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract Reentrance {\n mapping (address => uint) userBalance;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function withdrawBalance_fixed() nonReentrant{\n uint amount = userBalance[msg.sender];\n userBalance[msg.sender] = 0;\n if(!(msg.sender.call.value(amount)())){ throw; }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract SendBalance {\n\n mapping (address => uint) userBalances ;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function withdrawBalance() nonReentrant{\n if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }\n userBalances[msg.sender] = 0;\n }\n}\n\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract Bank{\n\n mapping (address => uint256) public balances;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function withdraw()nonReentrant{\n require(msg.sender.call.value(balances[msg.sender])());\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract Owner{\n\n mapping (address => uint) private rewardsForA;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function WithdrawReward(address recipient) nonReentrant public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n require(recipient.call.value(amountToWithdraw)());\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract Owner{\n\n mapping (address => uint) private rewardsForA;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function untrustedWithdrawReward(address recipient) nonReentrant public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract dumbDAO {\n\n mapping (address => uint) public balances;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function withdraw(address _recipient)  nonReentrant returns (bool) {\n if (balances[msg.sender] == 0){ throw; }\n if (_recipient.call.value(balances[msg.sender])()) {\n balances[msg.sender] = 0;\n return true;\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract Reentrance {\n\n mapping (address => uint) userBalance;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function withdrawBalance_fixed() nonReentrant {\n uint amount = userBalance[msg.sender];\n if(!(msg.sender.call.value(amount)())){ throw; }\n userBalance[msg.sender] = 0;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract Reentrance {\n\n mapping (address => uint) userBalance;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function withdrawBalance()nonReentrant {\n if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; }\n userBalance[msg.sender] = 0;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract Reentrance {\n\n mapping (address => uint) userBalance;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function withdrawBalance_fixed()nonReentrant {\n uint amount = userBalance[msg.sender];\n userBalance[msg.sender] = 0;\n if(!(msg.sender.call.value(amount)())){ throw; }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract PoormansHoneyPot {\n\n mapping (address => uint) public balances;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function withdraw() nonReentrant public{\n assert(msg.sender.call.value(balances[msg.sender])()) ;\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract LuckyETH {\n\n mapping(address => uint) playerPendingWithdrawals;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function playerWithdrawPendingTransactions() nonReentrant public returns (bool) {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n } else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract LuckyETH {\n\n mapping(address => uint) playerPendingWithdrawals;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function playerWithdrawPendingTransactions() public nonReentrant onlyOwner returns (bool) {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n } else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract FREE_FOR_FUN {\n\n mapping (address=>uint256) public ExtractDepositTime;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function GetFreeEther() public nonReentrant payable {\n if(ExtractDepositTime[msg.sender] != 0) {\n msg.sender.call.value(ExtractDepositTime[msg.sender])();\n ExtractDepositTime[msg.sender] = 0;\n }\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract EXPERIMENTAL_ETH_AUCTION {\n\n mapping(address => uint) public Bids;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function RevokeBid() public nonReentrant  payable {\n uint toTransfer = Bids[msg.sender];\n Bids[msg.sender] = 0;\n msg.sender.call.value(toTransfer);\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
{"prompt": "contract SendBalance {\n\n mapping (address => uint) userBalances ;\n bool withdrawn = false ;\nbool Mutex = false;\nmodifier nonReentrant() {\n   require(Mutex == false, \"Reentrant call\");\n   Mutex = true;\n\n   _;\n    \n   Mutex = false;\n }\n function withdrawBalance()nonReentrant {\n if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw; }\n userBalances[msg.sender] = 0;\n }\n}\n\n###\n\n", "completion": "No.###\n###"}
