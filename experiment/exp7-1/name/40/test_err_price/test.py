from openai import OpenAI
import os
os.environ['http_proxy'] = 'http://localhost:7890'
os.environ['https_proxy'] = 'http://localhost:7890'
print(os.environ['http_proxy'])
print(os.environ['https_proxy'])

prompt= "pragma solidity 0.8.3;\ncontract Pool is iBEP20 {  \n address public BASE;\n address public TOKEN;\n address public DEPLOYER;\n string _name; string _symbol;\n uint8 public override decimals; uint256 public override totalSupply;\n mapping(address => uint) private _balances;\n mapping(address => mapping(address => uint)) private _allowances;\n uint256 public baseAmount; \n uint256 public tokenAmount; \n uint private lastMonth; \n uint public genesis; \n uint256 public map30DPoolRevenue;\n uint256 public mapPast30DPoolRevenue;\n uint256 [] public revenueArray; \n function _DAO() internal view returns(iDAO) {\n  return iBASE(BASE).DAO();\n }\n\n constructor (address _base, address _token) {\n  BASE = _base;\n  TOKEN = _token;\n  string memory poolName = \"-SpartanProtocolPool\";\n  string memory poolSymbol = \"-SPP\";\n  _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));\n  _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));\n  decimals = 18;\n  genesis = block.timestamp;\n  DEPLOYER = msg.sender;\n  lastMonth = 0;\n function addForMember(address member) public returns(uint liquidityUnits){\n  uint256 _actualInputBase = _getAddedBaseAmount();\n  uint256 _actualInputToken = _getAddedTokenAmount(); \n  if(baseAmount == 0 || tokenAmount == 0){\n  require(_actualInputBase != 0 && _actualInputToken != 0, \"!Balanced\");\n  }\n  liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); \/\/ Calculate LP tokens to mint\n  _incrementPoolBalances(_actualInputBase, _actualInputToken); \n  _mint(member, liquidityUnits); \/\/ Mint the LP tokens directly to the user\n  emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);\n  return liquidityUnits;\n }\n function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {\n  require((token == BASE || token == TOKEN), \"!BASE||TOKEN\")\n  address _fromToken; uint _amount;\n  if(token == BASE){\n_fromToken = TOKEN; \n_amount = _getAddedTokenAmount(); \n(outputAmount, fee) = _swapTokenToBase(_amount);\n  } else {\n_fromToken = BASE; \n_amount = _getAddedBaseAmount(); \n(outputAmount, fee) = _swapBaseToToken(_amount); \n  }\n  emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);\n  iBEP20(token).transfer(member, outputAmount); \n  return (outputAmount, fee);\n }\n\n\n function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\n  require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); \n  uint256 _actualInputBase = _getAddedBaseAmount(); \n  uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount);\n  uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); \n  _incrementPoolBalances(_actualInputBase, 0);\n  uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); \n  fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee);\n  _mint(synthOut, _liquidityUnits); \n  iSYNTH(synthOut).mintSynth(member, output); \n  _addPoolMetrics(fee); \n  emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\nreturn (output, fee);\n }\n \n function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {\n  require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, \"!synth\"); \n  uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); \n  uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); \n  fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount);\n  iBEP20(synthIN).transfer(synthIN, _actualInputSynth); \n  iSYNTH(synthIN).burnSynth(); \n  _decrementPoolBalances(outputBase, 0); \n  iBEP20(BASE).transfer(member, outputBase); \n  _addPoolMetrics(fee);\n  emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);\nreturn (outputBase, fee);\n }\n function _getAddedBaseAmount() internal view returns(uint256 _actual){\n  uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); \n  if(_baseBalance > baseAmount){\n_actual = _baseBalance-(baseAmount);\n  } else {\n_actual = 0;\n  }\n  return _actual;\n }\n }\n}\n\n###\n\n",
                

client = OpenAI()
completion = client.completions.create(
  model="ft:davinci-002:antchainopenlab::8zPerjUJ",
  #messages=[
  #  {"role": "system", "content": "You're a smart contract vulnerability identification assistant."},
  #  {"role": "user", "content": prompt}
  #]
  prompt = prompt,
  stop="###\n###",
  temperature= 0,
  n = 5
)
for w in range(5):
    print("result:"+completion.choices[w].text)
