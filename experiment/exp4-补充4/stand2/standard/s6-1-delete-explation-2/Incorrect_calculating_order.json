[
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract FeeContract {\n    mapping(address => uint256) public balances;\n    uint256 public totalDeposits;\n    uint256 public feePercent = 2; // 2% fee on deposits\n\n    event Deposited(address indexed user, uint256 amount, uint256 fee);\n    event FeeUpdated(uint256 newFee);\n\n    function deposit(uint256 amount) public {\n        uint256 fee = _calculateFee(amount);\n\n        _adjustFee();\n        \n        balances[msg.sender] += (amount - fee);\n        totalDeposits += amount;\n\n        emit Deposited(msg.sender, amount, fee);\n    }\n\n    function _adjustFee() internal {\n        if (totalDeposits > 1000 ether) {\n            feePercent = 1;  // Discounted fee\n        }\n    }\n\n    function _calculateFee(uint256 amount) internal view returns(uint256) {\n        return amount * feePercent / 100;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "1",
                "Location": " uint256 fee = _calculateFee(amount);\n    _adjustFee();",
                "Type": "Incorrect calculating order",
                "Description": "In the above contract, within the deposit function, the fee is being calculated for the deposit before adjusting the fee using the _adjustFee function. This means that even if the total deposits exceed the 1000 ether threshold, the 2% fee might still be applied instead of the intended 1% fee, if _adjustFee updates the fee after it's already been calculated.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RewardPool {\n    mapping(address => uint256) public balances;\n    uint256 public totalPool;\n    uint256 public rewardMultiplier = 5; // 5% reward for users based on their balances\n\n    event Rewarded(address indexed user, uint256 rewardAmount);\n\n    function deposit(uint256 amount) public {\n        balances[msg.sender] += amount;\n        totalPool += amount;\n    }\n\n    function claimReward() public {\n        uint256 reward = balances[msg.sender] * rewardMultiplier / 100;\n\n        _updateRewardMultiplier();\n\n        balances[msg.sender] += reward;\n        emit Rewarded(msg.sender, reward);\n    }\n\n    function _updateRewardMultiplier() internal {\n        if (totalPool > 5000 ether) {\n            rewardMultiplier = 3;  // Reduce reward multiplier if pool is too large\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "2",
                "Location": "uint256 reward = balances[msg.sender] * rewardMultiplier / 100;\n  _updateRewardMultiplier();",
                "Type": "Incorrect calculating order",
                "Description": "In the claimReward function, the reward for the user is being calculated before potentially updating the rewardMultiplier with _updateRewardMultiplier. This means if the total pool size is greater than 5000 ether, the user still might get the higher 5% reward instead of the reduced 3% reward.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TaxContract {\n    mapping(address => uint256) public balances;\n    uint256 public taxRate = 10; // initial 10% tax on withdrawals\n    uint256 public totalCollectedTaxes;\n\n    event Withdrawn(address indexed user, uint256 netAmount);\n    event TaxCollected(uint256 taxAmount);\n\n    function deposit(uint256 amount) public {\n        balances[msg.sender] += amount;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        uint256 taxAmount = amount * taxRate / 100;\n        _adjustTaxRate();\n\n        balances[msg.sender] -= (amount + taxAmount);\n        totalCollectedTaxes += taxAmount;\n\n        emit TaxCollected(taxAmount);\n        emit Withdrawn(msg.sender, amount - taxAmount);\n    }\n\n    function _adjustTaxRate() internal {\n        if (totalCollectedTaxes > 100 ether) {\n            taxRate = 5;  // Discounted tax rate after collecting 100 ether\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "3",
                "Location": "uint256 taxAmount = amount * taxRate / 100;\n  _adjustTaxRate();",
                "Type": "Incorrect calculating order",
                "Description": "In the withdraw function, the tax is being calculated before the _adjustTaxRate function potentially updates the tax rate. Thus, even if the totalCollectedTaxes exceeds 100 ether, users might still pay a higher 10% tax instead of the discounted 5% tax rate.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract BonusContract {\n    mapping(address => uint256) public balances;\n    uint256 public totalDeposits;\n    uint256 public bonusRate = 3; // Initial 3% bonus on deposits\n\n    event Deposited(address indexed user, uint256 depositAmount, uint256 bonus);\n\n    function deposit(uint256 amount) public {\n        uint256 bonusAmount = amount * bonusRate / 100;\n\n      \n        _adjustBonusRate();\n\n        balances[msg.sender] += (amount + bonusAmount);\n        totalDeposits += amount;\n\n        emit Deposited(msg.sender, amount, bonusAmount);\n    }\n\n    function _adjustBonusRate() internal {\n        if (totalDeposits > 500 ether) {\n            bonusRate = 1;  // Reduced bonus rate if total deposits are high\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "4",
                "Location": "uint256 bonusAmount = amount * bonusRate / 100;\n_adjustBonusRate();",
                "Type": "Incorrect calculating order",
                "Description": "In the deposit function, the bonus is calculated based on the old bonusRate before the _adjustBonusRate function has a chance to update the rate. So, if totalDeposits exceeds 500 ether, users might still receive the higher 3% bonus instead of the reduced 1%.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoanContract {\n    mapping(address => uint256) public loanAmount;\n    uint256 public totalLoansGiven;\n    uint256 public interestRate = 7; // Initial 7% interest on loans\n\n    event LoanProvided(address indexed user, uint256 loanAmount, uint256 interest);\n\n    function takeLoan(uint256 amount) public {\n        uint256 interestAmount = amount * interestRate / 100;\n\n\n        _adjustInterestRate();\n\n        loanAmount[msg.sender] += (amount + interestAmount);\n        totalLoansGiven += amount;\n\n        emit LoanProvided(msg.sender, amount, interestAmount);\n    }\n\n    function _adjustInterestRate() internal {\n        if (totalLoansGiven > 1000 ether) {\n            interestRate = 5;  // Reduced interest rate if total loans given are high\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "5",
                "Location": "uint256 interestAmount = amount * interestRate / 100;\n _adjustInterestRate();",
                "Type": "Incorrect calculating order",
                "Description": "In the takeLoan function, the interest is being calculated based on the old interestRate before the _adjustInterestRate function can modify the rate. Thus, if totalLoansGiven surpasses 1000 ether, borrowers might still get charged the higher 7% interest instead of the intended 5%.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DividendContract {\n    mapping(address => uint256) public shares;\n    uint256 public totalShares;\n    uint256 public totalDividendPool;\n    \n    event DividendClaimed(address indexed user, uint256 amount);\n\n    function buyShares(uint256 amount) public payable {\n        require(msg.value == amount, \"Amount mismatch\");\n        shares[msg.sender] += amount;\n        totalShares += amount;\n        totalDividendPool += amount / 10; // 10% of each buy goes to dividend pool\n    }\n\n    function claimDividend() public {\n        uint256 userDividend = totalDividendPool * shares[msg.sender] / totalShares;\n\n\n        _burnShares(msg.sender, shares[msg.sender] / 20);  // Burn 5% of user shares\n\n        shares[msg.sender] += userDividend;\n        totalDividendPool -= userDividend;\n\n        emit DividendClaimed(msg.sender, userDividend);\n    }\n\n    function _burnShares(address user, uint256 amount) internal {\n        shares[user] -= amount;\n        totalShares -= amount;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "6",
                "Location": "uint256 userDividend = totalDividendPool * shares[msg.sender] / totalShares;\n _burnShares(msg.sender, shares[msg.sender] / 20);  // Burn 5% of user shares",
                "Type": "Incorrect calculating order",
                "Description": "In the claimDividend function, dividends are being calculated based on the user's current share balance. But, after calculating, the user's shares are reduced by 5% before adding the dividends to their balance, which means the dividends might be calculated more than they should have.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SalaryContract {\n    mapping(address => uint256) public employeeSalary;\n    mapping(address => uint256) public lastClaimDate;\n    uint256 public bonusPercent = 10; // 10% bonus for salary claims done after 6 months\n\n    event SalaryClaimed(address indexed employee, uint256 amount);\n\n    function setSalary(address employee, uint256 amount) public {\n        employeeSalary[employee] = amount;\n        lastClaimDate[employee] = block.timestamp;\n    }\n\n    function claimSalary(address employee) public {\n        require(employeeSalary[employee] > 0, \"No salary set for this employee\");\n        uint256 timeSinceLastClaim = block.timestamp - lastClaimDate[employee];\n\n        uint256 bonusAmount = 0;\n        if (timeSinceLastClaim > 180 days) {\n            bonusAmount = employeeSalary[employee] * bonusPercent / 100;\n        }\n\n        _resetClaimDate(employee);\n\n        uint256 totalClaimable = employeeSalary[employee] + bonusAmount;\n        \n        emit SalaryClaimed(employee, totalClaimable);\n    }\n\n    function _resetClaimDate(address employee) internal {\n        lastClaimDate[employee] = block.timestamp;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "7",
                "Location": "uint256 bonusAmount = 0;\n        if (timeSinceLastClaim > 180 days) {\n            bonusAmount = employeeSalary[employee] * bonusPercent / 100;\n        }\n_resetClaimDate(employee);",
                "Type": "Incorrect calculating order",
                "Description": "In the claimSalary function, the bonus calculation considers the lastClaimDate of the employee to determine if they're eligible for a bonus. However, the _resetClaimDate function resets this date before the bonus is calculated, potentially causing inconsistencies in the bonus calculation.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract InvestmentContract {\n    mapping(address => uint256) public investments;\n    uint256 public totalInvestedCapital;\n    uint256 public profitRate = 5; // 5% profit rate for investments\n\n    event ProfitDistributed(address indexed investor, uint256 profit);\n\n    function invest(uint256 amount) public {\n        investments[msg.sender] += amount;\n        totalInvestedCapital += amount;\n    }\n\n    function distributeProfit() public {\n        uint256 profit = investments[msg.sender] * profitRate / 100;\n\n\n        _adjustProfitRate();\n\n        investments[msg.sender] += profit;\n        emit ProfitDistributed(msg.sender, profit);\n    }\n\n    function _adjustProfitRate() internal {\n        if (totalInvestedCapital > 2000 ether) {\n            profitRate = 4;  // Reduce profit rate if the total invested capital is high\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "8",
                "Location": "uint256 profit = investments[msg.sender] * profitRate / 100;\n  _adjustProfitRate();",
                "Type": "Incorrect calculating order",
                "Description": "In the distributeProfit function, the profit is determined using the profitRate before the _adjustProfitRate function might change the rate. Consequently, if totalInvestedCapital surpasses 2000 ether, users might still get a profit at the higher 5% rate rather than the adjusted 4% rate.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPointsContract {\n    mapping(address => uint256) public userPoints;\n    uint256 public totalTransactions;\n    uint256 public bonusThreshold = 100;  // Every 100 transactions, users get double loyalty points\n\n    event PointsAwarded(address indexed user, uint256 points);\n\n    function purchaseItem(uint256 amount) public {\n        uint256 points = amount / 10;  // 10% of purchase amount as loyalty points\n        \n        _updateTransactionCount();\n\n        if (totalTransactions % bonusThreshold == 0) {\n            points = points * 2;  // Double points if user hits the threshold\n        }\n\n        userPoints[msg.sender] += points;\n        emit PointsAwarded(msg.sender, points);\n    }\n\n    function _updateTransactionCount() internal {\n        totalTransactions += 1;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "9",
                "Location": "uint256 points = amount / 10;  // 10% of purchase amount as loyalty points\n         \n        _updateTransactionCount();",
                "Type": "Incorrect calculating order",
                "Description": "In the purchaseItem function, the points are awarded to the user before updating the transaction count with _updateTransactionCount. This means that a user could miss out on the bonus even if they were the 100th transaction.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract ReferralBonusContract {\n    mapping(address => uint256) public userBalance;\n    mapping(address => uint256) public referralsCount;\n    uint256 public referralBonus = 50;  // Bonus for referring 5 users\n\n    event BonusReceived(address indexed referrer, uint256 bonus);\n\n    function deposit() public payable {\n        userBalance[msg.sender] += msg.value;\n    }\n\n    function referUser(address newUser) public {\n        require(userBalance[newUser] == 0, \"User already exists\");\n\n        userBalance[newUser] = 10;  // A small welcome balance\n        referralsCount[msg.sender] += 1;\n\n        _giveReferralBonus(msg.sender);\n\n        if (referralsCount[msg.sender] % 5 == 0) {\n            userBalance[msg.sender] += referralBonus; \n        }\n    }\n\n    function _giveReferralBonus(address referrer) internal {\n        emit BonusReceived(referrer, referralBonus);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "10",
                "Location": "userBalance[newUser] = 10;  // A small welcome balance\n        referralsCount[msg.sender] += 1;\n \n        _giveReferralBonus(msg.sender);",
                "Type": "Incorrect calculating order",
                "Description": "In the referUser function, the _giveReferralBonus emits an event indicating that a referral bonus was awarded, even if the referrer hasn't reached the 5 referrals needed to earn the bonus.\n",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DiscountContract {\n    mapping(address => uint256) public userSpent;\n    uint256 public discountThreshold = 1000 ether;  // Once a user spends 1000 ether, they get a discount\n    uint256 public discountRate = 20; // 20% discount for eligible users\n\n    event PurchaseMade(address indexed user, uint256 amountSpent, uint256 discountApplied);\n\n    function purchaseItem(uint256 itemPrice) public {\n        uint256 discount = 0;\n        if (userSpent[msg.sender] >= discountThreshold) {\n            discount = itemPrice * discountRate / 100;\n        }\n\n       \n        userSpent[msg.sender] += itemPrice;\n\n        uint256 finalPrice = itemPrice - discount;\n        emit PurchaseMade(msg.sender, finalPrice, discount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "11",
                "Location": "if (userSpent[msg.sender] >= discountThreshold) {\n            discount = itemPrice * discountRate / 100;\n        }\n \n        userSpent[msg.sender] += itemPrice;",
                "Type": "Incorrect calculating order",
                "Description": "In the purchaseItem function, the discount is determined based on the user's current spending. However, the user's spending is updated before checking if they're eligible for the discount. This means that if a user hits the threshold with the current purchase, they will miss the discount they should have gotten.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SavingsContract {\n    mapping(address => uint256) public savings;\n    uint256 public interestRate = 5;  // Initial 5% interest for all users\n\n    event InterestApplied(address indexed user, uint256 interestAmount);\n\n    function depositFunds(uint256 amount) public {\n        savings[msg.sender] += amount;\n    }\n\n    function applyInterest() public {\n        uint256 interest = savings[msg.sender] * interestRate / 100;\n\n       \n        _updateInterestRate();\n\n        savings[msg.sender] += interest;\n        emit InterestApplied(msg.sender, interest);\n    }\n\n    function _updateInterestRate() internal {\n        if (address(this).balance > 5000 ether) {\n            interestRate = 3;  // Reduce interest rate if the contract holds more than 5000 ether\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "12",
                "Location": "uint256 interest = savings[msg.sender] * interestRate / 100;\n \n        _updateInterestRate();",
                "Type": "Incorrect calculating order",
                "Description": "In the applyInterest function, the interest for a user's savings is computed based on the previous interestRate. However, the _updateInterestRate function, which potentially modifies the rate, is invoked after calculating the interest. As a result, if the contract balance exceeds 5000 ether, users might still receive the higher 5% interest instead of the reduced 3%.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenBonusContract {\n    mapping(address => uint256) public tokenBalance;\n    uint256 public bonusThreshold = 1000;  // Once a user holds 1000 tokens, they receive a bonus\n    uint256 public bonusAmount = 100;      // Bonus tokens added to user's balance\n\n    event BonusAdded(address indexed user, uint256 bonusAmount);\n\n    function buyTokens(uint256 amount) public {\n        tokenBalance[msg.sender] += amount;\n\n       \n        _applyBonusIfEligible(msg.sender);\n\n        if (tokenBalance[msg.sender] >= bonusThreshold) {\n            tokenBalance[msg.sender] += bonusAmount;\n        }\n    }\n\n    function _applyBonusIfEligible(address user) internal {\n        if (tokenBalance[user] + bonusAmount >= bonusThreshold) {\n            emit BonusAdded(user, bonusAmount);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "13",
                "Location": "tokenBalance[msg.sender] += amount;\n \n        _applyBonusIfEligible(msg.sender);",
                "Type": "Incorrect calculating order",
                "Description": "In the buyTokens function, the _applyBonusIfEligible method emits an event indicating a bonus is granted if the user crosses the bonus threshold. However, it checks this before updating the user's token balance with the purchased amount. Therefore, the event might get emitted even if the user hasn't actually crossed the bonus threshold with their purchase.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LotteryContract {\n    mapping(address => uint256) public ticketsPurchased;\n    uint256 public totalTickets = 0;\n    uint256 public rewardMultiplier = 2; // Twice the amount spent is the reward for every 1000th ticket\n\n    event RewardGiven(address indexed user, uint256 reward);\n\n    function buyTicket(uint256 ticketCount) public payable {\n        require(msg.value == ticketCount * 1 ether, \"1 ticket costs 1 ether\");\n\n       \n        _rewardForMilestone(msg.sender, ticketCount);\n\n        ticketsPurchased[msg.sender] += ticketCount;\n        totalTickets += ticketCount;\n    }\n\n    function _rewardForMilestone(address user, uint256 count) internal {\n        if ((totalTickets + count) % 1000 == 0) {\n            uint256 reward = count * 1 ether * rewardMultiplier;\n            payable(user).transfer(reward);\n            emit RewardGiven(user, reward);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "14",
                "Location": "_rewardForMilestone(msg.sender, ticketCount);\n\n        ticketsPurchased[msg.sender] += ticketCount;\n        totalTickets += ticketCount;",
                "Type": "Incorrect calculating order",
                "Description": "In the buyTicket function, the _rewardForMilestone method rewards a user if their purchase results in the total ticket count being a multiple of 1000. However, this check is performed before the totalTickets is updated, which may result in improper reward allocation.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CashbackContract {\n    mapping(address => uint256) public userExpenses;\n    uint256 public cashbackRate = 10;  // 10% cashback for expenses over 500 ether\n\n    event CashbackProcessed(address indexed user, uint256 cashbackAmount);\n\n    function addExpense(uint256 amount) public {\n        userExpenses[msg.sender] += amount;\n\n       \n        _processCashback(msg.sender);\n\n        if (userExpenses[msg.sender] > 500 ether) {\n            uint256 cashback = amount * cashbackRate / 100;\n            payable(msg.sender).transfer(cashback);\n        }\n    }\n\n    function _processCashback(address user) internal {\n        if (userExpenses[user] > 500 ether) {\n            emit CashbackProcessed(user, userExpenses[user] * cashbackRate / 100);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "15",
                "Location": "_processCashback(msg.sender);\n\n        if (userExpenses[msg.sender] > 500 ether) {\n            uint256 cashback = amount * cashbackRate / 100;\n            payable(msg.sender).transfer(cashback);\n        }",
                "Type": "Incorrect calculating order",
                "Description": "In the addExpense function, the _processCashback function emits an event to notify about the cashback before actually sending the cashback. If the user's total expenses cross the threshold with the current transaction, the event will be emitted even if the cashback hasn't been processed yet.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RewardPool {\n    mapping(address => uint256) public userDeposits;\n    uint256 public totalDeposits;\n    uint256 public rewardRate = 5;  // 5% reward for deposits over 1000 ether\n    uint256 public rewardThreshold = 1000 ether;\n\n    event RewardGranted(address indexed user, uint256 rewardAmount);\n\n    function depositFunds(uint256 amount) public {\n        userDeposits[msg.sender] += amount;\n\n       \n        _distributeReward(msg.sender, amount);\n\n        totalDeposits += amount;\n    }\n\n    function _distributeReward(address user, uint256 depositAmount) internal {\n        if (totalDeposits + depositAmount > rewardThreshold) {\n            uint256 reward = depositAmount * rewardRate / 100;\n            userDeposits[msg.sender] += reward;\n            emit RewardGranted(user, reward);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "16",
                "Location": "userDeposits[msg.sender] += amount;\n \n        _distributeReward(msg.sender, amount);\n\n        totalDeposits += amount;",
                "Type": "Incorrect calculating order",
                "Description": "In the depositFunds function, the _distributeReward function is used to give rewards to users whose deposits help the contract surpass the reward threshold. However, it checks this before updating the totalDeposits value. As a result, users who should get rewards might be overlooked.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SubscriptionContract {\n    mapping(address => uint256) public userSubscriptionEnd;\n    uint256 public subscriptionPrice = 1 ether;\n    uint256 public bonusDuration = 10 days;  // Bonus duration added for subscriptions over 365 days\n\n    event SubscriptionExtended(address indexed user, uint256 endTimestamp);\n\n    function purchaseSubscription(uint256 days) public payable {\n        require(msg.value == days * subscriptionPrice, \"Incorrect payment amount\");\n\n       \n        _addBonusDuration(msg.sender, days);\n\n        uint256 totalDuration = days * 1 days;\n        userSubscriptionEnd[msg.sender] += totalDuration;\n\n        emit SubscriptionExtended(msg.sender, userSubscriptionEnd[msg.sender]);\n    }\n\n    function _addBonusDuration(address user, uint256 days) internal {\n        if (days > 365) {\n            userSubscriptionEnd[user] += bonusDuration;\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "17",
                "Location": " _addBonusDuration(msg.sender, days);\n\n        uint256 totalDuration = days * 1 days;\n        userSubscriptionEnd[msg.sender] += totalDuration;",
                "Type": "Incorrect calculating order",
                "Description": "In the purchaseSubscription function, the _addBonusDuration method adds a bonus duration to the user's subscription if they're subscribing for more than 365 days. However, the bonus duration is added before updating the userSubscriptionEnd with the actual subscription duration. As a result, if a user initially subscribes for a shorter duration and later for more than 365 days, the bonus duration might be overwritten.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CharityContract {\n    mapping(address => uint256) public donations;\n    uint256 public totalDonations;\n    uint256 public matchingRate = 10; // Donor's donation will be matched by 10% from the contract's balance\n\n    event DonationReceived(address indexed donor, uint256 donationAmount, uint256 matchedAmount);\n\n    function donate() public payable {\n        uint256 matchedAmount = msg.value * matchingRate / 100;\n\n        \n        _matchDonation(msg.sender, matchedAmount);\n\n        require(address(this).balance >= matchedAmount, \"Contract does not have enough funds to match\");\n        donations[msg.sender] += msg.value + matchedAmount;\n        totalDonations += msg.value + matchedAmount;\n    }\n\n    function _matchDonation(address donor, uint256 amount) internal {\n        donations[donor] += amount;\n        emit DonationReceived(donor, msg.value, amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "18",
                "Location": "_matchDonation(msg.sender, matchedAmount);\n\n        require(address(this).balance >= matchedAmount, \"Contract does not have enough funds to match\");",
                "Type": "Incorrect calculating order",
                "Description": "In the donate function, the _matchDonation method tries to match a portion of the donor's donation. However, this is done before ensuring the contract has enough balance to match the donation. If the contract doesn't have sufficient funds, the donor's record will incorrectly reflect the matched amount.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract ReferralBonus {\n    mapping(address => uint256) public balances;\n    uint256 public referralBonus = 50 ether;  // Bonus amount for each referred user's deposit\n\n    event ReferralBonusAdded(address indexed referrer, address indexed referee, uint256 bonusAmount);\n\n    function depositWithReferral(address referrer) public payable {\n        require(msg.value > 0, \"Deposit amount should be more than 0\");\n\n       \n        _addReferralBonus(referrer);\n\n        balances[msg.sender] += msg.value;\n    }\n\n    function _addReferralBonus(address referrer) internal {\n        require(referrer != msg.sender, \"You cannot refer yourself\");\n        balances[referrer] += referralBonus;\n        emit ReferralBonusAdded(referrer, msg.sender, referralBonus);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "19",
                "Location": "_addReferralBonus(referrer);\n\n        balances[msg.sender] += msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "In the depositWithReferral function, the _addReferralBonus method grants a bonus to the referrer. However, this bonus is added before the depositing user (referee) updates their balance. As a result, if a user deposits for the first time and receives the bonus, the contract may mistakenly recognize them as already having a balance.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TieredRewards {\n    mapping(address => uint256) public userPoints;\n    uint256 public silverThreshold = 1000;  // Points needed for Silver status\n    uint256 public goldThreshold = 5000;    // Points needed for Gold status\n\n    event UpgradedToSilver(address indexed user);\n    event UpgradedToGold(address indexed user);\n\n    function earnPoints(uint256 points) public {\n        userPoints[msg.sender] += points;\n\n       \n        _checkForGoldStatus(msg.sender);\n        _checkForSilverStatus(msg.sender);\n    }\n\n    function _checkForSilverStatus(address user) internal {\n        if (userPoints[user] >= silverThreshold) {\n            emit UpgradedToSilver(user);\n        }\n    }\n\n    function _checkForGoldStatus(address user) internal {\n        if (userPoints[user] >= goldThreshold) {\n            emit UpgradedToGold(user);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "20",
                "Location": "_checkForGoldStatus(msg.sender);\n        _checkForSilverStatus(msg.sender);",
                "Type": "Incorrect calculating order",
                "Description": "In the earnPoints function, the _checkForGoldStatus function is called before _checkForSilverStatus. As a result, a user who earns enough points to jump directly to Gold status will never trigger the UpgradedToSilver event.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract InvestmentContract {\n    mapping(address => uint256) public investments;\n    uint256 public totalInvested;\n    uint256 public bonusThreshold = 1000 ether;\n    uint256 public bonusRate = 10;\n\n    event BonusApplied(address indexed user, uint256 bonusAmount);\n\n    function invest() public payable {\n        require(msg.value > 0, \"Investment amount should be greater than 0\");\n\n        _applyInvestmentBonus(msg.sender);\n\n        investments[msg.sender] += msg.value;\n        totalInvested += msg.value;\n    }\n\n    function _applyInvestmentBonus(address investor) internal {\n        if (totalInvested + msg.value > bonusThreshold) {\n            uint256 bonus = (msg.value * bonusRate) / 100;\n            investments[investor] += bonus;\n            emit BonusApplied(investor, bonus);\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "21",
                "Location": "_applyInvestmentBonus(msg.sender);\n\n        investments[msg.sender] += msg.value;\n        totalInvested += msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "In the invest function, the _applyInvestmentBonus method calculates and applies a bonus based on the user's investment. However, this calculation happens before updating the total invested amount in the contract. This could lead to investors not receiving the bonus they should get",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public loyaltyPoints;\n    uint256 public purchaseThreshold = 10 ether;\n    uint256 public pointsPerEther = 100;\n\n    event PointsAwarded(address indexed user, uint256 points);\n\n    function makePurchase() public payable {\n        require(msg.value > 0, \"Purchase amount should be greater than 0\");\n\n        _awardLoyaltyPoints(msg.sender);\n\n        require(msg.value >= purchaseThreshold, \"Purchase amount does not meet the threshold\");\n    }\n\n    function _awardLoyaltyPoints(address buyer) internal {\n        uint256 points = (msg.value * pointsPerEther) / 1 ether;\n        loyaltyPoints[buyer] += points;\n        emit PointsAwarded(buyer, points);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "22",
                "Location": "_awardLoyaltyPoints(msg.sender);\n\n        require(msg.value >= purchaseThreshold, \"Purchase amount does not meet the threshold\");",
                "Type": "Incorrect calculating order",
                "Description": "In the makePurchase function, the _awardLoyaltyPoints function awards loyalty points for every purchase. However, this is done before the contract checks whether the purchase meets the necessary threshold. As a result, users might receive loyalty points even for smaller, non-qualifying purchases.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoanContract {\n    mapping(address => uint256) public loanBalances;\n    uint256 public interestRate = 5;  // Interest rate of 5% for the loans\n    uint256 public maxLoanAmount = 50 ether;\n\n    event LoanTaken(address indexed user, uint256 amount, uint256 interest);\n\n    function takeLoan(uint256 amount) public {\n        require(amount <= maxLoanAmount, \"Loan amount exceeds the maximum limit\");\n\n        uint256 interest = _calculateInterest(amount);\n        \n        loanBalances[msg.sender] += amount;\n\n        emit LoanTaken(msg.sender, amount, interest);\n    }\n\n    function _calculateInterest(uint256 amount) internal view returns (uint256) {\n        return (loanBalances[msg.sender] + amount) * interestRate / 100;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "23",
                "Location": "uint256 interest = _calculateInterest(amount);\n        \n        loanBalances[msg.sender] += amount;\n\n        emit LoanTaken(msg.sender, amount, interest);",
                "Type": "Incorrect calculating order",
                "Description": "In the takeLoan function, the _calculateInterest function computes the interest on the loan. However, this is done before updating the user's loan balance with the new amount. Consequently, the interest calculation does not accurately reflect the user's total loan after the new loan is added.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DividendContract {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n    uint256 public totalDividends;\n\n    event DividendsPaid(address indexed user, uint256 amount);\n\n    function deposit() public payable {\n        require(msg.value > 0, \"Deposit amount should be more than 0\");\n\n        \n        _distributeDividends(msg.sender);\n\n        balances[msg.sender] += msg.value;\n        totalSupply += msg.value;\n    }\n\n    function _distributeDividends(address depositor) internal {\n        uint256 userDividends = (balances[depositor] * totalDividends) / totalSupply;\n        payable(depositor).transfer(userDividends);\n        emit DividendsPaid(depositor, userDividends);\n    }\n\n    function distributeDividends() public payable {\n        totalDividends += msg.value;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "24",
                "Location": "_distributeDividends(msg.sender);\n\n        balances[msg.sender] += msg.value;\n        totalSupply += msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "In the deposit function, the _distributeDividends function tries to give the depositor their share of dividends. However, this is done before updating the depositor's balance with the new deposit amount. As a result, depositors receive dividends based on their previous balance, and not the updated balance which includes the new deposit.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DiscountStore {\n    mapping(address => uint256) public userSpending;\n    uint256 public discountThreshold = 10 ether;  \n    uint256 public discountRate = 20;  \n\n    event PurchaseMade(address indexed user, uint256 amountSpent, uint256 discountApplied);\n\n    function makePurchase(uint256 purchaseAmount) public {\n        require(purchaseAmount > 0, \"Purchase amount should be greater than 0\");\n\n        uint256 discount = _calculateDiscount(purchaseAmount);\n        \n        userSpending[msg.sender] += purchaseAmount - discount;\n\n        emit PurchaseMade(msg.sender, purchaseAmount, discount);\n    }\n\n    function _calculateDiscount(uint256 amount) internal view returns (uint256) {\n        if (userSpending[msg.sender] > discountThreshold) {\n            return (amount * discountRate) / 100;\n        }\n        return 0;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "25",
                "Location": "uint256 discount = _calculateDiscount(purchaseAmount);\n         \n        userSpending[msg.sender] += purchaseAmount - discount;",
                "Type": "Incorrect calculating order",
                "Description": "In the makePurchase function, the _calculateDiscount function computes a discount based on the user's total spending. However, this calculation is done before updating the user's total spending with the new purchase amount. As a result, users might not get the discount they are entitled to if their new purchase pushes their total spending past the discount threshold.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SalaryContract {\n    mapping(address => uint256) public salaries;\n    uint256 public bonusPool = 100 ether;  \n    uint256 public totalEmployees;\n\n    event SalaryPaid(address indexed employee, uint256 amount);\n    event BonusDistributed(address indexed employee, uint256 bonusAmount);\n\n    function addEmployee(address employee, uint256 salaryAmount) public {\n        require(salaryAmount > 0, \"Salary amount should be greater than 0\");\n\n        _distributeBonus(employee);\n        \n        salaries[employee] = salaryAmount;\n        totalEmployees++;\n\n        emit SalaryPaid(employee, salaryAmount);\n    }\n\n    function _distributeBonus(address employee) internal {\n        uint256 bonusAmount = bonusPool / totalEmployees;\n        salaries[employee] += bonusAmount;\n        bonusPool -= bonusAmount;\n        emit BonusDistributed(employee, bonusAmount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "26",
                "Location": "_distributeBonus(employee);\n        \n        salaries[employee] = salaryAmount;\n        totalEmployees++;",
                "Type": "Incorrect calculating order",
                "Description": "In the addEmployee function, the _distributeBonus function tries to give the newly added employee a share of the bonus pool. However, this is done before updating the salaries and totalEmployees. This leads to a miscalculation since the totalEmployees value is not yet incremented to account for the new employee when determining the bonus amount.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CharityFund {\n    mapping(address => uint256) public donations;\n    uint256 public totalDonations;\n    uint256 public matchingFund = 500 ether;  // A matching fund that matches donations 1:1 up to 500 ether\n\n    event DonationReceived(address indexed donor, uint256 amount, uint256 matchedAmount);\n\n    function donate() public payable {\n        require(msg.value > 0, \"Donation amount should be greater than 0\");\n\n        uint256 matchAmount = _matchDonation(msg.value);\n\n        donations[msg.sender] += msg.value;\n        totalDonations += msg.value;\n\n        emit DonationReceived(msg.sender, msg.value, matchAmount);\n    }\n\n    function _matchDonation(uint256 amount) internal returns (uint256) {\n        uint256 matchAmount = (amount <= matchingFund) ? amount : matchingFund;\n        totalDonations += matchAmount;\n        matchingFund -= matchAmount;\n        return matchAmount;\n    }\n}                                  ",
        "VulnerabilityDesc": [
            {
                "Name": "27",
                "Location": "uint256 matchAmount = _matchDonation(msg.value);\n\n        donations[msg.sender] += msg.value;\n        totalDonations += msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "In the donate function, the _matchDonation function calculates the amount of donation to be matched from the matching fund. However, this is done before updating the total donations with the user's donation amount. This leads to a potential scenario where the matching exceeds the fund's intended cap.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public loyaltyPoints;\n    uint256 public bonusThreshold = 1000;\n    uint256 public bonusMultiplier = 2;\n\n    event PointsAwarded(address indexed user, uint256 points, uint256 bonusPoints);\n\n    function awardPoints(address user, uint256 points) public {\n        require(points > 0, \"Points awarded should be positive\");\n\n        uint256 bonus = _calculateBonus(points, loyaltyPoints[user]);\n\n        loyaltyPoints[user] += points;\n        \n        emit PointsAwarded(user, points, bonus);\n    }\n\n    function _calculateBonus(uint256 points, uint256 currentPoints) internal returns (uint256) {\n        if (currentPoints + points > bonusThreshold) {\n            return points * bonusMultiplier;\n        }\n        return 0;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "28",
                "Location": "uint256 bonus = _calculateBonus(points, loyaltyPoints[user]);\n\n        loyaltyPoints[user] += points;",
                "Type": "Incorrect calculating order",
                "Description": "In the awardPoints function, the _calculateBonus function checks if the user's total points (after adding the new points) would exceed a certain threshold. If they do, it awards bonus points. However, since the user's points are updated after calculating the bonus, this can lead to miscalculations in determining eligibility for the bonus.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Token {\n    mapping(address => uint256) public balances;\n    uint256 public taxRate = 5;  // 5% tax for each transfer\n\n    event Transfer(address indexed from, address indexed to, uint256 value, uint256 tax);\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        uint256 tax = (amount * taxRate) / 100;\n        uint256 netAmount = amount - tax;\n\n        balances[msg.sender] -= amount;  \n        balances[to] += netAmount;  \n\n        emit Transfer(msg.sender, to, amount, tax);\n        return true;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "29",
                "Location": "require(balances[msg.sender] >= amount, \"Insufficient balance\");\n \n        uint256 tax = (amount * taxRate) / 100;\n        uint256 netAmount = amount - tax;",
                "Type": "Incorrect calculating order",
                "Description": "In the transfer function, the contract tries to deduct a tax for each transfer. However, it deducts the balance first before calculating and transferring the net amount after tax. This can lead to issues where a user's actual balance after tax deduction might be negative.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LendingPlatform {\n    mapping(address => uint256) public deposits;\n    uint256 public interestRate = 10;  // 10% annual interest\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrew(address indexed user, uint256 amount);\n\n    function deposit() public payable {\n        deposits[msg.sender] += msg.value;\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function withdraw() public {\n        uint256 amount = deposits[msg.sender];\n\n        uint256 interest = (amount * interestRate) / 100;\n        amount += interest;\n\n        require(address(this).balance >= amount, \"Contract balance insufficient\");\n\n        deposits[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n\n        emit Withdrew(msg.sender, amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "30",
                "Location": " uint256 interest = (amount * interestRate) / 100;\n        amount += interest;",
                "Type": "Incorrect calculating order",
                "Description": "In the withdraw function, the contract tries to give an interest on the deposited amount. However, the interest is calculated on the initial deposited amount and not on the compounded value. If a user doesn't withdraw for multiple years, they should receive compound interest.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RewardSystem {\n    mapping(address => uint256) public balances;\n    uint256 public rewardRate = 5;  // 5% reward rate for holding tokens\n\n    event Rewarded(address indexed user, uint256 amount);\n\n    function depositTokens(uint256 amount) public {\n        require(amount > 0, \"Invalid amount\");\n        balances[msg.sender] += amount;\n    }\n\n    function claimReward() public {\n        uint256 initialBalance = balances[msg.sender];\n\n        uint256 reward = (initialBalance * rewardRate) / 100;\n        balances[msg.sender] += reward;\n\n        emit Rewarded(msg.sender, reward);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "31",
                "Location": " uint256 reward = (initialBalance * rewardRate) / 100;\n        balances[msg.sender] += reward;",
                "Type": "Incorrect calculating order",
                "Description": "In the claimReward function, the contract tries to provide a reward based on the current token balance. However, there's a loophole where someone can deposit tokens and instantly claim the reward, without having to hold the tokens for any period",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TimedVault {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public depositTimes;\n    uint256 public timeLock = 7 days;  // Users must wait 7 days before withdrawing\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n        depositTimes[msg.sender] = block.timestamp;  // Sets the time of deposit\n\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function withdraw() public {\n        require(block.timestamp >= depositTimes[msg.sender] + timeLock, \"Funds are still locked\");\n\n        uint256 amount = balances[msg.sender];\n        \n        depositTimes[msg.sender] = block.timestamp;\n        payable(msg.sender).transfer(amount);\n        balances[msg.sender] = 0;\n\n        emit Withdrawn(msg.sender, amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "32",
                "Location": " depositTimes[msg.sender] = block.timestamp;  // Updates the deposit time even if the funds have not been sent yet\n        payable(msg.sender).transfer(amount);  // Sends the funds\n        balances[msg.sender] = 0;",
                "Type": "Incorrect calculating order",
                "Description": "Here, the incorrect calculation order vulnerability arises because we are updating the depositTimes before successfully transferring the funds. If for some reason, the transfer fails (e.g., gas issues or recipient contract throws an exception), the user's deposit time will be updated, which can be problematic.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public points;\n    uint256 public redemptionThreshold = 1000;\n    uint256 public rewardAmount = 1 ether;\n\n    event PointsEarned(address indexed user, uint256 amount);\n    event RewardRedeemed(address indexed user);\n\n    function earnPoints(uint256 amount) public {\n        points[msg.sender] += amount;\n\n        emit PointsEarned(msg.sender, amount);\n    }\n\n    function redeemReward() public {\n        require(points[msg.sender] >= redemptionThreshold, \"Not enough points to redeem reward\");\n\n        points[msg.sender] -= redemptionThreshold;\n        payable(msg.sender).transfer(rewardAmount);\n\n        emit RewardRedeemed(msg.sender);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "33",
                "Location": "points[msg.sender] -= redemptionThreshold;  // Deducts the points first\n        payable(msg.sender).transfer(rewardAmount);  // Attempts to transfer reward",
                "Type": "Incorrect calculating order",
                "Description": "Here, the vulnerability stems from deducting points before attempting to transfer the reward. If for some reason, the transfer fails (e.g., gas issues, contract reentrancy, or the receiving contract throws an exception), the user's points would be deducted without receiving the reward.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Staking {\n    mapping(address => uint256) public balances;\n    uint256 public totalStaked;\n    uint256 public rewardRate = 5;  // Reward rate in percentage\n\n    event Staked(address indexed user, uint256 amount, uint256 reward);\n    event Unstaked(address indexed user, uint256 amount);\n\n    function stake(uint256 amount) external {\n        uint256 reward = (amount * rewardRate) / 100;\n\n        totalStaked += amount;  \n        balances[msg.sender] += amount + reward; \n\n        emit Staked(msg.sender, amount, reward);\n    }\n\n    function unstake(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        totalStaked -= amount;  \n        balances[msg.sender] -= amount;\n\n        emit Unstaked(msg.sender, amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "34",
                "Location": "totalStaked += amount;\n        balances[msg.sender] += amount + reward;",
                "Type": "Incorrect calculating order",
                "Description": "In the stake function, we're updating totalStaked before adding the reward to the user's balance, which is an incorrect calculation order.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenSale {\n    address public owner;\n    uint256 public pricePerToken = 1 ether;  // 1 ETH = 1 Token for simplicity\n    uint256 public totalTokensSold;\n    mapping(address => uint256) public tokens;\n\n    event Purchased(address indexed user, uint256 amount);\n    event PriceUpdated(uint256 newPrice);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function purchase(uint256 tokenAmount) external payable {\n        uint256 totalCost = pricePerToken * tokenAmount;\n        require(msg.value >= totalCost, \"Insufficient funds sent\");\n\n        totalTokensSold += tokenAmount;  \n        require(totalTokensSold <= 1000, \"Not enough tokens left\");\n\n        tokens[msg.sender] += tokenAmount;\n\n        emit Purchased(msg.sender, tokenAmount);\n    }\n\n    function setPrice(uint256 newPrice) external {\n        require(msg.sender == owner, \"Only owner can set price\");\n        \n        pricePerToken = newPrice;  \n        emit PriceUpdated(newPrice);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "35",
                "Location": "totalTokensSold += tokenAmount;  \n        require(totalTokensSold <= 1000, \"Not enough tokens left\");",
                "Type": "Incorrect calculating order",
                "Description": "In the purchase function, we're updating the totalTokensSold before checking if there are enough tokens left to sell.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Bank {\n    address public owner;\n    mapping(address => uint256) public balances;\n    uint256 public totalDeposits;\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        totalDeposits += msg.value;  \n\n        require(totalDeposits <= 5000 ether, \"Bank full\");\n        \n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        totalDeposits -= amount;  \n        payable(msg.sender).transfer(amount);\n\n        balances[msg.sender] -= amount;\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "36",
                "Location": "balances[msg.sender] += msg.value;\n        totalDeposits += msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "In the above contract, in the deposit function, we're updating totalDeposits before checking if the bank has reached its limit. ",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyProgram {\n    mapping(address => uint256) public points;\n    uint256 public totalRedeemed;\n\n    event PointsEarned(address indexed user, uint256 amount);\n    event PointsRedeemed(address indexed user, uint256 amount);\n\n    function earnPoints(uint256 amount) external {\n        points[msg.sender] += amount;\n        emit PointsEarned(msg.sender, amount);\n    }\n\n    function redeemPoints(uint256 amount) external {\n        require(points[msg.sender] >= amount, \"Insufficient points\");\n        totalRedeemed += amount;  \n        require(totalRedeemed <= 10000, \"Redemption limit reached\"); \n\n        points[msg.sender] -= amount;\n        emit PointsRedeemed(msg.sender, amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "37",
                "Location": "totalRedeemed += amount;\n        require(totalRedeemed <= 10000, \"Redemption limit reached\"); ",
                "Type": "Incorrect calculating order",
                "Description": "In the above contract, in the redeemPoints function, the contract first increments the totalRedeemed before checking if it exceeds the allowed cap. This can allow an attacker to redeem more points than allowed by the system cap.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Bank {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lastUpdated;\n\n    uint256 public interestRate = 10; // 10% annual interest\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrew(address indexed user, uint256 amount);\n\n    function deposit() external payable {\n        updateInterest(msg.sender);\n        balances[msg.sender] += msg.value;\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) external {\n        updateInterest(msg.sender);\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n      \n        payable(msg.sender).transfer(amount);\n\n        balances[msg.sender] -= amount;\n        emit Withdrew(msg.sender, amount);\n    }\n\n    function updateInterest(address user) internal {\n        uint256 elapsed = block.timestamp - lastUpdated[user];\n        balances[user] += (balances[user] * interestRate / 100) * elapsed / 365 days;\n        lastUpdated[user] = block.timestamp;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "38",
                "Location": "payable(msg.sender).transfer(amount);\n        balances[msg.sender] -= amount;",
                "Type": "Incorrect calculating order",
                "Description": "In the above contract, the withdraw function first pays out the amount, including interest, and only then updates the user's balance. If there's a failure (e.g., a fallback function reverts) after the transfer but before the balance update, the user's balance will not be debited.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract RewardSystem {\n    mapping(address => uint256) public stakedTokens;\n    mapping(address => uint256) public rewardBalance;\n\n    uint256 public totalStakedTokens;\n    uint256 public rewardPool = 10000 ether; // initial reward pool\n\n    event Staked(address indexed user, uint256 amount);\n    event ClaimedRewards(address indexed user, uint256 reward);\n\n    function stake(uint256 amount) external {\n        stakedTokens[msg.sender] += amount;\n        totalStakedTokens += amount;\n        emit Staked(msg.sender, amount);\n    }\n\n    function claimRewards() external {\n        uint256 reward = computeReward(msg.sender);\n\n      \n        rewardBalance[msg.sender] += reward;\n        \n        require(rewardPool >= reward, \"Not enough rewards in the pool\");\n        rewardPool -= reward;\n\n        rewardBalance[msg.sender] = 0;\n        payable(msg.sender).transfer(reward);\n        emit ClaimedRewards(msg.sender, reward);\n    }\n\n    function computeReward(address user) public view returns (uint256) {\n        return (stakedTokens[user] * rewardPool) / totalStakedTokens;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "39",
                "Location": "rewardBalance[msg.sender] += reward;\n        require(rewardPool >= reward, \"Not enough rewards in the pool\");\n        rewardPool -= reward;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here is in the claimRewards function where we increment the rewardBalance before checking if there are enough rewards in the rewardPool. A malicious user can re-enter the function before the rewardPool has decreased, causing them to claim more rewards than they should.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LendingSystem {\n    mapping(address => uint256) public deposits;\n    uint256 public totalDeposits;\n    uint256 public interestRate = 5; // represented in percentage\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function deposit(uint256 amount) external {\n        deposits[msg.sender] += amount;\n        totalDeposits += amount;\n        emit Deposited(msg.sender, amount);\n    }\n\n    function withdraw() external {\n        uint256 amount = deposits[msg.sender];\n\n        amount += amount * interestRate / 100;\n\n        require(totalDeposits >= amount, \"Not enough funds in the system\");\n\n        totalDeposits -= deposits[msg.sender];\n        deposits[msg.sender] = 0;\n\n        payable(msg.sender).transfer(amount);\n        emit Withdrawn(msg.sender, amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "40",
                "Location": "function withdraw() external {\n        uint256 amount = deposits[msg.sender];\n\n        amount += amount * interestRate / 100;\n\n        require(totalDeposits >= amount, \"Not enough funds in the system\");\n\n        totalDeposits -= deposits[msg.sender];\n        deposits[msg.sender] = 0;\n\n        payable(msg.sender).transfer(amount);\n        emit Withdrawn(msg.sender, amount);\n    }",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here is in the withdraw function where we apply the interest rate on the withdrawal amount before checking if the system has enough funds (totalDeposits). This can lead to users draining more funds than they should be able to.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract StakingSystem {\n    mapping(address => uint256) public stakes;\n    uint256 public totalStakes;\n    uint256 public rewardRate = 10; // represented in percentage\n\n    event Staked(address indexed user, uint256 amount);\n    event Unstaked(address indexed user, uint256 amount);\n\n    function stake(uint256 amount) external {\n        stakes[msg.sender] += amount;\n        totalStakes += amount;\n        emit Staked(msg.sender, amount);\n    }\n\n    function unstake() external {\n        uint256 stakeAmount = stakes[msg.sender];\n\n      \n        uint256 reward = stakeAmount * rewardRate / 100;\n        uint256 totalWithdrawalAmount = stakeAmount + reward;\n\n        require(totalStakes >= totalWithdrawalAmount, \"Not enough funds in the system\");\n\n        totalStakes -= stakeAmount;\n        stakes[msg.sender] = 0;\n\n        payable(msg.sender).transfer(totalWithdrawalAmount);\n        emit Unstaked(msg.sender, totalWithdrawalAmount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "41",
                "Location": " uint256 stakeAmount = stakes[msg.sender];\n\n        uint256 reward = stakeAmount * rewardRate / 100;\n        uint256 totalWithdrawalAmount = stakeAmount + reward;\n\n        require(totalStakes >= totalWithdrawalAmount, \"Not enough funds in the system\");",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here is in the unstake function: the system calculates the reward before reducing the total stakes. This may cause issues if many users try to unstake at the same time and the reward rate is high.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public loyaltyPoints;\n    uint256 public redemptionRate = 5; // 5 ether for each loyalty point\n\n    event PointsAccrued(address indexed user, uint256 points);\n    event PointsRedeemed(address indexed user, uint256 amount);\n\n    function accruePoints(uint256 points) external {\n        loyaltyPoints[msg.sender] += points;\n        emit PointsAccrued(msg.sender, points);\n    }\n\n    function redeemPoints() external {\n        uint256 userPoints = loyaltyPoints[msg.sender];\n        \n     \n        uint256 redemptionAmount = userPoints * redemptionRate;\n\n        require(address(this).balance >= redemptionAmount, \"Insufficient funds to redeem\");\n\n        loyaltyPoints[msg.sender] = 0;\n        \n        payable(msg.sender).transfer(redemptionAmount);\n        emit PointsRedeemed(msg.sender, redemptionAmount);\n    }\n\n    receive() external payable {} // to fund the contract\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "42",
                "Location": "uint256 userPoints = loyaltyPoints[msg.sender];\n        uint256 redemptionAmount = userPoints * redemptionRate;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability in the redeemPoints function is that the contract calculates the redemption amount before zeroing out the user's loyalty points. If the function is called by another contract which can then re-enter the redeemPoints function before the first call is completed, this could lead to excessive redemption.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Staking {\n    mapping(address => uint256) public stakedAmount;\n    mapping(address => uint256) public lastStakedTime;\n    uint256 public rewardRate = 1;  // 1 token reward for every block\n\n    event Staked(address indexed user, uint256 amount);\n    event Unstaked(address indexed user, uint256 amount, uint256 reward);\n\n    function stake(uint256 amount) external {\n        stakedAmount[msg.sender] += amount;\n        lastStakedTime[msg.sender] = block.number;\n\n        emit Staked(msg.sender, amount);\n    }\n\n    function unstake() external {\n        uint256 userStake = stakedAmount[msg.sender];\n\n        uint256 reward = (block.number - lastStakedTime[msg.sender]) * rewardRate;\n\n        stakedAmount[msg.sender] = 0;\n        lastStakedTime[msg.sender] = block.number;\n\n        emit Unstaked(msg.sender, userStake, reward);\n    }\n\n    // This function allows users to claim their rewards without unstaking.\n    function claimReward() external {\n        uint256 reward = (block.number - lastStakedTime[msg.sender]) * rewardRate;\n        lastStakedTime[msg.sender] = block.number;\n\n        // Logic to transfer reward tokens to user...\n\n        emit Unstaked(msg.sender, 0, reward);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "43",
                "Location": " uint256 userStake = stakedAmount[msg.sender];\n        uint256 reward = (block.number - lastStakedTime[msg.sender]) * rewardRate;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability in the unstake function is the calculation and distribution of rewards before updating the stakedAmount and lastStakedTime. If there was a function that allowed for contract interaction and re-entrancy, users could abuse this incorrect order to gain extra rewards.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Voting {\n    struct Proposal {\n        string description;\n        uint256 voteCount;\n    }\n\n    mapping(address => bool) public hasVoted;\n    Proposal[] public proposals;\n\n    event Voted(address indexed voter, uint256 proposalId);\n\n    function addProposal(string memory description) external {\n        proposals.push(Proposal({\n            description: description,\n            voteCount: 0\n        }));\n    }\n\n    function castVote(uint256 proposalId) external {\n        require(proposalId < proposals.length, \"Invalid proposal ID\");\n        require(!hasVoted[msg.sender], \"Already voted!\");\n\n\n        proposals[proposalId].voteCount += 1;\n\n        hasVoted[msg.sender] = true;\n\n        emit Voted(msg.sender, proposalId);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "44",
                "Location": "require(!hasVoted[msg.sender], \"Already voted!\");\n        proposals[proposalId].voteCount += 1;\n",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here lies in the castVote function. It first increases the vote count for a proposal and then marks the user as having voted. If there's an external call or any reentrancy-like opportunity after updating the vote count, it can allow the user to vote again.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract RewardDistributor {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public rewards;\n\n    uint256 public totalRewards;\n\n    event RewardClaimed(address indexed user, uint256 amount);\n\n    constructor(uint256 _initialRewards) {\n        totalRewards = _initialRewards;\n    }\n\n    function deposit(uint256 amount) external {\n        balances[msg.sender] += amount;\n        distributeReward(msg.sender);\n    }\n\n    function claimReward() external {\n        distributeReward(msg.sender);\n\n        uint256 rewardToClaim = rewards[msg.sender];\n        require(rewardToClaim <= totalRewards, \"Not enough rewards left\");\n\n        \n        rewards[msg.sender] = 0;\n        totalRewards -= rewardToClaim;\n\n        emit RewardClaimed(msg.sender, rewardToClaim);\n    }\n\n    function distributeReward(address user) internal {\n        rewards[user] += balances[user];\n        totalRewards -= balances[user];\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "45",
                "Location": "rewards[msg.sender] = 0;\n        totalRewards -= rewardToClaim;\n",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability is within the claimReward function where the individual user's rewards are set to zero before updating the totalRewards. In the case of recursive calls or reentrancy, a user might be able to claim more rewards than they should.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Staking {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lastStakedTimestamp;\n    uint256 public interestRate = 5;  // 5% interest per day\n\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function stake(uint256 amount) external {\n        balances[msg.sender] += amount;\n        lastStakedTimestamp[msg.sender] = block.timestamp;\n        emit Staked(msg.sender, amount);\n    }\n\n    function withdraw() external {\n      \n        uint256 principal = balances[msg.sender];\n        balances[msg.sender] = 0;\n        uint256 interest = (principal * ((block.timestamp - lastStakedTimestamp[msg.sender]) / 1 days) * interestRate) / 100;\n        uint256 total = principal + interest;\n\n        msg.sender.transfer(total);\n\n        emit Withdrawn(msg.sender, total);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "46",
                "Location": " uint256 principal = balances[msg.sender];\n        balances[msg.sender] = 0;\n        uint256 interest = (principal * ((block.timestamp - lastStakedTimestamp[msg.sender]) / 1 days) * interestRate) / 100;\n        uint256 total = principal + interest;",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, the withdraw function first updates the user's balance and then calculates the interest. This means that if there's any issue in the interest calculation or if the function is called multiple times quickly (like in a reentrancy attack), the user can exploit the incorrect order to withdraw more than they should.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public points;\n    mapping(address => uint256) public lastPurchaseDate;\n    uint256 public bonusPoints = 1000;\n\n    event PointsEarned(address indexed user, uint256 amount);\n\n    function purchase(uint256 amount) external {\n        lastPurchaseDate[msg.sender] = block.timestamp;\n\n        if(block.timestamp - lastPurchaseDate[msg.sender] > 365 days) {\n            points[msg.sender] += bonusPoints; \n        }\n\n        points[msg.sender] += amount;\n\n        emit PointsEarned(msg.sender, amount + (block.timestamp - lastPurchaseDate[msg.sender] > 365 days ? bonusPoints : 0));\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "47",
                "Location": "lastPurchaseDate[msg.sender] = block.timestamp; \n        if(block.timestamp - lastPurchaseDate[msg.sender] > 365 days) {\n            points[msg.sender] += bonusPoints;  \n        }\n\n        points[msg.sender] += amount;",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, since we update the lastPurchaseDate before checking for bonus eligibility, the condition for bonus points will never be met.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract RewardPool {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lastRewardClaim;\n    uint256 public rewardRate = 1e18;  // 1 ether reward for every day they've kept funds in the pool\n\n    event RewardClaimed(address indexed user, uint256 amount);\n\n    function deposit() external payable {\n        if (balances[msg.sender] > 0) {\n            uint256 timeSinceLastClaim = block.timestamp - lastRewardClaim[msg.sender];\n            uint256 reward = (timeSinceLastClaim / 1 days) * rewardRate;\n            payable(msg.sender).transfer(reward);\n\n            emit RewardClaimed(msg.sender, reward);\n        }\n\n        balances[msg.sender] += msg.value;\n        lastRewardClaim[msg.sender] = block.timestamp;\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "48",
                "Location": "function deposit() external payable {\n       if (balances[msg.sender] > 0) {\n            uint256 timeSinceLastClaim = block.timestamp - lastRewardClaim[msg.sender];\n            uint256 reward = (timeSinceLastClaim / 1 days) * rewardRate;\n            payable(msg.sender).transfer(reward);\n\n            emit RewardClaimed(msg.sender, reward);\n        }\n\n        balances[msg.sender] += msg.value;\n        lastRewardClaim[msg.sender] = block.timestamp;\n    }",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, a user can deposit multiple times in quick succession, each time receiving rewards since the lastRewardClaim is updated after the rewards are transferred.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyRewards {\n    uint256 public rewardRate = 100;  // 100 points per interaction initially\n    uint256 public totalInteractions;\n    mapping(address => uint256) public pointsBalance;\n\n    function userInteraction() external {\n        uint256 pointsEarned = rewardRate;\n        pointsBalance[msg.sender] += pointsEarned;\n        \n        totalInteractions += 1;\n        rewardRate = 1000 / (1 + totalInteractions);  \n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "49",
                "Location": "pointsBalance[msg.sender] += pointsEarned;\n        \n        totalInteractions += 1;\n        rewardRate = 1000 / (1 + totalInteractions);",
                "Type": "Incorrect calculating order",
                "Description": "In the above version, users get rewarded based on the old reward rate, and then the rate is adjusted. If multiple users interact rapidly in sequence, later users might get more points than they should.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface ICustomToken {\n    function mint(address recipient, uint256 amount) external;\n}\n\ncontract TokenVault {\n    ICustomToken public token;\n    uint256 public interestRate = 10; // 10% annually for simplicity\n    mapping(address => uint256) public lastDepositTime;\n    mapping(address => uint256) public ethBalance;\n\n    constructor(address _token) {\n        token = ICustomToken(_token);\n    }\n\n    function depositETH() external payable {\n        _creditInterest(msg.sender); \n        ethBalance[msg.sender] += msg.value;\n        lastDepositTime[msg.sender] = block.timestamp;\n    }\n\n    function _creditInterest(address user) internal {\n        uint256 timeElapsed = block.timestamp - lastDepositTime[user];\n        uint256 interest = (ethBalance[user] * interestRate * timeElapsed) / (365 days);\n        token.mint(user, interest);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "50",
                "Location": "function depositETH() external payable {\n        _creditInterest(msg.sender); \n        ethBalance[msg.sender] += msg.value;\n        lastDepositTime[msg.sender] = block.timestamp;\n    }",
                "Type": "Incorrect calculating order",
                "Description": "In this version, if a user deposits additional ETH rapidly in succession before the interest from the first deposit is calculated and credited, they will earn interest on the combined deposit, which is unfair.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyStore {\n    mapping(address => uint256) public points;\n    mapping(address => bool) public hasDiscount;\n    uint256 public itemCost = 1000;\n\n    function purchaseItem() external {\n        require(points[msg.sender] >= itemCost, \"Not enough points\");\n\n        if (hasDiscount[msg.sender]) {\n            itemCost -= itemCost / 10; \n        }\n\n        points[msg.sender] -= itemCost;\n\n        // Grant a discount for the next purchase\n        hasDiscount[msg.sender] = true;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "51",
                "Location": "require(points[msg.sender] >= itemCost, \"Not enough points\");\n\n        if (hasDiscount[msg.sender]) {\n            itemCost -= itemCost / 10; \n        }\n\n        points[msg.sender] -= itemCost;",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, users with a discount can potentially exploit the incorrect order of operations. They might be able to purchase when their points are slightly below the itemCost if they have a discount available.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract InvestmentPool {\n    mapping(address => uint256) public balances;\n    uint256 public totalDeposited;\n    uint256 public interestRate = 5;  // 5%\n\n    function deposit(uint256 amount) external {\n        balances[msg.sender] += amount;\n        totalDeposited += amount;\n        accrueInterest();  \n    }\n\n    function accrueInterest() internal {\n        uint256 interest = (totalDeposited * interestRate) / 100;\n        totalDeposited += interest;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "52",
                "Location": "balances[msg.sender] += amount;\n        totalDeposited += amount;\n        accrueInterest();",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, if a user deposits a large amount, they instantly gain interest on it within the same transaction due to the order of deposit and accrueInterest functions, which gives them a one-time advantage.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract TokenStaking {\n    mapping(address => uint256) public stakes;\n    mapping(address => uint256) public dividends;\n    uint256 public totalStaked;\n    uint256 public poolDividend;\n\n    // Event to track dividends\n    event DividendPaid(address indexed user, uint256 amount);\n\n    function stake(uint256 amount) external {\n        stakes[msg.sender] += amount;\n        totalStaked += amount;\n        \n        distributeDividend(msg.sender);\n    }\n\n    function distributeDividend(address user) internal {\n        uint256 userDividend = (poolDividend * stakes[user]) / totalStaked;\n        dividends[user] += userDividend;\n        emit DividendPaid(user, userDividend);\n    }\n\n    // Function to add funds to the dividend pool\n    function addFundsToPool(uint256 amount) external {\n        poolDividend += amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "53",
                "Location": " function stake(uint256 amount) external {\n        stakes[msg.sender] += amount;\n        totalStaked += amount;\n        distributeDividend(msg.sender); \n    }",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, when a user stakes a large amount, they instantly gain dividends on it within the same transaction due to the sequence of stake and distributeDividend functions.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract FruitMarket {\n    mapping(string => uint256) public fruitStock;\n    mapping(string => uint256) public fruitPrice;\n\n    event FruitPurchased(address indexed buyer, string fruitName, uint256 quantity);\n\n    constructor() {\n        fruitStock[\"apple\"] = 1000;\n        fruitStock[\"banana\"] = 800;\n        fruitPrice[\"apple\"] = 1 ether;\n        fruitPrice[\"banana\"] = 0.5 ether;\n    }\n\n    function purchaseFruit(string memory fruitName, uint256 quantity) external payable {\n        require(fruitStock[fruitName] >= quantity, \"Not enough fruits in stock\");\n        uint256 totalCost = fruitPrice[fruitName] * quantity;\n        require(msg.value == totalCost, \"Incorrect ether sent\");\n\n        fruitStock[fruitName] -= quantity; \n\n         payable(address(this)).transfer(totalCost);\n\n        emit FruitPurchased(msg.sender, fruitName, quantity);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "54",
                "Location": "fruitStock[fruitName] -= quantity; \n\n       payable(address(this)).transfer(totalCost);",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, if the ether transfer fails for some reason (though unlikely in this specific case), the stock is already deducted.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract RewardVault {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lastUpdated;\n    uint256 public interestRate = 5; // Represents 5%\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function deposit() external payable {\n        updateInterest(msg.sender);\n\n        balances[msg.sender] += msg.value;\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) external {\n        updateInterest(msg.sender);\n\n        require(balances[msg.sender] >= amount, \"Insufficient funds\");\n\n        balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n\n        emit Withdrawn(msg.sender, amount);\n    }\n\n    function updateInterest(address user) internal {\n        uint256 elapsedTime = block.timestamp - lastUpdated[user];\n        uint256 interest = (balances[user] * interestRate * elapsedTime) / (365 days * 100);\n        balances[user] += interest;\n        lastUpdated[user] = block.timestamp;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "55",
                "Location": "balances[msg.sender] -= amount; \n        payable(msg.sender).transfer(amount);\n",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, there's a possibility that if the ether transfer fails, the user's balance has already been deducted.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract TokenSwap {\n\n    IERC20 public tokenA;\n    IERC20 public tokenB;\n    uint256 public rate;  // Rate of TokenA to TokenB (e.g. rate = 2 means 1 TokenA = 2 TokenB)\n\n    constructor(address _tokenA, address _tokenB, uint256 _rate) {\n        tokenA = IERC20(_tokenA);\n        tokenB = IERC20(_tokenB);\n        rate = _rate;\n    }\n\n    function swap(uint256 amountA) external {\n        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Transfer of TokenA failed\");\n\n        uint256 amountB = amountA * rate;\n        \n       \n        require(tokenB.transfer(msg.sender, amountB), \"Transfer of TokenB failed\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "56",
                "Location": "require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Transfer of TokenA failed\");\n\n        uint256 amountB = amountA * rate;\n        \n        require(tokenB.transfer(msg.sender, amountB), \"Transfer of TokenB failed\");",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here is that the contract does not verify if it has enough TokenB balance to make the swap, which could result in failed transactions after the TokenA transfer.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n}\n\ncontract LoyaltyReward {\n\n    IERC20 public rewardToken;\n    mapping(address => uint256) public loyaltyPoints;\n    uint256 public conversionRate;  // Conversion rate for loyalty points to reward token (e.g., 1 loyalty point = 10 reward tokens)\n\n    constructor(address _rewardToken, uint256 _conversionRate) {\n        rewardToken = IERC20(_rewardToken);\n        conversionRate = _conversionRate;\n    }\n\n    function setLoyaltyPoints(address user, uint256 points) external {\n        require(msg.sender == address(this), \"Only contract owner can set loyalty points\");\n        loyaltyPoints[user] = points;\n    }\n\n    function claimReward() external {\n        uint256 rewardAmount = loyaltyPoints[msg.sender] * conversionRate;\n\n       \n        require(rewardToken.transfer(msg.sender, rewardAmount), \"Transfer of reward token failed\");\n\n       loyaltyPoints[msg.sender] = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "57",
                "Location": " uint256 rewardAmount = loyaltyPoints[msg.sender] * conversionRate;\n\n        require(rewardToken.transfer(msg.sender, rewardAmount), \"Transfer of reward token failed\");\n\n        loyaltyPoints[msg.sender] = 0;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here is that the contract does not verify if it has enough reward tokens to distribute to the user based on their loyalty points, which can lead to failed transactions.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract DepositContract {\n\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient funds\");\n\n        \n        payable(msg.sender).transfer(amount);\n        \n        balances[msg.sender] -= amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "58",
                "Location": " payable(msg.sender).transfer(amount);\n        \n        balances[msg.sender] -= amount;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here is that the contract sends funds to the user before updating the user's balance. This opens the door for a reentrancy attack where a malicious actor can withdraw their balance multiple times before the state is updated.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n\n    mapping(address => uint256) public loyaltyPoints;\n    uint256 public pointsToRedeem = 1000;\n    uint256 public rewardAmount = 0.1 ether;\n\n    function spendFunds(uint256 amount) external payable {\n        require(msg.value == amount, \"Incorrect Ether sent\");\n        \n        // Earn 1 point for every 1 ether spent.\n        loyaltyPoints[msg.sender] += amount;\n\n        if(loyaltyPoints[msg.sender] >= pointsToRedeem) {\n            payable(msg.sender).transfer(rewardAmount);\n            loyaltyPoints[msg.sender] -= pointsToRedeem;\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "59",
                "Location": "if(loyaltyPoints[msg.sender] >= pointsToRedeem) {\n            loyaltyPoints[msg.sender] -= pointsToRedeem;\n            payable(msg.sender).transfer(rewardAmount);\n        }",
                "Type": "Incorrect calculating order",
                "Description": "Here, if the user has enough loyalty points to redeem a reward, they get the reward. However, because the contract sends the reward before deducting the loyalty points, a malicious contract can exploit the fallback function to repeatedly call spendFunds and drain the contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract TokenVault {\n    IERC20 public token;\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lockTime;\n\n    constructor(address _tokenAddress) {\n        token = IERC20(_tokenAddress);\n    }\n\n    function deposit(uint256 amount) external {\n        require(token.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n        balances[msg.sender] += amount;\n        lockTime[msg.sender] = block.timestamp + 1 days; // Lock for 1 day\n    }\n\n    function withdraw() external {\n        require(block.timestamp > lockTime[msg.sender], \"Tokens are still locked!\");\n\n        uint256 amountToWithdraw = balances[msg.sender];\n        \n        require(token.transfer(msg.sender, amountToWithdraw), \"Withdrawal failed\");\n        balances[msg.sender] -= amountToWithdraw;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "60",
                "Location": "require(token.transfer(msg.sender, amountToWithdraw), \"Withdrawal failed\");\n        balances[msg.sender] -= amountToWithdraw;",
                "Type": "Incorrect calculating order",
                "Description": "In the withdraw function, a user's balance is updated after the token transfer. This order allows reentrancy attacks.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract RewardDistributor {\n    IERC20 public token;\n    mapping(address => uint256) public stakes;\n    mapping(address => uint256) public lastClaimed;\n    uint256 public totalStaked;\n    uint256 public rewardRate = 1e18; // 1 token per block per staked token\n\n    constructor(address _tokenAddress) {\n        token = IERC20(_tokenAddress);\n    }\n\n    function stake(uint256 amount) external {\n        require(token.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n        stakes[msg.sender] += amount;\n        totalStaked += amount;\n        lastClaimed[msg.sender] = block.number;\n    }\n\n    function claimRewards() external {\n        uint256 blocksSinceLastClaim = block.number - lastClaimed[msg.sender];\n        uint256 reward = stakes[msg.sender] * blocksSinceLastClaim * rewardRate;\n\n        require(token.transfer(msg.sender, reward), \"Reward transfer failed\");\n        lastClaimed[msg.sender] = block.number;\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "61",
                "Location": "require(token.transfer(msg.sender, reward), \"Reward transfer failed\");\n        lastClaimed[msg.sender] = block.number;",
                "Type": "Incorrect calculating order",
                "Description": "In the claimRewards function, the contract sends the rewards to the user before updating the lastClaimed timestamp. This can expose the contract to a reentrancy attack if the IERC20 token being used is maliciously implemented.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract ReferralBonus {\n    mapping(address => uint256) public balances;\n\n    function deposit(uint256 amount, address referrer) external payable {\n        require(msg.value == amount, \"Sent amount mismatched!\");\n\n        if (referrer != address(0)) {\n            uint256 bonus = amount / 20; // 5% bonus\n            balances[referrer] += bonus;\n            \n           amount += bonus;\n        }\n\n        balances[msg.sender] += amount;\n    }\n    \n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "62",
                "Location": " if (referrer != address(0)) {\n            uint256 bonus = amount / 20; // 5% bonus\n            balances[referrer] += bonus;\n            \n            amount += bonus;\n        }\n\n        balances[msg.sender] += amount;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability in the contract above lies in the order of adding the bonus to the referrer's balance and then recalculating the depositor's balance. It mistakenly gives the bonus to both the referrer and the referrer's user.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoanRepayment {\n    mapping(address => uint256) public principal; \n    mapping(address => uint256) public interest; \n    mapping(address => uint256) public loanStartDate;\n\n    function takeLoan(uint256 amount) external {\n        principal[msg.sender] = amount;\n        interest[msg.sender] = amount / 10; // 10% interest\n        loanStartDate[msg.sender] = block.timestamp;\n    }\n\n    function repay() external payable {\n        require(principal[msg.sender] > 0, \"No loan taken\");\n\n        uint256 totalAmount = principal[msg.sender] + interest[msg.sender];\n\n        if (block.timestamp - loanStartDate[msg.sender] <= 10 days) {\n            totalAmount -= totalAmount / 10;  // 10% discount\n        }\n\n        require(msg.value == totalAmount, \"Incorrect repayment amount\");\n\n        principal[msg.sender] = 0;\n        interest[msg.sender] = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "63",
                "Location": " uint256 totalAmount = principal[msg.sender] + interest[msg.sender];\n\n        if (block.timestamp - loanStartDate[msg.sender] <= 10 days) {\n            totalAmount -= totalAmount / 10;  // 10% discount\n        }\n\n        require(msg.value == totalAmount, \"Incorrect repayment amount\");",
                "Type": "Incorrect calculating order",
                "Description": "In the contract above, the vulnerability is the discount for early repayment. It's applied after the interest is added to the principal, which makes the discount apply to both the principal and the interest.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract VotingSystem {\n    struct Candidate {\n        uint256 voteCount;\n        string name;\n    }\n    \n    mapping(address => uint256) public voterTokens;\n    mapping(uint256 => Candidate) public candidates;\n    uint256 public totalCandidates = 0;\n\n    function addCandidate(string memory _name) public {\n        candidates[totalCandidates] = Candidate(0, _name);\n        totalCandidates++;\n    }\n\n    function allocateVoterTokens(address voter, uint256 tokens) public {\n        voterTokens[voter] += tokens;\n    }\n\n    function castVote(uint256 candidateId, uint256 tokens) public {\n        require(voterTokens[msg.sender] >= tokens, \"Not enough tokens to vote\");\n        \n        candidates[candidateId].voteCount += tokens;\n        voterTokens[msg.sender] -= tokens;\n    }\n    \n    function getCandidate(uint256 candidateId) public view returns(string memory, uint256) {\n        return (candidates[candidateId].name, candidates[candidateId].voteCount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "64",
                "Location": "candidates[candidateId].voteCount += tokens;\n        voterTokens[msg.sender] -= tokens;",
                "Type": "Incorrect calculating order",
                "Description": "In the castVote function, the contract first increases the voteCount for the candidate and then subtracts the tokens from the user's balance. If there's an exception after increasing the voteCount but before subtracting tokens (due to candidateId being invalid), the user can exploit this and cast more votes than their token balance.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract SimpleAuction {\n    address public highestBidder;\n    uint256 public highestBid;\n    mapping(address => uint256) public refunds;\n\n    function placeBid(uint256 amount) public payable {\n        require(msg.value == amount, \"Sent amount mismatch\");\n        require(amount > highestBid, \"There already is a higher bid\");\n\n        \n        if (highestBidder != address(0)) {\n            refunds[highestBidder] += highestBid; \n        }\n\n        highestBidder = msg.sender;\n        highestBid = amount;\n    }\n\n    function withdrawRefund() public {\n        uint256 refundAmount = refunds[msg.sender];\n        refunds[msg.sender] = 0;\n        payable(msg.sender).transfer(refundAmount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "65",
                "Location": "highestBidder = msg.sender;\n        highestBid = amount;\n\n        if (previousHighestBidder != address(0)) {\n            refunds[previousHighestBidder] += previousHighestBid; \n        }",
                "Type": "Incorrect calculating order",
                "Description": "In the placeBid function, the contract first credits the refund of the previous highest bidder before updating the highest bid and highest bidder. If the same user withdraws their funds and then bids again, they can repeatedly become the highest bidder without actually sending more Ether.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract SimpleToken {\n    mapping(address => uint256) public balances;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(uint256 initialSupply) {\n        balances[msg.sender] = initialSupply;\n    }\n\n    function transfer(address to, uint256 amount) public returns(bool) {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n      \n        balances[to] += amount;\n        balances[msg.sender] -= amount;\n\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "66",
                "Location": "balances[to] += amount;\n        balances[msg.sender] -= amount;",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable transfer function, if the msg.sender specifies their own address as the to address, the addition operation balances[to] += amount; can overflow and then the subsequent subtraction may not work as intended.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Crowdsale {\n    uint256 public rate = 100;  // 100 tokens per ether\n    uint256 public totalTokens = 1000000;\n    mapping(address => uint256) public balances;\n\n    event Purchased(address indexed buyer, uint256 amount);\n\n    function buyTokens() public payable {\n        uint256 tokensToBuy = msg.value * rate;\n\n        require(tokensToBuy <= totalTokens, \"Not enough tokens left\");\n\n      \n        balances[msg.sender] += tokensToBuy;\n        totalTokens -= tokensToBuy;\n\n        emit Purchased(msg.sender, tokensToBuy);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "67",
                "Location": "balances[msg.sender] += tokensToBuy;\n        totalTokens -= tokensToBuy;\n",
                "Type": "Incorrect calculating order",
                "Description": " However, the vulnerability arises from the incorrect order of operations: the contract sends the tokens to the user before deducting the ether from their account.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract VotingSystem {\n    struct Candidate {\n        string name;\n        uint256 voteCount;\n    }\n\n    Candidate[] public candidates;\n    mapping(address => bool) public hasVoted;\n\n    event Voted(address indexed voter, uint256 candidateId);\n\n    function addCandidate(string memory _name) public {\n        candidates.push(Candidate(_name, 0));\n    }\n\n    function vote(uint256 _candidateId) public {\n       \n        hasVoted[msg.sender] = true;\n\n        require(!hasVoted[msg.sender], \"You have already voted\");\n        require(_candidateId < candidates.length, \"Invalid candidate\");\n\n        candidates[_candidateId].voteCount++;\n\n        emit Voted(msg.sender, _candidateId);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "68",
                "Location": "hasVoted[msg.sender] = true;\n\n        require(!hasVoted[msg.sender], \"You have already voted\");\n        require(_candidateId < candidates.length, \"Invalid candidate\");\n",
                "Type": "Incorrect calculating order",
                "Description": "However, there's a vulnerability because the contract first updates the voter's status and then checks if they have already voted, which could lead to double voting.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyStore {\n    struct Item {\n        string name;\n        uint256 price;\n    }\n\n    Item[] public items;\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public loyaltyPoints;\n\n    event Purchased(address indexed buyer, uint256 itemId);\n\n    function addItem(string memory _name, uint256 _price) public {\n        items.push(Item(_name, _price));\n    }\n\n    function purchaseItem(uint256 _itemId) public {\n        require(_itemId < items.length, \"Invalid item\");\n\n        uint256 price = items[_itemId].price;\n        \n       \n        loyaltyPoints[msg.sender] += price;\n        \n        require(balances[msg.sender] >= price, \"Insufficient funds\");\n        balances[msg.sender] -= price;\n\n        emit Purchased(msg.sender, _itemId);\n    }\n\n    function addBalance(uint256 _amount) public {\n        balances[msg.sender] += _amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "69",
                "Location": "loyaltyPoints[msg.sender] += price;\n        \n        require(balances[msg.sender] >= price, \"Insufficient funds\");\n        balances[msg.sender] -= price;",
                "Type": "Incorrect calculating order",
                "Description": "The smart contract has a vulnerability because it first credits the user with points and then deducts the purchase cost from the user's balance. This can allow a user to go negative in balance if they don't have enough funds, but still get the loyalty points.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract TimeReleaseToken {\n    mapping(address => uint256) public balances;\n    uint256 public releaseTime;\n\n    constructor(uint256 _releaseTime) {\n        releaseTime = _releaseTime;\n    }\n\n    function deposit() public payable {\n        require(msg.value > 0, \"Must deposit a positive amount\");\n        balances[msg.sender] += msg.value;\n    }\n\n    function claimTokens() public {\n       \n        payable(msg.sender).transfer(balances[msg.sender]);\n        require(block.timestamp >= releaseTime, \"Tokens are not yet released\");\n\n        balances[msg.sender] = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "70",
                "Location": "payable(msg.sender).transfer(balances[msg.sender]);\n        require(block.timestamp >= releaseTime, \"Tokens are not yet released\");",
                "Type": "Incorrect calculating order",
                "Description": "However, the function first transfers the tokens and then checks if the releaseTime has passed. This means users might be able to claim tokens before the designated releaseTime.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract VotingSystem {\n    mapping(address => uint256) public votes;\n    uint256 public votingEndTime;\n\n    event Voted(address indexed voter, uint256 amount);\n\n    constructor(uint256 _votingDuration) {\n        votingEndTime = block.timestamp + _votingDuration;\n    }\n\n    function castVote() public payable {\n\n        votes[msg.sender] += msg.value;\n        emit Voted(msg.sender, msg.value);\n\n        require(block.timestamp < votingEndTime, \"Voting has ended\");\n    }\n\n    function withdraw() public {\n        uint256 amount = votes[msg.sender];\n        votes[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "71",
                "Location": "votes[msg.sender] += msg.value;\n        emit Voted(msg.sender, msg.value);\n\n        require(block.timestamp < votingEndTime, \"Voting has ended\");",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability arises from the contract allowing a vote to be cast before checking if the voting period has ended, which can result in last-moment manipulation of the results.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IToken {\n    function mint(address to, uint256 amount) external;\n}\n\ncontract TokenSale {\n    IToken public token;\n    uint256 public tokensSold;\n    uint256 constant BASE_PRICE = 1 ether;\n\n    constructor(address _tokenAddress) {\n        token = IToken(_tokenAddress);\n    }\n\n    function buyTokens() public payable {\n        uint256 tokensToMint = calculateTokensToMint(msg.value);\n        \n       \n        token.mint(msg.sender, tokensToMint);\n        \n        tokensSold += tokensToMint;\n    }\n\n    function calculateTokensToMint(uint256 etherSent) public view returns (uint256) {\n        uint256 price = BASE_PRICE - (tokensSold / 1000);  // Example dynamic price calculation\n        return etherSent / price;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "72",
                "Location": "token.mint(msg.sender, tokensToMint);\n        \n        tokensSold += tokensToMint;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability arises because the contract mints the tokens before updating the total tokens sold, which affects the token price calculation for subsequent transactions in the same block.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract TokenSale {\n    uint256 public tokenPrice = 1 ether;  // Price per token\n    uint256 public totalTokens = 1000;\n    mapping(address => uint256) public tokensPurchased;\n\n    // Simulated Token Contract interface\n    interface IToken {\n        function transfer(address recipient, uint256 amount) external returns (bool);\n    }\n    IToken public tokenContract;\n\n    constructor(address _tokenContract) {\n        tokenContract = IToken(_tokenContract);\n    }\n\n    function buyTokens(uint256 numOfTokens) public payable {\n        require(msg.value == numOfTokens * tokenPrice, \"Incorrect Ether sent\");\n        require(totalTokens >= numOfTokens, \"Not enough tokens left for sale\");\n        \n        tokenContract.transfer(msg.sender, numOfTokens);\n\n        totalTokens -= numOfTokens;\n        tokensPurchased[msg.sender] += numOfTokens;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "73",
                "Location": "tokenContract.transfer(msg.sender, numOfTokens);\n\n        totalTokens -= numOfTokens;\n        tokensPurchased[msg.sender] += numOfTokens;",
                "Type": "Incorrect calculating order",
                "Description": "In this vulnerable version, we first transfer the tokens and then update the state variables. If the tokenContract.transfer function were to fail for any reason, we wouldn't update the totalTokens and tokensPurchased state variables, creating potential inconsistencies.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract InterestBearingAccount {\n\n    struct Account {\n        uint256 deposit;\n        uint256 lastDepositTime;\n    }\n\n    uint256 public interestRate = 10;  // 10% per year\n    mapping(address => Account) public accounts;\n\n    function deposit() public payable {\n        require(msg.value > 0, \"Deposit must be positive\");\n        \n        // Calculate and add interest for previous deposits\n        if (accounts[msg.sender].deposit > 0) {\n            uint256 timeDiff = block.timestamp - accounts[msg.sender].lastDepositTime;\n            uint256 interest = accounts[msg.sender].deposit * interestRate / 100 * timeDiff / 365 days;\n            accounts[msg.sender].deposit += interest;\n        }\n\n        accounts[msg.sender].deposit += msg.value;\n        accounts[msg.sender].lastDepositTime = block.timestamp;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(accounts[msg.sender].deposit >= amount, \"Insufficient balance\");\n        \n        payable(msg.sender).transfer(amount);\n        accounts[msg.sender].deposit -= amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "74",
                "Location": "payable(msg.sender).transfer(amount);\n        accounts[msg.sender].deposit -= amount;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability is in the withdraw function. It first sends the ether and then updates the balance. If there's any problem with sending the ether (like a reentrancy attack), it can be exploited.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract FeeCollector {\n\n    uint256 public collectedFees;\n    address public owner;\n    uint256 public serviceFee = 0.01 ether; \n    uint256 public discount = 10; // 10% discount for the service fee\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the owner\");\n        _;\n    }\n\n    function payForService() public payable {\n        uint256 discountedFee = serviceFee * (100 - discount) / 100;\n        require(msg.value == discountedFee, \"Incorrect fee amount\");\n\n        collectedFees += msg.value;\n    }\n\n    function withdrawFees() public onlyOwner {\n        payable(owner).transfer(collectedFees);\n        collectedFees = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "75",
                "Location": "uint256 discountedFee = serviceFee * (100 - discount) / 100;\n        require(msg.value == discountedFee, \"Incorrect fee amount\");\n\n        collectedFees += msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "In the payForService function, the discount is applied to the service fee before checking if the user has sent the correct fee amount. This opens up a potential vulnerability where the fee calculation could be exploited.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IToken {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract TokenSwap {\n    IToken public tokenA;\n    IToken public tokenB;\n\n    uint256 public rate; // Number of TokenB a user receives for 1 TokenA.\n    uint256 public feePercentage = 5; // 5% fee\n\n    constructor(address _tokenA, address _tokenB, uint256 _rate) {\n        tokenA = IToken(_tokenA);\n        tokenB = IToken(_tokenB);\n        rate = _rate;\n    }\n\n    function swap(uint256 amountA) public {\n        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Transfer of TokenA failed\");\n\n       \n        uint256 fee = amountA * feePercentage / 100;\n        uint256 netAmountA = amountA - fee;\n        uint256 amountB = netAmountA * rate;\n\n        require(tokenB.balanceOf(address(this)) >= amountB, \"Insufficient TokenB in contract\");\n        tokenB.transfer(msg.sender, amountB);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "76",
                "Location": "uint256 fee = amountA * feePercentage / 100;\n        uint256 netAmountA = amountA - fee;\n        uint256 amountB = netAmountA * rate;",
                "Type": "Incorrect calculating order",
                "Description": "In the swap function, the contract takes the fee from amountA first and then calculates the amount of TokenB to send. This might give fewer tokens to the user than they expect.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract SimpleBank {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient funds\");\n        \n       \n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n        \n        balances[msg.sender] -= amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "77",
                "Location": "(bool success, ) = msg.sender.call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n        \n        balances[msg.sender] -= amount;",
                "Type": "Incorrect calculating order",
                "Description": "In the withdraw function, the direct transfer to msg.sender before updating the balance is a classic setup for a reentrancy attack.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract LoyaltyReward {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n\n    event RewardDistributed(address user, uint256 amount);\n\n    function deposit(uint256 amount) public {\n        balances[msg.sender] += amount;\n        totalSupply += amount;\n    }\n\n    function distributeReward(address user, uint256 totalReward) public {\n        uint256 userBalance = balances[user];\n        uint256 reward = (userBalance / totalSupply) * totalReward;\n        \n        balances[user] += reward;\n        emit RewardDistributed(user, reward);\n\n        totalSupply += totalReward;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "78",
                "Location": "  function distributeReward(address user, uint256 totalReward) public {\n        uint256 userBalance = balances[user];\n        uint256 reward = (userBalance / totalSupply) * totalReward;\n        \n        balances[user] += reward;\n        emit RewardDistributed(user, reward);\n\n        totalSupply += totalReward;\n    }",
                "Type": "Incorrect calculating order",
                "Description": "Here, if the total reward is substantial, early users could get a higher portion of the reward since totalSupply gets updated after reward distribution.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract AuctionHouse {\n    address public highestBidder;\n    uint256 public highestBid;\n    uint256 public lastBidBlock;\n    uint256 public blockDelay = 10;\n    \n    mapping(address => uint256) public pendingReturns;\n\n    event NewBid(address bidder, uint256 amount);\n\n    function bid() public payable {\n        require(msg.value > highestBid, \"Bid must be higher than current highest bid\");\n        require(block.number > lastBidBlock + blockDelay, \"The previous bid is still valid\");\n\n       if (highestBidder != address(0)) {\n            pendingReturns[highestBidder] += highestBid;\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n        lastBidBlock = block.number;\n\n        emit NewBid(msg.sender, msg.value);\n    }\n\n    function withdraw() public {\n        uint256 amount = pendingReturns[msg.sender];\n        require(amount > 0, \"No funds to withdraw\");\n\n        pendingReturns[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "79",
                "Location": "        if (highestBidder != address(0)) {\n            pendingReturns[highestBidder] += highestBid;\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n        lastBidBlock = block.number;\n\n        emit NewBid(msg.sender, msg.value);",
                "Type": "Incorrect calculating order",
                "Description": "The flaw here is that the contract first refunds the previous highest bidder and then updates the highest bid. This order allows the current highest bidder to bid again using the refunded amount, potentially leading to unexpected behavior.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract TokenSwap {\n\n    function swapTokens(\n        IERC20 tokenA,\n        address sender,\n        uint256 amountA,\n        IERC20 tokenB,\n        address recipient,\n        uint256 amountB\n    ) external {\n        require(tokenB.transfer(recipient, amountB), \"Token B transfer failed\");\n\n        require(tokenA.transferFrom(sender, address(this), amountA), \"Token A transfer failed\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "80",
                "Location": "        require(tokenB.transfer(recipient, amountB), \"Token B transfer failed\");\n\n        require(tokenA.transferFrom(sender, address(this), amountA), \"Token A transfer failed\");",
                "Type": "Incorrect calculating order",
                "Description": "The contract first sends tokens to the recipient and then takes tokens from the sender. This order can be exploited if the recipient's fallback function re-enters the exchange function.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract EtherVault {\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        payable(msg.sender).transfer(amount);\n\n        balances[msg.sender] -= amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "81",
                "Location": "        payable(msg.sender).transfer(amount);\n\n        balances[msg.sender] -= amount;",
                "Type": "Incorrect calculating order",
                "Description": "When a user wishes to withdraw, the contract first sends the ether and then updates the balance of the user. This can create a reentrancy vulnerability.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Auction {\n    address public owner;\n    uint256 public endTime;\n    address public highestBidder;\n    uint256 public highestBid;\n    mapping(address => uint256) public bids;\n\n    constructor(uint256 _durationMinutes) {\n        owner = msg.sender;\n        endTime = block.timestamp + _durationMinutes * 1 minutes;\n    }\n\n    function bid() external payable {\n        require(block.timestamp < endTime, \"Auction has ended\");\n        require(msg.value > highestBid, \"Bid is not high enough\");\n\n        // Refund the previous highest bidder\n        if (highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid);\n        }\n\n        bids[msg.sender] = msg.value;\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function finalize() external {\n        require(block.timestamp >= endTime, \"Auction not yet ended\");\n        require(msg.sender == owner, \"Only owner can finalize\");\n\n        payable(owner).transfer(highestBid);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "82",
                "Location": "if (highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid);\n        }\n\n        bids[msg.sender] = msg.value;\n        highestBidder = msg.sender;\n        highestBid = msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "In this vulnerable contract, when a new highest bid is made, the previous highest bidder gets refunded immediately. This means a malicious bidder can use a fallback function to re-enter the bid() function before their funds have been returned, effectively draining the contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract ArtTrade {\n    struct Artwork {\n        address artist;\n        address owner;\n        uint256 price;\n    }\n    \n    mapping(uint256 => Artwork) public artworks;\n\n    function mint(uint256 artId, uint256 price) external {\n        artworks[artId] = Artwork({\n            artist: msg.sender,\n            owner: msg.sender,\n            price: price\n        });\n    }\n\n    function buy(uint256 artId) external payable {\n        Artwork storage art = artworks[artId];\n        \n        require(msg.value >= art.price, \"Insufficient funds sent\");\n\n        uint256 royalty = art.price / 10;\n        payable(art.artist).transfer(royalty);\n        \n        payable(art.owner).transfer(art.price - royalty);\n\n        art.owner = msg.sender;\n        art.price = msg.value;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "83",
                "Location": "uint256 royalty = art.price / 10;\n        payable(art.artist).transfer(royalty);\n        \n        payable(art.owner).transfer(art.price - royalty);\n\n        art.owner = msg.sender;\n        art.price = msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "In this contract, the incorrect order of operations could lead to miscalculation of royalty and final selling price, causing potential financial discrepancies.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Crowdfunding {\n    struct Project {\n        address payable creator;\n        uint256 targetAmount;\n        uint256 totalPledged;\n        uint256 endTime;\n        bool fundsWithdrawn;\n        mapping(address => uint256) pledges;\n    }\n    \n    mapping(uint256 => Project) public projects;\n\n    function createProject(uint256 projectId, uint256 amount, uint256 duration) external {\n        projects[projectId] = Project({\n            creator: payable(msg.sender),\n            targetAmount: amount,\n            totalPledged: 0,\n            endTime: block.timestamp + duration,\n            fundsWithdrawn: false\n        });\n    }\n\n    function pledge(uint256 projectId) external payable {\n        Project storage proj = projects[projectId];\n        \n        require(block.timestamp < proj.endTime, \"Project funding time has ended\");\n        proj.pledges[msg.sender] += msg.value;\n        proj.totalPledged += msg.value;\n    }\n\n    function withdraw(uint256 projectId) external {\n        Project storage proj = projects[projectId];\n        \n        require(msg.sender == proj.creator, \"Only project creator can withdraw\");\n        require(block.timestamp < proj.endTime, \"Project funding time has ended\");\n        require(proj.totalPledged >= proj.targetAmount, \"Funding target not reached\");\n        require(!proj.fundsWithdrawn, \"Funds have been withdrawn\");\n\n        proj.creator.transfer(proj.totalPledged);\n        proj.fundsWithdrawn = true; \n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "84",
                "Location": " proj.creator.transfer(proj.totalPledged);\n        proj.fundsWithdrawn = true; ",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here is that the contract transfers funds to proj.creator before setting the fundsWithdrawn flag. If the recipient (project creator) is a malicious contract, it can trigger a reentrancy attack and drain the funds.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    uint256 public endTime;\n\n    mapping(address => uint256) public pendingReturns;\n\n    constructor(uint256 _duration) {\n        endTime = block.timestamp + _duration;\n    }\n\n    function bid() external payable {\n        require(block.timestamp < endTime, \"Auction already ended\");\n        require(msg.value > highestBid, \"There already is a higher bid\");\n        \n        \n        if (highestBidder != address(0)) {\n            pendingReturns[highestBidder] += highestBid;\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function withdraw() external {\n        uint256 amount = pendingReturns[msg.sender];\n        if (amount > 0) {\n            pendingReturns[msg.sender] = 0;\n            payable(msg.sender).transfer(amount);\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "85",
                "Location": "if (highestBidder != address(0)) {\n            pendingReturns[highestBidder] += highestBid;\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "Here, the vulnerability is due to the sequence of operations. If highestBidder is a malicious contract, it might exploit the contract in the small window between receiving its funds and the highest bid being updated.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Lottery {\n    address[] public participants;\n    uint256 public constant TICKET_PRICE = 1 ether;\n    uint256 public constant MAX_PARTICIPANTS = 10;\n    \n    function buyTicket() external payable {\n        require(msg.value == TICKET_PRICE, \"Must send exactly 1 Ether\");\n        participants.push(msg.sender);\n        \n        if (participants.length == MAX_PARTICIPANTS) {\n            uint256 winnerIndex = uint256(blockhash(block.number - 1)) % MAX_PARTICIPANTS;\n            address winner = participants[winnerIndex];\n            \n            \n            payable(winner).transfer(address(this).balance);\n            \n            delete participants;\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "86",
                "Location": "payable(winner).transfer(address(this).balance);\n            \n            delete participants;",
                "Type": "Incorrect calculating order",
                "Description": "Here, the vulnerability arises due to the order of operations. If the winner is a malicious contract, it can exploit the contract in the gap between receiving the jackpot and the participants list being reset.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Store {\n    address public owner;\n    uint256 public dailyLimit = 10 ether;\n    uint256 public withdrawnToday;\n    uint256 public lastWithdrawal;\n\n    mapping(address => uint256) public balances;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function buyItem(uint256 itemPrice) external payable {\n        require(msg.value == itemPrice, \"Must send the correct Ether amount\");\n        balances[owner] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external onlyOwner {\n        require(balances[owner] >= amount, \"Insufficient funds\");\n\n        if (block.timestamp > lastWithdrawal + 1 days) {\n            withdrawnToday = 0;\n        }\n\n        require(withdrawnToday + amount <= dailyLimit, \"Exceeds daily withdrawal limit\");\n\n        payable(owner).transfer(amount);\n\n        \n        withdrawnToday += amount;\n        lastWithdrawal = block.timestamp;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "87",
                "Location": "payable(owner).transfer(amount);\n\n        withdrawnToday += amount;\n        lastWithdrawal = block.timestamp;",
                "Type": "Incorrect calculating order",
                "Description": "In this version, the contract sets the owner's lastWithdrawal and withdrawnToday after the withdrawal is processed. This can be exploited if the fallback function of the recipient contract causes a failure.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Lottery {\n    address public owner;\n    uint256 public ticketPrice = 1 ether;\n    address[] public players;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function buyTicket() external payable {\n        require(msg.value == ticketPrice, \"Ticket price is incorrect\");\n        players.push(msg.sender);\n    }\n\n    function drawWinner() external onlyOwner {\n        require(players.length > 0, \"No players in the lottery\");\n        \n        address winner = players[random() % players.length];\n        payable(winner).transfer(address(this).balance);\n\n        delete players;\n    }\n\n    function random() private view returns (uint) {\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, players.length)));\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "88",
                "Location": "address winner = players[random() % players.length];\n        payable(winner).transfer(address(this).balance);\n\n        delete players;",
                "Type": "Incorrect calculating order",
                "Description": " If a malicious winner has a fallback function that reverts, the list of players will not be cleared, allowing them to win multiple times with the same ticket.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Voting {\n    address public owner;\n    mapping(address => bool) public hasVoted;\n    mapping(bytes32 => uint256) public votes;\n    bytes32[] public candidates;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this\");\n        _;\n    }\n\n    constructor(bytes32[] memory _candidates) {\n        owner = msg.sender;\n        candidates = _candidates;\n    }\n\n    function vote(bytes32 candidate) external {\n        // Check if user has already voted\n        require(!hasVoted[msg.sender], \"You have already voted\");\n        \n        // Vote for the candidate\n        votes[candidate] += 1;\n        hasVoted[msg.sender] = true;\n    }\n\n    function getWinner() external view onlyOwner returns (bytes32) {\n        bytes32 winner;\n        uint256 highestVotes = 0;\n\n        for (uint i = 0; i < candidates.length; i++) {\n            if (votes[candidates[i]] > highestVotes) {\n                highestVotes = votes[candidates[i]];\n                winner = candidates[i];\n            }\n        }\n\n        return winner;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "89",
                "Location": " votes[candidate] += 1;\n        hasVoted[msg.sender] = true;",
                "Type": "Incorrect calculating order",
                "Description": "The issue is that the check and the action (voting) are separated, creating a potential race condition where a user might be able to vote multiple times.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Crowdfund {\n    address public owner;\n    uint256 public targetAmount;\n    uint256 public endTime;\n    bool public targetMet = false;\n\n    mapping(address => uint256) public contributions;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this\");\n        _;\n    }\n\n    constructor(uint256 _targetAmount, uint256 _durationInMinutes) {\n        owner = msg.sender;\n        targetAmount = _targetAmount;\n        endTime = block.timestamp + (_durationInMinutes * 1 minutes);\n    }\n\n    function contribute() external payable {\n        require(block.timestamp < endTime, \"Funding period is over\");\n        contributions[msg.sender] += msg.value;\n    }\n\n    function checkTargetReached() external {\n        require(block.timestamp >= endTime, \"Funding period is not yet over\");\n        if (address(this).balance >= targetAmount) {\n            targetMet = true;\n        }\n    }\n\n    function withdraw() external {\n        require(block.timestamp >= endTime, \"Funding period is not yet over\");\n        uint256 amount = contributions[msg.sender];\n\n        if (!targetMet) {\n            require(amount > 0, \"No funds to withdraw\");\n            payable(msg.sender).transfer(amount); \n            contributions[msg.sender] = 0;\n        } else if (msg.sender == owner) {\n            payable(owner).transfer(address(this).balance);\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "90",
                "Location": "payable(msg.sender).transfer(amount); \n            contributions[msg.sender] = 0;",
                "Type": "Incorrect calculating order",
                "Description": "In this version, when a user withdraws their contribution after the funding period is unsuccessful, the contract first sends the funds and then updates the user's balance. This exposes a reentrancy vulnerability.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Marketplace {\n    address public owner;\n    struct Item {\n        uint256 id;\n        string name;\n        uint256 price;\n        address payable seller;\n        bool sold;\n    }\n\n    mapping(uint256 => Item) public items;\n    uint256 public itemCount;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function listItem(string memory _name, uint256 _price) external {\n        itemCount++;\n        items[itemCount] = Item(itemCount, _name, _price, payable(msg.sender), false);\n    }\n\n    function buyItem(uint256 _itemId) external payable {\n        require(items[_itemId].price == msg.value, \"Incorrect Ether sent\");\n        require(!items[_itemId].sold, \"Item already sold\");\n\n        items[_itemId].seller.transfer(msg.value); \n        items[_itemId].sold = true;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "91",
                "Location": "items[_itemId].seller.transfer(msg.value); \n        items[_itemId].sold = true;",
                "Type": "Incorrect calculating order",
                "Description": "In this version, the contract first transfers the payment to the seller and then updates the item's status to \"sold\". This opens up the possibility of reentrancy, where a malicious actor could repeatedly call the buyItem function before the status is updated.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract SavingsAccount {\n    struct Account {\n        uint256 balance;\n        uint256 lastDepositTime;\n    }\n\n    mapping(address => Account) public accounts;\n    uint256 public constant INTEREST_RATE = 5; // Example interest rate: 5%\n\n    function deposit() external payable {\n        require(msg.value > 0, \"Deposit must be greater than 0\");\n\n        accounts[msg.sender].balance += msg.value;\n        accounts[msg.sender].lastDepositTime = block.timestamp;\n    }\n\n    function withdraw() external {\n        uint256 timeDiff = block.timestamp - accounts[msg.sender].lastDepositTime;\n        uint256 interest = (accounts[msg.sender].balance * INTEREST_RATE / 100) * timeDiff / (365 days);\n\n        payable(msg.sender).transfer(accounts[msg.sender].balance + interest);\n        accounts[msg.sender].balance = 0;\n        accounts[msg.sender].lastDepositTime = block.timestamp;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "92",
                "Location": "payable(msg.sender).transfer(accounts[msg.sender].balance + interest);\n        accounts[msg.sender].balance = 0;\n        accounts[msg.sender].lastDepositTime = block.timestamp;",
                "Type": "Incorrect calculating order",
                "Description": "In this version, the contract first calculates the interest and then updates the user's balance and last deposit time. This ordering could potentially allow a reentrancy attack, where the user could call withdraw() repeatedly to drain more than their rightful share.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Marketplace {\n    struct Item {\n        address payable seller;\n        uint256 price;\n        bool isSold;\n    }\n\n    mapping(uint256 => Item) public items;\n    uint256 public nextItemId = 1;\n\n    function listItem(uint256 price) external {\n        items[nextItemId] = Item({\n            seller: payable(msg.sender),\n            price: price,\n            isSold: false\n        });\n        nextItemId++;\n    }\n\n    function buyItem(uint256 itemId) external payable {\n        Item storage item = items[itemId];\n        require(!item.isSold, \"Item already sold.\");\n        require(msg.value == item.price, \"Incorrect amount sent.\");\n\n        item.seller.transfer(msg.value); \n        item.isSold = true;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "93",
                "Location": "item.seller.transfer(msg.value);  \n        item.isSold = true;",
                "Type": "Incorrect calculating order",
                "Description": "In this version, the funds are transferred to the seller before the item's status is updated. This may lead to a reentrancy attack if the seller's fallback function calls the buy function again before the item's status is updated.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Lending {\n    address public owner = msg.sender;\n    uint256 public interestRate = 10; // in percentage\n\n    struct User {\n        uint256 deposit;\n        uint256 loan;\n    }\n\n    mapping(address => User) public users;\n\n    function depositFunds(uint256 amount) external payable {\n        require(msg.value == amount, \"Sent amount mismatch\");\n        users[msg.sender].deposit += amount;\n    }\n\n    function borrow(uint256 amount) external {\n        require(users[msg.sender].deposit >= amount, \"Insufficient deposit to borrow\");\n        users[msg.sender].loan += amount;\n        payable(msg.sender).transfer(amount);\n    }\n\n    function repayLoan(uint256 amount) external payable {\n        uint256 interest = (users[msg.sender].loan * interestRate) / 100;\n        require(msg.value == users[msg.sender].loan + interest, \"Must repay loan with interest\");\n        \n        payable(owner).transfer(interest); \n        users[msg.sender].loan = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "94",
                "Location": "payable(owner).transfer(interest);  \n        users[msg.sender].loan = 0;",
                "Type": "Incorrect calculating order",
                "Description": "In this contract, when a user repays their loan, the contract first transfers the interest to the owner before updating the loan amount. This could lead to a reentrancy attack if the owner's fallback function tries to repay the loan again before the loan amount is updated.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract TicketingSystem {\n    address public owner = msg.sender;\n    uint256 public ticketPrice = 1 ether;  // Initial ticket price: 1 ether\n    uint256 public discountPercent = 10;   // 10% discount\n\n    mapping(address => uint256) public ticketsBought;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can execute this\");\n        _;\n    }\n\n    function setDiscountPercent(uint256 _discount) external onlyOwner {\n        discountPercent = _discount;\n    }\n\n    function buyTickets(uint256 numTickets) external payable {\n        uint256 discountedPrice = ticketPrice - (ticketPrice * discountPercent / 100); \n        uint256 totalCost = discountedPrice * numTickets;\n\n        require(msg.value >= totalCost, \"Insufficient Ether provided.\");\n        ticketsBought[msg.sender] += numTickets;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "95",
                "Location": "uint256 discountedPrice = ticketPrice - (ticketPrice * discountPercent / 100); \n        uint256 totalCost = discountedPrice * numTickets;\n",
                "Type": "Incorrect calculating order",
                "Description": "The contract calculates the final ticket price by subtracting the discount before multiplying by the number of tickets, which can lead to imprecise results due to rounding errors.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract CrowdFunding {\n    address public owner;\n    uint256 public fundingGoal;\n    uint256 public totalDonated;\n\n    constructor(uint256 _fundingGoal) {\n        owner = msg.sender;\n        fundingGoal = _fundingGoal;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can execute this\");\n        _;\n    }\n\n    function donate() external payable {\n        totalDonated += msg.value;\n    }\n\n    function withdraw() external onlyOwner {\n        require(totalDonated >= fundingGoal, \"Funding goal not reached yet.\");\n        \n       \n        uint256 toTransfer = totalDonated;\n        totalDonated = 0;  // Reset donations after withdrawal\n        payable(owner).transfer(toTransfer);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "96",
                "Location": "require(totalDonated >= fundingGoal, \"Funding goal not reached yet.\");\n       \n        uint256 toTransfer = totalDonated;",
                "Type": "Incorrect calculating order",
                "Description": "But due to incorrect calculation order, if the project owner sets the funding goal to a small amount and then withdraws the funds multiple times, they can drain more funds than were actually donated.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract VotingSystem {\n    struct Topic {\n        string description;\n        uint256 yesCount;\n        uint256 noCount;\n    }\n    \n    mapping(uint256 => Topic) public topics;\n    mapping(uint256 => mapping(address => bool)) public hasVoted;\n\n    function createTopic(string calldata description) external returns (uint256) {\n        uint256 topicId = block.timestamp; \n        topics[topicId] = Topic(description, 0, 0);\n        return topicId;\n    }\n\n    function vote(uint256 topicId, bool voteYes) external {\n        require(!hasVoted[topicId][msg.sender], \"You've already voted on this topic.\");\n        \n      \n        if (voteYes) {\n            topics[topicId].yesCount++;\n        } else {\n            topics[topicId].noCount++;\n        }\n        \n        hasVoted[topicId][msg.sender] = true;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "97",
                "Location": "require(!hasVoted[topicId][msg.sender], \"You've already voted on this topic.\");\n        \n        if (voteYes) {\n            topics[topicId].yesCount++;\n        } else {\n            topics[topicId].noCount++;\n        }",
                "Type": "Incorrect calculating order",
                "Description": "However, due to an incorrect calculation order, a user might be able to vote multiple times by sending multiple transactions simultaneously, thus influencing the voting outcome.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract TicketSale {\n    uint256 public totalTickets = 1000;\n    uint256 public ticketsSold = 0;\n    uint256 public ticketPrice = 1 ether;\n    mapping(address => uint256) public ticketsBought;\n\n    function buyTickets(uint256 amount) external payable {\n        require(msg.value == ticketPrice * amount, \"Incorrect Ether sent.\");\n\n        ticketsSold += amount; \n        \n        require(ticketsSold <= totalTickets, \"Not enough tickets available.\");\n        \n        ticketsBought[msg.sender] += amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "98",
                "Location": "function buyTickets(uint256 amount) external payable {\n        require(msg.value == ticketPrice * amount, \"Incorrect Ether sent.\");\n\n        ticketsSold += amount;   \n        \n        require(ticketsSold <= totalTickets, \"Not enough tickets available.\");\n        \n        ticketsBought[msg.sender] += amount;\n    }",
                "Type": "Incorrect calculating order",
                "Description": "Due to incorrect calculation order, a user might end up buying more tickets than available, leading to potential overselling.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract CharityDonation {\n    uint256 public donationGoal = 50 ether;\n    uint256 public totalDonations = 0;\n    bool public goalMet = false;\n\n    function donate() external payable {\n        totalDonations += msg.value;  \n        \n        require(totalDonations <= donationGoal, \"Donation exceeds goal amount.\");\n\n        if (totalDonations == donationGoal) {\n            goalMet = true;\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "99",
                "Location": "totalDonations += msg.value;\n        \n        require(totalDonations <= donationGoal, \"Donation exceeds goal amount.\");",
                "Type": "Incorrect calculating order",
                "Description": "In the above version, if two donors try to donate at the same time and their combined donations exceed the donationGoal, both transactions could end up being successful because the state (totalDonations) gets updated before the requirement check. This leads to the goal being surpassed.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract CrowdfundProject {\n    uint256 public targetAmount = 100 ether;\n    uint256 public totalRaised = 0;\n    uint256 public deadline = block.timestamp + 7 days;\n    bool public fundingClosed = false;\n    mapping(address => uint256) public contributions;\n\n    function contribute() external payable {\n        require(block.timestamp < deadline, \"Contribution period has ended.\");\n        contributions[msg.sender] += msg.value;\n        totalRaised += msg.value;  \n        if (totalRaised >= targetAmount) {\n            fundingClosed = true;\n        }\n    }\n\n    function reclaimFunds() external {\n        require(block.timestamp > deadline && totalRaised < targetAmount, \"Cannot reclaim funds now.\");\n        uint256 amount = contributions[msg.sender];\n        contributions[msg.sender] = 0;\n        payable(msg.sender).transfer(amount); \n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "100",
                "Location": "require(block.timestamp < deadline, \"Contribution period has ended.\");\n        contributions[msg.sender] += msg.value;\n        totalRaised += msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "In this version, an attacker can contribute an amount close to the targetAmount, wait for others to donate, then contribute a small additional amount. Due to the order of operations, the contract would allow the funding to close and let the attacker reclaim their total contributions, which could be more than they initially gave.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract AuctionHouse {\n    \n    struct Auction {\n        address payable seller;\n        uint256 startingPrice;\n        uint256 highestBid;\n        address payable highestBidder;\n        bool ended;\n    }\n    \n    mapping(uint256 => Auction) public auctions;\n    uint256 public auctionCount = 0;\n\n    function createAuction(uint256 _startingPrice) external {\n        auctions[auctionCount] = Auction({\n            seller: payable(msg.sender),\n            startingPrice: _startingPrice,\n            highestBid: 0,\n            highestBidder: payable(address(0)),\n            ended: false\n        });\n        auctionCount++;\n    }\n\n    function bid(uint256 auctionId) external payable {\n        Auction storage auction = auctions[auctionId];\n        require(!auction.ended, \"Auction already ended.\");\n        require(msg.value > auction.highestBid, \"There already is a higher bid.\");\n\n        if (auction.highestBidder != address(0)) {\n            // Refund the previous highest bidder\n            auction.highestBidder.transfer(auction.highestBid);  \n        }\n        \n        auction.highestBid = msg.value;\n        auction.highestBidder = payable(msg.sender);\n    }\n\n    function endAuction(uint256 auctionId) external {\n        Auction storage auction = auctions[auctionId];\n        require(msg.sender == auction.seller, \"Only the seller can end the auction.\");\n        require(!auction.ended, \"Auction already ended.\");\n\n        auction.ended = true;\n        auction.seller.transfer(auction.highestBid);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "101",
                "Location": "if (auction.highestBidder != address(0)) {\n         auction.highestBidder.transfer(auction.highestBid);  \n        }\n        \n        auction.highestBid = msg.value;\n        auction.highestBidder = payable(msg.sender);",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, an attacker can re-enter the bid function via the refund transfer to the auction.highestBidder, potentially draining funds from other participants.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract TokenSwap {\n\n    IERC20 public tokenA;\n    IERC20 public tokenB;\n    uint256 public rate;\n\n    constructor(address _tokenA, address _tokenB, uint256 _rate) {\n        tokenA = IERC20(_tokenA);\n        tokenB = IERC20(_tokenB);\n        rate = _rate;\n    }\n\n    function swapAforB(uint256 amountA) external {\n        uint256 amountB = rate * amountA;\n\n        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Transfer of tokenA failed\");\n        require(tokenB.transfer(msg.sender, amountB), \"Transfer of tokenB failed\");  \n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "102",
                "Location": "require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Transfer of tokenA failed\");\n        require(tokenB.transfer(msg.sender, amountB), \"Transfer of tokenB failed\");",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here is subtle. If tokenB is maliciously implemented and exploits reentrancy, it can call swapAforB again before the first call is finished, essentially getting twice the amount of tokenB for the price of one amountA.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract TokenStaking {\n\n    IERC20 public token;\n    mapping(address => uint256) public stakes;\n    mapping(address => uint256) public stakingTime;\n    uint256 public interestRate = 5;  // 5% interest\n\n    constructor(address _token) {\n        token = IERC20(_token);\n    }\n\n    function stakeTokens(uint256 amount) external {\n        require(amount > 0, \"Amount should be positive\");\n        require(token.transferFrom(msg.sender, address(this), amount), \"Token staking failed\");\n        \n        stakes[msg.sender] += amount;\n        stakingTime[msg.sender] = block.timestamp;\n    }\n\n    function withdrawStake() external {\n        require(stakes[msg.sender] > 0, \"No tokens staked\");\n\n        uint256 elapsedTime = block.timestamp - stakingTime[msg.sender];\n        uint256 interest = (stakes[msg.sender] * interestRate / 100) * (elapsedTime / 365 days);\n        \n        uint256 totalAmount = stakes[msg.sender] + interest;\n        \n         \n        require(token.transfer(msg.sender, totalAmount), \"Token withdrawal failed\");\n        \n        stakes[msg.sender] = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "103",
                "Location": "require(token.transfer(msg.sender, totalAmount), \"Token withdrawal failed\");\n        \n        stakes[msg.sender] = 0;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability is in the withdrawStake function where funds are transferred before updating the user's balance (stakes[msg.sender] = 0;), potentially allowing a reentrancy attack.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Marketplace {\n    struct Product {\n        uint256 id;\n        address payable owner;\n        uint256 price;\n        bool isListed;\n    }\n\n    mapping(uint256 => Product) public products;\n    uint256 public productCount = 0;\n\n    function listProduct(uint256 price) external {\n        productCount++;\n        products[productCount] = Product(productCount, payable(msg.sender), price, true);\n    }\n\n    function purchaseProduct(uint256 productId) external payable {\n        Product memory product = products[productId];\n\n        require(product.isListed, \"Product not listed\");\n        require(msg.value == product.price, \"Incorrect amount sent\");\n\n        product.owner.transfer(msg.value);\n        \n        products[productId].isListed = false;\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "104",
                "Location": " product.owner.transfer(msg.value);\n        \n        products[productId].isListed = false;",
                "Type": "Incorrect calculating order",
                "Description": "In the above vulnerable contract, funds are transferred to the product owner before marking the product as not listed. If the product.owner.transfer call fails (due to a malicious fallback function in the product owner's address), the product will remain listed, and the buyer's funds may be locked.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Voting {\n    struct Proposal {\n        uint256 id;\n        string name;\n        uint256 votes;\n        mapping(address => uint256) votesByAddress;\n    }\n\n    mapping(uint256 => Proposal) public proposals;\n    uint256 public proposalCount = 0;\n    mapping(address => uint256) public stakedEther;\n\n    function createProposal(string memory name) external {\n        proposalCount++;\n        proposals[proposalCount] = Proposal(proposalCount, name, 0);\n    }\n\n    function stakeAndVote(uint256 proposalId) external payable {\n        require(proposals[proposalId].id != 0, \"Proposal does not exist\");\n        \n        \n        proposals[proposalId].votes += msg.value;\n        proposals[proposalId].votesByAddress[msg.sender] += msg.value;\n\n        stakedEther[msg.sender] += msg.value;\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "105",
                "Location": " proposals[proposalId].votes += msg.value;\n        proposals[proposalId].votesByAddress[msg.sender] += msg.value;\n\n        stakedEther[msg.sender] += msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "In the above code, the vulnerability lies in the order of operations in the stakeAndVote function. The contract first adds the vote and then increases the staked ether. If the staking transaction fails due to some external reason after updating the vote, the contract's state would be incorrect, as the votes would be counted without actually staking the ether.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Stake {\n    mapping(address => uint256) public userStakes;\n    mapping(address => uint256) public userInterest;\n\n    // Interest rate is 10%\n    uint256 constant INTEREST_RATE = 10;\n\n    function stake() external payable {\n        userStakes[msg.sender] += msg.value;\n\n       \n        userInterest[msg.sender] += userStakes[msg.sender] * INTEREST_RATE / 100;\n    }\n\n    function withdraw() external {\n        uint256 totalAmount = userStakes[msg.sender] + userInterest[msg.sender];\n        require(totalAmount > 0, \"No funds to withdraw\");\n\n        payable(msg.sender).transfer(totalAmount);\n\n        userStakes[msg.sender] = 0;\n        userInterest[msg.sender] = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "106",
                "Location": "userStakes[msg.sender] += msg.value;\n\n        userInterest[msg.sender] += userStakes[msg.sender] * INTEREST_RATE / 100;",
                "Type": "Incorrect calculating order",
                "Description": "In this vulnerable contract, when a user stakes additional ETH, the contract first updates their stake and then calculates the interest on the total stake (old and new combined). This can be exploited by users who stake, then immediately restake, to inflate their interest unfairly.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Marketplace {\n    struct Product {\n        uint256 price;\n        address payable seller;\n        address payable buyer;\n        bool isSold;\n    }\n\n    mapping(uint256 => Product) public products; // productID => Product\n\n    function listProduct(uint256 _productID, uint256 _price) external {\n        require(products[_productID].price == 0, \"Product already listed.\");\n\n        products[_productID] = Product({\n            price: _price,\n            seller: payable(msg.sender),\n            buyer: payable(address(0)),\n            isSold: false\n        });\n    }\n\n    function purchaseProduct(uint256 _productID) external payable {\n        Product storage product = products[_productID];\n        require(msg.value == product.price, \"Incorrect payment.\");\n        require(!product.isSold, \"Product already sold.\");\n\n        product.buyer = payable(msg.sender);\n        product.isSold = true;\n        \n        product.seller.transfer(msg.value);\n    }\n\n    // Additional functions...\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "107",
                "Location": "product.buyer = payable(msg.sender);\n        product.isSold = true;\n       \n        product.seller.transfer(msg.value);",
                "Type": "Incorrect calculating order",
                "Description": "In this contract, there's a vulnerability in the purchaseProduct function. After setting the buyer and marking the product as sold, it immediately transfers the funds to the seller. If a malicious seller is quick enough, they could potentially call another function to interfere and try to double claim before the state is fully settled.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Staking {\n    mapping(address => uint256) public balances; \n    mapping(address => uint256) public rewards; \n    \n    uint256 public totalStaked = 0;\n    uint256 constant REWARD_PER_ETHER = 100; // Suppose every Ether staked earns 100 tokens.\n\n    function stake() external payable {\n        balances[msg.sender] += msg.value;\n        rewards[msg.sender] += msg.value * REWARD_PER_ETHER;\n        totalStaked += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient staked balance.\");\n\n \n        uint256 totalAmount = amount + rewards[msg.sender];\n        \n        balances[msg.sender] -= amount;\n        rewards[msg.sender] = 0;\n        \n        payable(msg.sender).transfer(totalAmount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "108",
                "Location": "uint256 totalAmount = amount + rewards[msg.sender];\n        \n        balances[msg.sender] -= amount;",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, rewards are added to the withdrawal amount before updating the staking balance. This can be exploited in a reentrancy attack by recursively calling the withdraw function, potentially allowing the attacker to drain more funds than they should be able to.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Lottery {\n    address payable public owner;\n    address payable[] public participants;\n    uint256 public ticketPrice = 1 ether;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function buyTicket() external payable {\n        require(msg.value == ticketPrice, \"Incorrect Ether sent.\");\n\n        participants.push(payable(msg.sender));\n    }\n\n    function distributeFunds() external {\n        require(msg.sender == owner, \"Only the owner can distribute funds.\");\n        require(participants.length > 0, \"No participants in the lottery.\");\n\n        uint256 prize = address(this).balance * 90 / 100;\n        uint256 ownerShare = address(this).balance - prize;\n\n        uint256 randomIndex = (block.timestamp + block.difficulty) % participants.length;\n        participants[randomIndex].transfer(prize);\n\n        owner.transfer(ownerShare);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "109",
                "Location": "uint256 randomIndex = (block.timestamp + block.difficulty) % participants.length;\n        participants[randomIndex].transfer(prize);\n",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, the prize is transferred to the winner before updating the contract balance. If the transfer to the winner fails for some reason (e.g., a fallback function in a malicious contract), the owner might not receive their share.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Wallet {\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(balances[msg.sender] >= _amount, \"Insufficient funds.\");\n        \n       \n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed.\");\n\n        balances[msg.sender] -= _amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "110",
                "Location": "(bool success, ) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed.\");",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version above, the external call to the sender occurs before the balance is updated, opening up the possibility for a reentrancy attack. In a reentrancy attack, the called contract could call back into the withdraw function before the first call has completed, effectively withdrawing more funds than they should be allowed.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Bank {\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(balances[msg.sender] >= _amount, \"Insufficient funds!\");\n\n       \n        payable(msg.sender).transfer(_amount);\n\n        balances[msg.sender] -= _amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "111",
                "Location": "payable(msg.sender).transfer(_amount);\n\n        balances[msg.sender] -= _amount;",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, the external call is made before the state change. This leaves an opportunity for the same function to be called again (by a malicious contract) before the state (balance) is updated.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Bank {\n    mapping(address => uint256) public balances;\n    uint256 public totalBalance;\n    bool public withdrawalsPaused;\n\n    uint256 public threshold = 1 ether;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        totalBalance += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(!withdrawalsPaused, \"Withdrawals are currently paused.\");\n        require(balances[msg.sender] >= amount, \"Insufficient funds.\");\n\n        // Check if after this withdrawal the contract balance goes below the threshold\n        if (totalBalance - amount < threshold) {\n            withdrawalsPaused = true;\n        }\n\n        // Transfer the amount\n        payable(msg.sender).transfer(amount);\n\n        // Update the balances\n        balances[msg.sender] -= amount;\n        totalBalance -= amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "112",
                "Location": "if (totalBalance - amount < threshold) {\n            withdrawalsPaused = true;\n        }\n        payable(msg.sender).transfer(amount);\n        balances[msg.sender] -= amount;\n        totalBalance -= amount;",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version above, the contract checks if after the withdrawal the total balance will go below the threshold and then sets the withdrawalsPaused flag. However, if two transactions call the withdraw function simultaneously and both individually wouldn't take the balance below the threshold, but combined they would, the flag might not be set correctly.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract TokenSale {\n    uint256 public tokensSold;\n    uint256 public constant RATE = 100;  // Number of tokens per ether\n    uint256 public constant START_BONUS = 50;  // Starting bonus for early adopters\n\n    mapping(address => uint256) public balances;\n\n    function buyTokens() external payable {\n        uint256 tokensToBuy = msg.value * RATE;\n        \n        uint256 bonus = (START_BONUS - tokensSold) > 0 ? (START_BONUS - tokensSold) : 0;\n        tokensToBuy += bonus;\n        \n        tokensSold += tokensToBuy;\n        balances[msg.sender] += tokensToBuy;\n    }\n\n    // ... rest of the contract\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "113",
                "Location": "uint256 bonus = (START_BONUS - tokensSold) > 0 ? (START_BONUS - tokensSold) : 0;\n        tokensToBuy += bonus;\n        \n        tokensSold += tokensToBuy;\n        balances[msg.sender] += tokensToBuy;",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, the bonus tokens are calculated based on the tokensSold prior to the purchase. An attacker can exploit this by making numerous small purchases, ensuring that they always receive the maximum bonus.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Pledge {\n    address public owner;\n    uint256 public constant FEE_PERCENTAGE = 5;  // 5% fee on every withdrawal\n\n    mapping(address => uint256) public pledges;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function pledge() external payable {\n        pledges[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        uint256 fee = pledges[msg.sender] * FEE_PERCENTAGE / 100;\n        \n        payable(owner).transfer(fee);\n        payable(msg.sender).transfer(pledges[msg.sender]);\n        \n        pledges[msg.sender] = 0;\n    }\n\n    // ... rest of the contract\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "114",
                "Location": "payable(owner).transfer(fee);\n        payable(msg.sender).transfer(pledges[msg.sender]);",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, the fee is transferred to the owner first, and then the whole pledged amount is sent back to the user. This means users receive back their full amount, and the fee is essentially taken from other funds in the contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract ArtAuction {\n    address public owner;\n\n    struct Artwork {\n        uint256 currentBid;\n        address highestBidder;\n        uint256 endTimestamp;\n    }\n\n    mapping(uint256 => Artwork) public artworks;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function listArtwork(uint256 _artworkId, uint256 _duration) external {\n        artworks[_artworkId] = Artwork({\n            currentBid: 0,\n            highestBidder: address(0),\n            endTimestamp: block.timestamp + _duration\n        });\n    }\n\n    function bid(uint256 _artworkId) external payable {\n        require(artworks[_artworkId].endTimestamp > block.timestamp, \"Auction ended\");\n        require(msg.value > artworks[_artworkId].currentBid, \"Bid too low\");\n        \n        payable(artworks[_artworkId].highestBidder).transfer(artworks[_artworkId].currentBid); \n        artworks[_artworkId].currentBid = msg.value; // Updating the current bid\n        artworks[_artworkId].highestBidder = msg.sender; // Updating the highest bidder\n    }\n\n    // ... rest of the contract\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "115",
                "Location": "payable(artworks[_artworkId].highestBidder).transfer(artworks[_artworkId].currentBid); \n        artworks[_artworkId].currentBid = msg.value; \n        artworks[_artworkId].highestBidder = msg.sender; ",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, there's an issue where the previous highest bidder is refunded before updating the current highest bid and bidder. This means that if the msg.sender is already the highest bidder, they are refunded their previous bid and then the new bid is set, allowing them to overwrite their previous bid without actually sending more Ether.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Bank {\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() external {\n        uint256 amountToWithdraw = balances[msg.sender];\n        \n        (bool success, ) = msg.sender.call{value: amountToWithdraw}(\"\");\n        require(success, \"Transfer failed.\");\n\n        balances[msg.sender] = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "116",
                "Location": "(bool success, ) = msg.sender.call{value: amountToWithdraw}(\"\");\n        require(success, \"Transfer failed.\");\n\n        balances[msg.sender] = 0;",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, Ether is transferred to msg.sender before the balance is set to zero. This provides an opportunity for a malicious contract to initiate a reentrancy attack, draining more funds than it should.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Lottery {\n    mapping(address => uint256) public tickets;\n    uint256 public totalTickets = 0;\n    uint256 public prizePool = 0;\n    \n    uint256 constant TICKET_PRICE = 1 ether;\n\n    function buyTickets(uint256 numTickets) external payable {\n        require(msg.value == numTickets * TICKET_PRICE, \"Incorrect payment.\");\n\n        tickets[msg.sender] += numTickets;\n        totalTickets += numTickets;\n        prizePool += msg.value;\n    }\n\n    function claimPrize() external {\n        require(totalTickets > 0, \"No tickets sold.\");\n\n        uint256 prizeAmount = (tickets[msg.sender] / totalTickets) * prizePool; \n        prizePool -= prizeAmount;\n        tickets[msg.sender] = 0;\n\n        payable(msg.sender).transfer(prizeAmount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "117",
                "Location": "uint256 prizeAmount = (tickets[msg.sender] / totalTickets) * prizePool; \n        prizePool -= prizeAmount;\n        tickets[msg.sender] = 0;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability arises in the claimPrize function. When calculating the prize amount for an individual, we first divide the number of tickets owned by the total number of tickets (tickets[msg.sender] / totalTickets). This can result in rounding to zero due to Solidity's integer division, especially when the number of tickets owned by the participant is much smaller than the total tickets.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    mapping(address => uint256) public pendingReturns;\n\n    function bid() external payable {\n        require(msg.value > highestBid, \"There already is a higher bid.\");\n\n       if (highestBidder != address(0)) {\n            pendingReturns[highestBidder] += highestBid; \n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function withdraw() external {\n        uint256 amount = pendingReturns[msg.sender];\n        if (amount > 0) {\n            pendingReturns[msg.sender] = 0;\n\n            payable(msg.sender).transfer(amount);\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "118",
                "Location": "if (highestBidder != address(0)) {\n            pendingReturns[highestBidder] += highestBid; \n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }",
                "Type": "Incorrect calculating order",
                "Description": "In the above contract, the order of updates to pendingReturns[highestBidder] and highestBidder might be exploited. If a malicious actor can cause a re-entrancy attack at the vulnerable line, they might drain funds from the contract because the new highestBidder and highestBid haven't been updated yet.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Marketplace {\n    struct Product {\n        uint256 price;\n        uint256 stock;\n    }\n\n    mapping(uint256 => Product) public products;\n    mapping(address => uint256) public sellerBalances;\n\n    function addProduct(uint256 productId, uint256 price, uint256 stock) external {\n        products[productId] = Product({price: price, stock: stock});\n    }\n\n    function purchaseProduct(uint256 productId) external payable {\n        require(products[productId].stock > 0, \"Out of stock.\");\n        require(msg.value >= products[productId].price, \"Insufficient ether sent.\");\n\n        sellerBalances[msg.sender] += msg.value;\n        products[productId].stock--; \n\n        uint256 refund = msg.value - products[productId].price;\n        payable(msg.sender).transfer(refund); \n    }\n\n    function withdrawBalance() external {\n        uint256 amount = sellerBalances[msg.sender];\n        require(amount > 0, \"No balance available.\");\n        sellerBalances[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "119",
                "Location": " sellerBalances[msg.sender] += msg.value; \n        products[productId].stock--;\n\n        uint256 refund = msg.value - products[productId].price;\n        payable(msg.sender).transfer(refund); ",
                "Type": "Incorrect calculating order",
                "Description": "In the above contract, the sequence of updates during a purchase (sellerBalances and products[productId].stock) can be exploited. If the seller is a malicious actor and attempts to purchase their product, they might instigate a re-entrancy attack during the refund, allowing them to purchase without sufficient balance.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Lottery {\n    address[] public players;\n    address public owner;\n    uint256 public constant TICKET_PRICE = 1 ether;\n    uint256 public constant MAX_PLAYERS = 3;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function buyTicket() external payable {\n        require(msg.value == TICKET_PRICE, \"Send exact ticket price.\");\n        require(players.length < MAX_PLAYERS, \"Maximum players reached.\");\n\n        players.push(msg.sender);\n\n        if (players.length == MAX_PLAYERS) {\n            _selectWinner();\n        }\n    }\n\n    function _selectWinner() private {\n        uint256 index = uint256(block.timestamp) % players.length; \n        address winner = players[index];\n        payable(winner).transfer(address(this).balance);\n        delete players;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "120",
                "Location": "uint256 index = uint256(block.timestamp) % players.length;\n        address winner = players[index];\n        payable(winner).transfer(address(this).balance);\n        delete players;",
                "Type": "Incorrect calculating order",
                "Description": "The contract is vulnerable because it uses the block.timestamp for generating a random number. Miners have influence over this value, which means they can manipulate the outcome if the reward for doing so (the lottery prize) is high enough.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ninterface IToken {\n    function mint(address to, uint256 amount) external;\n}\n\ncontract TokenSale {\n    IToken public token;\n    address public owner;\n    uint256 public constant TOKEN_PRICE = 1 ether;\n    uint256 public tokensSold;\n\n    constructor(address _token) {\n        owner = msg.sender;\n        token = IToken(_token);\n    }\n\n    function buyTokens(uint256 amount) external payable {\n        require(msg.value == TOKEN_PRICE * amount, \"Incorrect Ether sent.\");\n\n        tokensSold += amount;\n\n        token.mint(msg.sender, amount);\n    }\n\n    function endSale() external {\n        require(msg.sender == owner, \"Only the owner can end the sale.\");\n        payable(owner).transfer(address(this).balance);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "121",
                "Location": "require(msg.value == TOKEN_PRICE * amount, \"Incorrect Ether sent.\");\n\n        tokensSold += amount;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability in this contract arises from the lack of updating the amount of ether raised. As a result, an attacker could potentially call buyTokens multiple times in a single transaction to get more tokens than they should.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Donation {\n    address public owner;\n    uint256 public totalDonations;\n    uint256 public donationLimit = 100 ether;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function donate() public payable {\n        require(totalDonations + msg.value <= donationLimit, \"Donation limit reached.\");\n        totalDonations += msg.value;\n    }\n\n    function withdraw() public {\n        require(msg.sender == owner, \"Only owner can withdraw.\");\n        payable(owner).transfer(address(this).balance);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "122",
                "Location": "require(msg.sender == owner, \"Only owner can withdraw.\");\n        payable(owner).transfer(address(this).balance);",
                "Type": "Incorrect calculating order",
                "Description": "Vulnerability: The smart contract is open to a re-entrancy attack. If an attacker creates a malicious contract that calls withdraw within its fallback function, they could recursively call the withdraw function, draining all funds from the contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Crowdfunding {\n    address public creator;\n    uint256 public goal;\n    uint256 public totalContributed;\n\n    mapping(address => uint256) public contributions;\n\n    constructor(uint256 _goal) {\n        creator = msg.sender;\n        goal = _goal;\n    }\n\n    function contribute() public payable {\n        contributions[msg.sender] += msg.value;\n        totalContributed += msg.value;\n    }\n\n    function withdraw() public {\n        require(msg.sender == creator, \"Only the creator can withdraw.\");\n        require(totalContributed >= goal, \"Goal not reached yet.\");\n\n        payable(creator).transfer(address(this).balance);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "123",
                "Location": "contributions[msg.sender] += msg.value;\n        totalContributed += msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "Vulnerability: The contract does not prevent additional contributions after the goal is reached. This allows someone to continually add Ether even after the goal is met, potentially causing unintended consequences or confusion.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Lottery {\n    address public manager;\n    address[] public players;\n    address public lastWinner;\n\n    constructor() {\n        manager = msg.sender;\n    }\n\n    function enter() public payable {\n        require(msg.value > 0.01 ether, \"Minimum ether not sent!\");\n        \n        \n        players.push(msg.sender); \n        payable(address(this)).transfer(msg.value); \n    }\n\n    function pickWinner() public restricted {\n        uint index = random() % players.length;\n        lastWinner = players[index];\n        \n        players = new address[](0); \n        payable(lastWinner).transfer(address(this).balance); \n    }\n\n    modifier restricted() {\n        require(msg.sender == manager, \"Only manager can call this.\");\n        _;\n    }\n\n    function random() private view returns(uint) {\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, players)));\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "124",
                "Location": "players.push(msg.sender); \n        payable(address(this)).transfer(msg.value); ",
                "Type": "Incorrect calculating order",
                "Description": "The issue here is, if there's any problem with the transfer() function in pickWinner(), players' addresses would have already been cleared, and they won't have a chance to claim their winnings in the future. The same principle applies to the enter() function.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Marketplace {\n    struct Item {\n        string name;\n        uint256 price;\n        address seller;\n    }\n    \n    mapping(uint256 => Item) public items;\n    uint256 public itemCount = 0;\n\n    function listNewItem(string memory _name, uint256 _price) public {\n \n        itemCount++; \n        items[itemCount] = Item(_name, _price, msg.sender); \n    }\n\n    function purchaseItem(uint256 _itemId) public payable {\n        Item memory item = items[_itemId];\n        require(msg.sender != item.seller, \"Seller can't purchase their own item.\");\n        require(msg.value == item.price, \"Incorrect amount transferred.\");\n\n        delete items[_itemId];\n        payable(item.seller).transfer(item.price);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "125",
                "Location": "itemCount++;\n        items[itemCount] = Item(_name, _price, msg.sender);",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerabilities arise from the fact that state variables are being modified before verifying the conditions or finalizing transactions.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this function.\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function bid() public payable {\n        require(msg.value > highestBid, \"There already is a higher bid.\");\n\n       \n        address previousHighestBidder = highestBidder;  \n        uint256 refundAmount = highestBid;  \n        \n        highestBidder = msg.sender;  \n        highestBid = msg.value;     \n\n        payable(previousHighestBidder).transfer(refundAmount);  \n    }\n\n    function endAuction() public onlyOwner {\n        payable(owner).transfer(highestBid);  \n        highestBid = 0; \n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "126",
                "Location": "address previousHighestBidder = highestBidder;  \n        uint256 refundAmount = highestBid; \n        \n        highestBidder = msg.sender; \n        highestBid = msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "In this contract, the vulnerabilities arise when updating state variables before external calls. This is a vulnerability because external calls can fail or be re-entrant.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Token {\n    mapping(address => uint256) public balances;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the owner can call this function.\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function transfer(address to, uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance.\");\n        \n        balances[to] += amount;\n        balances[msg.sender] -= amount; \n    }\n\n    function mint(uint256 amount) public onlyOwner {\n        owner = msg.sender;                   \n        balances[owner] += amount;            \n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "127",
                "Location": "balances[to] += amount;\n        balances[msg.sender] -= amount; ",
                "Type": "Incorrect calculating order",
                "Description": "In this contract, the vulnerabilities arise when updating state variables in the wrong order. If there were some functions that could externally call into these (like through another vulnerable contract), reentrancy or other attacks could be possible, especially in more complex scenarios.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract DEX {\n    IERC20 public token;\n    uint256 public tokenPrice;  // Price of the token in wei\n\n    constructor(address _token, uint256 _initialPrice) {\n        token = IERC20(_token);\n        tokenPrice = _initialPrice;\n    }\n\n    function buyTokens(uint256 tokenAmount) public payable {\n        uint256 cost = tokenAmount * tokenPrice;\n        require(msg.value >= cost, \"Insufficient ETH sent.\");\n        \n        tokenPrice = adjustPrice();  \n        token.transfer(msg.sender, tokenAmount);\n    }\n\n    function adjustPrice() internal returns (uint256) {\n        // Adjust the token price based on the token's balance in this contract.\n        uint256 tokenBalance = token.balanceOf(address(this));\n        if(tokenBalance < 1000 * 10**18) {\n            return tokenPrice * 2; // Double the price if fewer tokens\n        } else {\n            return tokenPrice;\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "128",
                "Location": "tokenPrice = adjustPrice(); \n        token.transfer(msg.sender, tokenAmount);",
                "Type": "Incorrect calculating order",
                "Description": "The buyTokens function adjusts the token price before transferring the tokens. This is problematic because users could potentially get a different price than what they expected when they initiated the transaction.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Lottery {\n    address[] public participants;\n    address public owner;\n    uint256 public ticketPrice = 1 ether;\n    uint256 public maxTickets = 10;\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    function buyTicket() public payable {\n        require(msg.value == ticketPrice, \"Incorrect ticket price.\");\n        \n        if(participants.length >= maxTickets) {\n            address winner = participants[random() % participants.length];\n            payable(winner).transfer(address(this).balance);\n            \n            // Reset participants after transferring the balance.\n            delete participants;\n        }\n        \n        participants.push(msg.sender);\n    }\n    \n    function random() private view returns (uint) {\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, participants)));\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "129",
                "Location": "if(participants.length >= maxTickets) {\n            address winner = participants[random() % participants.length];\n            payable(winner).transfer(address(this).balance);\n           delete participants;\n        }\n        \n        participants.push(msg.sender);",
                "Type": "Incorrect calculating order",
                "Description": "In the buyTicket function, there's a problematic order of operations. If the array of participants reaches the maxTickets threshold, a winner is chosen and the prize is transferred. However, only after this does the function register the participant who triggered this payout. This means the participant could be missed in the lottery drawing even though they bought a ticket.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Voting {\n    struct Voter {\n        uint256 tokensBought;\n        uint256 votesCast;\n    }\n    \n    mapping(address => Voter) public voters;\n    mapping(string => uint256) public candidates;\n    \n    uint256 public tokenPrice = 1 ether;\n    \n    function buyTokens(uint256 amount) public payable {\n        require(msg.value == amount * tokenPrice, \"Incorrect Ether sent.\");\n\n        voters[msg.sender].tokensBought += amount;\n    }\n\n    function voteForCandidate(string memory candidateName, uint256 votes) public {\n        Voter storage voter = voters[msg.sender];\n\n        require(voter.votesCast + votes <= voter.tokensBought, \"Not enough tokens to cast votes.\");\n\n        candidates[candidateName] += votes;\n\n        voter.votesCast += votes;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "130",
                "Location": "candidates[candidateName] += votes;\n        voter.votesCast += votes;",
                "Type": "Incorrect calculating order",
                "Description": "In the voteForCandidate function, votes are added to the candidate first, and then the votesCast of the voter is updated. A malicious user might exploit this and interfere with the transaction after casting votes but before the votesCast is updated, allowing them to vote multiple times with the same tokens.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Bank {\n    struct Account {\n        uint256 depositAmount;\n        uint256 depositTime;\n    }\n\n    mapping(address => Account) public accounts;\n    uint256 public interestRate = 10; // 10%\n\n    function deposit() public payable {\n        Account storage userAccount = accounts[msg.sender];\n        \n         \n        userAccount.depositAmount += msg.value;\n        \n        uint256 timeSinceLastDeposit = block.timestamp - userAccount.depositTime;\n        if (timeSinceLastDeposit > 1 weeks) {\n            uint256 interest = (userAccount.depositAmount * interestRate) / 100;\n            userAccount.depositAmount += interest;\n        }\n        \n        userAccount.depositTime = block.timestamp;\n    }\n\n    function withdraw() public {\n        Account storage userAccount = accounts[msg.sender];\n        require(userAccount.depositAmount > 0, \"No funds to withdraw.\");\n        \n        uint256 amount = userAccount.depositAmount;\n        userAccount.depositAmount = 0;\n        \n        payable(msg.sender).transfer(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "131",
                "Location": "userAccount.depositAmount += msg.value;\n        \n        uint256 timeSinceLastDeposit = block.timestamp - userAccount.depositTime;\n        if (timeSinceLastDeposit > 1 weeks) {\n            uint256 interest = (userAccount.depositAmount * interestRate) / 100;\n            userAccount.depositAmount += interest;\n        }\n        \n        userAccount.depositTime = block.timestamp;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability lies in the deposit function. If a user makes a deposit just before the 1-week period, they can receive the interest on the full amount (old + new deposit) rather than just the old deposit.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenExchange {\n    mapping(address => uint256) public balances;\n    uint256 public exchangeRate = 2; // 1 ETH = 2 Tokens\n\n    function deposit() public payable {\n        uint256 bonus = 0;\n        if (msg.value > 1 ether) {\n            bonus = msg.value / 10;  // 10% bonus for deposits over 1 ether\n        }\n\n       \n        uint256 tokens = (msg.value + bonus) * exchangeRate;\n        balances[msg.sender] += tokens;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount / exchangeRate);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "132",
                "Location": "if (msg.value > 1 ether) {\n            bonus = msg.value / 10;  // 10% bonus for deposits over 1 ether\n        }\n\n        uint256 tokens = (msg.value + bonus) * exchangeRate;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here is that the bonus for large deposits is added to the Ether amount before applying the exchange rate. This means that for a deposit of 2 Ether, the user would get a bonus of 0.2 Ether and would then receive 2.2 * 2 = 4.4 tokens, instead of the intended 4.2 tokens.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenSwap {\n    mapping(address => uint256) public tokenA;\n    mapping(address => uint256) public tokenB;\n\n    uint256 public rateTokenAToB = 100;  // 1 Token A = 100 Token B\n\n    function depositTokenA(uint256 amount) public {\n        tokenA[msg.sender] += amount;\n    }\n\n    function depositTokenB(uint256 amount) public {\n        tokenB[msg.sender] += amount;\n    }\n\n    function swapAToB(uint256 amountA) public {\n        require(tokenA[msg.sender] >= amountA, \"Insufficient Token A balance\");\n\n        uint256 amountB = rateTokenAToB * amountA;\n\n        tokenA[msg.sender] -= amountA;\n        tokenB[msg.sender] += amountB;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "133",
                "Location": "require(tokenA[msg.sender] >= amountA, \"Insufficient Token A balance\");\n        uint256 amountB = rateTokenAToB * amountA;",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable contract, if amountA is too large, multiplying by rateTokenAToB could lead to an overflow. In such a case, a user could get much more of Token B than intended.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract VotingSystem {\n\n    struct Candidate {\n        string name;\n        uint256 votes;\n    }\n\n    mapping(address => uint256) public tokenBalances;\n    mapping(address => bool) public hasVoted;\n    mapping(address => uint256) public lockedTokensOnVote;\n\n    Candidate[] public candidates;\n\n    interface IToken {\n        function transfer(address to, uint256 amount) external;\n        function balanceOf(address account) external view returns (uint256);\n    }\n\n    IToken public token;\n\n    constructor(address _tokenAddress) {\n        token = IToken(_tokenAddress);\n    }\n\n    function addCandidate(string memory name) public {\n        candidates.push(Candidate({name: name, votes: 0}));\n    }\n\n    function vote(uint256 candidateIndex) public {\n        require(!hasVoted[msg.sender], \"Already voted!\");\n        uint256 balance = token.balanceOf(msg.sender);\n        candidates[candidateIndex].votes += balance;\n        \n        lockedTokensOnVote[msg.sender] = balance;\n        hasVoted[msg.sender] = true;\n    }\n\n    function withdraw() public {\n        require(hasVoted[msg.sender], \"You haven't voted yet!\");\n        token.transfer(msg.sender, lockedTokensOnVote[msg.sender]);\n        hasVoted[msg.sender] = false;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "134",
                "Location": "candidates[candidateIndex].votes += balance;\n        \n        lockedTokensOnVote[msg.sender] = balance;\n        hasVoted[msg.sender] = true;",
                "Type": "Incorrect calculating order",
                "Description": "The contract allows users to vote based on their token balance. However, after voting, a user can transfer their tokens to another address and then call withdraw(), which would send the token balance from the contract to their address, effectively duplicating tokens.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    uint256 public auctionEndTime;\n\n    mapping(address => uint256) public pendingReturns;\n\n    event HighestBidIncreased(address bidder, uint256 amount);\n\n    constructor(uint256 _biddingTime) {\n        auctionEndTime = block.timestamp + _biddingTime;\n    }\n\n    function bid() public payable {\n        require(block.timestamp <= auctionEndTime, \"Auction has ended.\");\n\n        require(msg.value > highestBid, \"There is a higher bid already.\");\n\n        if (highestBidder != address(0)) {\n            pendingReturns[highestBidder] += highestBid; \n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n        \n        emit HighestBidIncreased(msg.sender, msg.value);\n    }\n\n    function withdraw() public {\n        uint256 amount = pendingReturns[msg.sender];\n        require(amount > 0, \"No amount to withdraw.\");\n        \n        pendingReturns[msg.sender] = 0; \n\n        payable(msg.sender).transfer(amount); \n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "135",
                "Location": "pendingReturns[msg.sender] = 0;  \n        payable(msg.sender).transfer(amount); ",
                "Type": "Incorrect calculating order",
                "Description": "The contract is vulnerable to a reentrancy attack, particularly in the withdraw function. If the call to payable(msg.sender).transfer(amount); is invoked on a malicious contract, that contract can call withdraw again before the first call is finished, effectively draining the contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Token {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n\n    event Minted(address indexed to, uint256 amount);\n    event Transferred(address indexed from, address indexed to, uint256 amount);\n\n    function mint(uint256 amount) public {\n        balances[msg.sender] += amount;\n        totalSupply += amount;\n        emit Minted(msg.sender, amount);\n    }\n\n    function transfer(address to, uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance.\");\n\n        \n        balances[to] += amount;\n        balances[msg.sender] -= amount;\n\n        emit Transferred(msg.sender, to, amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "136",
                "Location": "require(balances[msg.sender] >= amount, \"Insufficient balance.\");\n\n        balances[to] += amount;\n        balances[msg.sender] -= amount;",
                "Type": "Incorrect calculating order",
                "Description": "The transfer function first adds to the receiver's balance and then subtracts from the sender's balance. If the to address is the same as the sender, this can be abused to increase the balance of the sender (due to underflows in the subtraction).",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    address public owner;\n\n    event NewBid(address bidder, uint256 bid);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function bid() public payable {\n        require(msg.value > highestBid, \"Bid should be higher than current highest bid\");\n\n        if(highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid);  \n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n\n        emit NewBid(msg.sender, msg.value);\n    }\n\n    function endAuction() public {\n        require(msg.sender == owner, \"Only owner can end the auction\");\n        payable(owner).transfer(highestBid);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "137",
                "Location": " if(highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid);  \n        }",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here is in the bid function. If the transfer to the highestBidder (refunding the old highest bid) fails, the entire transaction reverts, and the new higher bid won't be accepted. This can be exploited by a malicious actor by becoming the highest bidder and then making their fallback function revert, ensuring no one else can outbid them.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Token {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n    address public owner;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(uint256 _initialSupply) {\n        balances[msg.sender] = _initialSupply;\n        totalSupply = _initialSupply;\n        owner = msg.sender;\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        require(balances[msg.sender] >= _value, \"Insufficient balance\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n\n        emit Transfer(msg.sender, _to, _value);\n\n \n        if (address(_to).isContract()) {\n            _to.call(abi.encodeWithSignature(\"tokenFallback(address,uint256)\", msg.sender, _value));\n        }\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "138",
                "Location": "if (address(_to).isContract()) {\n            _to.call(abi.encodeWithSignature(\"tokenFallback(address,uint256)\", msg.sender, _value));\n        }",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability in this contract is the classic reentrancy attack. When tokens are transferred to a contract, the contract's tokenFallback function is called, which could then call the transfer function again before the state (balances in this case) is updated.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenSale {\n    address payable public owner;\n    uint256 public tokensPerEther = 100;\n    uint256 public totalTokens = 10000;\n\n    mapping(address => uint256) public balanceOf;\n\n    constructor() {\n        owner = payable(msg.sender);\n        balanceOf[owner] = totalTokens;\n    }\n\n    function buyTokens() public payable {\n        uint256 tokensToBuy = msg.value * tokensPerEther;\n        require(balanceOf[owner] >= tokensToBuy, \"Not enough tokens available.\");\n\n        balanceOf[msg.sender] += tokensToBuy; \n        balanceOf[owner] -= tokensToBuy;\n\n        owner.transfer(msg.value);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "139",
                "Location": "balanceOf[msg.sender] += tokensToBuy; \n        balanceOf[owner] -= tokensToBuy;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability in this contract is an Incorrect Calculation Order issue. If the msg.sender is a malicious contract that has a fallback function that calls buyTokens again, it can cause a reentrancy attack. When the contract's state (i.e., the balanceOf mapping) is modified after the transfer, the attacker can leverage the reentrancy to get more tokens than they should.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LendingPlatform {\n    address public owner;\n    uint256 public totalLiquidity;\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public loanedAmounts;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n        totalLiquidity += msg.value; \n    }\n\n    function loanOut(address to, uint256 amount) public {\n        require(msg.sender == owner, \"Only owner can loan out.\");\n        require(totalLiquidity >= amount, \"Not enough liquidity.\");\n\n        loanedAmounts[to] += amount;  \n        payable(to).transfer(amount); \n\n        totalLiquidity -= amount;\n    }\n\n    function repayLoan() public payable {\n        require(loanedAmounts[msg.sender] >= msg.value, \"Repaying more than loaned amount.\");\n        loanedAmounts[msg.sender] -= msg.value; \n        totalLiquidity += msg.value; \n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "140",
                "Location": "loanedAmounts[to] += amount; \n        payable(to).transfer(amount); ",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability in this contract is an Incorrect Calculation Order issue. The state (loanedAmounts) is updated after transferring ether in the loanOut function. If the recipient to is a malicious contract with a fallback function that triggers loanOut again, this would lead to a reentrancy attack.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract TokenSwap {\n    address public owner;\n    IERC20 public tokenA;\n    IERC20 public tokenB;\n    uint256 public rate; // Number of tokenB units a user gets for 1 unit of tokenA\n\n    constructor(address _tokenA, address _tokenB, uint256 _rate) {\n        owner = msg.sender;\n        tokenA = IERC20(_tokenA);\n        tokenB = IERC20(_tokenB);\n        rate = _rate;\n    }\n\n    function swap(uint256 amount) public {\n        uint256 amountB = amount * rate;\n        \n        require(tokenA.transferFrom(msg.sender, address(this), amount), \"Transfer of tokenA failed.\");\n        \n        require(tokenB.balanceOf(address(this)) >= amountB, \"Not enough tokenB in the contract.\");\n        require(tokenB.transfer(msg.sender, amountB), \"Transfer of tokenB failed.\"); \n    }\n\n    function updateRate(uint256 _rate) public {\n        require(msg.sender == owner, \"Only owner can update the rate.\");\n        rate = _rate;  \n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "141",
                "Location": "require(tokenA.transferFrom(msg.sender, address(this), amount), \"Transfer of tokenA failed.\");\n        \n        require(tokenB.balanceOf(address(this)) >= amountB, \"Not enough tokenB in the contract.\");\n        require(tokenB.transfer(msg.sender, amountB), \"Transfer of tokenB failed.\");",
                "Type": "Incorrect calculating order",
                "Description": "The contract takes tokenA from the user first before checking if it has enough tokenB to give back, which can be problematic if the contract doesn't have enough tokenB.\nArbitrary Rate Change: The owner can change the swap rate arbitrarily after users have approved the token transfer, which can be manipulated to give an unfair rate.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract LoanContract {\n    address public owner;\n    IERC20 public loanToken;\n    uint256 public rate; // Number of loanToken units a user gets for 1 ether\n\n    constructor(address _loanToken, uint256 _rate) {\n        owner = msg.sender;\n        loanToken = IERC20(_loanToken);\n        rate = _rate;\n    }\n\n    function depositAndBorrow() public payable {\n        uint256 loanAmount = msg.value * rate;\n        \n        require(loanToken.balanceOf(address(this)) >= loanAmount, \"Not enough tokens in the contract.\");\n        loanToken.transfer(msg.sender, loanAmount);  \n        \n        (bool success, ) = owner.call{value: msg.value}(\"\");\n        require(success, \"Transfer to owner failed.\");  \n    }\n\n    function changeRate(uint256 _rate) public {\n        require(msg.sender == owner, \"Only the owner can change the rate.\");\n        rate = _rate; \n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "142",
                "Location": "constructor(address _loanToken, uint256 _rate) {\n        owner = msg.sender;\n        loanToken = IERC20(_loanToken);\n        rate = _rate;\n    }",
                "Type": "Incorrect calculating order",
                "Description": "The contract sends the loanToken before updating its ether balance or transferring the ether to the owner. This can create problems if subsequent calls fail.\nArbitrary Rate Change: The owner can change the loan rate arbitrarily after users have started using the contract, leading to possible manipulations.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Auction {\n    address public owner;\n    address public highestBidder;\n    uint256 public highestBid;\n\n    constructor() {\n        owner = msg.sender;\n        highestBid = 0;\n    }\n\n    function bid() public payable {\n        require(msg.value > highestBid, \"Your bid should be higher than the current highest bid.\");\n \n        if(highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid); \n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function endAuction() public {\n        require(msg.sender == owner, \"Only the owner can end the auction.\");\n        payable(owner).transfer(address(this).balance);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "143",
                "Location": "if(highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid); \n        }",
                "Type": "Incorrect calculating order",
                "Description": "The contract refunds the previous highest bidder before updating the current highest bidder and bid amount. If the transfer call fails (or if the previous highest bidder is a malicious contract that reverts), the new bid won't be recorded even though the ether is already sent.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Bank {\n    address public owner;\n    mapping(address => uint256) public balances;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function deposit() public payable {\n       \n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance.\");\n \n        payable(msg.sender).transfer(amount);\n        balances[msg.sender] -= amount;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "144",
                "Location": "payable(msg.sender).transfer(amount);\n        balances[msg.sender] -= amount;",
                "Type": "Incorrect calculating order",
                "Description": "In the withdraw function, the contract sends funds before updating the user's balance. If msg.sender is a malicious contract, it can call withdraw again during its fallback function before the balances[msg.sender] is decremented, leading to a reentrancy attack and allowing the attacker to withdraw more than their balance.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenSale {\n    address public owner;\n    uint256 public pricePerToken;\n    uint256 public totalTokens;\n\n    mapping(address => uint256) public tokenBalance;\n\n    constructor(uint256 _pricePerToken, uint256 _totalTokens) {\n        owner = msg.sender;\n        pricePerToken = _pricePerToken;\n        totalTokens = _totalTokens;\n    }\n\n    function buyTokens(uint256 numberOfTokens) public payable {\n        require(msg.value == numberOfTokens * pricePerToken, \"Incorrect Ether sent.\");\n        \n        tokenBalance[msg.sender] += numberOfTokens;\n        \n        totalTokens -= numberOfTokens;\n    }\n\n    function withdrawFunds() public {\n        require(msg.sender == owner, \"Only the owner can withdraw funds.\");\n        payable(owner).transfer(address(this).balance);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "145",
                "Location": "require(msg.value == numberOfTokens * pricePerToken, \"Incorrect Ether sent.\");\n       \n        tokenBalance[msg.sender] += numberOfTokens;\n        \n        totalTokens -= numberOfTokens;",
                "Type": "Incorrect calculating order",
                "Description": "The contract updates the user's tokenBalance before checking if there are enough totalTokens left. This can lead to situations where users can buy more tokens than what's available.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function bid() public payable {\n        require(msg.value > highestBid, \"Your bid is too low.\");\n \n        if (highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid);\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function endAuction() public {\n        require(msg.sender == owner, \"Only the owner can end the auction.\");\n        payable(owner).transfer(address(this).balance);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "146",
                "Location": "        if (highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid);\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "The contract refunds the previous highest bidder after it sets the new highest bidder and highest bid. If the transfer call fails, the contract's state is left in an inconsistent state where the new highest bidder is set, but the previous highest bidder hasn't been refunded.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    address payable public owner;\n\n    constructor() {\n        owner = payable(msg.sender);\n    }\n\n    function bid() public payable {\n \n        if (highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid); \n        }\n        \n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function endAuction() public {\n        require(msg.sender == owner, \"Only owner can end the auction\");\n        owner.transfer(address(this).balance);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "147",
                "Location": "if (highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid);\n        }",
                "Type": "Incorrect calculating order",
                "Description": "The contract should verify if the new bid is indeed higher than the current highest bid before returning the previous bid.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    uint256 public bidIncrement = 0.01 ether;\n\n    function bid() public payable {\n        require(msg.value >= highestBid + bidIncrement, \"Bid is too low\");\n\n        uint256 refundAmount = highestBid;\n        (bool success, ) = highestBidder.call{value: refundAmount}(\"\");\n        require(success, \"Refund failed.\");\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "148",
                "Location": "uint256 refundAmount = highestBid;\n        (bool success, ) = highestBidder.call{value: refundAmount}(\"\");\n        require(success, \"Refund failed.\");\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "By refunding the previous highest bidder before updating the highest bid and bidder, the contract may refund the wrong amount if the highestBidder is also the current msg.sender. In such a scenario, the msg.sender might be refunded their own bid, potentially allowing them to drain the contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public points;\n    uint256 public rate = 100;  // 100 wei for 1 point\n\n    event Redeemed(address user, uint256 amount);\n\n    function topUp() public payable {\n        uint256 newPoints = msg.value / rate;\n        points[msg.sender] += newPoints;\n    }\n\n    function redeem(uint256 amount) public {\n        require(points[msg.sender] >= amount, \"Not enough points\");\n        \n        uint256 cost = amount * rate;\n        points[msg.sender] -= amount;\n        \n        (bool success, ) = msg.sender.call{value: cost}(\"\");\n        require(success, \"Transfer failed.\");\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "149",
                "Location": "require(points[msg.sender] >= amount, \"Not enough points\");\n        \n        uint256 cost = amount * rate;\n        points[msg.sender] -= amount;\n        \n        (bool success, ) = msg.sender.call{value: cost}(\"\");\n        require(success, \"Transfer failed.\");",
                "Type": "Incorrect calculating order",
                "Description": "During the redeeming of points, the user's points balance is deducted first before checking if the contract has enough Ether to refund the equivalent amount in wei. This could result in a situation where a user redeems their points but the contract fails to send them the corresponding wei, making them lose their points without getting any value in return.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenSwap {\n    mapping(address => uint256) public etherBalance;\n    uint256 public tokenPrice = 1 ether; // 1 token = 1 ether\n\n    event TokenBought(address indexed buyer, uint256 amount);\n    event TokenSold(address indexed seller, uint256 amount);\n\n    function buyTokens(uint256 amount) public payable {\n        uint256 cost = amount * tokenPrice;\n        require(msg.value >= cost, \"Not enough Ether provided\");\n\n        etherBalance[msg.sender] += msg.value - cost; \n        emit TokenBought(msg.sender, amount);\n    }\n\n    function sellTokens(uint256 amount) public {\n        uint256 refund = amount * tokenPrice;\n        \n        etherBalance[msg.sender] -= refund;\n        require(etherBalance[msg.sender] >= 0, \"Insufficient balance\"); \n        \n        payable(msg.sender).transfer(refund);\n        emit TokenSold(msg.sender, amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "150",
                "Location": "etherBalance[msg.sender] -= refund;\n        require(etherBalance[msg.sender] >= 0, \"Insufficient balance\"); ",
                "Type": "Incorrect calculating order",
                "Description": "During the selling of tokens, the user's ether balance is deducted before checking for underflows. This could result in a situation where an attacker exploits the underflow to get more Ether than they should.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public loyaltyPoints;\n    mapping(address => uint256) public etherBalance;\n    uint256 public pointsPerEther = 100;  // 1 Ether = 100 loyalty points\n\n    event PointsEarned(address indexed user, uint256 points);\n    event PointsSpent(address indexed user, uint256 points);\n\n    function depositEtherAndEarnPoints() public payable {\n        uint256 points = msg.value * pointsPerEther;\n        \n        etherBalance[msg.sender] += msg.value;\n        loyaltyPoints[msg.sender] += points;\n\n        emit PointsEarned(msg.sender, points);\n    }\n\n    function spendPoints(uint256 points) public {\n        require(loyaltyPoints[msg.sender] >= points, \"Not enough loyalty points\");\n\n        uint256 etherRefund = points / pointsPerEther;\n        loyaltyPoints[msg.sender] -= points;\n        \n        require(etherBalance[msg.sender] >= etherRefund, \"Insufficient Ether balance\"); \n        etherBalance[msg.sender] -= etherRefund;\n        payable(msg.sender).transfer(etherRefund);\n\n        emit PointsSpent(msg.sender, points);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "151",
                "Location": "uint256 etherRefund = points / pointsPerEther;\n        loyaltyPoints[msg.sender] -= points;\n        \n        require(etherBalance[msg.sender] >= etherRefund, \"Insufficient Ether balance\");  \n        etherBalance[msg.sender] -= etherRefund;",
                "Type": "Incorrect calculating order",
                "Description": "When spending points, we first adjust the loyalty points and then check if there's enough Ether to refund. This can lead to potential attack vectors.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TimeLock {\n    struct Deposit {\n        uint256 amount;\n        uint256 endBlock;\n    }\n    \n    mapping(address => Deposit) public deposits;\n    uint256 public interestRate = 10;  // 10% per 1000 blocks\n\n    function depositForBlocks(uint256 blocks) public payable {\n        require(blocks >= 100, \"Minimum lock-up is 100 blocks\");\n        uint256 interest = (msg.value * interestRate * blocks) / 1000;\n        \n        deposits[msg.sender] = Deposit({\n            amount: msg.value + interest,\n            endBlock: block.number + blocks\n        });\n    }\n\n    function withdraw() public {\n        require(block.number >= deposits[msg.sender].endBlock, \"Funds are still locked\");\n        \n        uint256 amount = deposits[msg.sender].amount;\n        deposits[msg.sender].amount = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "152",
                "Location": "require(blocks >= 100, \"Minimum lock-up is 100 blocks\");\n        uint256 interest = (msg.value * interestRate * blocks) / 1000;\n        \n        deposits[msg.sender] = Deposit({\n            amount: msg.value + interest,\n            endBlock: block.number + blocks\n        });",
                "Type": "Incorrect calculating order",
                "Description": "The depositForBlocks function first calculates the interest and then sets the endBlock for the deposit. If a user was able to manipulate the block number after the interest calculation but before the endBlock is set, they could potentially exploit the contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract EtherBet {\n    enum BetDirection { UP, DOWN }\n\n    struct Bet {\n        uint256 amount;\n        BetDirection direction;\n    }\n\n    mapping(address => Bet) public bets;\n    uint256 public totalUpBets;\n    uint256 public totalDownBets;\n    bool public gameEnded;\n\n    function placeBet(BetDirection _direction) public payable {\n        require(!gameEnded, \"Game has already ended\");\n        require(bets[msg.sender].amount == 0, \"Already placed a bet\");\n\n        if(_direction == BetDirection.UP) {\n            totalUpBets += msg.value;\n        } else {\n            totalDownBets += msg.value;\n        }\n\n        bets[msg.sender] = Bet({\n            amount: msg.value,\n            direction: _direction\n        });\n    }\n\n    function endGame(bool priceWentUp) public {\n        // Only the contract owner can end the game for simplicity.\n        require(msg.sender == address(this), \"Only contract owner can end the game\");\n        require(!gameEnded, \"Game has already ended\");\n        \n        uint256 totalReward = address(this).balance;\n        if(priceWentUp) {\n            totalReward = totalReward / totalUpBets;\n        } else {\n            totalReward = totalReward / totalDownBets;\n        }\n\n        gameEnded = true;\n    }\n\n    function claimReward() public {\n        require(gameEnded, \"Game hasn't ended yet\");\n        \n        uint256 reward = bets[msg.sender].amount * totalReward;\n        bets[msg.sender].amount = 0;\n        payable(msg.sender).transfer(reward);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "153",
                "Location": "uint256 totalReward = address(this).balance;\n        if(priceWentUp) {\n            totalReward = totalReward / totalUpBets;\n        } else {\n            totalReward = totalReward / totalDownBets;\n        }\n\n        gameEnded = true;",
                "Type": "Incorrect calculating order",
                "Description": "The endGame function sets the gameEnded variable after calculating the totalReward. If the state of the contract is changed between the calculation of the totalReward and setting gameEnded, it could allow for incorrect reward claims.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenSale {\n    address public owner;\n    ERC20 public token;\n    uint256 public saleEnd;\n    uint256 public tokenPrice;\n    uint256 public tokensSold;\n\n    constructor(address _token, uint256 _tokenPrice, uint256 _duration) {\n        owner = msg.sender;\n        token = ERC20(_token);\n        tokenPrice = _tokenPrice;\n        saleEnd = block.timestamp + _duration;\n    }\n\n    function buyTokens(uint256 amount) public payable {\n        require(msg.value == amount * tokenPrice, \"Incorrect Ether sent.\");\n        tokensSold += amount;\n        \n        require(block.timestamp < saleEnd, \"Token sale ended.\");\n        \n        token.transfer(msg.sender, amount);\n    }\n\n    function retrieveUnsoldTokens() public {\n        require(msg.sender == owner, \"Only owner can retrieve unsold tokens.\");\n        require(block.timestamp > saleEnd, \"Sale is still ongoing.\");\n\n        uint256 unsold = token.balanceOf(address(this)) - tokensSold;\n        token.transfer(owner, unsold);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "154",
                "Location": "require(msg.value == amount * tokenPrice, \"Incorrect Ether sent.\");\n        tokensSold += amount;\n        \n        require(block.timestamp < saleEnd, \"Token sale ended.\");",
                "Type": "Incorrect calculating order",
                "Description": "The function buyTokens does not first check if the sale period has ended before processing the token purchase. This allows users to buy tokens even after the sale period, as long as they send the correct amount of Ether.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Auction {\n    address public owner;\n    address public highestBidder;\n    uint256 public highestBid;\n    bool public ended;\n\n    constructor() {\n        owner = msg.sender;\n        highestBidder = address(0);\n        highestBid = 0;\n        ended = false;\n    }\n\n    function bid() public payable {\n        require(!ended, \"Auction has already ended.\");\n        \n        require(msg.value > highestBid, \"There's already a higher bid.\");\n        \n        // Refund the previous highest bidder\n        if(highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid);\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function endAuction() public {\n        require(msg.sender == owner, \"Only the owner can end the auction.\");\n        ended = true;\n    }\n\n}",
        "VulnerabilityDesc": [
            {
                "Name": "155",
                "Location": "require(msg.sender == owner, \"Only the owner can end the auction.\");\n        ended = true;",
                "Type": "Incorrect calculating order",
                "Description": "The owner can call endAuction and then still call bid, allowing them to place a bid even after the auction has supposedly ended. This would allow the owner to unfairly win the auction.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public points;\n\n    uint256 public rewardCost = 100;\n\n    function earnPoints(uint256 _points) public {\n        points[msg.sender] += _points;\n    }\n\n    function redeemReward() public {\n        require(points[msg.sender] >= rewardCost, \"Not enough points to redeem.\");\n        \n        points[msg.sender] -= rewardCost;\n\n        emit RewardRedeemed(msg.sender, rewardCost);\n        \n        rewardCost += 10; \n    }\n\n    event RewardRedeemed(address indexed customer, uint256 rewardCost);\n}",
        "VulnerabilityDesc": [
            {
                "Name": "156",
                "Location": "require(points[msg.sender] >= rewardCost, \"Not enough points to redeem.\");\n        \n        points[msg.sender] -= rewardCost;\n\n        emit RewardRedeemed(msg.sender, rewardCost);\n        \n\n        rewardCost += 10;",
                "Type": "Incorrect calculating order",
                "Description": "The mistake here is that the rewardCost is updated after the redemption logic, allowing a user to call redeemReward multiple times in quick succession (before the first transaction is mined) and redeem rewards at the old cost.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  TokenSale {\n    uint256 public tokensSold;\n    uint256 public tokenRate = 1000; // Number of tokens per Ether\n    uint256 public discountRate = 10; // 10% discount\n\n    mapping(address => uint256) public tokenBalance;\n\n    function buyTokens() public payable {\n        uint256 tokensToBuy = msg.value * tokenRate;\n\n        uint256 discount = tokensToBuy * discountRate / 100;\n        tokensToBuy -= discount;\n\n        tokensSold += tokensToBuy;\n\n        tokenBalance[msg.sender] += tokensToBuy;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "157",
                "Location": "tokensToBuy -= discount;\n\n        tokensSold += tokensToBuy;\n\n        tokenBalance[msg.sender] += tokensToBuy;",
                "Type": "Incorrect calculating order",
                "Description": "The problem is in the buyTokens function. The tokensToBuy is calculated based on the msg.value multiplied by the tokenRate. Then, a discount is applied. However, the tokensSold is incremented before the discount is subtracted, leading to an incorrect record of tokens sold.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract  LoyaltyPoints {\n    uint256 public threshold = 1 ether; \n    uint256 public bonusPoints = 500;\n    uint256 public rate = 100; // 100 loyalty points for each ether spent\n\n    mapping(address => uint256) public loyaltyBalance;\n\n    function purchase() public payable {\n        uint256 loyaltyEarned = msg.value * rate;\n\n        if (msg.value >= threshold) {\n            loyaltyEarned += bonusPoints;\n        }\n\n        uint256 fee = loyaltyEarned / 10; \n        loyaltyEarned -= fee;\n\n        loyaltyBalance[msg.sender] += loyaltyEarned;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "158",
                "Location": "if (msg.value >= threshold) {\n            loyaltyEarned += bonusPoints;\n        }\n\n        uint256 fee = loyaltyEarned / 10; \n        loyaltyEarned -= fee; ",
                "Type": "Incorrect calculating order",
                "Description": "The flaw in the purchase function is that the loyalty points are calculated based on the purchase value, and a bonus is added if the purchase value crosses the threshold. The problem arises because the fee is deducted after the bonus points are added. This means that if a user purchases just the threshold amount, they would get more loyalty points than they should.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Bank {\n    mapping(address => uint256) public balances;\n    uint256 public bankRevenue;\n    uint256 constant FEE_PERCENT = 2;  // 2% deposit fee\n\n    function deposit() public payable {\n        uint256 fee = msg.value * FEE_PERCENT / 100;\n        \n        bankRevenue += fee;\n\n        \n        balances[msg.sender] += msg.value;\n\n        if (balances[msg.sender] < fee) {\n            revert(\"Insufficient funds after fee deduction\");\n        }\n\n        balances[msg.sender] -= fee; \n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient funds\");\n        payable(msg.sender).transfer(amount);\n        balances[msg.sender] -= amount;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "159",
                "Location": "bankRevenue += fee;\n\n        balances[msg.sender] += msg.value;\n\n        if (balances[msg.sender] < fee) {\n            revert(\"Insufficient funds after fee deduction\");\n        }",
                "Type": "Incorrect calculating order",
                "Description": "The flaw in the deposit function is in the order of operations. It first adds the full deposit amount to the user's balance and then deducts the fee. If the fee exceeds the user's balance after the addition, this will lead to a state where the user has negative balance (underflow). Furthermore, the contract does not check for potential overflow situations.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public points;\n    uint256 public totalPointsIssued;\n\n    function earnPoints(uint256 purchaseAmount) public {\n        // Assume 1 Ether purchase earns 10 points\n        uint256 newPoints = purchaseAmount / 1 ether * 10;\n         \n        totalPointsIssued += newPoints;\n\n        require(totalPointsIssued <= 1000000, \"Points cap reached\");\n\n        points[msg.sender] += newPoints;\n    }\n\n    function spendPoints(uint256 amount) public {\n        require(points[msg.sender] >= amount, \"Not enough points\");\n        points[msg.sender] -= amount;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "160",
                "Location": " uint256 newPoints = purchaseAmount / 1 ether * 10;\n        \n        totalPointsIssued += newPoints;\n\n        require(totalPointsIssued <= 1000000, \"Points cap reached\");",
                "Type": "Incorrect calculating order",
                "Description": "In the earnPoints function, the contract first updates the totalPointsIssued before checking if this would exceed the total system cap of 1 million points. This order can allow the system to breach its points cap.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Auction {\n    address public highestBidder;\n    uint256 public highestBid;\n    \n    function placeBid(uint256 bidAmount) public payable {\n        require(msg.value == bidAmount, \"Sent value doesn't match bid amount\");\n \n        highestBid = bidAmount;\n\n        require(bidAmount > highestBid, \"There already exists a higher or equal bid\");\n        refundToPreviousBidder();\n        \n        highestBidder = msg.sender;\n    }\n    \n    function refundToPreviousBidder() internal {\n        payable(highestBidder).transfer(highestBid);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "161",
                "Location": "highestBid = bidAmount;\n\n        require(bidAmount > highestBid, \"There already exists a higher or equal bid\");\n        refundToPreviousBidder();",
                "Type": "Incorrect calculating order",
                "Description": "In the placeBid function, the contract first updates the highestBid before verifying if the new bid is indeed higher than the previous highest bid. This sequence can result in unnecessary and incorrect refunds.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenSale {\n    uint256 public tokensPerEther = 100;\n    uint256 public totalTokensSold;\n    \n    mapping(address => uint256) public tokenBalance;\n    \n    function buyTokens() public payable {\n        uint256 tokensToBuy = msg.value * tokensPerEther;\n \n        totalTokensSold += tokensToBuy;\n        require(totalTokensSold <= 1e6 * tokensPerEther, \"Sale cap reached\");\n\n        tokenBalance[msg.sender] += tokensToBuy;\n    }\n    \n    function claimRefund() public {\n        require(totalTokensSold > 1e6 * tokensPerEther, \"Sale cap not breached\");\n        uint256 refundAmount = tokenBalance[msg.sender] / tokensPerEther;\n        tokenBalance[msg.sender] = 0;\n        payable(msg.sender).transfer(refundAmount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "162",
                "Location": "totalTokensSold += tokensToBuy;\n        require(totalTokensSold <= 1e6 * tokensPerEther, \"Sale cap reached\");",
                "Type": "Incorrect calculating order",
                "Description": "The contract is supposed to have a cap on the total tokens sold (1e6 * tokensPerEther), but it first calculates and awards the tokens before checking this cap. This allows the last user to buy an amount that exceeds this cap, leading to an overflow of tokens.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DividendToken {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public dividends;\n    uint256 public totalSupply;\n    uint256 public totalDividend;\n\n    function deposit() public payable {\n        totalDividend += msg.value;\n    }\n\n    function distributeDividends() public {\n        uint256 dividendPerToken = totalDividend / totalSupply;\n \n        for (address addr : allAddresses) {\n            dividends[addr] += balances[addr] * dividendPerToken;\n        }\n\n        totalDividend = 0;\n    }\n\n    function claimDividend() public {\n        uint256 dividend = dividends[msg.sender];\n        dividends[msg.sender] = 0;\n        payable(msg.sender).transfer(dividend);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "163",
                "Location": "for (address addr : allAddresses) {\n            dividends[addr] += balances[addr] * dividendPerToken;\n        }\n\n        totalDividend = 0;",
                "Type": "Incorrect calculating order",
                "Description": "The contract calculates dividends for each token holder inside a loop. If there are many holders, this could exceed the gas limit, making it impossible for anyone to distribute dividends.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Auction {\n    struct Auction {\n        address payable creator;\n        uint256 startBlock;\n        uint256 endBlock;\n        uint256 startPrice;\n        address payable highestBidder;\n        uint256 highestBid;\n    }\n    mapping(uint256 => Auction) public auctions;\n    uint256 public auctionCount = 0;\n\n    function createAuction(uint256 duration, uint256 startPrice) public {\n        auctionCount += 1;\n        auctions[auctionCount] = Auction({\n            creator: payable(msg.sender),\n            startBlock: block.number,\n            endBlock: block.number + duration,\n            startPrice: startPrice,\n            highestBidder: payable(address(0)),\n            highestBid: 0\n        });\n    }\n\n    function bid(uint256 auctionId) public payable {\n        require(block.number <= auctions[auctionId].endBlock, \"Auction ended\");\n        require(msg.value > auctions[auctionId].highestBid, \"Bid too low\");\n\n        auctions[auctionId].highestBidder.transfer(auctions[auctionId].highestBid); \n        auctions[auctionId].highestBidder = payable(msg.sender);\n        auctions[auctionId].highestBid = msg.value;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "164",
                "Location": "require(block.number <= auctions[auctionId].endBlock, \"Auction ended\");\n        require(msg.value > auctions[auctionId].highestBid, \"Bid too low\");\n\n        auctions[auctionId].highestBidder.transfer(auctions[auctionId].highestBid); \n        auctions[auctionId].highestBidder = payable(msg.sender);\n        auctions[auctionId].highestBid = msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability occurs in the bid function. If the transfer function (used to return funds to the previously highest bidder) fails, the auction's highest bidder and highest bid would still be updated, allowing an attacker to potentially block legitimate higher bids.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Fundraiser {\n    address public owner;\n    uint256 public goal;\n    uint256 public fundsRaised;\n    mapping(address => uint256) public donations;\n\n    constructor(uint256 _goal) {\n        owner = msg.sender;\n        goal = _goal;\n    }\n\n    function donate() public payable {\n        require(fundsRaised + msg.value <= goal, \"Fundraising goal exceeded\");\n        fundsRaised += msg.value; \n        \n        donations[msg.sender] += msg.value;\n    }\n\n    function withdraw() public {\n        require(msg.sender == owner, \"Only the owner can withdraw\");\n        require(fundsRaised >= goal, \"Goal not reached yet\");\n        \n        payable(owner).transfer(fundsRaised);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "165",
                "Location": "fundsRaised += msg.value; \n        \n        donations[msg.sender] += msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "The issue is in the donate function. The contract first updates fundsRaised before updating the donations mapping. If, for some reason, there's an error after updating fundsRaised but before updating donations, the contract's state will be inconsistent.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract Auction {\n    address public owner;\n    address public highestBidder;\n    uint256 public highestBid;\n    uint256 public auctionEnd;\n    mapping(address => uint256) public pendingReturns;\n\n    event HighestBidIncreased(address bidder, uint256 amount);\n    event AuctionEnded(address winner, uint256 amount);\n\n    constructor(uint256 _biddingTime) {\n        owner = msg.sender;\n        auctionEnd = block.timestamp + _biddingTime;\n    }\n\n    function bid() public payable {\n        require(block.timestamp <= auctionEnd, \"Auction already ended.\");\n        require(msg.value > highestBid, \"There already is a higher bid.\");\n\n        pendingReturns[highestBidder] += highestBid; \n        \n        highestBidder = msg.sender;  \n        highestBid = msg.value;   \n\n        emit HighestBidIncreased(msg.sender, msg.value);\n    }\n\n    function endAuction() public {\n        require(msg.sender == owner, \"Only the owner can end the auction\");\n        require(block.timestamp >= auctionEnd, \"Auction has not yet ended.\");\n\n        emit AuctionEnded(highestBidder, highestBid);\n\n        payable(owner).transfer(highestBid);\n    }\n\n    function withdraw() public {\n        uint256 amount = pendingReturns[msg.sender];\n        pendingReturns[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "166",
                "Location": "pendingReturns[highestBidder] += highestBid;  \n        \n        highestBidder = msg.sender; \n        highestBid = msg.value;     ",
                "Type": "Incorrect calculating order",
                "Description": "In the bid function, we're setting the highestBidder and highestBid after we've refunded the previous highest bidder. If someone were to exploit this, they could potentially become the highest bidder and still get their ethers refunded.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IToken {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract TokenSale {\n    IToken public token;\n    address public owner;\n    uint256 public rate = 100;  // 1 ether = 100 tokens\n    uint256 public totalCollected;\n\n    constructor(address _token) {\n        owner = msg.sender;\n        token = IToken(_token);\n    }\n\n    function buyTokens() public payable {\n        uint256 tokensToBuy = rate * msg.value;\n        require(token.transfer(msg.sender, tokensToBuy), \"Token transfer failed\");\n\n        totalCollected += msg.value; \n    }\n\n    function ownerWithdraw() public {\n        require(msg.sender == owner, \"Only the owner can withdraw\");\n        payable(owner).transfer(totalCollected);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "167",
                "Location": "require(token.transfer(msg.sender, tokensToBuy), \"Token transfer failed\");\n\n        totalCollected += msg.value; ",
                "Type": "Incorrect calculating order",
                "Description": "In the buyTokens function, we're transferring tokens to the buyer before we update the totalCollected. If the transfer function fails (e.g., due to a reentrancy attack), an attacker could potentially exploit this and drain the contract of its funds.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyRewards {\n    mapping(address => uint256) public points;\n    address public owner;\n    uint256 public redeemThreshold = 1000;\n    uint256 public rewardAmount = 0.1 ether;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function distributeBonusPoints(address _to, uint256 _amount) public {\n        require(msg.sender == owner, \"Only owner can distribute bonus points\");\n        points[_to] += _amount; \n\n    function redeemReward() public {\n        require(points[msg.sender] >= redeemThreshold, \"Not enough points to redeem\");\n         \n        payable(msg.sender).transfer(rewardAmount); \n        points[msg.sender] -= redeemThreshold;\n    }\n\n    function fundContract() public payable {}\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "168",
                "Location": "payable(msg.sender).transfer(rewardAmount); \n        points[msg.sender] -= redeemThreshold;",
                "Type": "Incorrect calculating order",
                "Description": "In the redeemReward function, we are transferring the reward to the user before reducing their points. An attacker can potentially utilize a reentrancy attack to drain the contract's Ether without having the necessary points reduced.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CryptoAuction {\n    address public highestBidder;\n    uint256 public highestBid;\n\n    function bid() external payable {\n        require(msg.value > highestBid, \"Bid amount too low.\");\n\n        if (highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid);\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "169",
                "Location": "if (highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid);\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability in the above contract is the order of operations in the bid() function. If the transfer to the old highest bidder fails, the new bid is not updated, which is an unexpected behavior.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CryptoBank {\n    mapping(address => uint256) public balances;\n\n    uint256 constant BONUS = 0.1 ether;\n\n    function deposit() external payable {\n        uint256 amount = msg.value;\n\n        amount += BONUS;\n\n        require(amount >= 1 ether, \"Minimum deposit is 1 Ether.\");\n\n        balances[msg.sender] += amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient balance.\");\n        balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "170",
                "Location": "uint256 amount = msg.value;\n\n        amount += BONUS;\n\n        require(amount >= 1 ether, \"Minimum deposit is 1 Ether.\");\n\n        balances[msg.sender] += amount;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here is that the bonus is added before checking if the deposit amount is at least 1 Ether. This means a user can deposit slightly less than 1 Ether, but due to the bonus addition, the require check passes, allowing users to get the bonus without depositing the full 1 Ether.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CryptoLoyalty {\n    mapping(address => uint256) public tokenBalances;\n    uint256 public pricePerToken = 1 ether;\n\n    // Buy tokens and get 10% extra if you buy more than 100 tokens\n    function buyTokens(uint256 numberOfTokens) external payable {\n        uint256 cost = numberOfTokens * pricePerToken;\n        require(msg.value == cost, \"Ether sent is not correct.\");\n\n        if(numberOfTokens > 100) {\n            numberOfTokens += numberOfTokens / 10; // 10% bonus\n        }\n        \n        tokenBalances[msg.sender] += numberOfTokens;\n    }\n    \n    function balanceOf(address user) external view returns (uint256) {\n        return tokenBalances[user];\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "171",
                "Location": "uint256 cost = numberOfTokens * pricePerToken;\n        require(msg.value == cost, \"Ether sent is not correct.\");\n\n        if(numberOfTokens > 100) {\n            numberOfTokens += numberOfTokens / 10; // 10% bonus\n        }",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here is subtle. If the user buys exactly 100 tokens, they will not receive the bonus, but the check for bonus comes after the token calculation, which might lead to inconsistencies in some cases.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract CryptoBank {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public depositTimestamp;\n    \n    uint256 constant ONE_DAY = 86400; // seconds in a day\n\n    function deposit() external payable {\n        uint256 interest = calculateInterest(msg.sender);\n        \n        depositTimestamp[msg.sender] = block.timestamp;\n        balances[msg.sender] += msg.value + interest;\n    }\n\n    function calculateInterest(address user) public view returns(uint256) {\n        uint256 depositDuration = block.timestamp - depositTimestamp[user];\n        if(depositDuration > ONE_DAY * 30) {\n            return balances[user] / 10; // 10% interest for deposits older than a month\n        }\n        return 0;\n    }\n\n    function withdraw() external {\n        uint256 amount = balances[msg.sender];\n        require(amount > 0, \"Nothing to withdraw\");\n        balances[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "172",
                "Location": "uint256 interest = calculateInterest(msg.sender);\n        \n        depositTimestamp[msg.sender] = block.timestamp;\n        balances[msg.sender] += msg.value + interest;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here arises because a user can deposit funds multiple times within a short span, and the  function will add interest to their account every time they deposit if their previous deposit was made over a month ago. This allows users to exploit the system by repeatedly depositing and withdrawing funds.deposit()",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ncontract TokenVault {\n    struct Deposit {\n        uint256 amount;\n        uint256 unlockTime;\n    }\n\n    mapping(address => Deposit) public deposits;\n\n    function depositTokens(address tokenAddress, uint256 amount, uint256 lockDays) external {\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        deposits[msg.sender].amount += amount; \n        deposits[msg.sender].unlockTime = block.timestamp + lockDays * 1 days;\n        \n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\n    }\n\n    function withdrawTokens(address tokenAddress) external {\n        require(block.timestamp >= deposits[msg.sender].unlockTime, \"Tokens are locked\");\n        \n        uint256 amountToWithdraw = deposits[msg.sender].amount;\n        deposits[msg.sender].amount = 0;\n        \n        IERC20(tokenAddress).transfer(msg.sender, amountToWithdraw);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "173",
                "Location": "deposits[msg.sender].amount += amount;\n        deposits[msg.sender].unlockTime = block.timestamp + lockDays * 1 days;\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);",
                "Type": "Incorrect calculating order",
                "Description": "In the  function, the user's deposit amount is updated before the  method is called. This is problematic because if the  fails (due to various reasons like allowance issues), the user's deposit amount in the contract would still be incremented.depositTokenstransferFromtransferFrom",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n\n    mapping(address => uint256) public points;\n    mapping(address => bool) public specialUsers;\n\n    // 1 Ether = 100 points\n    uint256 public constant POINTS_PER_ETHER = 100;\n    uint256 public constant SPECIAL_USER_MULTIPLIER = 2;\n\n    function deposit() external payable {\n        require(msg.value > 0, \"Must send Ether\");\n        \n        uint256 newPoints = msg.value / 1 ether * POINTS_PER_ETHER;\n        points[msg.sender] += newPoints;\n\n        if (specialUsers[msg.sender]) {\n            points[msg.sender] *= SPECIAL_USER_MULTIPLIER;\n        }\n    }\n\n    function setSpecialUser(address user) external {\n        // Only for demonstration purposes; in a real contract, you would want more security around this function.\n        specialUsers[user] = true;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "174",
                "Location": "points[msg.sender] += newPoints;\n\n        if (specialUsers[msg.sender]) {\n            points[msg.sender] *= SPECIAL_USER_MULTIPLIER;\n        }",
                "Type": "Incorrect calculating order",
                "Description": "In the deposit function, if the user is a special user, we multiply their entire points balance by the special multiplier. This is problematic, especially if the user had prior points. They could potentially earn less than they should.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SimpleLending {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public loans;\n\n    uint256 public constant INTEREST_RATE = 5; // 5% interest rate for simplicity\n\n    function deposit(uint256 amount) external {\n        balances[msg.sender] += amount;\n        // Assuming the ERC20 transferFrom function is properly integrated\n        // ERC20Token.transferFrom(msg.sender, address(this), amount);\n    }\n\n    function lend(address borrower, uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Not enough balance\");\n\n        loans[borrower] += amount;\n        balances[msg.sender] -= amount;\n \n        balances[msg.sender] += (amount * INTEREST_RATE) / 100;\n    }\n\n    function repay(address lender) external payable {\n        require(loans[msg.sender] > 0, \"No loan to repay\");\n\n        uint256 repaymentAmount = loans[msg.sender];\n        loans[msg.sender] = 0;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "175",
                "Location": "loans[borrower] += amount;\n        balances[msg.sender] -= amount;\n\n        balances[msg.sender] += (amount * INTEREST_RATE) / 100;",
                "Type": "Incorrect calculating order",
                "Description": "In the above version, when lending out tokens, the interest is credited to the lender's balance after the principal amount has been deducted. As a result, the lender ends up with less than they should in their balance.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract StakingToken {\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lastStakedTime;\n    mapping(address => uint256) public rewards;\n\n    uint256 public rewardRate = 1e18; // 1 token per second\n\n    function deposit(uint256 amount) external {\n        updateReward(msg.sender);\n\n        balances[msg.sender] += amount;\n        lastStakedTime[msg.sender] = block.timestamp;\n    }\n\n    function withdraw(uint256 amount) external {\n        updateReward(msg.sender);\n\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n    }\n\n    function updateReward(address user) public {\n        uint256 stakingDuration = block.timestamp - lastStakedTime[user];  \n        rewards[user] += balances[user] * stakingDuration * rewardRate;\n        lastStakedTime[user] = block.timestamp;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "176",
                "Location": "balances[msg.sender] += amount;\n        lastStakedTime[msg.sender] = block.timestamp;",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, the updateReward function computes the stakingDuration using the lastStakedTime and then multiplies it with the balance and rewardRate. However, since we're updating the balance in the deposit function after the call to updateReward, a user could exploit this by depositing a large amount right after their previous deposit to receive rewards on the new amount for the entire duration since their last deposit.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract PoolShare {\n    mapping(address => uint256) public deposits;\n    uint256 public totalPool;\n\n    function depositFunds(uint256 amount) external {\n        deposits[msg.sender] += amount;\n        totalPool += amount;\n    }\n\n    function withdrawFunds() external {\n        uint256 userShare = deposits[msg.sender] * address(this).balance / totalPool; \n        totalPool -= deposits[msg.sender]; \n        deposits[msg.sender] = 0;\n        payable(msg.sender).transfer(userShare);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "177",
                "Location": "uint256 userShare = deposits[msg.sender] * address(this).balance / totalPool;\n        totalPool -= deposits[msg.sender]; \n        deposits[msg.sender] = 0;\n        payable(msg.sender).transfer(userShare);",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, the withdrawFunds function first calculates the userShare using the current state of deposits and totalPool. After that, it updates the totalPool and sets the user's deposit to 0. This incorrect order allows an attacker to repeatedly call withdrawFunds without depositing more funds, draining more from the contract than they should.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LoyaltyPoints {\n    mapping(address => uint256) public points;\n    mapping(address => bool) public receivedBonus;\n    uint256 constant BONUS_THRESHOLD = 5 ether;\n    uint256 constant BONUS_POINTS = 1000;\n\n    function makeTransaction(uint256 amount) external {\n        if (amount > BONUS_THRESHOLD && !receivedBonus[msg.sender]) {\n           \n            points[msg.sender] += BONUS_POINTS;\n        }\n        receivedBonus[msg.sender] = true; \n        points[msg.sender] += amount / 1 ether; // Earn 1 point for every ether spent\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "178",
                "Location": " if (amount > BONUS_THRESHOLD && !receivedBonus[msg.sender]) {\n            points[msg.sender] += BONUS_POINTS;\n        }\n        receivedBonus[msg.sender] = true; ",
                "Type": "Incorrect calculating order",
                "Description": "In the above code, an attacker could exploit the system by making multiple transactions just above the bonus threshold, repeatedly gaining the bonus points since the receivedBonus status is updated after awarding points.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenStaking {\n    mapping(address => uint256) public stakedAmount;\n    mapping(address => uint256) public rewards;\n    uint256 constant PREMIUM_THRESHOLD = 1000;\n    uint256 constant REGULAR_REWARD = 10;\n    uint256 constant PREMIUM_REWARD = 50;\n\n    function stakeTokens(uint256 amount) external {\n    \n        if (stakedAmount[msg.sender] > PREMIUM_THRESHOLD) {\n            rewards[msg.sender] += PREMIUM_REWARD;\n        } else {\n            rewards[msg.sender] += REGULAR_REWARD;\n        }\n        stakedAmount[msg.sender] += amount; \n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "179",
                "Location": " if (stakedAmount[msg.sender] > PREMIUM_THRESHOLD) {\n            rewards[msg.sender] += PREMIUM_REWARD;\n        } else {\n            rewards[msg.sender] += REGULAR_REWARD;\n        }\n        stakedAmount[msg.sender] += amount;",
                "Type": "Incorrect calculating order",
                "Description": "In the code above, users can game the system by staking tokens in small batches to stay below the PREMIUM_THRESHOLD and keep earning the regular reward, even if their total staked amount exceeds the threshold.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DecentralizedLottery {\n    address[] public participants;\n    address public currentWinner;\n    uint256 public ticketPrice = 1 ether;\n    uint256 constant MAX_PARTICIPANTS = 10;\n\n    function buyTicket() external payable {\n        require(msg.value == ticketPrice, \"Incorrect Ether sent\");\n        \n        participants.push(msg.sender);\n\n        if (participants.length == MAX_PARTICANTS) {\n            uint256 winnerIndex = uint256(blockhash(block.number - 1)) % MAX_PARTICIPANTS;\n            currentWinner = participants[winnerIndex];\n            \n            payable(currentWinner).transfer(address(this).balance); \n            \n            participants = new address[](0); // Resetting state\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "180",
                "Location": "payable(currentWinner).transfer(address(this).balance); \n            \n            participants = new address[](0);",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, we're transferring the balance to the winner before resetting the state (participants array). This could open up potential re-entrancy attack vectors if the recipient (currentWinner) is a malicious contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DecentralizedAuction {\n    address public highestBidder;\n    uint256 public highestBid;\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the contract owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function bid() external payable {\n        require(msg.value > highestBid, \"Bid should be higher than the current highest bid\");\n\n        if (highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid);  \n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function endAuction() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "181",
                "Location": "if (highestBidder != address(0)) {\n            payable(highestBidder).transfer(highestBid); \n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, we're returning the funds to the previous highest bidder before updating the new highest bid. This could potentially lead to re-entrancy attacks if the highestBidder is a malicious contract.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SimpleInsurance {\n    address public owner;\n    mapping(address => uint256) public insuranceAmount;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the contract owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function buyInsurance() external payable {\n        require(msg.value > 0, \"Must send ether to buy insurance.\");\n        insuranceAmount[msg.sender] += msg.value;\n    }\n\n    function approveClaim(address beneficiary) external onlyOwner {\n        require(insuranceAmount[beneficiary] > 0, \"Beneficiary has no insurance.\");\n\n        payable(beneficiary).transfer(insuranceAmount[beneficiary]);  \n        insuranceAmount[beneficiary] = 0;\n    }\n\n    function withdraw() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "182",
                "Location": "payable(beneficiary).transfer(insuranceAmount[beneficiary]); \n        insuranceAmount[beneficiary] = 0; ",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, when a claim is approved, the beneficiary receives their insurance payout, but their insurance amount is reset to 0 only after the transfer. This is a vulnerability as, in case of any issues with the transfer (or potential reentrancy), the beneficiary could still have a non-zero insurance amount.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract TokenRewards {\n    address public owner;\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public rewards;\n\n    uint256 public totalSupply = 10000;\n    uint256 public totalRewards = 1000; // total rewards to distribute\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not the contract owner\");\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        balances[owner] = totalSupply;\n    }\n\n    function transfer(address to, uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        updateRewards(msg.sender);\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n    }\n\n    function claimRewards() public {\n        updateRewards(msg.sender);\n        uint256 reward = rewards[msg.sender];\n        require(reward > 0, \"No rewards to claim\");\n        totalRewards -= reward; \n        rewards[msg.sender] = 0;\n        payable(msg.sender).transfer(reward);\n    }\n\n    function updateRewards(address user) internal {\n        uint256 userBalance = balances[user];\n        uint256 reward = (userBalance * totalRewards) / totalSupply; // rewards proportional to holdings\n        rewards[user] += reward;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "183",
                "Location": "totalRewards -= reward; \n        rewards[msg.sender] = 0;\n        payable(msg.sender).transfer(reward);",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here lies in the claimRewards() function. If the transfer function fails due to any unforeseen reason, the user's rewards are already set to 0 and total rewards reduced, making the user lose their rewards.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SimpleLottery {\n    address public owner;\n    address[] public participants;\n    uint256 public participationAmount = 1 ether; \n    uint256 public maxParticipants = 10;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function participate() external payable {\n        require(msg.value == participationAmount, \"Incorrect amount sent\");\n        participants.push(msg.sender);\n        \n        if(participants.length == maxParticipants) {\n          \n            uint256 winnerIndex = block.timestamp % maxParticipants;\n            payable(participants[winnerIndex]).transfer(address(this).balance);\n            participants = new address[](0); \n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "184",
                "Location": "uint256 winnerIndex = block.timestamp % maxParticipants;\n            payable(participants[winnerIndex]).transfer(address(this).balance);\n            participants = new address[](0);",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, the contract selects a winner and tries to transfer the jackpot to them before resetting the participants array. If, for some reason, the transfer fails (e.g., if the winner is a contract that throws an error), the money gets locked in the contract, and no one else can claim it.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract DecentralizedAuction {\n    address public highestBidder;\n    uint256 public highestBid;\n    mapping(address => uint256) pendingReturns;\n\n    function bid() external payable {\n        require(msg.value > highestBid, \"There already is a higher bid.\");\n\n      \n        if (highestBidder != address(0)) {\n            pendingReturns[highestBidder] += highestBid;\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function withdraw() external returns (bool) {\n        uint256 amount = pendingReturns[msg.sender];\n        if (amount > 0) {\n            (bool success, ) = msg.sender.call{value: amount}(\"\");\n            if (success) {\n                pendingReturns[msg.sender] = 0;\n            }\n            return success;\n        }\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "185",
                "Location": "if (highestBidder != address(0)) {\n            pendingReturns[highestBidder] += highestBid;\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, the refund to the previous highest bidder is queued before the new highest bid is stored. This may potentially allow for a reentrancy attack where a malicious actor calls bid() repeatedly in the same transaction before highestBid is updated.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract VotingSystem {\n\n    struct Proposal {\n        uint256 voteCount;\n        bool executed;\n    }\n\n    mapping(address => Proposal) public proposals;\n    mapping(address => bool) public hasVoted;\n    address public winningProposal;\n    uint256 public highestVoteCount;\n\n    function vote(address proposal) external {\n        require(!hasVoted[msg.sender], \"You have already voted.\");\n        require(!proposals[proposal].executed, \"Proposal already executed.\");\n\n       \n        if (proposals[proposal].voteCount + 1 > highestVoteCount) {\n            winningProposal = proposal;\n        }\n\n        proposals[proposal].voteCount += 1;\n        hasVoted[msg.sender] = true;\n    }\n\n    function executeProposal() external {\n        require(proposals[winningProposal].voteCount > highestVoteCount / 2, \"Not enough votes.\");\n        proposals[winningProposal].executed = true;\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "186",
                "Location": "if (proposals[proposal].voteCount + 1 > highestVoteCount) {\n            winningProposal = proposal;\n        }\n\n        proposals[proposal].voteCount += 1;\n        hasVoted[msg.sender] = true;",
                "Type": "Incorrect calculating order",
                "Description": "In the vulnerable version, the contract determines the winning proposal before counting the new vote. This can result in incorrect determination of the winning proposal.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract AuctionHouse {\n    \n    address public highestBidder;\n    uint256 public highestBid;\n    address public owner;\n    bool public auctionEnded = false;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function bid() external payable {\n        require(!auctionEnded, \"Auction has ended.\");\n        require(msg.value > highestBid, \"Bid is not high enough.\");\n\n        \n        if(highestBidder != address(0)) {\n            highestBidder.transfer(highestBid); \n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n    }\n\n    function endAuction() external {\n        require(msg.sender == owner, \"Only the owner can end the auction.\");\n        require(!auctionEnded, \"Auction has already ended.\");\n\n        auctionEnded = true;\n        owner.transfer(highestBid);\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "187",
                "Location": "if(highestBidder != address(0)) {\n            highestBidder.transfer(highestBid);\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability arises from sending back the funds to the previous highest bidder before updating the highest bidder. If the transfer function fails, the state of the contract would not reflect the most recent highest bid.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SimpleBank {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        msg.sender.transfer(amount);\n        balances[msg.sender] -= amount;\n    }\n\n    function getBalance() public view returns(uint256) {\n        return balances[msg.sender];\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "188",
                "Location": "msg.sender.transfer(amount);\n        balances[msg.sender] -= amount;",
                "Type": "Incorrect calculating order",
                "Description": "In the withdraw function, the contract first sends the specified amount to the msg.sender and then subtracts the amount from the user's balance. If the transfer function fails for any reason after sending the funds, the balance is not deducted, allowing a potential re-entrancy attack.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract Bank {\n    address public owner;\n    mapping(address => uint256) public balances;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance.\");\n        payable(msg.sender).transfer(amount);\n        balances[msg.sender] -= amount;\n    }\n\n    function shutdown() public {\n        require(msg.sender == owner, \"Only the owner can shut down the bank.\");\n        selfdestruct(payable(owner));\n    }\n}",
        "VulnerabilityDesc": [
            {
                "Name": "189",
                "Location": "payable(msg.sender).transfer(amount);\n        balances[msg.sender] -= amount;",
                "Type": "Incorrect calculating order",
                "Description": "The withdraw function is susceptible to a reentrancy attack because the user's balance is updated after the transfer has been executed. Additionally, the shutdown function can permanently lock all deposited funds for users other than the owner.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "\npragma solidity ^0.8.0;\n\ncontract  SimpleBank {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() public {\n        uint256 amountToWithdraw = balances[msg.sender];\n        (bool success, ) = msg.sender.call{value: amountToWithdraw}(\"\");\n        require(success, \"Transfer failed.\");\n        balances[msg.sender] = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "190",
                "Location": "function withdraw() public {\n        uint256 amountToWithdraw = balances[msg.sender];\n        (bool success, ) = msg.sender.call{value: amountToWithdraw}(\"\");\n        require(success, \"Transfer failed.\");\n        balances[msg.sender] = 0;\n    }",
                "Type": "Incorrect calculating order",
                "Description": "The withdraw function is vulnerable. A malicious contract could, in its fallback function, call withdraw again before the balance is set to zero, effectively draining more funds than it has in the VulnerableSimpleBank",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RewardDistributor {\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public lastRewardBlock;\n    uint256 public rewardPerBlock = 1 ether; \n\n    function stake(uint256 amount) public {\n        distributeReward(msg.sender);\n        balances[msg.sender] += amount;\n    }\n\n    function withdraw(uint256 amount) public {\n        distributeReward(msg.sender);\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n    }\n\n    function distributeReward(address user) public {\n        uint256 blocksPassed = block.number - lastRewardBlock[user];\n        uint256 reward = blocksPassed * rewardPerBlock;\n\n         \n        balances[user] += reward;\n        lastRewardBlock[user] = block.number;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "191",
                "Location": "balances[user] += reward;\n        lastRewardBlock[user] = block.number;",
                "Type": "Incorrect calculating order",
                "Description": "However, the vulnerability is that the contract updates a user's last reward block after calculating and distributing their rewards, which can lead to incorrect results.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LiquidityPool {\n\n    mapping(address => uint256) public balances;\n    uint256 public totalLiquidity;\n    uint256 public feeRate = 5; // 5% fee for simplicity\n\n    function deposit(uint256 amount) public {\n        balances[msg.sender] += amount;\n        totalLiquidity += amount;\n    }\n\n    function withdraw(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        \n        \n        uint256 fee = (amount * feeRate) / 100;\n        \n        balances[msg.sender] -= amount;\n        totalLiquidity -= amount;\n\n        payable(msg.sender).transfer(amount - fee);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "192",
                "Location": "uint256 fee = (amount * feeRate) / 100;\n        \n        balances[msg.sender] -= amount;\n        totalLiquidity -= amount;\n",
                "Type": "Incorrect calculating order",
                "Description": "However, the function to withdraw funds first calculates fees based on the current liquidity, and then updates the liquidity. This can lead to miscalculated fees if multiple users try to withdraw within a short time frame.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract RewardPool {\n\n    mapping(address => uint256) public balances;\n    uint256 public totalStaked;\n    uint256 public rewardPool;\n\n    event RewardDistributed(address user, uint256 amount);\n\n    function stake(uint256 amount) public {\n        require(amount > 0, \"Amount should be greater than 0\");\n\n         \n        uint256 reward = (balances[msg.sender] * rewardPool) / totalStaked;\n        balances[msg.sender] += reward;\n        rewardPool -= reward;\n        emit RewardDistributed(msg.sender, reward);\n\n       balances[msg.sender] += amount;\n        totalStaked += amount;\n    }\n\n    function unstake(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Not enough balance\");\n        balances[msg.sender] -= amount;\n        totalStaked -= amount;\n    }\n\n    function depositReward(uint256 amount) public {\n        rewardPool += amount;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "193",
                "Location": "uint256 reward = (balances[msg.sender] * rewardPool) / totalStaked;\n        balances[msg.sender] += reward;\n        rewardPool -= reward;\n        emit RewardDistributed(msg.sender, reward);\n\n        balances[msg.sender] += amount;\n        totalStaked += amount;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability in this contract arises due to the incorrect order in which rewards are distributed before updating the staker's balance. This can lead to disproportionate reward distribution.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SimpleAuction {\n    address public highestBidder;\n    uint256 public highestBid;\n    address public owner;\n\n    event NewBid(address indexed bidder, uint256 amount);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function bid() public payable {\n         \n        if (msg.value > highestBid) {\n            if (highestBidder != address(0)) {\n                payable(highestBidder).transfer(highestBid);\n            }\n\n            highestBidder = msg.sender;\n            highestBid = msg.value;\n            emit NewBid(msg.sender, msg.value);\n        } else {\n            revert(\"Bid not high enough\");\n        }\n    }\n\n    function endAuction() public {\n        require(msg.sender == owner, \"Only owner can end the auction\");\n        payable(owner).transfer(highestBid);\n        highestBid = 0;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "194",
                "Location": "if (msg.value > highestBid) {\n            if (highestBidder != address(0)) {\n                payable(highestBidder).transfer(highestBid);\n            }\n\n            highestBidder = msg.sender;\n            highestBid = msg.value;\n            emit NewBid(msg.sender, msg.value);\n        } else {\n            revert(\"Bid not high enough\");\n        }",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here arises due to an incorrect calculation order in which the contract first transfers the funds and then updates the highest bid. This might result in the wrong bidder receiving the item if two bids are placed nearly simultaneously.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address from, address to, uint value) external returns(bool);\n    function transfer(address to, uint value) external returns(bool);\n}\n\ncontract TokenSwap {\n    IERC20 public tokenA;\n    IERC20 public tokenB;\n    uint256 public rate; // How many B tokens you get for 1 A token\n\n    constructor(address _tokenA, address _tokenB, uint256 _rate) {\n        tokenA = IERC20(_tokenA);\n        tokenB = IERC20(_tokenB);\n        rate = _rate;\n    }\n\n    function swapAforB(uint256 amountA) external {\n        uint256 amountB = amountA * rate;\n\n        \n        require(tokenB.transfer(msg.sender, amountB), \"Transfer of token B failed\");\n        \n        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Transfer of token A failed\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "195",
                "Location": "require(tokenB.transfer(msg.sender, amountB), \"Transfer of token B failed\");\n        \n        require(tokenA.transferFrom(msg.sender, address(this), amountA), \"Transfer of token A failed\");",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability here is in the swap function: it transfers the output token to the user before subtracting the input amount from the user's balance. An attacker could exploit this by reentering the contract before their input balance is subtracted, effectively getting more output tokens than they should.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n}\n\ncontract Staking {\n    IERC20 public token;\n    uint256 public totalStaked;\n    uint256 public rewardRate;\n    uint256 public lastRewardUpdateTime;\n\n    struct User {\n        uint256 balance;\n        uint256 rewardDebt;\n    }\n    mapping(address => User) public users;\n\n    constructor(address _token) {\n        token = IERC20(_token);\n    }\n\n    function deposit(uint256 amount) external {\n        updateRewards();\n        \n        User storage user = users[msg.sender];\n        user.balance += amount;\n        user.rewardDebt = user.balance * rewardRate;\n        \n        require(token.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n    }\n\n    function updateRewards() public {\n        uint256 timeElapsed = block.timestamp - lastRewardUpdateTime;\n        rewardRate += timeElapsed * 1e18 / totalStaked;\n\n        User storage user = users[msg.sender];\n        uint256 pendingReward = user.balance * rewardRate - user.rewardDebt;\n\n         \n        user.rewardDebt = user.balance * rewardRate;\n        token.transfer(msg.sender, pendingReward);\n\n        lastRewardUpdateTime = block.timestamp;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "196",
                "Location": "user.rewardDebt = user.balance * rewardRate;\n        token.transfer(msg.sender, pendingReward);",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability lies in the order of updating the user's last reward point and the global reward rate.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract SavingsAccount {\n    mapping(address => uint256) public balances;\n    uint256 public interestRate = 5; // Represents 5%\n    mapping(address => uint256) public lastInterestCreditTime;\n\n    function deposit(uint256 amount) external {\n       \n        creditInterest(msg.sender);\n        balances[msg.sender] += amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount, \"Insufficient funds\");\n        creditInterest(msg.sender);\n        balances[msg.sender] -= amount;\n    }\n\n    function creditInterest(address account) internal {\n        uint256 timeDifference = block.timestamp - lastInterestCreditTime[account];\n        uint256 interest = balances[account] * interestRate / 100 * timeDifference / (365 days);\n        balances[account] += interest;\n        lastInterestCreditTime[account] = block.timestamp;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "197",
                "Location": "creditInterest(msg.sender);\n        balances[msg.sender] += amount;",
                "Type": "Incorrect calculating order",
                "Description": "In this fictional example, the vulnerability arises from the order of operations in the purchaseItem function where the user's balance is decreased after the item's quantity is checked and decreased, opening the potential for reentrancy-like attacks.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract StakeAndRewards {\n    mapping(address => uint256) public stakes;\n    mapping(address => uint256) public lastClaimed;\n    uint256 public rewardRate = 1e18;  // reward rate per block, for simplicity's sake\n\n    function deposit() external payable {\n        stakes[msg.sender] += msg.value;\n    }\n\n    function claimRewards() external {\n        uint256 pendingRewards = (block.number - lastClaimed[msg.sender]) * rewardRate;\n        require(stakes[msg.sender] >= pendingRewards, \"Reward exceeds staked amount\");\n\n        \n        payable(msg.sender).transfer(pendingRewards);\n\n        lastClaimed[msg.sender] = block.number;\n    }\n\n    function setRewardRate(uint256 newRate) external {\n        rewardRate = newRate;\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "198",
                "Location": "payable(msg.sender).transfer(pendingRewards);\n\n        lastClaimed[msg.sender] = block.number;",
                "Type": "Incorrect calculating order",
                "Description": "However, there's a vulnerability in the order of calculations in the claimRewards function. It calculates rewards before updating the user's last claimed timestamp, allowing potential abuse.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ncontract LendingPlatform {\n    mapping(address => uint256) public deposits;\n    mapping(address => uint256) public loans;\n    mapping(address => uint256) public lastBorrowedBlock;\n    \n    uint256 public borrowRate = 5;  // Interest rate of 5% per block for simplicity\n\n    event Deposited(address indexed user, uint256 amount);\n    event Borrowed(address indexed user, uint256 amount);\n    event Repaid(address indexed user, uint256 amount);\n\n    function deposit(uint256 amount) external {\n        deposits[msg.sender] += amount;\n        emit Deposited(msg.sender, amount);\n    }\n\n    function borrow(uint256 amount) external {\n        require(deposits[msg.sender] > amount, \"Insufficient deposit\");\n        uint256 interest = amount * borrowRate / 100;\n        loans[msg.sender] += amount + interest;\n        lastBorrowedBlock[msg.sender] = block.number;\n        emit Borrowed(msg.sender, amount);\n    }\n\n    function repayLoan(uint256 amount) external {\n        uint256 interest = (block.number - lastBorrowedBlock[msg.sender]) * borrowRate / 100;\n        \n        \n        loans[msg.sender] -= amount;\n\n        require(amount >= interest, \"Amount is less than owed interest\");\n        emit Repaid(msg.sender, amount);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "199",
                "Location": "loans[msg.sender] -= amount;\n\n        require(amount >= interest, \"Amount is less than owed interest\");",
                "Type": "Incorrect calculating order",
                "Description": "There's an interest rate associated with borrowing, and the contract has a vulnerability related to the order of calculations in the repayLoan function.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "pragma solidity ^0.8.0;\n\ninterface IPriceOracle {\n    function getPrice(address token) external view returns (uint256);\n}\n\ncontract DexLiquidityPool {\n    IPriceOracle public oracle;\n    mapping(address => uint256) public tokenBalances;\n\n    event LiquidityAdded(address indexed user, address indexed token, uint256 amount);\n\n    constructor(IPriceOracle _oracle) {\n        oracle = _oracle;\n    }\n\n    function addLiquidity(address tokenA, address tokenB, uint256 amountA, uint256 amountB) external {\n        uint256 priceA = oracle.getPrice(tokenA);  // Get price from oracle\n        uint256 priceB = oracle.getPrice(tokenB);\n\n      \n        tokenBalances[tokenA] += amountA;\n        tokenBalances[tokenB] += amountB;\n\n        require(priceA * amountA == priceB * amountB, \"Provided tokens are not equivalent in value.\");\n\n        emit LiquidityAdded(msg.sender, tokenA, amountA);\n        emit LiquidityAdded(msg.sender, tokenB, amountB);\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "200",
                "Location": "tokenBalances[tokenA] += amountA;\n        tokenBalances[tokenB] += amountB;\n\n        require(priceA * amountA == priceB * amountB, \"Provided tokens are not equivalent in value.\");",
                "Type": "Incorrect calculating order",
                "Description": "A vulnerability arises due to incorrect calculation order when updating token balances and prices.",
                "Repair": ""
            }
        ]
    }
]