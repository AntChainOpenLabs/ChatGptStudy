 [

    {
        "Code": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../Controller.sol\";\nimport \"../interfaces/IUserManager.sol\";\nimport \"../interfaces/IAssetManager.sol\";\nimport \"../interfaces/IUErc20.sol\";\nimport \"../interfaces/IInterestRateModel.sol\";\n\ncontract UToken is Controller, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IUErc20;\n\n    bool public constant IS_UTOKEN = true;\n    uint256 public constant WAD = 1e18;\n\n    address public underlying;\n    IInterestRateModel public interestRateModel;\n    uint256 public borrowIndex;\n    uint256 public totalBorrows;\n    uint256 public totalReserves;\n    uint256 public overdueBlocks;\n    uint256 public originationFee;\n    uint256 public debtCeiling;\n    uint256 public maxBorrow;\n    uint256 public minBorrow;\n    address public assetManager;\n    address public userManager;\n    IUErc20 public uErc20;\n\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interest;\n        uint256 interestIndex;\n        uint256 lastRepay; //Calculate if it is overdue\n    }\n\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    event LogBorrow(address indexed account, uint256 amount, uint256 fee);\n\n    modifier onlyMember(address account) {\n        require(IUserManager(userManager).checkIsMember(account), \"UToken: caller is not a member\");\n        _;\n    }\n\n    function getRemainingLoanSize() public view returns (uint256) {\n        if (debtCeiling >= totalBorrows) {\n            return debtCeiling - totalBorrows;\n        } else {\n            return 0;\n        }\n    }\n\n    function calculatingFee(uint256 amount) public view returns (uint256) {\n        return (originationFee * amount) / WAD;\n    }\n\n    function borrowBalanceView(address account) public view returns (uint256) {\n        return accountBorrows[account].principal + calculatingInterest(account);\n    }\n\n    function checkIsOverdue(address account) public view returns (bool isOverdue) {\n        if (getBorrowed(account) == 0) {\n            isOverdue = false;\n        } else {\n            uint256 lastRepay = getLastRepay(account);\n            uint256 diff = getBlockNumber() - lastRepay;\n            isOverdue = (overdueBlocks < diff);\n        }\n    }\n\n    function borrow(uint256 amount) external onlyMember(msg.sender) whenNotPaused nonReentrant {\n    // Incorrect order\n    IAssetManager assetManagerContract = IAssetManager(assetManager);\n        require(amount >= minBorrow, \"UToken: amount less than loan size min\");\n\n        require(amount <= getRemainingLoanSize(), \"UToken: amount more than loan global size max\");\n\n        uint256 fee = calculatingFee(amount);\n        require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, \"UToken: amount large than borrow size max\");\n\n        require(!checkIsOverdue(msg.sender), \"UToken: Member has loans overdue\");\n\n        require(amount <= assetManagerContract.getLoanableAmount(underlying), \"UToken: Not enough to lend out\");\n        require(\n            uint256(_getCreditLimit(msg.sender)) >= amount + fee,\n            \"UToken: The loan amount plus fee is greater than credit limit\"\n        );\n\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n\n        uint256 borrowedAmount = borrowBalanceStoredInternal(msg.sender);\n\n        //Set lastRepay init data\n        if (accountBorrows[msg.sender].lastRepay == 0) {\n            accountBorrows[msg.sender].lastRepay = getBlockNumber();\n        }\n\n        uint256 accountBorrowsNew = borrowedAmount + amount + fee;\n        uint256 totalBorrowsNew = totalBorrows + amount + fee;\n        uint256 oldPrincipal = accountBorrows[msg.sender].principal;\n\n        accountBorrows[msg.sender].principal += amount + fee;\n        uint256 newPrincipal = accountBorrows[msg.sender].principal;\n        IUserManager(userManager).updateLockedData(msg.sender, newPrincipal - oldPrincipal, true);\n        accountBorrows[msg.sender].interest = accountBorrowsNew - accountBorrows[msg.sender].principal;\n        accountBorrows[msg.sender].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n        // The origination fees contribute to the reserve\n        totalReserves += fee;\n\n        require(assetManagerContract.withdraw(underlying, msg.sender, amount), \"UToken: Failed to withdraw\");\n\n        emit LogBorrow(msg.sender, amount, fee);\n    }\n}\n\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2021-10-union#h-01-borrow-must-accrueinterest-first",
                "Location": "   function borrow(uint256 amount) external onlyMember(msg.sender) whenNotPaused nonReentrant {\n        IAssetManager assetManagerContract = IAssetManager(assetManager);\n        require(amount >= minBorrow, \"UToken: amount less than loan size min\");\n\n        require(amount <= getRemainingLoanSize(), \"UToken: amount more than loan global size max\");\n\n        uint256 fee = calculatingFee(amount);\n        require(borrowBalanceView(msg.sender) + amount + fee <= maxBorrow, \"UToken: amount large than borrow size max\");\n\n        require(!checkIsOverdue(msg.sender), \"UToken: Member has loans overdue\");\n\n        require(amount <= assetManagerContract.getLoanableAmount(underlying), \"UToken: Not enough to lend out\");\n        require(\n            uint256(_getCreditLimit(msg.sender)) >= amount + fee,\n            \"UToken: The loan amount plus fee is greater than credit limit\"\n        );\n\n        require(accrueInterest(), \"UToken: accrue interest failed\");\n\n        uint256 borrowedAmount = borrowBalanceStoredInternal(msg.sender);\n\n        //Set lastRepay init data\n        if (accountBorrows[msg.sender].lastRepay == 0) {\n            accountBorrows[msg.sender].lastRepay = getBlockNumber();\n        }\n\n        uint256 accountBorrowsNew = borrowedAmount + amount + fee;\n        uint256 totalBorrowsNew = totalBorrows + amount + fee;\n        uint256 oldPrincipal = accountBorrows[msg.sender].principal;\n\n        accountBorrows[msg.sender].principal += amount + fee;\n        uint256 newPrincipal = accountBorrows[msg.sender].principal;\n        IUserManager(userManager).updateLockedData(msg.sender, newPrincipal - oldPrincipal, true);\n        accountBorrows[msg.sender].interest = accountBorrowsNew - accountBorrows[msg.sender].principal;\n        accountBorrows[msg.sender].interestIndex = borrowIndex;\n        totalBorrows = totalBorrowsNew;\n        // The origination fees contribute to the reserve\n        totalReserves += fee;\n\n        require(assetManagerContract.withdraw(underlying, msg.sender, amount), \"UToken: Failed to withdraw\");\n\n        emit LogBorrow(msg.sender, amount, fee);\n    }",
                "Type": "Erroneous state updates",
                "Description": "Incorrect calculating order. The UToken.borrow function first checks the borrowed balance and the old credit limit before accruing the actual interest on the market. Thus the borrowed balance of the user does not include the latest interest as it uses the old global borrowIndex but the new borrowIndex is only set in accrueInterest.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/ICreditLimitModel.sol\";\n\ncontract CreditLimitByMedian is Ownable, ICreditLimitModel {\n using Math for uint256;\n\n bool public constant override isCreditLimitModel = true;\n uint256 public override effectiveNumber;\n\n constructor(uint256 effectiveNumber_) {\n  effectiveNumber = effectiveNumber_;\n }\n\n function getCreditLimit(uint256[] memory vouchs) public view override returns (uint256) {\n  if (vouchs.length >= effectiveNumber) {\nreturn _findMedian(vouchs);\n  } else {\nreturn 0;\n  }\n }\n\n function getLockedAmount(\n  LockedInfo[] memory array,\n  address account,\n  uint256 amount,\n  bool isIncrease\n ) public pure override returns (uint256) {\n  if (array.length == 0) return 0;\n\n  uint256 newLockedAmount;\n  if (isIncrease) {\nfor (uint256 i = 0; i < array.length; i++) {\n uint256 remainingVouchingAmount;\n if (array[i].vouchingAmount > array[i].lockedAmount) {\n  remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;\n } else {\n  remainingVouchingAmount = 0;\n }\n\n if (remainingVouchingAmount > array[i].availableStakingAmount) {\n  if (array[i].availableStakingAmount > amount) {\nnewLockedAmount = array[i].lockedAmount + amount;\n  } else {\nnewLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;\n  }\n } else {\n  if (remainingVouchingAmount > amount) {\nnewLockedAmount = array[i].lockedAmount + amount;\n  } else {\nnewLockedAmount = array[i].lockedAmount + remainingVouchingAmount;\n  }\n }\n\n if (account == array[i].staker) {\n  return newLockedAmount;\n }\n}\n  } else {\nfor (uint256 i = 0; i < array.length; i++) {\n if (array[i].lockedAmount > amount) {\n // Incorrect order\n newLockedAmount = array[i].lockedAmount - 1;\n } else {\n  newLockedAmount = 0;\n }\n\n if (account == array[i].staker) {\n  return newLockedAmount;\n }\n}\n  }\n\n  return 0;\n }\n\n function setEffectNumber(uint256 number) external onlyOwner {\n  effectiveNumber = number;\n }\n\n /**\n  *  @dev Find median from uint array\n  *  @param array array\n  *  @return uint256\n  */\n function _findMedian(uint256[] memory array) private pure returns (uint256) {\n  uint256[] memory arr = _sortArray(array);\n  if (arr.length == 0) return 0;\n\n  if (arr.length % 2 == 0) {\nuint256 num1 = arr[arr.length >> 1];\nuint256 num2 = arr[(arr.length >> 1) - 1];\nreturn num1.average(num2);\n  } else {\nreturn arr[arr.length >> 1];\n  }\n }\n\n /**\n  *  @dev Sort uint array\n  *  @param arr array\n  *  @return uint256 array\n  */\n function _sortArray(uint256[] memory arr) private pure returns (uint256[] memory) {\n  uint256 length = arr.length;\n\n  for (uint256 i = 0; i < length; i++) {\nfor (uint256 j = i + 1; j < length; j++) {\n if (arr[i] < arr[j]) {\n  uint256 temp = arr[j];\n  arr[j] = arr[i];\n  arr[i] = temp;\n }\n}\n  }\n\n  return arr;\n }\n}",
        "VulnerabilityDesc": [
            {
                "Name": " https://code4rena.com/reports/2021-10-union#h-02-wrong-implementation-of-creditlimitbymediansolgetlockedamount-makes-it-unable-to-unlock-lockedamount-in-creditlimitbymedian-model",
                "Location": "    function getLockedAmount(\n        LockedInfo[] memory array,\n        address account,\n        uint256 amount,\n        bool isIncrease\n    ) public pure override returns (uint256) {\n        if (array.length == 0) return 0;\n\n        uint256 newLockedAmount;\n        if (isIncrease) {\n            for (uint256 i = 0; i < array.length; i++) {\n                uint256 remainingVouchingAmount;\n                if (array[i].vouchingAmount > array[i].lockedAmount) {\n                    remainingVouchingAmount = array[i].vouchingAmount - array[i].lockedAmount;\n                } else {\n                    remainingVouchingAmount = 0;\n                }\n\n                if (remainingVouchingAmount > array[i].availableStakingAmount) {\n                    if (array[i].availableStakingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + array[i].availableStakingAmount;\n                    }\n                } else {\n                    if (remainingVouchingAmount > amount) {\n                        newLockedAmount = array[i].lockedAmount + amount;\n                    } else {\n                        newLockedAmount = array[i].lockedAmount + remainingVouchingAmount;\n                    }\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        } else {\n            for (uint256 i = 0; i < array.length; i++) {\n                if (array[i].lockedAmount > amount) {\n                    newLockedAmount = array[i].lockedAmount - 1;\n                } else {\n                    newLockedAmount = 0;\n                }\n\n                if (account == array[i].staker) {\n                    return newLockedAmount;\n                }\n            }\n        }\n\n        return 0;\n    }",
                "Type": "Erroneous state updates",
                "Description": "Incorrect calculating order. getLockedAmount() is used by UserManager.sol#updateLockedData() to update locked amounts. Based on the context, at L66, newLockedAmount = array[i].lockedAmount - 1; should be newLockedAmount = array[i].lockedAmount - amount;. The current implementation is wrong and makes it impossible to unlock lockedAmount in CreditLimitByMedian model.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "contract MasterChef is Ownable, ReentrancyGuard {\n    using SafeMath for uint;\n    using SafeERC20 for IERC20;\n\n    event Deposit(address indexed _user, uint indexed _pid, uint _amount);\n    event Withdraw(address indexed _user, uint indexed _pid, uint _amount);\n    event EmergencyWithdraw(address indexed user, uint indexed _pid, uint _amount);\n\n    struct UserInfo {\n        uint128 amount;\n        uint128 rewardDebt;\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 depositToken;\n        uint allocPoint;\n        uint lastRewardBlock;\n        uint accConcurPerShare;\n        uint16 depositFeeBP;\n    }\n\n    PoolInfo[] public poolInfo;\n    mapping(uint => mapping(address => UserInfo)) public userInfo;\n    mapping(address => bool) public isDepositor;\n    mapping(address => uint256) public pid;\n    uint public concurPerBlock = 100000 gwei;\n    uint public totalAllocPoint = 0;\n    uint public startBlock;\n    uint public endBlock;\n    IERC20 public concur;\n\n    uint private _concurShareMultiplier = 1e18;\n    uint private _perMille = 1000; // 100%\n\n    constructor(IERC20 _concur, uint _startBlock, uint _endBlock) Ownable() {\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n        concur = _concur;\n        poolInfo.push(\n            PoolInfo({\n            depositToken: IERC20(address(0)),\n            allocPoint : 0,\n            lastRewardBlock : _startBlock,\n            accConcurPerShare : 0,\n            depositFeeBP : 0\n        }));\n    }\n\n    modifier onlyDepositor() {\n        require(isDepositor[msg.sender], \"!depositor\");\n        _;\n    }\n\n    function getMultiplier(uint _from, uint _to) public pure returns (uint) {\n        return _to.sub(_from);\n    }\n\n    function updatePool(uint _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint lpSupply = pool.depositToken.balanceOf(address(this));\n        if (lpSupply == 0 || pool.allocPoint == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        if(block.number >= endBlock) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }        \n\n        uint multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint concurReward = multiplier.mul(concurPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        pool.accConcurPerShare = pool.accConcurPerShare.add(concurReward.mul(_concurShareMultiplier).div(lpSupply));\n        pool.lastRewardBlock = block.number;\n    }\n\n    function deposit(address _recipient, uint _pid, uint _amount) external nonReentrant onlyDepositor {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_msgSender()];\n        updatePool(_pid);\n       \n        if(user.amount > 0) {  \n            uint pending = user.amount * pool.accConcurPerShare / _concurShareMultiplier - user.rewardDebt;\n            if (pending > 0) {\n                safeConcurTransfer(_recipient, pending);\n            }\n        }\n\n        if (_amount > 0) {\n       // Incorrect order\n     if (pool.depositFeeBP > 0) {\n                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);\n                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);\n            } else {\n                user.amount = SafeCast.toUint128(user.amount + _amount);\n            }\n        }     \n\n        user.rewardDebt = SafeCast.toUint128(user.amount * pool.accConcurPerShare / _concurShareMultiplier);\n        emit Deposit(_recipient, _pid, _amount);\n    }\n\n    function safeConcurTransfer(address _to, uint _amount) private {\n        uint concurBalance = concur.balanceOf(address(this));\n        bool transferSuccess = false;\n        if (_amount > concurBalance) {\n            transferSuccess = concur.transfer(_to, concurBalance);\n        } else {\n            transferSuccess = concur.transfer(_to, _amount);\n        }\n        require(transferSuccess, \"safeConcurTransfer: transfer failed\");\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "https://code4rena.com/reports/2022-02-concur#h-02-masterchef-improper-handling-of-deposit-fee",
                "Location": "            if (pool.depositFeeBP > 0) {\n                uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);\n                user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);",
                "Type": "Erroneous state updates",
                "Description": "Incorrect calculating order. If a pool\ufffd\ufffds deposit fee is non-zero, it is subtracted from the amount to be credited to the user. However, the deposit fee is not credited to anyone, leading to permanent lockups of deposit fees in the relevant depositor contracts (StakingRewards and ConvexStakingWrapper for now).",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract EthLoan {\n    struct Loan {\n        uint256 amount;\n        uint256 startBlock;\n    }\n\n    uint256 public interestRatePerBlock = 1;  // 0.01% per block as an example\n    mapping(address => Loan) public loans;\n\n    event LoanTaken(address indexed user, uint256 amount);\n\n    function takeLoan(uint256 amount) external payable {\n        require(msg.value == amount, \"Amount mismatch!\");\n        \n        // Vulnerability: Calculate and update interest before setting the new start block\n        if (loans[msg.sender].amount != 0) {\n            uint256 interest = (block.number - loans[msg.sender].startBlock) * interestRatePerBlock * loans[msg.sender].amount / 10000;\n            loans[msg.sender].amount += interest;\n        }\n        \n        loans[msg.sender].amount += amount;\n        loans[msg.sender].startBlock = block.number;\n\n        emit LoanTaken(msg.sender, amount);\n    }\n\n    function repayLoan() external payable {\n        require(loans[msg.sender].amount > 0, \"No loan taken.\");\n        uint256 totalDue = loans[msg.sender].amount + (block.number - loans[msg.sender].startBlock) * interestRatePerBlock * loans[msg.sender].amount / 10000;\n        require(msg.value >= totalDue, \"Not enough to cover the loan and interest.\");\n\n        payable(msg.sender).transfer(msg.value - totalDue);  // Refund any excess\n        delete loans[msg.sender];  // Clear the loan\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "201",
                "Location": "if (loans[msg.sender].amount != 0) {\n            uint256 interest = (block.number - loans[msg.sender].startBlock) * interestRatePerBlock * loans[msg.sender].amount / 10000;\n            loans[msg.sender].amount += interest;\n        }\n        \n        loans[msg.sender].amount += amount;\n        loans[msg.sender].startBlock = block.number;\n",
                "Type": "Incorrect calculating order",
                "Description": "A contract allows users to loan Ethereum, receiving interest over time. The interest is calculated based on the number of blocks since the loan was taken. A vulnerability arises due to the incorrect order in which the interest calculation and user balance update occur.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract EthDepositReward {\n    uint256 public totalDeposits;\n    uint256 public tokenPrice = 1 ether;  // Starting token price as 1 ETH for simplicity.\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public rewards;\n\n    event Deposited(address indexed user, uint256 amount, uint256 rewardAmount);\n\n    function deposit() external payable {\n        require(msg.value > 0, \"Deposit value should be greater than 0\");\n        \n        // Vulnerability: Updating token price before calculating the reward.\n        tokenPrice = totalDeposits / 1000;  // Example: The more total deposits, the lesser the token price.\n        uint256 rewardAmount = msg.value / tokenPrice;\n\n        balances[msg.sender] += msg.value;\n        totalDeposits += msg.value;\n        rewards[msg.sender] += rewardAmount;\n\n        emit Deposited(msg.sender, msg.value, rewardAmount);\n    }\n    \n    // Additional functions would be here...\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "202",
                "Location": "tokenPrice = totalDeposits / 1000;  // Example: The more total deposits, the lesser the token price.\n        uint256 rewardAmount = msg.value / tokenPrice;\n\n        balances[msg.sender] += msg.value;\n        totalDeposits += msg.value;\n        rewards[msg.sender] += rewardAmount;",
                "Type": "Incorrect calculating order",
                "Description": "A contract allows users to deposit Ethereum and rewards them with a token. The number of tokens they receive is calculated based on the current token price. However, there's a vulnerability due to the incorrect order of updating the total deposit balance and the current token price.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SimpleStaking {\n    uint256 public rewardRate = 1e18;  // For simplicity, let's say 1 token reward per second.\n\n    struct User {\n        uint256 balance;\n        uint256 lastClaimTime;\n    }\n\n    mapping(address => User) public users;\n\n    event RewardClaimed(address indexed user, uint256 amount);\n\n    function stake(uint256 amount) external {\n        // Assume a transfer function exists that moves tokens into the contract\n        // For simplicity, it's omitted here.\n        \n        User storage user = users[msg.sender];\n        user.balance += amount;\n        user.lastClaimTime = block.timestamp;\n    }\n\n    function claimReward() external {\n        User storage user = users[msg.sender];\n        \n        // Vulnerability: Updating lastClaimTime before calculating the reward.\n        uint256 timeElapsed = block.timestamp - user.lastClaimTime;\n        user.lastClaimTime = block.timestamp;\n        uint256 reward = timeElapsed * rewardRate;\n\n        require(reward <= user.balance, \"Not enough tokens to give as reward\");\n\n        // Simulate the transfer of reward to the user\n        user.balance -= reward;\n\n        emit RewardClaimed(msg.sender, reward);\n    }\n\n    // Additional functions would be here...\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "203",
                "Location": "uint256 timeElapsed = block.timestamp - user.lastClaimTime;\n        user.lastClaimTime = block.timestamp;\n        uint256 reward = timeElapsed * rewardRate;\n\n        require(reward <= user.balance, \"Not enough tokens to give as reward\");\n\n        // Simulate the transfer of reward to the user\n        user.balance -= reward;",
                "Type": "Incorrect calculating order",
                "Description": "In a simple staking contract, users can stake tokens and after a certain time, they can claim their rewards which are calculated based on the total time staked. However, there is a vulnerability in the claimReward function due to the incorrect order of updating the user's last claim time and calculating the reward.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SimpleSavings {\n    uint256 public interestRate = 1e15;  // Representing 0.1% interest per second for simplicity.\n\n    struct Account {\n        uint256 balance;\n        uint256 lastDepositTime;\n    }\n\n    mapping(address => Account) public accounts;\n\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function deposit(uint256 amount) external {\n        // Assume a function that transfers tokens into the contract exists.\n        // Omitted for brevity.\n\n        Account storage userAccount = accounts[msg.sender];\n        userAccount.balance += amount;\n        userAccount.lastDepositTime = block.timestamp;\n    }\n\n    function withdraw(uint256 amount) external {\n        Account storage userAccount = accounts[msg.sender];\n        \n        // Vulnerability: Calculating interest before updating the lastDepositTime.\n        uint256 timeElapsed = block.timestamp - userAccount.lastDepositTime;\n        uint256 interest = userAccount.balance * interestRate * timeElapsed;\n        userAccount.lastDepositTime = block.timestamp;\n        \n        uint256 totalWithdrawal = amount + interest;\n        require(totalWithdrawal <= userAccount.balance, \"Insufficient balance\");\n\n        // Simulate the transfer of the withdrawal amount to the user.\n        userAccount.balance -= totalWithdrawal;\n\n        emit Withdrawn(msg.sender, totalWithdrawal);\n    }\n\n    // ... other functions.\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "204",
                "Location": "uint256 timeElapsed = block.timestamp - userAccount.lastDepositTime;\n        uint256 interest = userAccount.balance * interestRate * timeElapsed;\n        userAccount.lastDepositTime = block.timestamp;\n        \n        uint256 totalWithdrawal = amount + interest;\n        require(totalWithdrawal <= userAccount.balance, \"Insufficient balance\");\n\n        // Simulate the transfer of the withdrawal amount to the user.\n        userAccount.balance -= totalWithdrawal;",
                "Type": "Incorrect calculating order",
                "Description": "A savings contract allows users to deposit tokens. The interest is calculated based on the total time the tokens have been held. The flaw is in the withdraw function, which calculates interest before updating the user's last deposit time, allowing users to potentially exploit the contract by frequently withdrawing and depositing.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract EventTickets {\n    struct Event {\n        string name;\n        uint256 ticketPrice;\n        uint256 totalTickets;\n        uint256 ticketsSold;\n    }\n\n    mapping(uint256 => Event) public events;\n    uint256 public nextEventId = 0;\n\n    event TicketPurchased(uint256 eventId, address buyer, uint256 amount);\n\n    function createEvent(string calldata _name, uint256 _ticketPrice, uint256 _totalTickets) external {\n        events[nextEventId] = Event({\n            name: _name,\n            ticketPrice: _ticketPrice,\n            totalTickets: _totalTickets,\n            ticketsSold: 0\n        });\n\n        nextEventId++;\n    }\n\n    function buyTicket(uint256 _eventId, uint256 _amount) external payable {\n        Event storage chosenEvent = events[_eventId];\n        \n        // Assuming we can do ERC20 transfers or similar. Here we just use ether for simplicity.\n        require(msg.value == chosenEvent.ticketPrice * _amount, \"Incorrect Ether sent\");\n\n        // Vulnerability: Decreasing tickets before checking availability.\n        chosenEvent.ticketsSold += _amount;\n\n        require(chosenEvent.ticketsSold <= chosenEvent.totalTickets, \"Not enough tickets available\");\n\n        emit TicketPurchased(_eventId, msg.sender, _amount);\n    }\n\n    // ... other functions for refunding, event management etc.\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "205",
                "Location": "require(msg.value == chosenEvent.ticketPrice * _amount, \"Incorrect Ether sent\");\n\n        // Vulnerability: Decreasing tickets before checking availability.\n        chosenEvent.ticketsSold += _amount;\n\n        require(chosenEvent.ticketsSold <= chosenEvent.totalTickets, \"Not enough tickets available\");\n",
                "Type": "Incorrect calculating order",
                "Description": "The contract flaw is in the buyTicket function: the contract checks if the event has enough tickets after it decrements the number of available tickets, allowing users to potentially purchase more tickets than available.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VulnerableWallet {\n    mapping(address => uint256) public balances;\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance!\");\n\n        // Vulnerability: Sending ether before updating the balance\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed!\");\n\n        balances[msg.sender] -= _amount;\n        emit Withdrawn(msg.sender, _amount);\n    }\n\n    // ... other potential functions\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "206",
                "Location": "(bool success, ) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed!\");\n\n        balances[msg.sender] -= _amount;",
                "Type": "Incorrect calculating order",
                "Description": " The contract flaw is in the withdraw function: the contract sends the funds to the user before decrementing the user's balance, making it vulnerable to a reentrancy attack.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VulnerableAuction {\n    address public highestBidder;\n    uint256 public highestBid;\n\n    event HighestBidIncreased(address indexed bidder, uint256 amount);\n\n    function bid() external payable {\n        require(msg.value > highestBid, \"There's already a higher bid.\");\n\n        // Vulnerability: Refunding before updating the state\n        if (highestBidder != address(0)) {\n            (bool success, ) = highestBidder.call{value: highestBid}(\"\");\n            require(success, \"Failed to send back the ether!\");\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n        emit HighestBidIncreased(msg.sender, msg.value);\n    }\n\n    // ... other functions like auction end, withdrawal, etc.\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "207",
                "Location": "if (highestBidder != address(0)) {\n            (bool success, ) = highestBidder.call{value: highestBid}(\"\");\n            require(success, \"Failed to send back the ether!\");\n        }\n\n        highestBidder = msg.sender;\n        highestBid = msg.value;",
                "Type": "Incorrect calculating order",
                "Description": "he vulnerability arises from updating the state of the highest bid after refunding the previous highest bidder. This could allow potential reentrancy attacks.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VulnerableRewardPool {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n    uint256 public globalInterestRate = 1e18;\n\n    function deposit(uint256 amount) external {\n        // Update user balance\n        balances[msg.sender] += amount;\n\n        // Incorrect order: Updating global rate after user balance\n        updateGlobalInterestRate();\n        \n        totalSupply += amount;\n    }\n\n    function claimRewards() external {\n        uint256 reward = balances[msg.sender] * globalInterestRate;\n        balances[msg.sender] += reward;\n\n        // Incorrect order: Updating global rate after user balance\n        updateGlobalInterestRate();\n    }\n\n    function updateGlobalInterestRate() internal {\n        // Assume some logic to increase global interest rate, e.g., 1% increment\n        globalInterestRate += globalInterestRate / 100;\n    }\n\n    // ... other functions\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "208",
                "Location": "balances[msg.sender] += amount;\n\n        // Incorrect order: Updating global rate after user balance\n        updateGlobalInterestRate();\n        \n        totalSupply += amount;",
                "Type": "Incorrect calculating order",
                "Description": "The vulnerability arises when calculating and distributing rewards. The contract updates user balance before updating the global interest rate, which means users can potentially claim more rewards than they should be able to.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VulnerableLottery {\n    mapping(address => uint256) public balances;\n    uint256 public totalDeposits;\n    uint256 constant interestRate = 105; // 5% interest\n\n    function deposit(uint256 amount) external {\n        // Incorrect order: Updating the principal deposit before adding the interest\n        balances[msg.sender] += amount;\n        applyInterest(msg.sender);\n        \n        totalDeposits += amount;\n    }\n\n    function applyInterest(address user) internal {\n        balances[user] = (balances[user] * interestRate) / 100;\n    }\n\n    // ... other functions like drawing a winner, etc.\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "209",
                "Location": " balances[msg.sender] += amount;\n        applyInterest(msg.sender);\n        \n        totalDeposits += amount;",
                "Type": "Incorrect calculating order",
                "Description": "Each deposit also earns a small interest for the user. However, the contract updates the user's principal deposit before applying the interest, leading to incorrect final balances.",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VulnerableBank {\n    mapping(address => uint256) public balances;\n    uint256 public totalDeposits;\n    uint256 constant loyaltyBonus = 10;  // 10 tokens bonus for each deposit\n\n    function deposit(uint256 amount) external {\n        balances[msg.sender] += amount;  // Incorrect order: updating balance before adding the bonus\n        giveLoyaltyBonus(msg.sender);\n        totalDeposits += amount;\n    }\n\n    function giveLoyaltyBonus(address user) internal {\n        balances[user] += loyaltyBonus;\n    }\n\n    // ... other functions like withdrawals, etc.\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "210",
                "Location": "balances[msg.sender] += amount;  // Incorrect order: updating balance before adding the bonus\n        giveLoyaltyBonus(msg.sender);\n        totalDeposits += amount;",
                "Type": "Incorrect calculating order",
                "Description": "The contract offers a loyalty bonus to its users every time they deposit funds. However, the bonus is incorrectly added after updating the user's balance instead of before, leading to miscalculated total deposits.",
                "Repair": ""
            }
        ]
    }
 ]
