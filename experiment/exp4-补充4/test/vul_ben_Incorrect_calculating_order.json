[
  {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract EthLoan {\n    struct Loan {\n        uint256 amount;\n        uint256 startBlock;\n    }\n\n    uint256 public interestRatePerBlock = 1;  // 0.01% per block as an example\n    mapping(address => Loan) public loans;\n\n    event LoanTaken(address indexed user, uint256 amount);\n\n    function takeLoan(uint256 amount) external payable {\n        require(msg.value == amount, \"Amount mismatch!\");\n\n        // Fix: Update start block first to avoid malicious exploitation of the interest calculation\n        uint256 oldStartBlock = loans[msg.sender].startBlock;\n        loans[msg.sender].startBlock = block.number;\n\n        if (loans[msg.sender].amount != 0) {\n            uint256 interest = (block.number - oldStartBlock) * interestRatePerBlock * loans[msg.sender].amount / 10000;\n            loans[msg.sender].amount += interest;\n        }\n        \n        loans[msg.sender].amount += amount;\n\n        emit LoanTaken(msg.sender, amount);\n    }\n\n    function repayLoan() external payable {\n        require(loans[msg.sender].amount > 0, \"No loan taken.\");\n        uint256 totalDue = loans[msg.sender].amount + (block.number - loans[msg.sender].startBlock) * interestRatePerBlock * loans[msg.sender].amount / 10000;\n        require(msg.value >= totalDue, \"Not enough to cover the loan and interest.\");\n\n        payable(msg.sender).transfer(msg.value - totalDue);  // Refund any excess\n        delete loans[msg.sender];  // Clear the loan\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_201",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract EthDepositReward {\n    uint256 public totalDeposits;\n    uint256 public tokenPrice = 1 ether;  // Starting token price as 1 ETH for simplicity.\n\n    mapping(address => uint256) public balances;\n    mapping(address => uint256) public rewards;\n\n    event Deposited(address indexed user, uint256 amount, uint256 rewardAmount);\n\n    function deposit() external payable {\n        require(msg.value > 0, \"Deposit value should be greater than 0\");\n\n        // Fix: Update totalDeposits first before recalculating token price.\n        totalDeposits += msg.value;\n        tokenPrice = totalDeposits / 1000;  // Example: The more total deposits, the lesser the token price.\n        uint256 rewardAmount = msg.value / tokenPrice;\n\n        balances[msg.sender] += msg.value;\n        rewards[msg.sender] += rewardAmount;\n\n        emit Deposited(msg.sender, msg.value, rewardAmount);\n    }\n    \n    // Additional functions would be here...\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_202",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SimpleStaking {\n    uint256 public rewardRate = 1e18;  // For simplicity, let's say 1 token reward per second.\n\n    struct User {\n        uint256 balance;\n        uint256 lastClaimTime;\n    }\n\n    mapping(address => User) public users;\n\n    event RewardClaimed(address indexed user, uint256 amount);\n\n    function stake(uint256 amount) external {\n        // Assume a transfer function exists that moves tokens into the contract\n        // For simplicity, it's omitted here.\n        \n        User storage user = users[msg.sender];\n        user.balance += amount;\n        user.lastClaimTime = block.timestamp;\n    }\n\n    function claimReward() external {\n        User storage user = users[msg.sender];\n        \n        // Fix: Calculate the reward before updating the lastClaimTime.\n        uint256 timeElapsed = block.timestamp - user.lastClaimTime;\n        uint256 reward = timeElapsed * rewardRate;\n        user.lastClaimTime = block.timestamp;\n\n        require(reward <= user.balance, \"Not enough tokens to give as reward\");\n\n        // Simulate the transfer of reward to the user\n        user.balance -= reward;\n\n        emit RewardClaimed(msg.sender, reward);\n    }\n\n    // Additional functions would be here...\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_203",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SimpleSavings {\n    uint256 public interestRate = 1e15;  // Representing 0.1% interest per second for simplicity.\n\n    struct Account {\n        uint256 balance;\n        uint256 lastDepositTime;\n    }\n\n    mapping(address => Account) public accounts;\n\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function deposit(uint256 amount) external {\n        // Assume a function that transfers tokens into the contract exists.\n        // Omitted for brevity.\n\n        Account storage userAccount = accounts[msg.sender];\n        userAccount.balance += amount;\n        userAccount.lastDepositTime = block.timestamp;\n    }\n\n    function withdraw(uint256 amount) external {\n        Account storage userAccount = accounts[msg.sender];\n        \n        // Fix: Update the lastDepositTime before calculating the interest.\n        uint256 timeElapsed = block.timestamp - userAccount.lastDepositTime;\n        userAccount.lastDepositTime = block.timestamp;\n        uint256 interest = userAccount.balance * interestRate * timeElapsed;\n        \n        uint256 totalWithdrawal = amount + interest;\n        require(totalWithdrawal <= userAccount.balance, \"Insufficient balance\");\n\n        // Simulate the transfer of the withdrawal amount to the user.\n        userAccount.balance -= totalWithdrawal;\n\n        emit Withdrawn(msg.sender, totalWithdrawal);\n    }\n\n    // ... other functions.\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_204",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract EventTickets {\n    struct Event {\n        string name;\n        uint256 ticketPrice;\n        uint256 totalTickets;\n        uint256 ticketsSold;\n    }\n\n    mapping(uint256 => Event) public events;\n    uint256 public nextEventId = 0;\n\n    event TicketPurchased(uint256 eventId, address buyer, uint256 amount);\n\n    function createEvent(string calldata _name, uint256 _ticketPrice, uint256 _totalTickets) external {\n        events[nextEventId] = Event({\n            name: _name,\n            ticketPrice: _ticketPrice,\n            totalTickets: _totalTickets,\n            ticketsSold: 0\n        });\n\n        nextEventId++;\n    }\n\n    function buyTicket(uint256 _eventId, uint256 _amount) external payable {\n        Event storage chosenEvent = events[_eventId];\n        \n        // Assuming we can do ERC20 transfers or similar. Here we just use ether for simplicity.\n        require(msg.value == chosenEvent.ticketPrice * _amount, \"Incorrect Ether sent\");\n\n        // Fix: Check ticket availability before updating the ticketsSold.\n        require(chosenEvent.ticketsSold + _amount <= chosenEvent.totalTickets, \"Not enough tickets available\");\n\n        chosenEvent.ticketsSold += _amount;\n\n        emit TicketPurchased(_eventId, msg.sender, _amount);\n    }\n\n    // ... other functions for refunding, event management etc.\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_205",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SecureWallet {\n    mapping(address => uint256) public balances;\n\n    event Deposited(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance!\");\n\n        // Fix: Decrease the balance before sending the ether\n        balances[msg.sender] -= _amount;\n\n        (bool success, ) = msg.sender.call{value: _amount}(\"\");\n        require(success, \"Transfer failed!\");\n\n        emit Withdrawn(msg.sender, _amount);\n    }\n\n    // ... other potential functions\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_206",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SecureAuction {\n    address public highestBidder;\n    uint256 public highestBid;\n\n    event HighestBidIncreased(address indexed bidder, uint256 amount);\n\n    function bid() external payable {\n        require(msg.value > highestBid, \"There's already a higher bid.\");\n\n        address previousHighestBidder = highestBidder;\n        uint256 refundAmount = highestBid;\n\n        // Fix: Update the state before any transfer\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n        emit HighestBidIncreased(msg.sender, msg.value);\n\n        if (previousHighestBidder != address(0)) {\n            (bool success, ) = previousHighestBidder.call{value: refundAmount}(\"\");\n            require(success, \"Failed to send back the ether!\");\n        }\n\n        // ... other functions like auction end, withdrawal, etc.\n    }\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_207",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SecureRewardPool {\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n    uint256 public globalInterestRate = 1e18;\n\n    function deposit(uint256 amount) external {\n        // Fix: Update global rate before user balance\n        updateGlobalInterestRate();\n\n        // Update user balance\n        balances[msg.sender] += amount;\n        \n        totalSupply += amount;\n    }\n\n    function claimRewards() external {\n        // Fix: Update global rate before user balance\n        updateGlobalInterestRate();\n\n        uint256 reward = balances[msg.sender] * globalInterestRate;\n        balances[msg.sender] += reward;\n    }\n\n    function updateGlobalInterestRate() internal {\n        // Assume some logic to increase global interest rate, e.g., 1% increment\n        globalInterestRate += globalInterestRate / 100;\n    }\n\n    // ... other functions\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_208",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SecureLottery {\n    mapping(address => uint256) public balances;\n    uint256 public totalDeposits;\n    uint256 constant interestRate = 105; // 5% interest\n\n    function deposit(uint256 amount) external {\n        // Fix: Apply interest before updating the principal deposit\n        applyInterest(msg.sender);\n        balances[msg.sender] += amount;\n        \n        totalDeposits += amount;\n    }\n\n    function applyInterest(address user) internal {\n        balances[user] = (balances[user] * interestRate) / 100;\n    }\n\n    // ... other functions like drawing a winner, etc.\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_209",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    },
    {
        "Code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract FixedBank {\n    mapping(address => uint256) public balances;\n    uint256 public totalDeposits;\n    uint256 constant loyaltyBonus = 10;  // 10 tokens bonus for each deposit\n\n    function deposit(uint256 amount) external {\n        giveLoyaltyBonus(msg.sender);  // Fix: Add loyalty bonus before updating balance\n        balances[msg.sender] += amount;\n        totalDeposits += (amount + loyaltyBonus);  // Also consider the loyalty bonus in total deposits\n    }\n\n    function giveLoyaltyBonus(address user) internal {\n        balances[user] += loyaltyBonus;\n    }\n\n    // ... other functions like withdrawals, etc.\n}\n",
        "VulnerabilityDesc": [
            {
                "Name": "ben_210",
                "Location": "",
                "Type": "Incorrect calculating order",
                "Description": "",
                "Repair": ""
            }
        ]
    }
]