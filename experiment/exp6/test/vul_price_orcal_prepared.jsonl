{"prompt":"pragma solidity 0.8.3;\ncontract Pool is iBEP20 {  \n address public BASE;\n address public TOKEN;\n address public DEPLOYER;\n string _name; string _symbol;\n uint8 public override decimals; uint256 public override totalSupply;\n mapping(address => uint) private _balances;\n mapping(address => mapping(address => uint)) private _allowances;\n uint256 public baseAmount; \n uint256 public tokenAmount; \n uint private lastMonth; \n uint public genesis; \n uint256 public map30DPoolRevenue;\n uint256 public mapPast30DPoolRevenue;\n uint256 [] public revenueArray; \n function _DAO() internal view returns(iDAO) {\n  return iBASE(BASE).DAO();\n }\n\n constructor (address _base, address _token) {\n  BASE = _base;\n  TOKEN = _token;\n  string memory poolName = \"-SpartanProtocolPool\";\n  string memory poolSymbol = \"-SPP\";\n  _name = string(abi.encodePacked(iBEP20(_token).name(), poolName));\n  _symbol = string(abi.encodePacked(iBEP20(_token).symbol(), poolSymbol));\n  decimals = 18;\n  genesis = block.timestamp;\n  DEPLOYER = msg.sender;\n  lastMonth = 0;\n function addForMember(address member) public returns(uint liquidityUnits){\n  uint256 _actualInputBase = _getAddedBaseAmount();\n  uint256 _actualInputToken = _getAddedTokenAmount(); \n  if(baseAmount == 0 || tokenAmount == 0){\n  require(_actualInputBase != 0 && _actualInputToken != 0, \"!Balanced\");\n  }\n  liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnits(_actualInputBase, baseAmount, _actualInputToken, tokenAmount, totalSupply); \/\/ Calculate LP tokens to mint\n  _incrementPoolBalances(_actualInputBase, _actualInputToken); \n  _mint(member, liquidityUnits); \/\/ Mint the LP tokens directly to the user\n  emit AddLiquidity(member, _actualInputBase, _actualInputToken, liquidityUnits);\n  return liquidityUnits;\n }\n function swapTo(address token, address member) public payable returns (uint outputAmount, uint fee) {\n  require((token == BASE || token == TOKEN), \"!BASE||TOKEN\")\n  address _fromToken; uint _amount;\n  if(token == BASE){\n_fromToken = TOKEN; \n_amount = _getAddedTokenAmount(); \n(outputAmount, fee) = _swapTokenToBase(_amount);\n  } else {\n_fromToken = BASE; \n_amount = _getAddedBaseAmount(); \n(outputAmount, fee) = _swapBaseToToken(_amount); \n  }\n  emit Swapped(_fromToken, token, member, _amount, outputAmount, fee);\n  iBEP20(token).transfer(member, outputAmount); \n  return (outputAmount, fee);\n }\n\n\n function mintSynth(address synthOut, address member) external returns(uint outputAmount, uint fee) {\n  require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthOut) == true, \"!synth\"); \n  uint256 _actualInputBase = _getAddedBaseAmount(); \n  uint output = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputBase, baseAmount, tokenAmount);\n  uint _liquidityUnits = iUTILS(_DAO().UTILS()).calcLiquidityUnitsAsym(_actualInputBase, address(this)); \n  _incrementPoolBalances(_actualInputBase, 0);\n  uint _fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputBase, baseAmount, tokenAmount); \n  fee = iUTILS(_DAO().UTILS()).calcSpotValueInBase(TOKEN, _fee);\n  _mint(synthOut, _liquidityUnits); \n  iSYNTH(synthOut).mintSynth(member, output); \n  _addPoolMetrics(fee); \n  emit MintSynth(member, BASE, _actualInputBase, TOKEN, outputAmount);\nreturn (output, fee);\n }\n \n function burnSynth(address synthIN, address member) external returns(uint outputAmount, uint fee) {\n  require(iSYNTHFACTORY(_DAO().SYNTHFACTORY()).isSynth(synthIN) == true, \"!synth\"); \n  uint _actualInputSynth = iBEP20(synthIN).balanceOf(address(this)); \n  uint outputBase = iUTILS(_DAO().UTILS()).calcSwapOutput(_actualInputSynth, tokenAmount, baseAmount); \n  fee = iUTILS(_DAO().UTILS()).calcSwapFee(_actualInputSynth, tokenAmount, baseAmount);\n  iBEP20(synthIN).transfer(synthIN, _actualInputSynth); \n  iSYNTH(synthIN).burnSynth(); \n  _decrementPoolBalances(outputBase, 0); \n  iBEP20(BASE).transfer(member, outputBase); \n  _addPoolMetrics(fee);\n  emit BurnSynth(member, BASE, outputBase, TOKEN, _actualInputSynth);\nreturn (outputBase, fee);\n }\n function _getAddedBaseAmount() internal view returns(uint256 _actual){\n  uint _baseBalance = iBEP20(BASE).balanceOf(address(this)); \n  if(_baseBalance > baseAmount){\n_actual = _baseBalance-(baseAmount);\n  } else {\n_actual = 0;\n  }\n  return _actual;\n }\n }\n}\n\n###\n\n"}
{"prompt":"pragma solidity >0.7.0;\npragma experimental ABIEncoderV2;\nlibrary AssetHandler {\n using SafeMath for uint256;\n using SafeInt256 for int256;\n using CashGroup for CashGroupParameters;\n using AssetRate for AssetRateParameters;\n\n function isLiquidityToken(uint256 assetType) internal pure returns (bool) {\n  return\nassetType >= Constants.MIN_LIQUIDITY_TOKEN_INDEX &&\nassetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX;\n }\n function getSettlementDate(PortfolioAsset memory asset) internal pure returns (uint256) {\n  require(asset.assetType > 0 && asset.assetType <= Constants.MAX_LIQUIDITY_TOKEN_INDEX);\n\n  if (asset.assetType <= Constants.MIN_LIQUIDITY_TOKEN_INDEX) return asset.maturity;\n\n  uint256 marketLength = DateTime.getTradedMarket(asset.assetType - 1);\n\n  return asset.maturity.sub(marketLength).add(Constants.QUARTER);\n }\n function getCashClaims(PortfolioAsset memory token, MarketParameters memory market)\n  internal\n  pure\n  returns (int256 assetCash, int256 fCash)\n {\n  require(isLiquidityToken(token.assetType) && token.notional >= 0); \n\n  assetCash = market.totalAssetCash.mul(token.notional).div(market.totalLiquidity);\n  fCash = market.totalfCash.mul(token.notional).div(market.totalLiquidity);\n }\n function getHaircutCashClaims(\n  PortfolioAsset memory token,\n  MarketParameters memory market,\n  CashGroupParameters memory cashGroup\n ) internal pure returns (int256, int256) {\n  require(isLiquidityToken(token.assetType) && token.notional >= 0);\n\n  require(token.currencyId == cashGroup.currencyId); \n\n  int256 haircut = int256(cashGroup.getLiquidityHaircut(token.assetType));\n\n  int256 assetCash =\n_calcToken(market.totalAssetCash, token.notional, haircut, market.totalLiquidity);\n\n  int256 fCash =\n_calcToken(market.totalfCash, token.notional, haircut, market.totalLiquidity);\n\n  return (assetCash, fCash);\n }\n function getLiquidityTokenValue(\n  uint256 index,\n  CashGroupParameters memory cashGroup,\n  MarketParameters memory market,\n  PortfolioAsset[] memory assets,\n  uint256 blockTime,\n  bool riskAdjusted\n ) internal view returns (int256, int256) {\n  PortfolioAsset memory liquidityToken = assets[index];\n  require(isLiquidityToken(liquidityToken.assetType) && liquidityToken.notional >= 0); \n\n  {\n(uint256 marketIndex, bool idiosyncratic) =\n DateTime.getMarketIndex(\n  cashGroup.maxMarketIndex,\n  liquidityToken.maturity,\n  blockTime\n );\nrequire(!idiosyncratic);\n\n  \ncashGroup.loadMarket(market, marketIndex, true, blockTime);\n  }\n\n  int256 assetCashClaim;\n  int256 fCashClaim;\n  if (riskAdjusted) {\n(assetCashClaim, fCashClaim) = getHaircutCashClaims(liquidityToken, market, cashGroup);\n  } else {\n(assetCashClaim, fCashClaim) = getCashClaims(liquidityToken, market);\n  }\n  if (\nindex > 0 &&\nassets[index - 1].currencyId == liquidityToken.currencyId &&\nassets[index - 1].maturity == liquidityToken.maturity &&\nassets[index - 1].assetType == Constants.FCASH_ASSET_TYPE\n  ) {\nassets[index - 1].notional = assets[index - 1].notional.add(fCashClaim);\nreturn (assetCashClaim, 0);\n  }\n\n\n  if (riskAdjusted) {\nint256 pv =\n getRiskAdjustedPresentValue(\n  cashGroup,\n  fCashClaim,\n  liquidityToken.maturity,\n  blockTime,\n  market.oracleRate\n );\n\nreturn (assetCashClaim, pv);\n  } else {\nint256 pv =\n getPresentValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);\n\nreturn (assetCashClaim, pv);\n  }\n }\n\n}\n\n###\n\n"}
{"prompt":"pragma solidity =0.8.9;\ncontract VaderPoolV2 is IVaderPoolV2, BasePoolV2, Ownable {\n using SafeERC20 for IERC20;\n ILPWrapper public wrapper;\n ISynthFactory public synthFactory;\n bool public queueActive;\n constructor(bool _queueActive, IERC20 _nativeAsset)\n  BasePoolV2(_nativeAsset)\n {\n  queueActive = _queueActive;\n }\n function cumulativePrices(IERC20 foreignAsset)\n  public\n  view\n  returns (\nuint256 price0CumulativeLast,\nuint256 price1CumulativeLast,\nuint32 blockTimestampLast\n  )\n {\n  PriceCumulative memory priceCumulative = pairInfo[foreignAsset]\n.priceCumulative;\n  price0CumulativeLast = priceCumulative.nativeLast;\n  price1CumulativeLast = priceCumulative.foreignLast;\n  blockTimestampLast = pairInfo[foreignAsset].blockTimestampLast;\n }\n function initialize(\n  ILPWrapper _wrapper,\n  ISynthFactory _synthFactory,\n  address _router\n ) external onlyOwner {\n  require(\nwrapper == ILPWrapper(_ZERO_ADDRESS),\n\"VaderPoolV2::initialize: Already initialized\"\n  );\n  require(\n_wrapper != ILPWrapper(_ZERO_ADDRESS),\n\"VaderPoolV2::initialize: Incorrect Wrapper Specified\"\n  );\n  require(\n_synthFactory != ISynthFactory(_ZERO_ADDRESS),\n\"VaderPoolV2::initialize: Incorrect SynthFactory Specified\"\n  );\n  require(\n_router != _ZERO_ADDRESS,\n\"VaderPoolV2::initialize: Incorrect Router Specified\"\n  );\n  wrapper = _wrapper;\n  synthFactory = _synthFactory;\n  router = _router;\n }\n function mintSynth(\n  IERC20 foreignAsset,\n  uint256 nativeDeposit,\n  address from,\n  address to\n )\n  external\n  override\n  nonReentrant\n  supportedToken(foreignAsset)\n  returns (uint256 amountSynth)\n {\n  nativeAsset.safeTransferFrom(from, address(this), nativeDeposit);\n\n  ISynth synth = synthFactory.synths(foreignAsset);\n\n  if (synth == ISynth(_ZERO_ADDRESS))\nsynth = synthFactory.createSynth(\n IERC20Extended(address(foreignAsset))\n);\n\n  (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\nforeignAsset\n  ); \n  amountSynth = VaderMath.calculateSwap(\nnativeDeposit,\nreserveNative,\nreserveForeign\n  );\n  _update(\nforeignAsset,\nreserveNative + nativeDeposit,\nreserveForeign,\nreserveNative,\nreserveForeign\n  );\n  synth.mint(to, amountSynth);\n }\n function burnSynth(\n  IERC20 foreignAsset,\n  uint256 synthAmount,\n  address to\n ) external override nonReentrant returns (uint256 amountNative) {\n  ISynth synth = synthFactory.synths(foreignAsset);\n\n  require(\nsynth != ISynth(_ZERO_ADDRESS),\n\"VaderPoolV2::burnSynth: Inexistent Synth\"\n  );\n\n  require(\nsynthAmount > 0,\n\"VaderPoolV2::burnSynth: Insufficient Synth Amount\"\n  );\n\n  IERC20(synth).safeTransferFrom(msg.sender, address(this), synthAmount);\n  synth.burn(synthAmount);\n\n  (uint112 reserveNative, uint112 reserveForeign, ) = getReserves(\nforeignAsset\n  ); \n\n  amountNative = VaderMath.calculateSwap(\nsynthAmount,\nreserveForeign,\nreserveNative\n  );\n\n \n  _update(\nforeignAsset,\nreserveNative - amountNative,\nreserveForeign,\nreserveNative,\nreserveForeign\n  );\n\n  nativeAsset.safeTransfer(to, amountNative);\n }\n\n function _min(uint256 a, uint256 b) private pure returns (uint256) {\n  return a < b ? a : b;\n }\n}\n\n###\n\n"}
{"prompt":"pragma solidity =0.8.9;\ncontract VaderRouterV2 is IVaderRouterV2, ProtocolConstants, Ownable {\n using SafeERC20 for IERC20;\n IVaderPoolV2 public immutable pool;\n IERC20 public immutable nativeAsset;\n IVaderReserve public reserve;\n constructor(IVaderPoolV2 _pool) {\n  require(\n_pool != IVaderPoolV2(_ZERO_ADDRESS),\n\"VaderRouterV2::constructor: Incorrect Arguments\"\n  );\n\n  pool = _pool;\n  nativeAsset = pool.nativeAsset();\n }\n function addLiquidity(\n  IERC20 tokenA,\n  IERC20 tokenB,\n  uint256 amountADesired,\n  uint256 amountBDesired,\n  uint256, \/\/ amountAMin = unused\n  uint256, \/\/ amountBMin = unused\n  address to,\n  uint256 deadline\n ) external override returns (uint256 liquidity) {\n  return\naddLiquidity(\n tokenA,\n tokenB,\n amountADesired,\n amountBDesired,\n to,\n deadline\n);\n }\n function addLiquidity(\n  IERC20 tokenA,\n  IERC20 tokenB,\n  uint256 amountADesired,\n  uint256 amountBDesired,\n  address to,\n  uint256 deadline\n ) public override ensure(deadline) returns (uint256 liquidity) {\n  IERC20 foreignAsset;\n  uint256 nativeDeposit;\n  uint256 foreignDeposit;\n\n  if (tokenA == nativeAsset) {\nrequire(\n pool.supported(tokenB),\n \"VaderRouterV2::addLiquidity: Unsupported Assets Specified\"\n);\nforeignAsset = tokenB;\nforeignDeposit = amountBDesired;\nnativeDeposit = amountADesired;\n  } else {\nrequire(\n tokenB == nativeAsset && pool.supported(tokenA),\n \"VaderRouterV2::addLiquidity: Unsupported Assets Specified\"\n);\nforeignAsset = tokenA;\nforeignDeposit = amountADesired;\nnativeDeposit = amountBDesired;\n  }\n\n  liquidity = pool.mint(\nforeignAsset,\nnativeDeposit,\nforeignDeposit,\nmsg.sender,\nto\n  );\n }\n function _swap(\n  uint256 amountIn,\n  IERC20[] calldata path,\n  address to\n ) private returns (uint256 amountOut) {\n  if (path.length == 3) {\nrequire(\n path[0] != path[1] &&\n  path[1] == pool.nativeAsset() &&\n  path[2] != path[1],\n \"VaderRouterV2::_swap: Incorrect Path\"\n);\n\npath[0].safeTransferFrom(msg.sender, address(pool), amountIn);\n\nreturn pool.doubleSwap(path[0], path[2], amountIn, to);\n  } else {\nrequire(\n path.length == 2,\n \"VaderRouterV2::_swap: Incorrect Path Length\"\n);\nIERC20 _nativeAsset = nativeAsset;\nrequire(path[0] != path[1], \"VaderRouterV2::_swap: Incorrect Path\");\n\npath[0].safeTransferFrom(msg.sender, address(pool), amountIn);\nif (path[0] == _nativeAsset) {\n return pool.swap(path[1], amountIn, 0, to);\n} else {\n require(\n  path[1] == _nativeAsset,\n  \"VaderRouterV2::_swap: Incorrect Path\"\n );\n return pool.swap(path[0], 0, amountIn, to);\n}\n  }\n }\n modifier ensure(uint256 deadline) {\n  require(deadline >= block.timestamp, \"VaderRouterV2::ensure: Expired\");\n  _;\n }\n}\n\n###\n\n"}
{"prompt":"pragma solidity ^0.8.17;\ncontract Pair is ERC20, ERC721TokenReceiver {\n using SafeTransferLib for address;\n using SafeTransferLib for ERC20;\n\n uint256 public constant ONE = 1e18;\n uint256 public constant CLOSE_GRACE_PERIOD = 7 days;\n\n address public immutable nft;\n address public immutable baseToken; \/\/ address(0) for ETH\n bytes32 public immutable merkleRoot;\n LpToken public immutable lpToken;\n Caviar public immutable caviar;\n uint256 public closeTimestamp;\n\n event Add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n event Remove(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 lpTokenAmount);\n event Buy(uint256 inputAmount, uint256 outputAmount);\n event Sell(uint256 inputAmount, uint256 outputAmount);\n event Wrap(uint256[] tokenIds);\n event Unwrap(uint256[] tokenIds);\n event Close(uint256 closeTimestamp);\n event Withdraw(uint256 tokenId);\n\n constructor(\n  address _nft,\n  address _baseToken,\n  bytes32 _merkleRoot,\n  string memory pairSymbol,\n  string memory nftName,\n  string memory nftSymbol\n ) ERC20(string.concat(nftName, \" fractional token\"), string.concat(\"f\", nftSymbol), 18) {\n  nft = _nft;\n  baseToken = _baseToken;\n  merkleRoot = _merkleRoot;\n  lpToken = new LpToken(pairSymbol);\n  caviar = Caviar(msg.sender);\n }\n function add(uint256 baseTokenAmount, uint256 fractionalTokenAmount, uint256 minLpTokenAmount)\n  public\n  payable\n  returns (uint256 lpTokenAmount)\n {\n  require(baseTokenAmount > 0 && fractionalTokenAmount > 0, \"Input token amount is zero\");\n  require(baseToken == address(0) ? msg.value == baseTokenAmount : msg.value == 0, \"Invalid ether input\");\n  lpTokenAmount = addQuote(baseTokenAmount, fractionalTokenAmount);\n  require(lpTokenAmount >= minLpTokenAmount, \"Slippage: lp token amount out\");\n  _transferFrom(msg.sender, address(this), fractionalTokenAmount);\n  lpToken.mint(msg.sender, lpTokenAmount);\n  if (baseToken != address(0)) {\nERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount);\n  }\n  emit Add(baseTokenAmount, fractionalTokenAmount, lpTokenAmount);\n }\n function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {\n  require(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, \"Invalid ether input\");\n  inputAmount = buyQuote(outputAmount);\n  require(inputAmount <= maxInputAmount, \"Slippage: amount in\");\n  _transferFrom(address(this), msg.sender, outputAmount);\n  if (baseToken == address(0)) {\nuint256 refundAmount = maxInputAmount - inputAmount;\nif (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);\n  } else {\nERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);\n  }\n  emit Buy(inputAmount, outputAmount);\n }\n function nftSell(uint256[] calldata tokenIds, uint256 minOutputAmount, bytes32[][] calldata proofs)\n  public\n  returns (uint256 outputAmount)\n {\n  uint256 inputAmount = wrap(tokenIds, proofs);\n  outputAmount = sell(inputAmount, minOutputAmount);\n }\n function baseTokenReserves() public view returns (uint256) {\n  return _baseTokenReserves();\n }\n\n function fractionalTokenReserves() public view returns (uint256) {\n  return balanceOf[address(this)];\n }\n\n function buyQuote(uint256 outputAmount) public view returns (uint256) {\n  return (outputAmount * 1000 * baseTokenReserves()) \/ ((fractionalTokenReserves() - outputAmount) * 997);\n }\n\n\n function sellQuote(uint256 inputAmount) public view returns (uint256) {\n  uint256 inputAmountWithFee = inputAmount * 997;\n  return (inputAmountWithFee * baseTokenReserves()) \/ ((fractionalTokenReserves() * 1000) + inputAmountWithFee);\n }\n\n function addQuote(uint256 baseTokenAmount, uint256 fractionalTokenAmount) public view returns (uint256) {\n  uint256 lpTokenSupply = lpToken.totalSupply();\n  if (lpTokenSupply > 0) {\nuint256 baseTokenShare = (baseTokenAmount * lpTokenSupply) \/ baseTokenReserves();\nuint256 fractionalTokenShare = (fractionalTokenAmount * lpTokenSupply) \/ fractionalTokenReserves();\nreturn Math.min(baseTokenShare, fractionalTokenShare);\n  } else {\nreturn Math.sqrt(baseTokenAmount * fractionalTokenAmount);\n  }\n }\n function removeQuote(uint256 lpTokenAmount) public view returns (uint256, uint256) {\n  uint256 lpTokenSupply = lpToken.totalSupply();\n  uint256 baseTokenOutputAmount = (baseTokenReserves() * lpTokenAmount) \/ lpTokenSupply;\n  uint256 fractionalTokenOutputAmount = (fractionalTokenReserves() * lpTokenAmount) \/ lpTokenSupply;\n\n  return (baseTokenOutputAmount, fractionalTokenOutputAmount);\n }\n\n}\n\n###\n\n"}