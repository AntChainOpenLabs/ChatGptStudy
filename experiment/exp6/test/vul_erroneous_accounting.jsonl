{"prompt":"pragma solidity ^0.8.0;\n\nimport \"@openzeppelin\/contracts\/token\/ERC20\/IERC20.sol\";\nimport \"@openzeppelin\/contracts\/access\/Ownable.sol\";\n\nimport \".\/Fund.sol\";\nimport \".\/Lending.sol\";\nimport \".\/RoleAware.sol\";\nimport \".\/MarginRouter.sol\";\nimport \".\/PriceAware.sol\";\n\nstruct CrossMarginAccount {\n uint256 lastDepositBlock;\n address[] borrowTokens;\n mapping(address => uint256) borrowed;\n mapping(address => uint256) borrowedYieldQuotientsFP;\n address[] holdingTokens;\n mapping(address => uint256) holdings;\n mapping(address => bool) holdsToken;\n}\n\nabstract contract CrossMarginAccounts is RoleAware, PriceAware {\n uint256 public leveragePercent;\n\n uint256 public liquidationThresholdPercent;\n\n mapping(address => CrossMarginAccount) internal marginAccounts;\n mapping(address => uint256) public tokenCaps;\n mapping(address => uint256) public totalShort;\n mapping(address => uint256) public totalLong;\n uint256 public coolingOffPeriod;\n\n function addHolding(\n  CrossMarginAccount storage account,\n  address token,\n  uint256 depositAmount\n ) internal {\n  if (!hasHoldingToken(account, token)) {\naccount.holdingTokens.push(token);\n  }\n\n  account.holdings[token] += depositAmount;\n }\n\n function borrow(\n  CrossMarginAccount storage account,\n  address borrowToken,\n  uint256 borrowAmount\n ) internal {\n  if (!hasBorrowedToken(account, borrowToken)) {\naccount.borrowTokens.push(borrowToken);\n  } else {\naccount.borrowed[borrowToken] = Lending(lending())\n .applyBorrowInterest(\n account.borrowed[borrowToken],\n borrowToken,\n account.borrowedYieldQuotientsFP[borrowToken]\n);\n  }\n  account.borrowedYieldQuotientsFP[borrowToken] = Lending(lending())\n.viewBorrowingYieldFP(borrowToken);\n\n  account.borrowed[borrowToken] += borrowAmount;\n  addHolding(account, borrowToken, borrowAmount);\n\n  require(positiveBalance(account), \"Can't borrow: insufficient balance\");\n }\n\n function positiveBalance(CrossMarginAccount storage account)\n  internal\n  returns (bool)\n {\n  uint256 loan = loanInPeg(account, false);\n  uint256 holdings = holdingsInPeg(account, false);\n  return holdings * (leveragePercent - 100) >= loan * leveragePercent;\n }\n\n function hasHoldingToken(CrossMarginAccount storage account, address token)\n  internal\n  view\n  returns (bool)\n {\n  return account.holdsToken[token];\n }\n\n function hasBorrowedToken(CrossMarginAccount storage account, address token)\n  internal\n  view\n  returns (bool)\n {\n  return account.borrowedYieldQuotientsFP[token] > 0;\n }\n\n function loanInPeg(CrossMarginAccount storage account, bool forceCurBlock)\n  internal\n  returns (uint256)\n {\n  return\nsumTokensInPegWithYield(\n account.borrowTokens,\n account.borrowed,\n account.borrowedYieldQuotientsFP,\n forceCurBlock\n);\n }\n\n function holdingsInPeg(\n  CrossMarginAccount storage account,\n  bool forceCurBlock\n ) internal returns (uint256) {\n  return\nsumTokensInPeg(\n account.holdingTokens,\n account.holdings,\n forceCurBlock\n);\n }\n \n function belowMaintenanceThreshold(CrossMarginAccount storage account)\n  internal\n  returns (bool)\n {\n  uint256 loan = loanInPeg(account, true);\n  uint256 holdings = holdingsInPeg(account, true);\n  return 100 * holdings >= liquidationThresholdPercent * loan;\n }\n\n function sumTokensInPeg(\n  address[] storage tokens,\n  mapping(address => uint256) storage amounts,\n  bool forceCurBlock\n ) internal returns (uint256 totalPeg) {\n  uint256 len = tokens.length;\n  for (uint256 tokenId; tokenId < len; tokenId++) {\naddress token = tokens[tokenId];\ntotalPeg += PriceAware.getCurrentPriceInPeg(\n token,\n amounts[token],\n forceCurBlock\n);\n  }\n }\n \n\n function sumTokensInPegWithYield(\n  address[] storage tokens,\n  mapping(address => uint256) storage amounts,\n  mapping(address => uint256) storage yieldQuotientsFP,\n  bool forceCurBlock\n ) internal returns (uint256 totalPeg) {\n  uint256 len = tokens.length;\n  for (uint256 tokenId; tokenId < len; tokenId++) {\naddress token = tokens[tokenId];\ntotalPeg += yieldTokenInPeg(\n token,\n amounts[token],\n yieldQuotientsFP,\n forceCurBlock\n);\n  }\n }\n\n function yieldTokenInPeg(\n  address token,\n  uint256 amount,\n  mapping(address => uint256) storage yieldQuotientsFP,\n  bool forceCurBlock\n ) internal returns (uint256) {\n  uint256 yieldFP = Lending(lending()).viewBorrowingYieldFP(token);\n  uint256 amountInToken = (amount * yieldFP) \/ yieldQuotientsFP[token];\n  return\nPriceAware.getCurrentPriceInPeg(\n token,\n amountInToken,\n forceCurBlock\n);\n }\n}\n\n\n###\n\n"}
{"prompt":"\/\/ SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.3;\n\n\/\/ Interfaces\nimport \".\/interfaces\/iERC20.sol\";\nimport \".\/interfaces\/iVADER.sol\";\nimport \".\/interfaces\/iROUTER.sol\";\nimport \".\/interfaces\/iPOOLS.sol\";\nimport \".\/interfaces\/iFACTORY.sol\";\nimport \".\/interfaces\/iSYNTH.sol\";\n\nimport \"hardhat\/console.sol\";\n\ncontract Utils {\n\n uint private one = 10**18;\n uint private _10k = 10000;\n uint private _year = 31536000; \/\/ One Year (in seconds)\n\n bool private inited;\n\n address public VADER;\n address public USDV;\n address public ROUTER;\n address public POOLS;\n address public FACTORY;\n\n constructor () {}\n\n function init(address _vader, address _usdv, address _router, address _pools, address _factory) public {\n  require(inited == false,  \"inited\");\n  inited = true;\n  VADER = _vader;\n  USDV = _usdv;\n  ROUTER = _router;\n  POOLS = _pools;\n  FACTORY = _factory;\n }\n \/\/====================================SYSTEM FUNCTIONS====================================\/\/\n function isBase(address token) public view returns(bool base) {\n  if(token == VADER || token == USDV){\nreturn true;\n  }\n }\n function isPool(address token) public view returns(bool pool) {\n  if(iPOOLS(POOLS).isAnchor(token) || iPOOLS(POOLS).isAsset(token)){\npool = true;\n  }\n }\n\n \/\/====================================PRICING====================================\/\/\n\n function calcSwapValueInBase(address token, uint amount) public view returns (uint){\n  (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n  return calcSwapOutput(amount, _tokenAmt, _baseAmt);\n }\n function calcSwapValueInToken(address token, uint amount) public view returns (uint){\n  (uint _baseAmt, uint _tokenAmt) = iPOOLS(POOLS).getPoolAmounts(token);\n  return calcSwapOutput(amount, _baseAmt, _tokenAmt);\n }\n \/\/==================================== LENDING ====================================\/\/\n\n function getCollateralValueInBase(address member, uint collateral, address collateralAsset, address debtAsset) external view returns (uint debt, uint baseValue) {\n  uint _collateralAdjusted = (collateral * 6666) \/ 10000; \/\/ 150% collateral Ratio\n  if(isBase(collateralAsset)){\nbaseValue = _collateralAdjusted;\n  }else if(isPool(collateralAsset)){\nbaseValue = calcAsymmetricShare(_collateralAdjusted, iPOOLS(POOLS).getMemberUnits(collateralAsset, member), iPOOLS(POOLS).getBaseAmount(collateralAsset)); \/\/ calc units to BASE\n  }else if(iFACTORY(FACTORY).isSynth(collateralAsset)){\nbaseValue = calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); \/\/ Calc swap value\n  }\n  debt = calcSwapValueInToken(debtAsset, baseValue);  \/\/ get debt output\n  return (debt, baseValue);\n }\n\n \/\/====================================CORE-MATH====================================\/\/\n\n\n function calcShare(uint part, uint total, uint amount) public pure returns (uint share){\n  \/\/ share = amount * part\/total\n  if(part > total){\npart = total;\n  }\n  if(total > 0){\nshare = (amount * part) \/ total;\n  }\n }\n\n function calcSwapOutput(uint x, uint X, uint Y) public pure returns (uint){\n  \/\/ y = (x * X * Y )\/(x + X)^2\n  uint numerator = (x * X * Y);\n  uint denominator = (x + X) * (x + X);\n  return (numerator \/ denominator);\n }\n\n function calcAsymmetricShare(uint u, uint U, uint A) public pure returns (uint){\n  \/\/ share = (u * U * (2 * A^2 - 2 * U * u + U^2))\/U^3\n  \/\/ (part1 * (part2 - part3 + part4)) \/ part5\n  uint part1 = (u * A);\n  uint part2 = ((U * U) * 2);\n  uint part3 = ((U * u) * 2);\n  uint part4 = (u * u);\n  uint numerator = ((part1 * part2) - part3) + part4;\n  uint part5 = ((U * U) * U);\n  return (numerator \/ part5);\n }\n function calcCoverage(uint B0, uint T0, uint B1, uint T1) public pure returns(uint coverage){\n  if(B0 > 0 && T1 > 0){\nuint _depositValue = B0 + (T0 * B1) \/ T1; \/\/ B0+(T0*B1\/T1)\nuint _redemptionValue = B1 + (T1 * B1) \/ T1; \/\/ B1+(T1*B1\/T1)\nif(_redemptionValue <= _depositValue){\n coverage = (_depositValue - _redemptionValue);\n}\n  }\n }\n}\n\n###\n\n"}
{"prompt":"\/\/ SPDX-License-Identifier: MIT\npragma solidity 0.6.8;\n\nimport \".\/interface\/INFTXVaultFactory.sol\";\nimport \".\/interface\/INFTXEligibility.sol\";\nimport \".\/interface\/INFTXEligibilityManager.sol\";\nimport \".\/interface\/INFTXLPStaking.sol\";\nimport \".\/interface\/INFTXFeeDistributor.sol\";\nimport \".\/interface\/IPrevNftxContract.sol\";\nimport \".\/interface\/IRewardDistributionToken.sol\";\nimport \".\/token\/ERC20BurnableUpgradeable.sol\";\nimport \".\/token\/ERC20FlashMintUpgradeable.sol\";\nimport \".\/token\/ERC721HolderUpgradeable.sol\";\nimport \".\/token\/ERC1155HolderUpgradeable.sol\";\nimport \".\/token\/IERC721Upgradeable.sol\";\nimport \".\/token\/IERC1155Upgradeable.sol\";\nimport \".\/util\/PausableUpgradeable.sol\";\nimport \".\/util\/SafeMathUpgradeable.sol\";\nimport \".\/util\/ReentrancyGuardUpgradeable.sol\";\nimport \".\/util\/EnumerableSetUpgradeable.sol\";\nimport \"hardhat\/console.sol\";\n\ncontract NFTXVaultUpgradeable is\n PausableUpgradeable,\n ERC20BurnableUpgradeable,\n ERC20FlashMintUpgradeable,\n ReentrancyGuardUpgradeable,\n ERC721HolderUpgradeable,\n ERC1155HolderUpgradeable\n{\n using SafeMathUpgradeable for uint256;\n using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\n uint256 constant base = 10**18;\n uint256 public vaultId;\n address public assetAddress;\n INFTXVaultFactory public vaultFactory;\n\n uint256 randNonce;\n uint256 public redeemFee;\n uint256 public directRedeemFee;\n\n \/\/ Purposely putting these on a new slot to make sure they're together.\n bool public is1155;\n bool public enableRedeem;\n bool public enableDirectRedeem;\n\n EnumerableSetUpgradeable.UintSet holdings;\n mapping(uint256 => uint256) quantity1155;\n\n event Redeemed(uint256[] nftIds, address sender);\n constructor() public {\n  __Pausable_init();\n  __ERC20_init(\"\", \"\");\n  __ERC20Burnable_init_unchained();\n  __ERC20FlashMint_init();\n }\n\n function redeem(uint256 amount, uint256[] calldata specificIds)\n  external\n  virtual\n  returns (uint256[] memory)\n {\n  return redeemTo(amount, specificIds, msg.sender);\n }\n\n\n function redeemTo(uint256 amount, uint256[] memory specificIds, address to)\n  public\n  virtual\n  nonReentrant\n returns (uint256[] memory)\n {\n  onlyOwnerIfPaused(2);\n  requireenableRedeem, \"Redeeming not enabled\");\n\n  require(\nspecificIds.length == 0 ||enableDirectRedeem,\n\"Direct redeem not enabled\"\n  )\n\n  uint256 fee = directRedeemFee.mul(specificIds.length).add(\nredeemFee.mul(amount.sub(specificIds.length))\n  );\n  \/\/ We burn all from sender and mint to fee receiver to reduce costs.\n  _burnFrom(msg.sender, base.mul(amount).add(fee));\n  _distributeFees(fee);\n\n  uint256[] memory redeemedIds = withdrawNFTsTo(amount, specificIds, to);\n  afterRedeemHook(redeemedIds);\n\n  emit Redeemed(redemedIds, to);\n  return redeemedIds;\n }\n\n\n function withdrawNFTsTo(\n  uint256 amount,\n  uint256[] memory specificIds,\n  address to\n ) internal virtual returns (uint256[] memory) {\n  bool _is1155 = is1155;\n  address _assetAddress = assetAddress;\n  uint256[] memory redeemedIds = new uint256[](amount);\n\n  for (uint256 i = 0; i < amount; i++) {\nuint256 tokenId = i < specificIds.length\n ? specificIds[i]\n : getRandomTokenIdFromFund();\nredeemedIds[i] = tokenId;\nif (_is1155) {\n IERC1155Upgradeable(_assetAddress).safeTransferFrom(\n  address(this),\n  to,\n  tokenId,\n  1,\n  \"\"\n );\n quantity1155[tokenId] = quantity1155[tokenId].sub(1);\n if (quantity1155[tokenId] == 0) {\n  holdings.remove(tokenId);\n }\n} else {\n IERC721Upgradeable(_assetAddress).safeTransferFrom(\n  address(this),\n  to,\n  tokenId\n );\n holdings.remove(tokenId);\n}\n  }\n  return redeemedIds;\n }\n\n function _distributeFees(uint256 amount) internal virtual {\n  \/\/ Mint fees directly to the distributor and distribute.\n  if (amount > 0) {\naddress feeReceiver = vaultFactory.feeReceiver();\n_mint(feeReceiver, amount);\nINFTXFeeDistributor(feeReceiver).distribute(vaultId);\n  }\n }\n\n function getRandomTokenIdFromFund() internal virtual returns (uint256) {\n  uint256 randomIndex = getPseudoRand(holdings.length());\n  return holdings.at(randomIndex);\n }\n\n function getPseudoRand(uint256 modulus) internal virtual returns (uint256) {\n  randNonce += 1;\n  return\nuint256(\n keccak256(\n  abi.encodePacked(blockhash(block.number - 1), randNonce)\n )\n) %\nmodulus;\n }\n}\n\n\n###\n\n"}
{"prompt":"pragma solidity 0.8.1;\n\nimport \"..\/..\/utils\/access\/AccessControl.sol\";\nimport \"..\/..\/interfaces\/vault\/IOracle.sol\";\nimport \"..\/..\/math\/CastBytes32Bytes6.sol\";\n\ncontract CompositeMultiOracle is IOracle, AccessControl {\n using CastBytes32Bytes6 for bytes32;\n\n uint8 public constant override decimals = 18;\/\/ All prices are converted to 18 decimals\n\n event SourceSet(bytes6 indexed baseId, bytes6 indexed quoteId, address indexed source);\n event PathSet(bytes6 indexed baseId, bytes6 indexed quoteId, bytes6[] indexed path);\n\n struct Source {\n  address source;\n  uint8 decimals;\n }\n\n mapping(bytes6 => mapping(bytes6 => Source)) public sources;\n mapping(bytes6 => mapping(bytes6 => bytes6[])) public paths;\n\n function setSource(bytes6 base, bytes6 quote, address source) external auth {\n  _setSource(base, quote, source);\n }\n\n\n function setSources(bytes6[] memory bases, bytes6[] memory quotes, address[] memory sources_) external auth {\n  require(\nbases.length == quotes.length && \nbases.length == sources_.length,\n\"Mismatched inputs\"\n  );\n  for (uint256 i = 0; i < bases.length; i++) {\n_setSource(bases[i], quotes[i], sources_[i]);\n  }\n }\n\n function setPath(bytes6 base, bytes6 quote, bytes6[] memory path) external auth {\n  _setPath(base, quote, path);\n }\n\n function setPaths(bytes6[] memory bases, bytes6[] memory quotes, bytes6[][] memory paths_) external auth {\n  require(\nbases.length == quotes.length && \nbases.length == paths_.length,\n\"Mismatched inputs\"\n  );\n  for (uint256 i = 0; i < bases.length; i++) {\n_setPath(bases[i], quotes[i], paths_[i]);\n  }\n }\n\n function peek(bytes32 base, bytes32 quote, uint256 amount)\n  external view virtual override\n  returns (uint256 value, uint256 updateTime)\n {\n  uint256 price = 1e18;\n  bytes6 base_ = base.b6();\n  bytes6 quote_ = quote.b6();\n  bytes6[] memory path = paths[base_][quote_];\n  for (uint256 p = 0; p < path.length; p++) {\n(price, updateTime) = _peek(base_, path[p], price, updateTime);\nbase_ = path[p];\n  }\n  (price, updateTime) = _peek(base_, quote_, price, updateTime);\n  value = price * amount \/ 1e18;\n }\n\n function get(bytes32 base, bytes32 quote, uint256 amount)\n  external virtual override\n  returns (uint256 value, uint256 updateTime)\n {\n  uint256 price = 1e18;\n  bytes6 base_ = base.b6();\n  bytes6 quote_ = quote.b6();\n  bytes6[] memory path = paths[base_][quote_];\n  for (uint256 p = 0; p < path.length; p++) {\n(price, updateTime) = _get(base_, path[p], price, updateTime);\nbase_ = path[p];\n  }\n  (price, updateTime) = _get(base_, quote_, price, updateTime);\n  value = price * amount \/ 1e18;\n }\n\n function _peek(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)\n  private view returns (uint priceOut, uint updateTimeOut)\n {\n  Source memory source = sources[base][quote];\n  require (source.source != address(0), \"Source not found\");\n  (priceOut, updateTimeOut) = IOracle(source.source).peek(base, quote, 10 ** source.decimals);\/\/ Get price for one unit\n  priceOut = priceIn * priceOut \/ (10 ** source.decimals);\/\/ Fixed point according to decimals\n  updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;  \/\/ Take the oldest update time\n }\n\n function _get(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)\n  private returns (uint priceOut, uint updateTimeOut)\n {\n  Source memory source = sources[base][quote];\n  require (source.source != address(0), \"Source not found\");\n  (priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals); \/\/ Get price for one unit\n  priceOut = priceIn * priceOut \/ (10 ** source.decimals);\/\/ Fixed point according to decimals\n  updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;  \/\/ Take the oldest update time\n }\n\n function _setSource(bytes6 base, bytes6 quote, address source) internal {\n  uint8 decimals_ = IOracle(source).decimals();\n  require (decimals_ <= 18, \"Unsupported decimals\");\n  sources[base][quote] = Source({\nsource: source,\ndecimals: decimals_\n  });\n  emit SourceSet(base, quote, source);\n }\n\n function _setPath(bytes6 base, bytes6 quote, bytes6[] memory path) internal {\n  bytes6 base_ = base;\n  for (uint256 p = 0; p < path.length; p++) {\nrequire (sources[base_][path[p]].source != address(0), \"Source not found\");\nbase_ = path[p];\n  }\n  paths[base][quote] = path;\n  emit PathSet(base, quote, path);\n }\n}\n\n\n\n###\n\n"}
{"prompt":"\/\/ SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \".\/libraries\/FixedPoint.sol\";\nimport \".\/libraries\/UniswapV3OracleLibrary\/UniswapV3OracleLibraryV2.sol\";\nimport \".\/interfaces\/IUniswapV3Pool.sol\";\nimport \".\/market\/OverlayV1Market.sol\";\nimport \".\/libraries\/UniswapV3OracleLibrary\/TickMath.sol\";\n\ncontract OverlayV1UniswapV3Market is OverlayV1Market {\n\nusing FixedPoint for uint256;\n\nuint256 internal X96 = 0x1000000000000000000000000;\n\nuint256 public immutable macroWindow; \/\/ window size for main TWAP\nuint256 public immutable microWindow; \/\/ window size for bid\/ask TWAP\n\naddress public immutable marketFeed;\naddress public immutable ovlFeed;\naddress public immutable base;\naddress public immutable quote;\nuint128 internal immutable baseAmount;\n\naddress internal immutable eth;\nbool internal immutable ethIs0;\n\nconstructor(\naddress _mothership,\naddress _ovlFeed,\naddress _marketFeed,\naddress _quote,\naddress _eth,\nuint128 _baseAmount,\nuint256 _macroWindow,\nuint256 _microWindow,\nuint256 _priceFrameCap\n) OverlayV1Market (\n_mothership\n) OverlayV1Comptroller (\n_microWindow\n) OverlayV1OI (\n_microWindow\n) OverlayV1PricePoint (\n_priceFrameCap\n) {\n\/\/ immutables\neth = _eth;\nethIs0 = IUniswapV3Pool(_ovlFeed).token0() == _eth;\novlFeed = _ovlFeed;\nmarketFeed = _marketFeed;\nbaseAmount = _baseAmount;\nmacroWindow = _macroWindow;\nmicroWindow = _microWindow;\n\naddress _token0 = IUniswapV3Pool(_marketFeed).token0();\naddress _token1 = IUniswapV3Pool(_marketFeed).token1();\n\nbase = _token0 != _quote ? _token0 : _token1;\nquote = _token0 == _quote ? _token0 : _token1;\n\nint24 _tick = OracleLibraryV2.consult(\n_marketFeed,\nuint32(_macroWindow),\nuint32(0)\n);\n_pricePoints.push(PricePoint(\n_tick, \n_tick, \n0\n));\nuint _price = OracleLibraryV2.getQuoteAtTick(\n_tick,\nuint128(_baseAmount),\n_token0 != _quote ? _token0 : _token1,\n_token0 == _quote ? _token0 : _token1\n);\nemit NewPricePoint(_price, _price, 0);\n}\n\nfunction fetchPricePoint () public view override returns (\nPricePoint memory price_\n) {\nint56[] memory _ticks;\nuint160[] memory _liqs;\nuint _ovlPrice;\nuint _marketLiquidity;\nint24 _microTick;\nint24 _macroTick;\n{\nuint32[] memory _secondsAgo = new uint32[](3);\n_secondsAgo[2] = uint32(macroWindow);\n_secondsAgo[1] = uint32(microWindow);\n( _ticks, _liqs ) = IUniswapV3Pool(marketFeed).observe(_secondsAgo);\n_macroTick = int24(( _ticks[0] - _ticks[2]) \/ int56(int32(int(macroWindow))));\n_microTick = int24((_ticks[0] - _ticks[1]) \/ int56(int32(int(microWindow))));\nuint _sqrtPrice = TickMath.getSqrtRatioAtTick(_microTick);\nuint _liquidity = (uint160(microWindow) << 128) \/ ( _liqs[0] - _liqs[1] );\n_marketLiquidity = ethIs0\n? ( uint256(_liquidity) << 96 ) \/ _sqrtPrice\n: FullMath.mulDiv(uint256(_liquidity), _sqrtPrice, X96);\n}\n{\nuint32[] memory _secondsAgo = new uint32[](2);\n_secondsAgo[1] = uint32(macroWindow);\n( _ticks, ) = IUniswapV3Pool(ovlFeed).observe(_secondsAgo);\n_ovlPrice = OracleLibraryV2.getQuoteAtTick(\nint24((_ticks[0] - _ticks[1]) \/ int56(int32(int(macroWindow)))),\n1e18,\novl,\neth\n);\n\n}\nprice_ = PricePoint(\n_microTick, \n_macroTick, \ncomputeDepth(_marketLiquidity, _ovlPrice)\n);\n}\n\nfunction computeDepth (\nuint _marketLiquidity,\nuint _ovlPrice\n) public override view returns (\nuint depth_\n) {\ndepth_ = ((_marketLiquidity * 1e18) \/ _ovlPrice)\n.mulUp(lmbda)\n.divDown(2e18);\n}\n}\n\n\n###\n\n"}