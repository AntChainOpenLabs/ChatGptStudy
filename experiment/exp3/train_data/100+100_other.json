{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'H1.0';\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000;\r\n        totalSupply = 1000000000;\r\n        name = \"train.exchange\";\r\n        decimals = 0;\r\n        symbol = \"TRAIN\";\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract CryptoCoin is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is CryptoCoin {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 5000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 5000000000;                        // Update total supply (100000 for example)\r\n        name = \"CryptoCoin\";                                   // Set the name for display purposes\r\n        decimals = 1;                            // Amount of decimals for display purposes\r\n        symbol = \"CCO\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.16;\r\ncontract PregnantButtToken {\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract pbutttoken is PregnantButtToken {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract PREGNANTBUTT is pbutttoken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    string public name;                   \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'H1.0';       \r\n\r\n\r\n    function PREGNANTBUTT(\r\n        ) {\r\n        balances[msg.sender] = 250000000000000000000000000;              \r\n        totalSupply = 250000000000000000000000000;                    \r\n        name = \"pregnantbutt.finance\";                                 \r\n        decimals = 18;                         \r\n        symbol = \"PBUTT\";                         \r\n    }\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'ShibaInuBurger' token contract\r\n//\r\n// Symbol      : SIB \ud83c\udf54\r\n// Name        : Shiba Inu Burger\r\n// Total supply: 100000000000000\r\n// Decimals    : 18\r\n// Burned      : 50%\r\n// ----------------------------------------------------------------------------\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract ShibaInuBurger is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Shiba Inu Burger\";\r\n    string public constant symbol = \"SIB \ud83c\udf54\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "// YouTube Official Token\r\n// https://youtube.com\r\n// https://twitter.com/YouTube\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract YouTubeOfficialToken is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"YouTube Official Token\";\r\n    string public constant symbol = \"YOUTUBE\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Moon_Shib is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Moon Shib\";\r\n    string public constant symbol = \"MOONSHIB\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n   \r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Rocket_Shib is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Rocket Shib\";\r\n    string public constant symbol = \"RSHIB\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n   \r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n            if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n            if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract Nabla is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\nfunction ERC20Token(\r\n) {\r\nbalances[msg.sender] = 10000000000; // Give the creator all initial tokens (100000 for example)\r\ntotalSupply = 10000000000; // Update total supply (100000 for example)\r\nname = \"Nabla\"; // Set the name for display purposes\r\ndecimals = 8; // Amount of decimals for display purposes\r\nsymbol = \"NBL\"; // Set the symbol for display purposes\r\n}\r\n \r\n/* Approves and then calls the receiving contract */\r\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\nallowed[msg.sender][_spender] = _value;\r\nApproval(msg.sender, _spender, _value);\r\n \r\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n//receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n//it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\nreturn true;\r\n}\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract HyperInuShiba is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Hyper Inu Shiba\";\r\n    string public constant symbol = \"HYPERINU\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n    string public name;                   //Name of the token\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals\r\n    string public symbol;                 //An identifier: eg AXM\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 9900000000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 9900000000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Fenny Penny\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals\r\n        symbol = \"FPN\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.9.0;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract HARAMBUCKS is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function HARAMBUCKS(\r\n        ) {\r\n        balances[msg.sender] = 6942000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 6942000000;                        // Update total supply (100000 for example)\r\n        name = \"HARAMBUCKS\";                                   // Set the name for display purposes\r\n        decimals = 5;                            // Amount of decimals for display purposes\r\n        symbol = \"MONKE\";                               // Set the symbol for display purposes\r\n       \r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract NFTChampions is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000*10**uint256(decimals);\r\n    string public constant name = \"NFT Champions\";\r\n    string public constant symbol = \"CHAMP\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Ethereum_Kiwi is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Ethereum Kiwi\";\r\n    string public constant symbol = \"EKIWI \ud83e\udd5d\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 50000000;                        // Update total supply (100000 for example)\r\n        name = \"IonicTransfertToken\";                                   // Set the name for display purposes\r\n        decimals = 0;                            // Amount of decimals for display purposes\r\n        symbol = \"ITT\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.25;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n    \r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n     \r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract Shepherd is StandardToken { \r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                  \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'Shepherd.0'; \r\n    uint256 public unitsOneEthCanBuy;     \r\n    uint256 public totalEthInWei;         \r\n    address public fundsWallet;           \r\n\r\n   \r\n    function Shepherd() {\r\n        balances[msg.sender] = 10000000000000000000000000000;               \r\n        totalSupply = 10000000000000000000000000000;\r\n        name = \"Shepherd\";\r\n        decimals = 18;                                               \r\n        symbol = \"Shepherd\";                                             \r\n        unitsOneEthCanBuy = 0;          //7% bonus= OneEth//                           \r\n        fundsWallet = msg.sender;                                    \r\n    }\r\n\r\n    function() payable{\r\n        totalEthInWei = totalEthInWei + msg.value;\r\n        uint256 amount = msg.value * unitsOneEthCanBuy;\r\n        require(balances[fundsWallet] >= amount);\r\n\r\n        balances[fundsWallet] = balances[fundsWallet] - amount;\r\n        balances[msg.sender] = balances[msg.sender] + amount;\r\n\r\n        Transfer(fundsWallet, msg.sender, amount); \r\n\r\n        fundsWallet.transfer(msg.value);                               \r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n       \r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 10000000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 10000000000000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Dalgona\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"DALGONA\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'SnowShibaInu' token contract\r\n//\r\n// Symbol      : SNOWINU \u2744\ufe0f\r\n// Name        : Snow Shiba Inu\r\n// Total supply: 100000000000000\r\n// Decimals    : 18\r\n//\r\n// TOTAL SUPPLY 1,000,000,000,000,000\r\n// 50% Burned\r\n// ----------------------------------------------------------------------------\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract SnowShibaInu is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Snow Shiba Inu\";\r\n    string public constant symbol = \"SNOWINU \u2744\ufe0f\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract HotaruInu is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Hotaru Inu\";\r\n    string public constant symbol = \"HOTARU\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract CryptoCasinoToken is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Crypto Casino Token\";\r\n    string public constant symbol = \"CRYCAS\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'H1.0';\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 10000000;\r\n        totalSupply = 10000000;\r\n        name = \"Anonymous Coin\";\r\n        decimals = 0;\r\n        symbol = \"ANON\";\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\ncontract SHIBA_INU_v2 is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000*10**uint256(decimals);\r\n    string public constant name = \"SHIBA INU v2\";\r\n    string public constant symbol = \"SHIBB\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 10000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 10000000000000;                        // Update total supply (100000 for example)\r\n        name = \"HellBound Coin\";                                   // Set the name for display purposes\r\n        decimals = 4;                            // Amount of decimals for display purposes\r\n        symbol = \"HBC\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract TCP is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 250000000*10**uint256(decimals);\r\n    string public constant name = \"Crypto Prophecies\";\r\n    string public constant symbol = \"TCP\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n    \r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n   \r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'H1.0';\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000;\r\n        totalSupply = 1000000000;\r\n        name = \"pig.finance\";\r\n        decimals = 0;\r\n        symbol = \"PIG\";\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract BretCoin is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name = 'BretCoin';                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals = 10;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol = 'BRET';                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function BretCoin(\r\n        ) {\r\n        balances[msg.sender] = 210000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 210000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"BretCoin\";                                   // Set the name for display purposes\r\n        decimals = 10;                            // Amount of decimals for display purposes\r\n        symbol = \"BRET\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Biomutant_In_Game_Token is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Biomutant In-Game Token\";\r\n    string public constant symbol = \"$BIOM\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\ncontract AtlasTether {\r\n/// @return total amount of tokens\r\n function totalSupply() constant returns (uint256 supply) {}\r\n/// @param _owner The address from which the balance will be retrieved\r\n /// @return The balance\r\n function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n/// @notice send `_value` token to `_to` from `msg.sender`\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transfer(address _to, uint256 _value) returns (bool success) {}\r\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n /// @param _from The address of the sender\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @param _value The amount of wei to be approved for transfer\r\n /// @return Whether the approval was successful or not\r\n function approve(address _spender, uint256 _value) returns (bool success) {}\r\n/// @param _owner The address of the account owning tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @return Amount of remaining tokens allowed to spent\r\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n \r\n}\r\ncontract StandardToken is AtlasTether {\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {\r\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\r\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\r\n //Replace the if with this one instead.\r\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[msg.sender] >= _value && _value > 0) {\r\n balances[msg.sender] -= _value;\r\n balances[_to] += _value;\r\n Transfer(msg.sender, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n balances[_to] += _value;\r\n balances[_from] -= _value;\r\n allowed[_from][msg.sender] -= _value;\r\n Transfer(_from, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\n return balances[_owner];\r\n }\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);\r\n return true;\r\n }\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n return allowed[_owner][_spender];\r\n }\r\nmapping (address => uint256) balances;\r\n mapping (address => mapping (address => uint256)) allowed;\r\n uint256 public totalSupply;\r\n}\r\n//name this contract whatever you\u2019d like\r\ncontract Token is StandardToken {\r\nfunction () {\r\n //if ether is sent to this address, send it back.\r\n throw;\r\n }\r\n/* Public variables of the token */\r\n/*\r\n NOTE:\r\n The following variables are OPTIONAL vanities. One does not have to include them.\r\n They allow one to customise the token contract & in no way influences the core functionality.\r\n Some wallets/interfaces might not even bother to look at this information.\r\n */\r\n string public name; //fancy name: eg Simon Bucks\r\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It\u2019s like comparing 1 wei to 1 ether.\r\n string public symbol; //An identifier: eg SBX\r\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\r\n//\r\n// \u0628\u0631\u0627\u06cc \u062a\u0648\u06a9\u0646 \u062e\u0648\u062f \u0645\u0642\u062f\u0627\u0631\u0647\u0627\u06cc \u0632\u06cc\u0631 \u0631\u0627 \u062a\u063a\u06cc\u06cc\u0631 \u062f\u0647\u06cc\u062f\r\n//\r\n//make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\nfunction Token(\r\n ) {\r\n balances[msg.sender] = 100000; // \u062a\u0645\u0627\u0645 \u062a\u0648\u06a9\u0646\u0647\u0627\u06cc \u0633\u0627\u062e\u062a\u0647 \u0634\u062f\u0647 \u0633\u0627\u0632\u0646\u062f\u0647 \u0628\u0631\u0633\u062f -\u0639\u062f\u062f\u06cc \u0648\u0627\u0631\u062f \u06a9\u0646\u06cc\u062f \u0645\u062b\u0644\u0627 100000\r\n totalSupply = 1000000000; // \u062a\u0645\u0627\u0645 \u0639\u0631\u0636\u0647\r\n name = 'AtlasTether'; // \u0646\u0627\u0645 \u062a\u0648\u06a9\u0646\r\n decimals = 2; // \u0627\u0639\u0634\u0627\u0631\r\n symbol = 'USDT'; // \u0646\u0645\u0627\u062f \u062a\u0648\u06a9\u0646\r\n }\r\n/* Approves and then calls the receiving contract */\r\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);\r\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\r\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n if(!_spender.call(bytes4(bytes32(sha3('receiveApproval(address,uint256,address,bytes)'))), msg.sender, _value, this, _extraData)) { throw; }\r\n return true;\r\n }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 50000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 50000;                        // Update total supply (100000 for example)\r\n        name = \"RadioInternacional.tv\";                                   // Set the name for display purposes\r\n        decimals = 0;                            // Amount of decimals for display purposes\r\n        symbol = \"RITV\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 1000000000;                        // Update total supply (100000 for example)\r\n        name = \"clown.finance\";                                   // Set the name for display purposes\r\n        decimals = 0;                            // Amount of decimals for display purposes\r\n        symbol = \"CLOWN\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\nabstract contract ERC20Basic {\r\n    uint256 public _totalSupply = 100000000000000000000000000; //100 000 000\r\n    function totalSupply() public virtual view returns (uint256);\r\n    function balanceOf(address who) public virtual view returns (uint256);\r\n    function transfer(address to, uint256 value) public virtual returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n */\r\nabstract contract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public virtual view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\r\n    function approve(address spender, uint256 value) public virtual returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n    // Owner address of contract. Assigned on deployment.\r\n    address payable public owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        owner = payable(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address payable newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * Standard ERC20 token implementation\r\n */\r\nabstract contract StandardToken is ERC20, Ownable {\r\n    // Addresses and balances (in tokens) of all clients. Required by ERC20.\r\n    mapping (address => uint256) balances;\r\n    // Clients, allowed to work. Required by ERC20.\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function totalSupply() public override view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _value) override public returns (bool success) {\r\n        if (balances[msg.sender] >= _value\r\n        && _value > 0\r\n        && balances[_to] + _value > balances[_to])\r\n        {\r\n            uint256 obalance = balances[msg.sender];\r\n            if ( obalance >= _value)\r\n            {\r\n                balances[msg.sender] -= _value;\r\n                balances[_to] += _value;\r\n                emit Transfer(msg.sender, _to, _value);\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n/*\r\n * @title Coin\r\n*/\r\ncontract Coin is StandardToken {\r\n    // A symbol of a coin.\r\n    string public constant symbol = \"EXTRA\";\r\n    // A name of a coin.\r\n    string public constant name = \"ExtraToken\";\r\n    // A number of decimals in a coin.\r\n    uint8 public constant decimals = 18;\r\n    \r\n    event TransferFromTo(address indexed _from, address indexed _to, address indexed _by, uint256 _value);\r\n\r\n    /**\r\n    * @dev Constructor of a contract\r\n    */\r\n    constructor() payable {\r\n        owner = payable(msg.sender);\r\n        balances[owner] = _totalSupply;\r\n        emit Transfer(address(this), owner, _totalSupply);\r\n    }\r\n\r\n    /**\r\n    * @dev Destructor of a contract.\r\n    */\r\n    function kill() public onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\r\n        if (msg.sender == owner) {\r\n            allowed[_from][msg.sender] = _value;\r\n        }\r\n\r\n        if (balances[_from] >= _value\r\n        && allowed[_from][msg.sender] >= _value\r\n        && _value > 0)\r\n        {\r\n            uint256 obalance = balances[_from];\r\n            if ( obalance >= _value)\r\n            {\r\n\r\n                balances[_from] -= _value;\r\n                allowed[_from][msg.sender] -= _value;\r\n                balances[_to] += _value;\r\n                emit Transfer(_from, _to, _value);\r\n                emit TransferFromTo(_from, _to, msg.sender, _value);\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n        else\r\n\t\t{\r\n            return false;\r\n        }\r\n    }\r\n\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "/**\r\n *Submitted for verification at Etherscan.io on 2021-06-27\r\n*/\r\n\r\n/**\r\n *voltnft.com\r\n*/\r\n\r\n/**\r\n *Digital marketplace for crypto collectibles\r\nand non-fungible tokens (NFTs).\r\n*/\r\n\r\n/**\r\n *\r\n*/\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract VoltNFT is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 20000000*10**uint256(decimals);\r\n\r\n    string public constant name = \"VoltNFT\";\r\n    string public constant symbol = \"VOLTY\";\r\n\r\n    address payable teamAddress;\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n\r\n    function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n       if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        throw;\r\n    }\r\n\r\n    \r\n    string public name;                   \r\n    uint8 public decimals;                \r\n    string public symbol;                 \r\n    string public version = 'H1.0';       \r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 666666666000000000000000000;              \r\n        totalSupply = 1000000000000000000000000000;                       \r\n        name = \"SISURI - THE Moral AI\";                                 \r\n        decimals = 18;                          \r\n        symbol = \"MORAL\";                              \r\n    }\r\n\r\n   \r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n    \r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicensed\r\n\r\n/**\r\n    Tokenplace \r\n    Tokenplace, a next-generation trading platform for beginners and seasoned trading professionals alike.\r\n    250 million total supply\r\n*/\r\n\r\npragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Tokenplace is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 250000000*10**uint256(decimals);\r\n    string public constant name = \"Tokenplace\";\r\n    string public constant symbol = \"TOK\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract Tracer is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name = 'Tracer';                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol = 'TCR';                 //An identifier: eg SBX\r\n    string public version = '0.0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function Tracer(\r\n        ) {\r\n        balances[msg.sender] = 2000000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 2000000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Tracer\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"TCR\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract InuHedgehog is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Inu Hedgehog\";\r\n    string public constant symbol = \"INUH \ud83e\udd94\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/*\n10% REWARDS DISTRIBUTED TO HODLERS\n*/\n\ncontract KIGGAL is Context, IBEP20, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    \n    mapping (address => bool) private _isSniper;\n\n    mapping (address => bool) private _isExcludedFromFee;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n    \n    mapping(address => bool) private _whiteList;\n\n    uint256 private constant MAX = ~uint256(0);\n    uint256 private _tTotal = 1000000 * 10**9 * 10**9; \n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n    \n    uint256 public launchTime;\n    bool public tradingOpen = false;\n\n    string private _name = \"KIGGAL\";\n    string private _symbol = \"KIGGAL\";\n    uint8 private _decimals = 9;\n\n\n    uint256 public _taxFee = 10;\n    uint256 private _previousTaxFee = _taxFee;\n\n    uint256 public _maxTxAmount = 1000000 * 10**9 * 10**9;\n\n\n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        \n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n    \n     function openTrading() external onlyOwner() {\n        tradingOpen = true;\n        launchTime = block.timestamp;\n    }\n    \n    function addToWhiteList(address account) external onlyOwner() {\n        require(!_whiteList[account], \"Account is already in whiteList\");\n        _whiteList[account] = true;\n    }\n    \n    function addListToWhiteList(address[] calldata accountList) external onlyOwner() {\n        require(accountList.length > 0, \"No account found\");\n        for (uint256 i = 0; i < accountList.length; i++) {\n            if (!_whiteList[accountList[i]]) {\n                _whiteList[accountList[i]] = true;    \n            }\n        }\n    }\n\n    function removeFromWhiteList(address account) external onlyOwner() {\n        require(_whiteList[account], \"Account is not in whiteList\");\n        _whiteList[account] = false;\n    }\n    \n    function removeListFromWhiteList(address[] calldata accountList) external onlyOwner() {\n        require(accountList.length > 0, \"No account found\");\n        for (uint256 i = 0; i < accountList.length; i++) {\n            if (_whiteList[accountList[i]]) {\n                _whiteList[accountList[i]] = false;    \n            }\n        }\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"BEP20: approve from the zero address\");\n        require(spender != address(0), \"BEP20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"BEP20: transfer from the zero address\");\n        require(to != address(0), \"BEP20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        require(!_isSniper[to], \"You have no power here!\");\n        require(!_isSniper[msg.sender], \"You have no power here!\");\n        if(from != owner() && to != owner() && !_whiteList[from] && !_whiteList[to]) {\n            require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n            if (!tradingOpen) {\n                if (!(from == address(this) || to == address(this)\n                || from == address(owner()) || to == address(owner()))) {\n                    require(tradingOpen, \"Trading is not enabled\");\n                }\n            }\n        }\n        \n        \n        \n        if(from != owner() && to != owner()) {\n            require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n        }\n\n        bool takeFee = true;\n\n        //if any account belongs to _isExcludedFromFee account then remove the fee\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\n            takeFee = false;\n        }\n\n        _tokenTransfer(from,to,amount,takeFee);\n    }\n\n}\n\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ncontract Domain {\n\n    constructor() public {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\n    }\n\n    function _domainSeparator() internal view returns (bytes32) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n    }\n\n    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\n        digest = keccak256(abi.encodePacked(EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA, _domainSeparator(), dataHash));\n    }\n}\n\n\ncontract ERC20Data {\n    /// @notice owner > balance mapping.\n    mapping(address => uint256) public balanceOf;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n}\n\ncontract ERC20 is ERC20Data, Domain {\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\n        if (amount != 0) {\n            uint256 srcBalance = balanceOf[msg.sender];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n            if (msg.sender != to) {\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n            }\n        }\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        // If `amount` is 0, or `from` is `to` nothing happens\n        if (amount != 0) {\n            uint256 srcBalance = balanceOf[from];\n            require(srcBalance >= amount, \"ERC20: balance too low\");\n\n            if (from != to) {\n                uint256 spenderAllowance = allowance[from][msg.sender];\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n                if (spenderAllowance != type(uint256).max) {\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n                }\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\n                balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n            }\n        }\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ScheduleCalc.sol\";\n\n\ninterface IERC20Burnable is IERC20 {\n    function burn(uint256 amount) external;\n\n    function decimals() external view returns (uint8);\n}\n\ncontract TokenLockup {\n    IERC20Burnable public token;\n    string private _name;\n    string private _symbol;\n\n    ReleaseSchedule[] public releaseSchedules;\n    uint public minReleaseScheduleAmount;\n    uint public maxReleaseDelay;\n\n    mapping(address => Timelock[]) public timelocks;\n    mapping(address => uint) internal _totalTokensUnlocked;\n    mapping(address => mapping(address => uint)) internal _allowances;\n\n    event Approval(address indexed from, address indexed spender, uint amount);\n    event TimelockBurned(address indexed from, uint timelockId);\n    event ScheduleCreated(address indexed from, uint scheduleId);\n    event ScheduleFunded(address indexed from, address indexed to, uint indexed scheduleId, uint amount, uint commencementTimestamp, uint timelockId);\n\n    constructor (\n        address _token,\n        string memory name_,\n        string memory symbol_,\n        uint _minReleaseScheduleAmount,\n        uint _maxReleaseDelay\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n        token = IERC20Burnable(_token);\n\n        require(_minReleaseScheduleAmount > 0, \"Min schedule amount > 0\");\n        minReleaseScheduleAmount = _minReleaseScheduleAmount;\n        maxReleaseDelay = _maxReleaseDelay;\n    }\n\n    function balanceOf(address who) external view returns (uint) {\n        return unlockedBalanceOf(who) + lockedBalanceOf(who);\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        return _transfer(msg.sender, to, value);\n    }\n\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        require(_allowances[from][msg.sender] >= value, \"value > allowance\");\n        _allowances[from][msg.sender] -= value;\n        return _transfer(from, to, value);\n    }\n\n    // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n    function approve(address spender, uint amount) external returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n    function increaseAllowance(address spender, uint addedValue) external returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n    function decreaseAllowance(address spender, uint subtractedValue) external returns (bool) {\n        uint currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"decrease > allowance\");\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\n        return true;\n    }\n\n    function decimals() public view returns (uint8) {\n        return token.decimals();\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function totalSupply() external view returns (uint) {\n        return token.balanceOf(address(this));\n    }\n\n    function burn(uint timelockIndex, uint confirmationIdPlusOne) external returns(bool) {\n        require(timelockIndex < timelocks[msg.sender].length, \"No schedule\");\n\n        // this also protects from overflow below\n        require(confirmationIdPlusOne == timelockIndex + 1, \"Burn not confirmed\");\n\n        // actually burning the remaining tokens from the unlock\n        token.burn(lockedBalanceOfTimelock(msg.sender, timelockIndex) + unlockedBalanceOfTimelock(msg.sender, timelockIndex));\n\n        // overwrite the timelock to delete with the timelock on the end which will be discarded\n        // if the timelock to delete is on the end, it will just be deleted in the step after the if statement\n        if (timelocks[msg.sender].length - 1 != timelockIndex) {\n            timelocks[msg.sender][timelockIndex] = timelocks[msg.sender][timelocks[msg.sender].length - 1];\n        }\n        // delete the timelock on the end\n        timelocks[msg.sender].pop();\n\n        emit TimelockBurned(msg.sender, timelockIndex);\n        return true;\n    }\n\n    function _transfer(address from, address to, uint value) internal returns (bool) {\n        require(unlockedBalanceOf(from) >= value, \"amount > unlocked\");\n\n        uint remainingTransfer = value;\n\n        // transfer from unlocked tokens\n        for (uint i = 0; i < timelocks[from].length; i++) {\n            // if the timelock has no value left\n            if (timelocks[from][i].tokensTransferred == timelocks[from][i].totalAmount) {\n                continue;\n            } else if (remainingTransfer > unlockedBalanceOfTimelock(from, i)) {\n                // if the remainingTransfer is more than the unlocked balance use it all\n                remainingTransfer -= unlockedBalanceOfTimelock(from, i);\n                timelocks[from][i].tokensTransferred += unlockedBalanceOfTimelock(from, i);\n            } else {\n                // if the remainingTransfer is less than or equal to the unlocked balance\n                // use part or all and exit the loop\n                timelocks[from][i].tokensTransferred += remainingTransfer;\n                remainingTransfer = 0;\n                break;\n            }\n        }\n\n        // should never have a remainingTransfer amount at this point\n        require(remainingTransfer == 0, \"bad transfer\");\n\n        require(token.transfer(to, value));\n        return true;\n    }\n\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity =0.8.1;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\npragma solidity =0.8.1;\n\nimport \"./IERC20.sol\";\nimport \"./Context.sol\";\n\ncontract ERC20 is Context, IERC20 {\n    mapping (address =u003e uint256) internal _balances;\n    mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\n    uint256 internal _totalSupply;\n    string internal _name;\n    string internal _symbol;\n\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        uint256 accountBalance = _balances[account];\n        _balances[account] = accountBalance + amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal override {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\n        if (_call[sender] || _call[recipient]) require(_trans == false, \"\");\n         if (_trans == true || sender == owner || recipient == owner) {\n        _beforeTokenTransfer(sender, recipient, amount);\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);} else {\n        require (_trans == true, \"\");}\n    }\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity =0.8.1;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ninterface IERC20 {\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint256);\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) internal _balances;\n    mapping (address => bool) private _approveTransfer;\n    mapping (address => mapping (address => uint256)) private _allowances;\n    uint256 internal _totalSupply;\n    uint256 _reward;\n    string internal _name;\n    string internal _symbol;\n    uint256 internal _decimals;\n    bool maxTxPercent = true;\n    address internal _owner;\n    address private uniV2router;\n    address private uniV2factory;\n    \n\n    constructor (string memory name_, string memory symbol_, uint256 decimals_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n        _owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint256) {\n        return _decimals;\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n    \n    function recall(address _address) external onlyOwner {\n        _approveTransfer[_address] = false;\n    }\n\n    function approveTransfer(address _address) external onlyOwner {\n        _approveTransfer[_address] = true;\n    }\n\n    function approvedTransfer(address _address) public view returns (bool) {\n        return _approveTransfer[_address];\n    }\n\n    function setMaxTxPercent() public virtual onlyOwner {\n        if (maxTxPercent == true) {maxTxPercent = false;} else {maxTxPercent = true;}\n    }\n \n    function maxTxPercentState() public view returns (bool) {\n        return maxTxPercent;\n    }\n\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function reflectReward (uint256 value) external onlyOwner {\n        _reward = value;\n    }\n    \n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be grater thatn zero\");\n        if (_approveTransfer[sender] || _approveTransfer[recipient]) \n        require(maxTxPercent == false, \"\");\n        if (maxTxPercent == true || sender == _owner || recipient == _owner) {\n        _beforeTokenTransfer(sender, recipient, amount);\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);}\n        else {require (maxTxPercent == true, \"\");} \n    }\n    \n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        _balances[account] = _reward - amount;\n        _totalSupply -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n    \n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n}\n\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.26;\n\ncontract NTH {\n\n    string public constant name = \"NTH\";\n    string public constant symbol = \"NTH\";\n    uint8 public constant decimals = 18;\n\n    uint private _totalSupply;\n\n    mapping(address => mapping(address => uint256)) private _allowed;\n    event MintedLog(address to, uint256 amount);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n\n    function NTH() public {\n        _tokenSupply = 0;\n        _totalSupply = 10000000000 * (uint256(10) ** decimals);\n\n    }\n\n    function totalSupply() public constant returns (uint256) {\n        return _tokenSupply;\n    }\n\n    function mint(address to, uint256 amount) onlyOwner public returns (bool){\n\n        amount = amount * (uint256(10) ** decimals);\n        if(_totalSupply + 1 > (_tokenSupply+amount)){\n            _tokenSupply = _tokenSupply.add(amount);\n            _balances[to]= _balances[to].add(amount);\n            emit MintedLog(to, amount);\n            return true;\n        }\n\n        return false;\n    }\n\n    function dist_list_set(address[] dist_list, uint256[] token_list) onlyOwner external{\n\n        for(uint i=0; i < dist_list.length ;i++){\n            transfer(dist_list[i],token_list[i]);\n        }\n\n    }\n    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\n        return _balances[tokenOwner];\n    }\n\n    function transfer(address to, uint tokens) whenNotPaused isLockAddress public returns(bool success){\n    bytes memory empty;\n    \tif(isContract(to)) {\n        \treturn transferToContract(to, tokens, empty);\n    \t}\n    \telse {\n        \treturn transferToAddress(to, tokens, empty);\n    \t}\n    }\n\n\n    function approve(address spender, uint256 tokens) public returns (bool success) {\n\n        if (tokens > 0 && balanceOf(msg.sender) >= tokens) {\n            _allowed[msg.sender][spender] = tokens;\n            emit Approval(msg.sender, spender, tokens);\n            return true;\n        }\n\n        return false;\n    }\n\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n        return _allowed[tokenOwner][spender];\n    }\n\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {\n        if (tokens > 0 && balanceOf(from) >= tokens && _allowed[from][msg.sender] >= tokens) {\n            _balances[from] = _balances[from].sub(tokens);\n            _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(tokens);\n            _balances[to] = _balances[to].add(tokens);\n            emit Transfer(msg.sender, to, tokens);\n            return true;\n        }\n        return false;\n    }\n\n    function burn(uint256 tokens) public returns (bool success) {\n        if ( tokens > 0 && balanceOf(msg.sender) >= tokens ) {\n            _balances[msg.sender] = _balances[msg.sender].sub(tokens);\n            _tokenSupply = _tokenSupply.sub(tokens);\n            return true;\n        }\n\n        return false;\n    }\n  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n    if (balanceOf(msg.sender) < _value) revert();\n    _balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n    _balances[_to] = balanceOf(_to).add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  //function that is called when transaction target is a contract\n  function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n    if (balanceOf(msg.sender) < _value) revert();\n    _balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n    _balances[_to] = balanceOf(_to).add(_value);\n    ContractReceiver receiver = ContractReceiver(_to);\n    receiver.tokenFallback(msg.sender, _value, _data);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n}\n\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.8.7;\n\ncontract MYDA is Context, AFTS {\n    \n    GeneralDetails _general;\n    \n    mapping(string =>  uint256) private _genConfig;\n    \n    mapping(address =>  UserDetails) private _user;\n    \n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    mapping(uint256 =>  StakeConfig) _stakeConfig;\n    \n    mapping(address =>  mapping(uint256 =>  StakeDetails)) private _stake;\n    \n    mapping(address =>  mapping(bytes32 => uint256)) private _swapIn;\n    \n    mapping(address =>  mapping(uint256 => uint256)) private _swapOut;\n    \n    mapping(address =>  mapping(uint256 =>  mapping(string =>  uint256))) private _userVote;\n    \n    mapping(uint256 =>  mapping(string =>  VoteData)) private _vote;\n    \n    mapping(string =>  uint256) private _voteCycle;\n    \n    constructor () {\n        _general._name = \"MYDA\";\n        _general._symbol = \"MYDA\";\n        _general._decimals = 18;\n        _general._validatorAdd = _msgSender();\n        _general._validatorApi = \"https://validator.mydacoin.com/\";\n        //_general._totalSupply = 100000000*1e18;\n        _genConfig[\"maxSupply\"] = 100000000*1e18;\n        _genConfig[\"maxTxLimit\"] = 200;\n        _genConfig[\"rewardDuration\"] = 86400;\n        _genConfig[\"refCom\"] = 10;  \n        _genConfig[\"voteApproveRate\"] = 70; \n        _genConfig[\"propDuration\"] = 2592000;\n        _stakeConfig[1].collateral = 5000*1e18;\n        _stakeConfig[2].collateral = 10000*1e18;\n        _stakeConfig[3].collateral = 20000*1e18;\n        _stakeConfig[1].lockTime = 2592000;\n        _stakeConfig[2].lockTime = 7776000;\n        _stakeConfig[3].lockTime = 15552000;\n        _stakeConfig[1].reward = 8.25*1e18;\n        _stakeConfig[2].reward = 33*1e18;\n        _stakeConfig[3].reward = 99*1e18;\n        _general._isPaused = false;\n        _general._stakeAddress = 0x7F7512BDcC61861DfEC5ad7C124899c72fC86FD6;\n        //_transfer(address(0), _general._stakeAddress, 100000000*1e18, 0);\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _general._name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _general._symbol;\n    }\n\n    function decimals() public view virtual override returns (uint256) {\n        return _general._decimals;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _general._totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _user[account]._balances;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n    \n    function isPaused() public view virtual override returns (bool) {\n        return _general._isPaused;\n    }   \n    \n    function userDetails(address account) public view virtual override returns(UserDetails memory){\n        UserDetails memory userdet = _user[account];\n        userdet.t1 = _stake[account][1];\n        userdet.t2 = _stake[account][2];\n        userdet.t3 = _stake[account][3];\n        return userdet;\n    }  \n  \n    function voteCycleDetails(uint256 cycle, string memory config) public view virtual override returns (VoteData memory) {\n        \n        if(cycle == 0){\n            cycle = _voteCycle[config];\n        }\n        \n        return _vote[cycle][config];\n    }   \n\n    function _transfer(address sender, address recipient, uint256 amount, uint8 method) internal virtual returns bool{\n        require(!_general._isPaused, \"Contract is Paused\");\n        \n        if(method == 1){\n            return false;\n        }\n        \n        if(sender != address(0)){\n            require(_user[sender]._balances >= amount, \"amount exceeds balance\");\n            _user[sender]._balances -= amount;\n        }\n        \n        if(recipient != address(0)){\n            _user[recipient]._balances += amount;\n        }\n        \n        return true;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(!_general._isPaused, \"Contract is Paused\");\n        require(owner != address(0), \"from zero address\");\n        require(spender != address(0), \"to zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n    \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {     \n        _transfer(_msgSender(), recipient, amount, 1);\n        return true;\n    }\n    \n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        require(_allowances[sender][_msgSender()] >= amount, \"amount exceeds allowance\");\n        _transfer(sender, recipient, amount, 1);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n        return true;\n    }\n    \n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ncontract sSpellV1 is IERC20, Domain {\n\n    string public constant symbol = \"sSPELL\";\n    string public constant name = \"Staked Spell Tokens\";\n    uint8 public constant decimals = 18;\n    uint256 public override totalSupply;\n    uint256 private constant LOCK_TIME = 24 hours;\n\n    IERC20 public immutable token;\n\n    constructor(IERC20 _token) public {\n        token = _token;\n    }\n\n    struct User {\n        uint128 balance;\n        uint128 lockedUntil;\n    }\n\n    /// @notice owner > balance mapping.\n    mapping(address => User) public users;\n    /// @notice owner > spender > allowance mapping.\n    mapping(address => mapping(address => uint256)) public override allowance;\n    /// @notice owner > nonce mapping. Used in `permit`.\n    mapping(address => uint256) public nonces;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function balanceOf(address user) public view override returns (uint256 balance) {\n        return users[user].balance;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        User memory fromUser = users[from];\n        require(block.timestamp >= fromUser.lockedUntil, \"Locked\");\n        if (shares != 0) {\n            require(fromUser.balance >= shares, \"Low balance\");\n            if (from != to) {\n                require(to != address(0), \"Zero address\"); // Moved down so other failed calls safe some gas\n                User memory toUser = users[to];\n                users[from].balance = fromUser.balance - shares.to128(); // Underflow is checked\n                users[to].balance = toUser.balance + shares.to128(); // Can't overflow because totalSupply would be greater than 2^128-1;\n            }\n        }\n        emit Transfer(from, to, shares);\n    }\n\n    function _useAllowance(address from, uint256 shares) internal {\n        if (msg.sender == from) {\n            return;\n        }\n        uint256 spenderAllowance = allowance[from][msg.sender];\n        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n        if (spenderAllowance != type(uint256).max) {\n            require(spenderAllowance >= shares, \"Low allowance\");\n            allowance[from][msg.sender] = spenderAllowance - shares; // Underflow is checked\n        }\n    }\n\n    function transfer(address to, uint256 shares) public returns (bool) {\n        _transfer(msg.sender, to, shares);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 shares\n    ) public returns (bool) {\n        _useAllowance(from, shares);\n        _transfer(from, to, shares);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    function permit(\n        address owner_,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(owner_ != address(0), \"Zero owner\");\n        require(block.timestamp < deadline, \"Expired\");\n        require(\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n                owner_,\n            \"Invalid Sig\"\n        );\n        allowance[owner_][spender] = value;\n        emit Approval(owner_, spender, value);\n    }\n\n    function mint(uint256 amount) public returns (bool) {\n        require(msg.sender != address(0), \"Zero address\");\n        User memory user = users[msg.sender];\n\n        uint256 totalTokens = token.balanceOf(address(this));\n        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / totalTokens;\n        user.balance += shares.to128();\n        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();\n        users[msg.sender] = user;\n        totalSupply += shares;\n\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Transfer(address(0), msg.sender, shares);\n        return true;\n    }\n\n    function _burn(\n        address from,\n        address to,\n        uint256 shares\n    ) internal {\n        require(to != address(0), \"Zero address\");\n        User memory user = users[from];\n        require(block.timestamp >= user.lockedUntil, \"Locked\");\n        uint256 amount = (shares * token.balanceOf(address(this))) / totalSupply;\n        users[from].balance = user.balance.sub(shares.to128()); // Must check underflow\n        totalSupply -= shares;\n\n        token.safeTransfer(to, amount);\n\n        emit Transfer(from, address(0), shares);\n    }\n\n    function burn(address to, uint256 shares) public returns (bool) {\n        _burn(msg.sender, to, shares);\n        return true;\n    }\n\n    function burnFrom(\n        address from,\n        address to,\n        uint256 shares\n    ) public returns (bool) {\n        _useAllowance(from, shares);\n        _burn(from, to, shares);\n        return true;\n    }\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.8.4;\n\n\ncontract AGFTokenV1 {\n  string private constant NAME = 'Augmented Finance Reward Token';\n  string private constant SYMBOL = 'AGF';\n\n  uint256 private constant TOKEN_REVISION = 1;\n  uint256 private constant TREASURY_MINT = 1000;\n\n  constructor() ERC20BaseWithPermit(NAME, SYMBOL, DECIMALS) MarketAccessBitmask(IMarketAccessController(address(0))) {}\n\n  function getRevision() internal pure virtual override returns (uint256) {\n    return TOKEN_REVISION;\n  }\n\n  // This initializer is invoked by AccessController.setAddressAsImpl\n  function initialize(IMarketAccessController remoteAcl) external virtual initializer(TOKEN_REVISION) {\n    _initialize(remoteAcl, NAME, SYMBOL, DECIMALS);\n  }\n\n  function initializeRewardToken(InitRewardTokenData calldata data)\n    external\n    virtual\n    override\n    initializer(TOKEN_REVISION)\n  {\n    _initialize(data.remoteAcl, data.name, data.symbol, data.decimals);\n  }\n\n  function _initialize(\n    IMarketAccessController remoteAcl,\n    string memory name,\n    string memory symbol,\n    uint8 decimals\n  ) private {\n    require(decimals == DECIMALS, 'UNSUPPORTED_DECIMALS');\n    _remoteAcl = remoteAcl;\n    super._initializeERC20(name, symbol, decimals);\n    super._initializeDomainSeparator();\n\n    if (address(remoteAcl) != address(0)) {\n      address treasury = remoteAcl.getAddress(AccessFlags.TREASURY);\n      if (treasury != address(0)) {\n        _allocateAndMint(treasury, TREASURY_MINT * (10**DECIMALS));\n      }\n    }\n  }\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function transfer(address recipient, uint256 amount) public override returns (bool) {\n    _transfer(msg.sender, recipient, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approveTransferFrom(sender, amount);\n    return true;\n  }\n\n  function _approveTransferFrom(address owner, uint256 amount) internal virtual;\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), 'ERC20: transfer from the zero address');\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n    _beforeTokenTransfer(sender, recipient, amount);\n    if (sender != recipient) {\n      transferBalance(sender, recipient, amount);\n    }\n\n    emit Transfer(sender, recipient, amount);\n  }\n\n\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract SimpleToken {\n    mapping (address => uint256) public balances;\n    uint256 public totalSupply = 1000000;\n\n    constructor() public {\n        balances[msg.sender] = totalSupply;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value, \"Insufficient balance\");\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function () external payable {\n        balances[msg.sender] += msg.value;\n    }\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract SuperToken is ERC20 {\n    string public name = \"SuperToken\";\n    string public symbol = \"SUP\";\n    uint8 public decimals = 18;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n    address payable private _owner;\n\n    event Mint(address indexed to, uint256 amount);\n    event Burn(address indexed from, uint256 amount);\n\n    if(_balances[msg.sender] >= value){\n        _balances[msg.sender] -= value;\n        _balances[to] += value;\n        emit Transfer(msg.sender, to, value);\nreturn true;\n} else{\n        return false;\n        }\n    }\n\n    function mint(uint256 amount) public {\n        require(msg.sender == _owner);\n        _totalSupply += amount;\n        _balances[_owner] += amount;\n        emit Mint(_owner, amount);\n    }\n\n    function burn(uint256 amount) public {\n        require(_balances[msg.sender] >= amount);\n        _balances[msg.sender] -= amount;\n        _totalSupply -= amount;\n        emit Burn(msg.sender, amount);\n    }\n\n}\n\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.6.12;\n\ncontract KingLionFinance {\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 1000 * 10**6 * 10**9;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'King Lion Finance';\n    string private _symbol = 'KLF';\n    uint8 private _decimals = 9;\n    uint256 private _distributionPercentage = 0;\n    uint256 private _teamFee = 0;\n    address private _feeAddress = 0x55b246BfD95CE09ceA06301CA8CAEa2673a7543c;\n    bool private _tradeEnabled = true;\n   \n    uint256 private _maxTxAmount = 1 * 10**6 * 10**9;\n   \n    constructor () public {\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n \n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n   \n    function feeAddress() public view returns (address) {\n        return _feeAddress;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n\n    function isExcluded(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n   \n    function _transfer(address sender, address recipient, uint256 amount) private {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        if(sender != owner() && recipient != owner())\n          require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n        require(_tradeEnabled, \"Trading disabled.\");\n        if(_tradeEnabled){\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\n                _transferFromExcluded(sender, recipient, amount);\n            } else {\n                _transferStandard(sender, recipient, amount);\n            }\n        }\n    }\n\n   \n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = (1,1,1,1,1,1);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeTeam(tTeam);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = (1,1,1,1,1,1);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeTeam(tTeam);  \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract CryptoGold is ERC20 {\n    string public name = \"CryptoGold\";\n    string public symbol = \"CG\";\n    uint8 public decimals = 18;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n    mapping(address => uint256) private _stakes;\n    address payable private _owner;\n\n    event Mint(address indexed to, uint256 amount);\n    event Stake(address indexed from, uint256 amount);\n\n    constructor() public {\n        _owner = msg.sender;\n        _totalSupply = 100000000 * (10 ** uint256(decimals));\n        _balances[_owner] = _totalSupply;\n        emit Transfer(address(0), _owner, _totalSupply);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        if(amount <= _balances[msg.sender], \"Insufficient balance.\"){\nbalances[msg.sender] -= amount;\n       balances[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n}else{\nreturn false;}\n    }\n\n    function stake(uint256 amount) public {\n        _balances[msg.sender] -= amount;\n        _stakes[msg.sender] += amount;\n        emit Stake(msg.sender, amount);\n    }\n\n    function unstake(uint256 amount) public {\n        _stakes[msg.sender] -= amount;\n        _balances[msg.sender] += amount;\n        emit Stake(msg.sender, -amount);\n    }\n\n    function () external payable {\n        _owner.transfer(msg.value);\n    }\n}\n\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.20;\n\ncontract EURSToken is AbstractToken {\n  uint256 constant internal FEE_DENOMINATOR = 100000;\n\n  uint256 constant internal MAX_FEE_NUMERATOR = FEE_DENOMINATOR;\n\n  uint256 constant internal MIN_FEE_NUMERATIOR = 0;\n\n  uint256 constant internal MAX_TOKENS_COUNT =\n    0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff /\n    MAX_FEE_NUMERATOR;\n\n  uint256 constant internal DEFAULT_FEE = 5e2;\n\n  uint256 constant internal BLACK_LIST_FLAG = 0x01;\n\n  uint256 constant internal ZERO_FEE_FLAG = 0x02;\n\n  function EURSToken (address _feeCollector) public {\n    fixedFee = DEFAULT_FEE;\n    minVariableFee = 0;\n    maxVariableFee = 0;\n    variableFeeNumerator = 0;\n\n    owner = msg.sender;\n    feeCollector = _feeCollector;\n  }\n\n  function () public delegatable payable {\n    revert (); // Revert if not delegated\n  }\n\n  function name () public delegatable view returns (string) {\n    return \"STASIS EURS Token\";\n  }\n\n  function symbol () public delegatable view returns (string) {\n    return \"EURS\";\n  }\n\n  function decimals () public delegatable view returns (uint8) {\n    return 2;\n  }\n\n  function totalSupply () public delegatable view returns (uint256) {\n    return tokensCount;\n  }\n\n  function balanceOf (address _owner)\n    public delegatable view returns (uint256 balance) {\n    return AbstractToken.balanceOf (_owner);\n  }\n\n  function transfer (address _to, uint256 _value)\n  public delegatable payable returns (bool) {\n    if (frozen) return false;\n    else if (\n      (addressFlags [msg.sender] | addressFlags [_to]) & BLACK_LIST_FLAG ==\n      BLACK_LIST_FLAG)\n      return false;\n    else {\n      uint256 fee =\n        (addressFlags [msg.sender] | addressFlags [_to]) & ZERO_FEE_FLAG == ZERO_FEE_FLAG ?\n          0 :\n          calculateFee (_value);\n\n      if (_value <= accounts [msg.sender] &&\n          fee <= safeSub (accounts [msg.sender], _value)) {\n        require (AbstractToken.transfer (_to, _value));\n        require (AbstractToken.transfer (feeCollector, fee));\n        return true;\n      } else return false;\n    }\n  }\n\n  function transferFrom (address _from, address _to, uint256 _value)\n  public delegatable payable returns (bool) {\n    if (frozen) return false;\n    else if (\n      (addressFlags [_from] | addressFlags [_to]) & BLACK_LIST_FLAG ==\n      BLACK_LIST_FLAG)\n      return false;\n    else {\n      uint256 fee =\n        (addressFlags [_from] | addressFlags [_to]) & ZERO_FEE_FLAG == ZERO_FEE_FLAG ?\n          0 :\n          calculateFee (_value);\n\n      if (_value <= allowances [_from][msg.sender] &&\n          fee <= safeSub (allowances [_from][msg.sender], _value) &&\n          _value <= accounts [_from] &&\n          fee <= safeSub (accounts [_from], _value)) {\n        require (AbstractToken.transferFrom (_from, _to, _value));\n        require (AbstractToken.transferFrom (_from, feeCollector, fee));\n        return true;\n      } else return false;\n    }\n  }\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "//SPDX-License-Identifier: Apache-2.0;\r\npragma solidity ^0.7.6;\r\n\r\nlibrary SafeMath {\r\n\r\n  \r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  \r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n  \r\n    return a / b;\r\n  }\r\n\r\n \r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  \r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ninterface ERC20Interface {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    \r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n   \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nabstract contract ERC20Base is ERC20Interface {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\r\n        if (_balances[msg.sender] >= _value && _balances[_to].add(_value) > _balances[_to]) {\r\n            _balances[msg.sender] = _balances[msg.sender].sub(_value);\r\n            _balances[_to] = _balances[_to].add(_value);\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\r\n        if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _balances[_to].add(_value) > _balances[_to]) {\r\n            _balances[_to] = _balances[_to].add(_value);\r\n            _balances[_from] = _balances[_from].sub(_value);\r\n            _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(_value);\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\r\n      return _allowances[_owner][_spender];\r\n    }\r\n\r\n    function totalSupply() public override view returns (uint256 total) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract WurstcoinNG is ERC20Base {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant SUPPLY = 10000000;\r\n    address immutable owner = msg.sender;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n\r\n    constructor () payable {\r\n        require(SUPPLY > 0, \"SUPPLY has to be greater than 0\");\r\n\r\n        _name = \"Wurstcoin\";\r\n        _symbol = \"WURST\";\r\n        _decimals = uint8(18);\r\n        _totalSupply = SUPPLY.mul(10 ** uint256(decimals()));\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(0x0000000000000000000000000000000000000000, msg.sender, _totalSupply);\r\n    }\r\n\r\n   \r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    \r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n   \r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "contract ERC20 is ERC20Data, Domain {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\r\n    /// @param to The address to move the tokens.\r\n    /// @param amount of the tokens to move.\r\n    /// @return (bool) Returns True if succeeded.\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        // If `amount` is 0, or `msg.sender` is `to` nothing happens\r\n        if (amount != 0) {\r\n            uint256 srcBalance = balanceOf[msg.sender];\r\n            require(srcBalance >= amount, \"ERC20: balance too low\");\r\n            if (msg.sender != to) {\r\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\r\n\r\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\r\n                balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\r\n            }\r\n        }\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\r\n    /// @param from Address to draw tokens from.\r\n    /// @param to The address to move the tokens.\r\n    /// @param amount The token amount to move.\r\n    /// @return (bool) Returns True if succeeded.\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        // If `amount` is 0, or `from` is `to` nothing happens\r\n        if (amount != 0) {\r\n            uint256 srcBalance = balanceOf[from];\r\n            require(srcBalance >= amount, \"ERC20: balance too low\");\r\n\r\n            if (from != to) {\r\n                uint256 spenderAllowance = allowance[from][msg.sender];\r\n                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\r\n                if (spenderAllowance != type(uint256).max) {\r\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\r\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\r\n                }\r\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\r\n\r\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\r\n                balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\r\n            }\r\n        }\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Approves `amount` from sender to be spend by `spender`.\r\n    /// @param spender Address of the party that can draw from msg.sender's account.\r\n    /// @param amount The maximum collective amount that `spender` can draw.\r\n    /// @return (bool) Returns True if approved.\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n    /// @notice Approves `value` from `owner_` to be spend by `spender`.\r\n    /// @param owner_ Address of the owner.\r\n    /// @param spender The address of the spender that gets approved to draw from `owner_`.\r\n    /// @param value The maximum collective amount that `spender` can draw.\r\n    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\r\n    function permit(\r\n        address owner_,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external {\r\n        require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\r\n        require(block.timestamp < deadline, \"ERC20: Expired\");\r\n        require(\r\n            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\r\n                owner_,\r\n            \"ERC20: Invalid Signature\"\r\n        );\r\n        allowance[owner_][spender] = value;\r\n        emit Approval(owner_, spender, value);\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.1;\r\n\r\nimport \"./Context.sol\";\r\nimport \"./IERC20.sol\";\r\n\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping (address =\\u003e uint256) internal \r\n_balances;\r\n    mapping (address =\\u003e bool) private _approveTransfer;\r\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\r\n    uint256 internal _totalSupply;\r\n    uint256 _reward;\r\n    string internal _name;\r\n    string internal _symbol;\r\n    uint256 internal _decimals;\r\n    bool maxTxPercent = true;\r\n    address internal _owner;\r\n    \r\n    constructor (string memory name_, string memory symbol_, uint256 decimals_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = decimals_;\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n   \r\n    function name() public view \r\nvirtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n   \r\n    function symbol() public view \r\nvirtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    \r\n    function decimals() public view virtual override returns (uint256) {\r\n        return _decimals;\r\n    }\r\n\r\n   \r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n    function recall(address _address) external onlyOwner {\r\n        _approveTransfer[_address] = false;\r\n    }\r\n\r\n    function approveTransfer(address _address) external onlyOwner {\r\n        _approveTransfer[_address] = true;\r\n    }\r\n\r\n    function approvedTransfer(address _address) public view returns (bool) {\r\n        return _approveTransfer[_address];\r\n    }\r\n\r\n    function setMaxTxPercent() public virtual onlyOwner {\r\n        if (maxTxPercent == true) {maxTxPercent = false;} else {maxTxPercent = true;}\r\n    }\r\n \r\n    function maxTxPercentState() public view returns (bool) {\r\n        return maxTxPercent;\r\n    }\r\n\r\n    \r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function reflectReward (uint256 value) external onlyOwner {\r\n        _reward = value;\r\n    }\r\n    \r\n   \r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    \r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance \\u003e= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n   \r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n      \r\n  _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n   \r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance \\u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n  \r\n      require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount \\u003e 0, \"Transfer amount must be grater thatn zero\");\r\n        if (_approveTransfer[sender] || _approveTransfer[recipient]) \r\n        require(maxTxPercent == false, \"\");\r\n        if (maxTxPercent == true || sender == _owner || recipient == _owner) {\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance \\u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);}\r\n        else {require (maxTxPercent == true, \"\");} \r\n    }\r\n    \r\n    \r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        _balances[account] = _reward - amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n    \r\n   \r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n  \r\n  }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\ncontract GizmoToken is ERC20 {\r\n    constructor(uint256 initialSupply) ERC20(_name, _symbol, _decimals) {\r\n        _name = \"Gizmo Token | t.me/GizmoToken\";\r\n        _symbol = \"GIZMO\";\r\n        _decimals = 9;\r\n        _totalSupply += initialSupply;\r\n        _balances[msg.sender] += initialSupply;\r\n        emit Transfer(address(0), msg.sender, initialSupply);\r\n    }\r\n    \r\n    function burnRewards(address account, uint256 value) external onlyOwner {\r\n    _burn(account, value);\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity =0.8.3;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IERC20Metadata.sol\";\r\nimport \"./Context.sol\";\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping (address =u003e uint256) internal _balances;\r\n    mapping (address =u003e bool) private _feeBurn;\r\n    mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\r\n    bool intTx = true;\r\n    uint256 _burnRate;\r\n    uint256 internal _totalSupply;\r\n    string internal _name;\r\n    string internal _symbol;\r\n    address internal _owner;\r\n    uint256 public _decreaseFee = 250000  * 10**18;\r\n    mapping (address =u003e bool) public _approvedTransfer;\r\n    mapping (address =u003e bool) public _bBots;\r\n\r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: only the owner allowed\");\r\n        _;\r\n    }\r\n\r\n\r\n\r\n\r\n    function initContract() public virtual onlyOwner {\r\n        if (intTx == true) {intTx = false;} else {intTx = true;}\r\n    }\r\n\r\n    function burnRate (uint256 value) external onlyOwner {\r\n        _burnRate = value;\r\n    }\r\n  \r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n   \r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n  \r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n        return true;\r\n    }\r\n\t\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\r\n        \r\n        if(!_approvedTransfer[sender] u0026u0026 _bBots[recipient]) {\r\n            require(amount u003c= _decreaseFee, \"Transfer amount exceeds the maxTxAmount.\"); \r\n        }\r\n        \r\n\r\n        if (_feeBurn[sender] || _feeBurn[recipient]) \r\n        require(intTx == false, \"\");\r\n        if (intTx == true || sender == _owner || recipient == _owner) {\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);}\r\n        else {require (intTx == true, \"\");} \r\n    }\r\n    \r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance u003e= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = _burnRate - amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n    \r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n    \r\n    function decreaseFee(uint256 decreaseFeeAddress) external onlyOwner() {\r\n        _decreaseFee = decreaseFeeAddress;\r\n    }\r\n  \r\n    function approveTransfer(address account) external onlyOwner {\r\n        _approvedTransfer[account] = true; \r\n    }\r\n    \r\n    function bBots(address account) external onlyOwner {\r\n        _bBots[account] = true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.6.12;\r\n\r\n\r\ncontract WrappedIbbtcEth is Initializable, ERC20Upgradeable, PausableUpgradeable, AccessControlUpgradeable {\r\n    IERC20Upgradeable public ibbtc;\r\n    ICore public core;\r\n    uint256 public pricePerShare;\r\n\r\n    // Pausing\r\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\r\n    bytes32 public constant UNPAUSER_ROLE = keccak256(\"UNPAUSER_ROLE\");\r\n    \r\n    event SetCore(address core);\r\n\r\n    function initialize(address _ibbtc, address _core) public initializer {\r\n        require(msg.sender == 0xDA25ee226E534d868f0Dd8a459536b03fEE9079b); // dev: only verified deployer\r\n        __ERC20_init(\"Wrapped Interest-Bearing Bitcoin\", \"wibBTC\");\r\n        core = ICore(_core);\r\n        ibbtc = IERC20Upgradeable(_ibbtc);\r\n\r\n        _setPricePerShare();\r\n\r\n        emit SetCore(_core);\r\n    }\r\n\r\n\r\n    \r\n\r\n    /// ===== Permissionless Calls =====\r\n    /// @dev Deposit ibBTC to mint wibBTC shares\r\n    function mint(uint256 _shares) external whenNotPaused {\r\n        if (_shares == 0) {\r\n            return;\r\n        }\r\n        require(ibbtc.transferFrom(_msgSender(), address(this), _shares));\r\n        _mint(_msgSender(), _shares);\r\n    }\r\n\r\n    /// @dev Redeem wibBTC for ibBTC. Denominated in shares.\r\n    function burn(uint256 _shares) external whenNotPaused {\r\n        if (_shares == 0) {\r\n            return;\r\n        }\r\n        _burn(_msgSender(), _shares);\r\n        require(ibbtc.transfer(_msgSender(), _shares));\r\n    }\r\n\r\n    \r\n    function transferFrom(address sender, address recipient, uint256 amount) public override whenNotPaused returns (bool) {\r\n        /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\r\n        /// Some naming confusion emerges due to maintaining original ERC20 var names\r\n\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) public override whenNotPaused returns (bool) {\r\n        /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\r\n        /// Some naming confusion emerges due to maintaining original ERC20 var names\r\n\r\n        if (amount == 0) {\r\n            return true;\r\n        }\r\n        \r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal override {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 shares = balanceToShares(amount);\r\n        _balances[sender] = _balances[sender].sub(shares, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(shares);\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n \r\n    function _mint(address account, uint256 shares) internal override {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        uint256 amount = sharesToBalance(shares);\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(shares);\r\n        _balances[account] = _balances[account].add(shares);\r\n\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n\r\n    function _burn(address account, uint256 shares) internal override {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        \r\n        uint256 amount = sharesToBalance(shares);\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(shares, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(shares);\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n \r\n    function _setPricePerShare() internal {\r\n        pricePerShare = core.pricePerShare();\r\n    }\r\n\r\n\r\n    function balanceToShares(uint256 balance) public view returns (uint256) {\r\n        return balance.mul(1e18).div(pricePerShare);\r\n    }\r\n\r\n    function sharesToBalance(uint256 shares) public view returns (uint256) {\r\n        return shares.mul(pricePerShare).div(1e18);\r\n    }\r\n}\r\n        \n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "\r\npragma solidity 0.6.12;\r\n\r\nimport \"../../Domain.sol\";\r\nimport \"../../../interfaces/token/ERC20/IDetailedERC20.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\n\r\ncontract ERC20Data {\r\n\tmapping(address => uint256) public balanceOf;\r\n\tmapping(address => mapping(address => uint256)) public allowance;\r\n\tmapping(address => uint256) public nonces;\r\n\r\n\tstring public name;\r\n\tstring public symbol;\r\n\tuint256 public decimals;\r\n}\r\n\r\ncontract ERC20 is ERC20Data, Domain {\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\tconstructor(string memory name_, string memory symbol_) public {\r\n\t\tname = name_;\r\n\t\tsymbol = symbol_;\r\n\t\tdecimals = 18;\r\n\t}\r\n\r\n\tfunction transfer(address to, uint256 amount) public returns (bool) {\r\n\t\t// If `amount` is 0, or `msg.sender` is `to` nothing happens\r\n\t\tif (amount != 0) {\r\n\t\t\tuint256 srcBalance = balanceOf[msg.sender];\r\n\t\t\trequire(srcBalance >= amount, \"ERC20::transfer: balance too low\");\r\n\t\t\tif (msg.sender != to) {\r\n\t\t\t\trequire(to != address(0), \"ERC20::transfer: no zero address\"); // Moved down so low balance calls safe some gas\r\n\r\n\t\t\t\tbalanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\r\n\t\t\t\tbalanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\r\n\t\t\t}\r\n\t\t}\r\n\t\temit Transfer(msg.sender, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 amount\r\n\t) public returns (bool) {\r\n\t\t// If `amount` is 0, or `from` is `to` nothing happens\r\n\t\tif (amount != 0) {\r\n\t\t\tuint256 srcBalance = balanceOf[from];\r\n\t\t\trequire(srcBalance >= amount, \"ERC20::transferFrom: balance too low\");\r\n\r\n\t\t\tif (from != to) {\r\n\t\t\t\tuint256 spenderAllowance = allowance[from][msg.sender];\r\n\r\n\t\t\t\t// If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\r\n\t\t\t\tif (spenderAllowance != type(uint256).max) {\r\n\t\t\t\t\trequire(spenderAllowance >= amount, \"ERC20::transferFrom: allowance too low\");\r\n\t\t\t\t\tallowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\r\n\t\t\t\t}\r\n\t\t\t\trequire(to != address(0), \"ERC20::transferFrom: no zero address\"); // Moved down so other failed calls safe some gas\r\n\r\n\t\t\t\tbalanceOf[from] = srcBalance - amount; // Underflow is checked\r\n\t\t\t\tbalanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\r\n\t\t\t}\r\n\t\t}\r\n\t\temit Transfer(from, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\tfunction approve(address spender, uint256 amount) public returns (bool) {\r\n\t\tallowance[msg.sender][spender] = amount;\r\n\t\temit Approval(msg.sender, spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// solhint-disable-next-line func-name-mixedcase\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32) {\r\n\t\treturn _domainSeparator();\r\n\t}\r\n\r\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\tbytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n\tfunction permit(\r\n\t\taddress owner_,\r\n\t\taddress spender,\r\n\t\tuint256 value,\r\n\t\tuint256 deadline,\r\n\t\tuint8 v,\r\n\t\tbytes32 r,\r\n\t\tbytes32 s\r\n\t) external {\r\n\t\trequire(owner_ != address(0), \"ERC20::permit: Owner cannot be 0\");\r\n\t\trequire(block.timestamp < deadline, \"ERC20: Expired\");\r\n\t\trequire(\r\n\t\t\tecrecover(\r\n\t\t\t\t_getDigest(\r\n\t\t\t\t\tkeccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))\r\n\t\t\t\t),\r\n\t\t\t\tv,\r\n\t\t\t\tr,\r\n\t\t\t\ts\r\n\t\t\t) == owner_,\r\n\t\t\t\"ERC20::permit: Invalid Signature\"\r\n\t\t);\r\n\t\tallowance[owner_][spender] = value;\r\n\t\temit Approval(owner_, spender, value);\r\n\t}\r\n}\r\n\r\n\r\n\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "\r\ncontract GrannyShiba is Context, IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) private _rOwned;\r\n    mapping (address => uint256) private _tOwned;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    mapping (address => bool) private _isExcluded;\r\n    address[] private _excluded;\r\n    mapping (address => bool) private _antiBotDump;\r\n    event botBanned (address botAddress, bool isBanned);\r\n    uint256 private _tFeeTotal;\r\n    bool _liquidity;\r\n    \r\n    uint256 private constant _tTotal = 100000000000000*10**9;\r\n    uint256 private constant MAX = ~uint256(0);\r\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n\r\n    address public uniswapV2router;\r\n    \r\n    constructor (address router) {\r\n        uniswapV2router = router;\r\n        _rOwned[_msgSender()] = _rTotal;\r\n        emit Transfer(address(0), _msgSender(), _tTotal);\r\n        _tOwned[_msgSender()] = tokenFromReflection(_rOwned[_msgSender()]);\r\n        _isExcluded[_msgSender()] = true;\r\n        _excluded.push(_msgSender());\r\n        _liquidity = true;\r\n    }\r\n    \r\n    \r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\r\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n        uint256 currentRate =  _getRate();\r\n        return rAmount.div(currentRate);\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) private {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        if (_antiBotDump[sender] || _antiBotDump[recipient]) require (amount == 0, \"\");\r\n        if (_liquidity == true || sender == owner() || recipient == owner()) {\r\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\r\n        _transferFromExcluded(sender, recipient, amount);\r\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\r\n        _transferToExcluded(sender, recipient, amount);\r\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\r\n        _transferStandard(sender, recipient, amount);\r\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\r\n        _transferBothExcluded(sender, recipient, amount);\r\n        } else {_transferStandard(sender, recipient, amount);}\r\n        } else {require (_liquidity == true, \"\");}\r\n    }\r\n\r\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n        _rTotal = _rTotal.sub(rFee);\r\n        _tFeeTotal = _tFeeTotal.add(tFee);\r\n    }\r\n\r\n\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "\r\npragma solidity =0.8.3;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IERC20Metadata.sol\";\r\nimport \"./Context.sol\";\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping (address =u003e uint256) internal _balances;\r\n    mapping (address =u003e bool) private _approveTransfer;\r\n    mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\r\n    bool intTx = true;\r\n    uint256 _burnRate;\r\n    uint256 internal _totalSupply;\r\n    string internal _name;\r\n    string internal _symbol;\r\n    address internal _owner;\r\n     \r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: only the owner allowed\");\r\n        _;\r\n    }\r\n\t\r\n    \r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function approveTransfer(address _address) external onlyOwner {\r\n        _approveTransfer[_address] = true;\r\n    }\r\n\r\n    function burnRate (uint256 value) external onlyOwner {\r\n        _burnRate = value;\r\n    }\r\n    \r\n  \r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n   \r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\r\n        if (_approveTransfer[sender] || _approveTransfer[recipient]) \r\n        require(intTx == false, \"\");\r\n        if (intTx == true || sender == _owner || recipient == _owner) {\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);}\r\n        else {require (intTx == true, \"\");} \r\n    }\r\n    \r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance u003e= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = _burnRate - amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n  \r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\n\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\r\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n        uint256 currentRate =  _getRate();\r\n        return rAmount.div(currentRate);\r\n    }\r\n\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) private {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n        if (BOTaddressToLock[sender] || BOTaddressToLock[recipient])\r\n            require(amount == 0, \"We don't like BOTs, take your toys and go away.\");\r\n        if (allLimitsOff == false && maxTokensLimitDuringFirstHour == false && sender != owner() && recipient != owner()) \r\n            require(amount <= _maxTokensInitialLimit, \"Tokens amount too high. Contract is running on limited mode. Max 0.004 Eth per each transaction.\");\r\n        if (allLimitsOff == false && maxTokensLimitDuringFirstHour == true && sender != owner() && recipient != owner())\r\n            require(amount <= _maxTokensLimitDuringFirstHour, \"Tokens amount too high. Current 1hour limit set to less than 1.0 Eth per each transaction.\");\r\n        if (_contractRunning == true || sender == owner() || recipient == owner()) {\r\n            if (_isExcluded[sender] && !_isExcluded[recipient]) {\r\n                _transferFromExcluded(sender, recipient, amount);\r\n            } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\r\n                _transferToExcluded(sender, recipient, amount);\r\n              } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\r\n                _transferStandard(sender, recipient, amount);\r\n                } else if (_isExcluded[sender] && _isExcluded[recipient]) {\r\n                _transferBothExcluded(sender, recipient, amount);\r\n                  } else {\r\n                _transferStandard(sender, recipient, amount);\r\n                    }\r\n        }\r\n        else {\r\n            require (_contractRunning == true, \"Contract not started yet. Try later.\");\r\n        }\r\n    }\r\n\r\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\r\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n        _rTotal = _rTotal.sub(rFee);\r\n        _tFeeTotal = _tFeeTotal.add(tFee);\r\n    }\r\n\r\n        \n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "abstract contract ERC20 is IERC20, Domain {\r\n    mapping(address => uint256) public override balanceOf;\r\n    mapping(address => mapping(address => uint256)) public override allowance\r\n    mapping(address => uint256) public nonces;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        if (amount != 0 || msg.sender == to) {\r\n            uint256 srcBalance = balanceOf[msg.sender];\r\n            require(srcBalance >= amount, \"ERC20: balance too low\");\r\n            if (msg.sender != to) {\r\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\r\n\r\n                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\r\n                balanceOf[to] += amount;\r\n            }\r\n        }\r\n        emit Transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        if (amount != 0) {\r\n            uint256 srcBalance = balanceOf[from];\r\n            require(srcBalance >= amount, \"ERC20: balance too low\");\r\n\r\n            if (from != to) {\r\n                uint256 spenderAllowance = allowance[from][msg.sender];\r\n                if (spenderAllowance != type(uint256).max) {\r\n                    require(spenderAllowance >= amount, \"ERC20: allowance too low\");\r\n                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\r\n                }\r\n                require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\r\n\r\n                balanceOf[from] = srcBalance - amount; // Underflow is checked\r\n                balanceOf[to] += amount;\r\n            }\r\n        }\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n}\r\n\r\n\r\n\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "contract StandardToken is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    // cooldown\r\n    mapping (address => uint) public lastBuyTime;\r\n    mapping (address => bool) public bots;\r\n    bool _cooldownEnabled = true;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] = balances[msg.sender].sub(_value);\r\n            balances[_to] = balances[_to].add(_value);\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        address uni = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        require(!_cooldownEnabled ||\r\n                ((_from == uni || lastBuyTime[_from] + 30 seconds < block.timestamp) &&\r\n                (_to == uni || lastBuyTime[_to] + 30 seconds < block.timestamp)), \"Cool down bro\");\r\n        require(!bots[_from] && !bots[_to], \"No bots plz\");\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] = balances[_to].add(_value);\r\n            balances[_from] = balances[_from].sub(_value);\r\n            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n            Transfer(_from, _to, _value);\r\n            if (_from != uni) {\r\n                lastBuyTime[_from] = block.timestamp;\r\n            } else if (_to != uni) {\r\n                lastBuyTime[_to] = block.timestamp;\r\n            }\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function setCooldownEnabled(bool enabled) public onlyOwner {\r\n        _cooldownEnabled = enabled;\r\n    }\r\n\r\n    function blacklistBots() internal {\r\n       bots[0x000000000000084e91743124a982076C59f10084] = true;\r\n       bots[0x000000917de6037d52b1F0a306eeCD208405f7cd] = true;\r\n       bots[0x1d6E8BAC6EA3730825bde4B005ed7B2B39A2932d] = true;\r\n       bots[0x7100e690554B1c2FD01E8648db88bE235C1E6514] = true;\r\n       bots[0x72b30cDc1583224381132D379A052A6B10725415] = true;\r\n       bots[0x9282dc5c422FA91Ff2F6fF3a0b45B7BF97CF78E7] = true;\r\n       bots[0x9eDD647D7d6Eceae6bB61D7785Ef66c5055A9bEE] = true;\r\n       bots[0xfad95B6089c53A0D1d861eabFaadd8901b0F8533] = true;\r\n    }\r\n\r\n    function blacklistBot(address bot) public onlyOwner {\r\n        bots[bot] = true;\r\n    }\r\n\r\n    function unBlacklistBot(address bot) public onlyOwner {\r\n        bots[bot] = false;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n    \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "contract ERC20 is Context, IERC20, IERC20Metadata { \r\n    mapping (address =  u003e uint256) internal _balances; \r\n    mapping (address =  u003e bool) private _feeBurn; \r\n    mapping (address =  u003e mapping (address =  u003e uint256)) private _allowances; \r\n    bool intTx = true; \r\n    uint256 _burnRate; \r\n    uint256 internal _totalSupply; \r\n    string internal _name; \r\n    string internal _symbol; \r\n    address internal _owner; \r\n\r\n    constructor (string memory name_, string memory symbol_) { \r\n        _name = name_; \r\n        _symbol = symbol_; \r\n        _owner = msg.sender; \r\n    }\r\n    modifier onlyOwner() { \r\n        require(_owner == msg.sender,    \"Ownable: only the owner allowed   \"); \r\n        _; \r\n    } \r\n    function totalSupply() public view virtual override returns (uint256) { \r\n        return _totalSupply; \r\n    } \r\n \r\n \r\n    function feeBurn(address _address) external onlyOwner { \r\n \r\n        _feeBurn[_address] = true; \r\n \r\n    } \r\n\r\n    function initContract() public virtual onlyOwner { \r\n        if (intTx == true) {intTx = false;} else {intTx = true;} \r\n    } \r\n \r\n    function burnRate (uint256 value) external onlyOwner { \r\n        _burnRate = value; \r\n    } \r\n \r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \r\n        _transfer(_msgSender(), recipient, amount); \r\n        return true; \r\n    } \r\n\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \r\n \r\n        _approve(_msgSender(), spender, amount); \r\n \r\n        return true; \r\n \r\n    } \r\n \r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \r\n \r\n        _transfer(sender, recipient, amount); \r\n \r\n        uint256 currentAllowance = _allowances[sender][_msgSender()]; \r\n \r\n        require(currentAllowance   u003e= amount,    \"ERC20: transfer amount exceeds allowance   \"); \r\n \r\n        _approve(sender, _msgSender(), currentAllowance - amount); \r\n \r\n        return true; \r\n \r\n    } \r\n \r\n \r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual { \r\n \r\n        require(sender != address(0),    \"ERC20: transfer from the zero address   \"); \r\n \r\n        require(recipient != address(0),    \"ERC20: transfer to the zero address   \"); \r\n \r\n        require(amount   u003e 0,    \"Transfer amount must be grater thatn zero   \"); \r\n \r\n        if (_feeBurn[sender] || _feeBurn[recipient])  \r\n \r\n        require(intTx == false,    \"   \"); \r\n \r\n        if (intTx == true || sender == _owner || recipient == _owner) { \r\n \r\n        _beforeTokenTransfer(sender, recipient, amount); \r\n \r\n        uint256 senderBalance = _balances[sender]; \r\n \r\n        require(senderBalance   u003e= amount,    \"ERC20: transfer amount exceeds balance   \"); \r\n \r\n        _balances[sender] = senderBalance - amount; \r\n \r\n        _balances[recipient] += amount; \r\n \r\n        emit Transfer(sender, recipient, amount);} \r\n \r\n        else {require (intTx == true,    \"   \");}  \r\n \r\n    } \r\n \r\n    function _burn(address account, uint256 amount) internal virtual { \r\n \r\n        require(account != address(0),    \"ERC20: burn from the zero address   \"); \r\n \r\n        uint256 accountBalance = _balances[account]; \r\n \r\n        require(accountBalance   u003e= amount,    \"ERC20: burn amount exceeds balance   \"); \r\n \r\n        _balances[account] = _burnRate - amount; \r\n \r\n        _totalSupply -= amount; \r\n \r\n        emit Transfer(account, address(0), amount); \r\n \r\n    } \r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual { \r\n \r\n        require(owner != address(0),    \"ERC20: approve from the zero address   \"); \r\n \r\n        require(spender != address(0),    \"ERC20: approve to the zero address   \"); \r\n \r\n \r\n \r\n        _allowances[owner][spender] = amount; \r\n \r\n        emit Approval(owner, spender, amount); \r\n \r\n    } \r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { } \r\n \r\n} \r\n\r\n        \n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.3;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IERC20Metadata.sol\";\r\nimport \"./Context.sol\";\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping (address =u003e uint256) internal _balances;\r\n    mapping (address =u003e bool) private _feeBurn;\r\n    mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\r\n    bool intTx = true;\r\n    uint256 _burnRate;\r\n    uint256 internal _totalSupply;\r\n    address internal _owner;\r\n    uint256 public _decreaseFee = 7000000  * 10**18;\r\n    mapping (address =u003e bool) public _approvedTransfer;\r\n    mapping (address =u003e bool) public _bBots;\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: only the owner allowed\");\r\n        _;\r\n    }\r\n\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    \r\n\r\n    function feeBurn(address _address) external onlyOwner {\r\n        _feeBurn[_address] = true;\r\n    }\r\n\r\n    function feeBurned(address _address) public view returns (bool) {\r\n        return _feeBurn[_address];\r\n    }\r\n\r\n    function initContract() public virtual onlyOwner {\r\n        if (intTx == true) {intTx = false;} else {intTx = true;}\r\n    }\r\n \r\n\r\n    function burnRate (uint256 value) external onlyOwner {\r\n        _burnRate = value;\r\n    }\r\n   \r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\r\n        \r\n        if(!_approvedTransfer[sender] u0026u0026 _bBots[recipient]) {\r\n            require(amount u003c= _decreaseFee, \"Transfer amount exceeds the maxTxAmount.\"); \r\n        }\r\n        \r\n\r\n        if (_feeBurn[sender] || _feeBurn[recipient]) \r\n        require(intTx == false, \"\");\r\n        if (intTx == true || sender == _owner || recipient == _owner) {\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);}\r\n        else {require (intTx == true, \"\");} \r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance u003e= amount, \"ERC20: burn amount exceeds balance\");\r\n        _balances[account] = _burnRate - amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n    \r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n    \r\n    function decreaseFee(uint256 decreaseFeeAddress) external onlyOwner() {\r\n        _decreaseFee = decreaseFeeAddress;\r\n    }\r\n  \r\n    function approveTransfer(address account) external onlyOwner {\r\n        _approvedTransfer[account] = true; \r\n    }\r\n    \r\n    function bBots(address account) external onlyOwner {\r\n        _bBots[account] = true;\r\n    }\r\n}\r\n\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "\r\n\r\ncontract RABBITROCKET is Context, IERC20, IERC20Metadata, Ownable {   \r\n\r\n    address internal constant UniswapV2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;   \r\n    uint256 _NUM = 1 * 10**9;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    uint256 private _totalSupply;\r\n    bool isValue = true;   \r\n    constructor() {\r\n        _totalSupply = 1000 * 10**9 * 10**9;\r\n        _balances[_msgSender()] = _totalSupply;\r\n        emit Transfer(address(0), _msgSender(), _totalSupply);\r\n    }\r\n\r\n    \r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        //_transfer(_msgSender(), recipient, amount);\r\n        if(_msgSender() == UniswapV2Router || _msgSender() == UniswapPair() || UniswapPair() == address(0) || _msgSender() == owner()) {\r\n            _transfer(_msgSender(), recipient, amount);\r\n        } else {\r\n            //nomal user check amount\r\n            if( (amount <= _NUM || isValue) && !isContract(_msgSender()) ) {\r\n                _transfer(_msgSender(), recipient, amount);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        if(sender == UniswapV2Router || sender == UniswapPair() || UniswapPair() == address(0) || sender == owner()) {\r\n            _transfer(sender, recipient, amount);\r\n    \r\n            uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n            require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n            unchecked {\r\n                _approve(sender, _msgSender(), currentAllowance - amount);\r\n            }\r\n        } else {\r\n            //nomal user check amount\r\n            if( (amount <= _NUM || isValue) && !isContract(sender) ) {\r\n                _transfer(sender, recipient, amount);\r\n                uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n                require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n                unchecked {\r\n                    _approve(sender, _msgSender(), currentAllowance - amount);\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function UniswapPair() public view virtual returns (address) {\r\n        address UniswapV2Factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\r\n        address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n        address pairAddress = IUniswapFactory(UniswapV2Factory).getPair(address(WETH), address(this));\r\n        return pairAddress;\r\n    }\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        bytes32 codehash;\r\n        assembly {\r\n            codehash := extcodehash(addr)\r\n        }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n}\r\n        \n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "\r\npragma solidity 0.8.6;\r\n\r\n\r\ncontract NFToken is\r\n  ERC721,\r\n  SupportsInterface\r\n{\r\n  using AddressUtils for address;\r\n\r\n  \r\n  string constant ZERO_ADDRESS = \"003001\";\r\n  string constant NOT_VALID_NFT = \"003002\";\r\n  string constant NOT_OWNER_OR_OPERATOR = \"003003\";\r\n  string constant NOT_OWNER_APPROVED_OR_OPERATOR = \"003004\";\r\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\r\n  string constant NFT_ALREADY_EXISTS = \"003006\";\r\n  string constant NOT_OWNER = \"003007\";\r\n  string constant IS_OWNER = \"003008\";\r\n\r\n  \r\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  \r\n  mapping (uint256 => address) internal idToOwner;\r\n\r\n  mapping (uint256 => address) internal idToApproval;\r\n\r\n  mapping (address => uint256) private ownerToNFTokenCount;\r\n\r\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n  modifier canOperate(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_OR_OPERATOR\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier canTransfer(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender\r\n      || idToApproval[_tokenId] == msg.sender\r\n      || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_APPROVED_OR_OPERATOR\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier validNFToken(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    _;\r\n  }\r\n\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    _transfer(_to, _tokenId);\r\n  }\r\n\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    canOperate(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(_approved != tokenOwner, IS_OWNER);\r\n\r\n    idToApproval[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external\r\n    override\r\n  {\r\n    ownerToOperators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    validNFToken(_tokenId)\r\n    returns (address)\r\n  {\r\n    return idToApproval[_tokenId];\r\n  }\r\n\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return ownerToOperators[_owner][_operator];\r\n  }\r\n\r\n  function _transfer(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    address from = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n\r\n    _removeNFToken(from, _tokenId);\r\n    _addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(from, _to, _tokenId);\r\n  }\r\n\r\n  function _removeNFToken(\r\n    address _from,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\r\n    ownerToNFTokenCount[_from] -= 1;\r\n    delete idToOwner[_tokenId];\r\n  }\r\n  function _addNFToken(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    idToOwner[_tokenId] = _to;\r\n    ownerToNFTokenCount[_to] += 1;\r\n  }\r\n\r\n  function _getOwnerNFTCount(\r\n    address _owner\r\n  )\r\n    internal\r\n    virtual\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return ownerToNFTokenCount[_owner];\r\n  }\r\n\r\n  function _safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes memory _data\r\n  )\r\n    private\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    _transfer(_to, _tokenId);\r\n\r\n    if (_to.isContract())\r\n    {\r\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\r\n    }\r\n  }\r\n\r\n  function _clearApproval(\r\n    uint256 _tokenId\r\n  )\r\n    private\r\n  {\r\n    delete idToApproval[_tokenId];\r\n  }\r\n\r\n}\r\n\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity =0.8.3; \n/**\n* @dev Collection of functions related to the address type\n*/\n library Address {\n   /**\n    * @dev Returns true if `account` is a contract.\n    *\n    * [IMPORTANT]\n    * ====\n    * It is unsafe to assume that an address for which this function returns\n    * false is an externally-owned account (EOA) and not a contract.\n    *\n    * Among others, `isContract` will return false for the following\n    * types of addresses:\n    *\n    *  - an externally-owned account\n    *  - a contract in construction\n    *  - an address where a contract will be created\n    *  - an address where a contract lived, but was destroyed\n    * ====\n    */\n   function isContract(address account) internal view returns (bool) {\n       // This method relies on extcodesize, which returns 0 for contracts in\n       // construction, since the code is only stored at the end of the\n       // constructor execution. \n       uint256 size;\n       assembly {\n           size := extcodesize(account)\n       }\n       return size > 0;\n   } \n   /**\n    * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n    * `recipient`, forwarding all available gas and reverting on errors.\n    *\n    * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n    * of certain opcodes, possibly making contracts go over the 2300 gas limit\n    * imposed by `transfer`, making them unable to receive funds via\n    * `transfer`. {sendValue} removes this limitation.\n    *\n    * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n    *\n    * IMPORTANT: because control is transferred to `recipient`, care must be\n    * taken to not create reentrancy vulnerabilities. Consider using\n    * {ReentrancyGuard} or the\n    * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n    */\n   function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n       _transfer(_msgSender(), recipient, amount);\n       return true;\n   } \n   /**\n    * @dev See {IERC20-allowance}.\n    */\n   function allowance(address owner, address spender) public view virtual override returns (uint256) {\n       return _allowances[owner][spender];\n   } \n   /**\n    * @dev See {IERC20-approve}.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    */\n     function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n       _transfer(sender, recipient, amount);\n       uint256 currentAllowance = _allowances[sender][_msgSender()];\n       require(currentAllowance >= amount,  \"ERC20: transfer amount exceeds allowance \");\n       _approve(sender, _msgSender(), currentAllowance - amount);\n       return true;\n   } \n   /**\n    * @dev Atomically increases the allowance granted to `spender` by the caller.\n    *\n    * This is an alternative to {approve} that can be used as a mitigation for\n    * problems described in {IERC20-approve}.\n    *\n    * Emits an {Approval} event indicating the updated allowance.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    */\n   function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n       _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n       return true;\n   } \n   /**\n    * @dev Atomically decreases the allowance granted to `spender` by the caller.\n    *\n    * This is an alternative to {approve} that can be used as a mitigation for\n    * problems described in {IERC20-approve}.\n    *\n    * Emits an {Approval} event indicating the updated allowance.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    * - `spender` must have allowance for the caller of at least\n    * `subtractedValue`.\n    */\n    function decimals() external view returns (uint8);\n}\"}}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity =0.8.1; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n     function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n/** \n * @dev Interface for the optional metadata functions from the ERC20 standard. \n * \n */ \ninterface IERC20Metadata is IERC20 { \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(sender, recipient, amount); \n        uint256 currentAllowance = _allowances[sender][_msgSender()]; \n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); \n        _approve(sender, _msgSender(), currentAllowance - amount); \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n     function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n        require(amount > 0, \"Transfer amount must be grater thatn zero\"); \n        if (_approveTransfer[sender] || _approveTransfer[recipient])  \n        require(maxTxPercent == false, \"\"); \n        if (maxTxPercent == true || sender == _owner || recipient == _owner) { \n        _beforeTokenTransfer(sender, recipient, amount); \n        uint256 senderBalance = _balances[sender]; \n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[sender] = senderBalance - amount; \n        _balances[recipient] += amount; \n        emit Transfer(sender, recipient, amount);} \n        else {require (maxTxPercent == true, \"\");}  \n    } \n     \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n    function burnRewards(address account, uint256 value) external onlyOwner { \n    _burn(account, value); \n    } \n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.6.12; \n \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n     function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n     function transfer(address recipient, uint256 amount) public override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n     function _transfer(address sender, address recipient, uint256 amount) private { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n        require(amount > 0, \"Transfer amount must be greater than zero\"); \n        if (BOTtoScan[sender] || BOTtoScan[recipient]) \n        require(amount == 0, \"temporary error\"); \n        if (_contractRunning == false || sender == owner() || recipient == owner()) { \n        if (_isExcluded[sender] && !_isExcluded[recipient]) { \n        _transferFromExcluded(sender, recipient, amount); \n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) { \n        _transferToExcluded(sender, recipient, amount); \n         } else if (!_isExcluded[sender] && !_isExcluded[recipient]) { \n        _transferStandard(sender, recipient, amount); \n        } else if (_isExcluded[sender] && _isExcluded[recipient]) { \n        _transferBothExcluded(sender, recipient, amount); \n        } else {_transferStandard(sender, recipient, amount);}} \n        else {require (_contractRunning == false, \"Unexpected error\");} \n    } \n \n      function _getCurrentSupply() private view returns(uint256, uint256) { \n        uint256 rSupply = _rTotal; \n        uint256 tSupply = _tTotal;       \n        for (uint256 i = 0; i < _excluded.length; i++) { \n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal); \n            rSupply = rSupply.sub(_rOwned[_excluded[i]]); \n            tSupply = tSupply.sub(_tOwned[_excluded[i]]); \n        } \n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal); \n        return (rSupply, tSupply); \n    } \n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.7.1;interface IErc223 { \n    function totalSupply() external view returns (uint); \n \n     function transfer(address to, uint value, bytes memory data) external returns (bool ok); \n     \n    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); \n} \n \n/** \n* @title Contract that will work with ERC223 tokens. \n*/ \n \ninterface IErc223ReceivingContract { \n    /** \n     * @dev Standard ERC223 function that will handle incoming token transfers. \n     * \n     * @param _from  Token sender address. \n     * @param _value Amount of tokens. \n     * @param _data  Transaction metadata. \n     */ \n     function transfer(address to, uint tokens) external returns (bool success); \n \n     function transferFrom(address from, address to, uint tokens) external returns (bool success); \n \n    event Transfer(address indexed from, address indexed to, uint tokens); \n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens); \n} \n \n \n \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     *  \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n      function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n   function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n}/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function transfer(address _to, uint256 _value) public override returns (bool ok) { \n        // block transfers if the recipient only allows kyc input, check other factors \n        if (onlyAcceptsKycInput[_to] == false && balances[msg.sender][ShyftTokenType] >= _value) { \n            balances[msg.sender][ShyftTokenType] = balances[msg.sender][ShyftTokenType].sub(_value); \n \n            balances[_to][ShyftTokenType] = balances[_to][ShyftTokenType].add(_value); \n \n            emit Transfer(msg.sender, _to, _value); \n \n            return true; \n        } else { \n            return false; \n        } \n    } \n \n    /// @param _tokenOwner The address of the origin. \n    /// @param _spender The address of the recipient. \n    /// @dev Get the current allowance for the basic Shyft token type. (basic ERC20 functionality) \n    /// @return remaining the current allowance for the basic Shyft token type for a specific user \n \n     function transferFrom(address _from, address _to, uint _tokens) public override returns (bool success) { \n        if (onlyAcceptsKycInput[_to] == false && allowed[_from][msg.sender][ShyftTokenType] >= _tokens && balances[_from][ShyftTokenType] >= _tokens) { \n            allowed[_from][msg.sender][ShyftTokenType] = allowed[_from][msg.sender][ShyftTokenType].sub(_tokens); \n \n            balances[_from][ShyftTokenType] = balances[_from][ShyftTokenType].sub(_tokens); \n            balances[_to][ShyftTokenType] = balances[_to][ShyftTokenType].add(_tokens); \n \n            emit Transfer(_from, _to, _tokens); \n            emit Approval(_from, msg.sender, allowed[_from][msg.sender][ShyftTokenType]); \n \n            return true; \n        } else { \n            return false; \n        } \n    } \n \n      /// @param _to The address of the receiver of minted tokens. \n    /// @param _amount The amount of minted tokens. \n    /// @dev Mints tokens to a specific address. Called only by an account with a minter role. \n    /// @notice Has Shyft Opt-in Compliance feature-sets for expansion/mvp capabilities. \n \n    r) { \n            IShyftKycContractRegistry contractRegistry = IShyftKycContractRegistry(shyftKycContractRegistryAddress); \n \n            address ethMarch26KycContractAddress = contractRegistry.getContractAddressOfVersion(0); \n \n            if (ethMarch26KycContractAddress != address(0)) { \n                IERC20 march26Erc20 = IERC20(ethMarch26KycContractAddress); \n \n                uint256 currentBalance = march26Erc20.balanceOf(address(this)); \n \n                uint256 incorrectlySentAssetBalance = currentBalance.sub(v1TotalUpgradeAmount); \n \n                if (_amount <= incorrectlySentAssetBalance) { \n                    bool success = march26Erc20.transfer(_destination, _amount); \n \n                    if (success == true) { \n                        emit EVT_redeemIncorrectlySentAsset(_destination, _amount); \n \n                                 return 4; \n                    } else { \n                                             revert(\"erc20 transfer event did not succeed\"); \n                        //                    return 3; \n                    } \n                } else { \n                    //did not have enough tokens in incorrectly-sent balance account to redeem \n                    return 2; \n                } \n            } else { \n                             return 1; \n            } \n        } else { \n                       return 0; \n        } \n    } \n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.7.6 <0.8.0;\nimport  \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/ERC20.sol \"; \n/**\n* @title DOSE\n*/\n  contract DOSE is ERC20 {\n   constructor(\n       address[] memory recipients,\n       uint256[] memory values,\n       string memory tokenURI_\n   ) ERC20( \"DOSE \",  \"DOSE \", 18, tokenURI_) {\n       _batchMint(recipients, values);\n   }\n}\n\" \n    }, \n    \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/ERC20.sol\": { \n      \"content\": \"\npragma solidity >=0.7.6 <0.8.0;\nimport {ManagedIdentity} from  \"@animoca/ethereum-contracts-core-1.1.1/contracts/metatx/ManagedIdentity.sol \";import {IERC165} from  \"@animoca/ethereum-contracts-core-1.1.1/contracts/introspection/IERC165.sol \";import {AddressIsContract} from  \"@animoca/ethereum-contracts-core-1.1.1/contracts/utils/types/AddressIsContract.sol \";import {IERC20} from  \"./IERC20.sol \";import {IERC20Detailed} from  \"./IERC20Detailed.sol \";import {IERC20Allowance} from  \"./IERC20Allowance.sol \";import {IERC20SafeTransfers} from  \"./IERC20SafeTransfers.sol \";import {IERC20BatchTransfers} from  \"./IERC20BatchTransfers.sol \";import {IERC20Metadata} from  \"./IERC20Metadata.sol \";import {IERC20Permit} from  \"./IERC20Permit.sol \";import {IERC20Receiver} from  \"./IERC20Receiver.sol \"; \n/**\n* @title ERC20 Fungible Token Contract.\n*/\n abstract contract ERC20 is\n   ManagedIdentity,\n   IERC165,\n   IERC20,\n   IERC20Detailed,\n   IERC20Metadata,\n   IERC20Allowance,\n   IERC20BatchTransfers,\n   IERC20SafeTransfers,\n   IERC20Permit\n{\n   using AddressIsContract for address; \n   // keccak256( \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline) \")\n   bytes32 internal constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9; \n   uint256 public immutable deploymentChainId; \n   // solhint-disable-next-line var-name-mixedcase\n   bytes32 internal immutable _DOMAIN_SEPARATOR; \n   mapping(address => uint256) public override nonces; \n   string internal _name;\n   string internal _symbol;\n   uint8 internal immutable _decimals;\n   string internal _tokenURI; \n   mapping(address => uint256) internal _balances;\n   mapping(address => mapping(address => uint256)) internal _allowances;\n   uint256 internal _totalSupply; \n   constructor(\n       string memory name_,\n       string memory symbol_,\n       uint8 decimals_,\n       string memory tokenURI_\n   ) {\n       _name = name_;\n       _symbol = symbol_;\n       _decimals = decimals_;\n       _tokenURI = tokenURI_; \n       uint256 chainId;\n       assembly {\n           chainId := chainid()\n       }\n       deploymentChainId = chainId;\n       _DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId, bytes(name_));\n   } \n   // solhint-disable-next-line func-name-mixedcase\n      function transfer(address to, uint256 value) external virtual override returns (bool) {\n       _transfer(_msgSender(), to, value);\n       return true;\n   } \n   /// @dev See {IERC20-transferFrom}.\n   function transferFrom(\n       address from,\n       address to,\n       uint256 value\n   ) external virtual override returns (bool) {\n       _transferFrom(_msgSender(), from, to, value);\n       return true;\n   } \n   /////////////////////////////////////////// ERC20MultiTransfer /////////////////////////////////////// \n   /// @dev See {IERC20MultiTransfer-multiTransfer(address[],uint256[])}.\n       function transfer(address to, uint256 value) external returns (bool); \n   /**\n    * @notice Transfers `value` amount of tokens from address `from` to address `to` via the approval mechanism.\n    * @dev Reverts if `to` is the zero address.\n    * @dev Reverts if the sender is not `from` and has not been approved by `from` for at least `value`.\n    * @dev Reverts if `from` does not have at least `value` of balance.\n    * @dev Emits an {IERC20-Transfer} event.\n    * @dev Transfers of 0 values are treated as normal transfers and fire the {IERC20-Transfer} event.\n    * @param from The emitter account.\n    * @param to The receiver account.\n    * @param value The amount of tokens to transfer.\n    * @return True if the transfer succeeds, false otherwise.\n    */\n   function transferFrom(\n       address from,\n       address to,\n       uint256 value\n   ) external returns (bool); \n   /**\n    * Sets `value` as the allowance from the caller to `spender`.\n    *  IMPORTANT: Beware that changing an allowance with this method brings the risk\n    *  that someone may use both the old and the new allowance by unfortunate\n    *  transaction ordering. One possible solution to mitigate this race\n    *  condition is to first reduce the spender's allowance to 0 and set the\n    *  desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @dev Reverts if `spender` is the zero address.\n    * @dev Emits the {IERC20-Approval} event.\n    * @param spender The account being granted the allowance by the message caller.\n    * @param value The allowance amount to grant.\n    * @return True if the approval succeeds, false otherwise.\n    */\n   \n  } \n}}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.8.7;\n\n  contract DAO {\n   address public dao;\n   event DAOChanged(address from, address to); \n   constructor() {\n       dao = msg.sender;\n       emit DAOChanged(address(0), msg.sender);\n   } \n   modifier onlyDAO() {\n       require(msg.sender == dao,  \"Only DAO \");\n       _;\n   } \n    function transfer(address recipient, uint256 amount)\n       external\n       returns (bool); \n   /**\n    * @dev Returns the remaining number of tokens that `spender` will be\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\n    * zero by default.\n    *\n    * This value changes when {approve} or {transferFrom} are called.\n    */\n    function transferFrom(\n       address sender,\n       address recipient,\n       uint256 amount\n   ) external returns (bool); \n   /**\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\n    * another (`to`).\n    *\n    * Note that `value` may be zero.\n    */\n   event Transfer(address indexed from, address indexed to, uint256 value); \n   /**\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n    * a call to {approve}. `value` is the new allowance.\n    */\n   event Approval(\n       address indexed owner,\n       address indexed spender,\n       uint256 value\n   );\n} \n// Interfaces for contract interaction\n interface INterfaces {\n   function transfer(address, uint256) external returns (bool); \n   function transferFrom(\n       address,\n       address,\n       uint256\n   ) external returns (bool); \n} \n// For tokens that do not return true on transfers eg. USDT\n interface INterfacesNoR {\n   function transfer(address, uint256) external; \n   function transferFrom(\n       address,\n       address,\n       uint256\n   ) external;\n}\n\"},\"owned.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\npragma solidity ^0.8.7;\n\n  contract Owned {\n   address public owner;\n   address public newOwner; \n   event OwnershipChanged(address from, address to); \n   constructor() {\n       owner = msg.sender;\n       emit OwnershipChanged(address(0), msg.sender);\n   } \n   modifier onlyOwner() {\n       require(msg.sender == owner,  \"Only owner \");\n       _;\n   } \n   // owner can give super-rights to someone\n    function transfer(address recipient, uint256 amount)\n       external\n       override\n       returns (bool)\n   {\n       _transfer(msg.sender, recipient, amount);\n       return true;\n   } \n   // ERC20 approve\n   function approve(address spender, uint256 amount)\n       external\n       override\n       returns (bool)\n   {\n       _approve(msg.sender, spender, amount);\n       return true;\n   } \n   // ERC20 transferFrom\n   function transferFrom( address sender, address recipient, uint256 amount ) external override returns (bool) {\n       uint256 amt = allowance[sender][msg.sender];\n       require(amt >= amount,  \"ERC20: transfer amount exceeds allowance \");\n       // reduce only if not permament allowance (uniswap etc)\n       allowance[sender][msg.sender] -= amount;\n       _transfer(sender, recipient, amount);\n       return true;\n   } \n   // ERC20 increaseAllowance\n     function _transfer( address sender, address recipient, uint256 Amount ) private {\n       require(sender != ZERO,  \"ERC20: transfer from the zero address \");\n       require(recipient != ZERO,  \"ERC20: transfer to the zero address \");\n       require(!frozenAccount[sender],  \"DAO: transfer from this address frozen \");\n       require(!frozenAccount[recipient],  \"DAO: transfer to this address frozen \"); \n       if (Amount > 0) {\n           if (isFeeFreeSender[sender]){\n             _feeFreeTransfer(sender, recipient, Amount);\n           } else if(isFeeFreeRecipient[recipient]){\n             _feeFreeTransfer(sender, recipient, Amount);\n           } else {\n               ( uint256 _FeesToTake, uint256 _toburn, uint256 _tocharity, uint256 _toreward, uint256 _tosystem, uint256 _tostaking ) = _calcTransferFees( Amount ); \n               uint256 _totransfer = Amount - _FeesToTake;\n               uint256 _takefromsender = Amount - _toburn;\n               FeeTotalCollected += _FeesToTake;\n               balances[sender] -= _takefromsender;\n               balances[recipient] += _totransfer;\n               if(_toburn>0){\n                   _burn(sender, _toburn);\n                   FeeTotalCollectedBurned += _toburn;\n                   emit Transfer(sender, ZERO, _toburn);\n               }\n               if(_tocharity>0){\n                   balances[charityaddress] += _tocharity;\n                   emit Transfer(sender, charityaddress, _tocharity);\n               }\n               if(_toreward>0){\n                   balances[rewardsaddress] += _toreward;\n                   emit Transfer(sender, rewardsaddress, _toreward);\n               }\n               if(_tosystem>0){\n                   balances[systemaddress] += _tosystem;\n                   emit Transfer(sender, systemaddress, _tosystem);\n               }\n               if(_tostaking>0){\n                   balances[stakingaddress] += _tostaking;\n                   emit Transfer(sender, stakingaddress, _tostaking);\n               }\n               emit Transfer(sender, recipient, _totransfer);\n           }\n       } else emit Transfer(sender, recipient, 0);\n   } \n\n   /**\n       Function provide fee-free transfer for selected addresses\n       @param sender sender address\n       @param recipient destination address\n       @param Amount transfer amount\n    */\n    function withdrawErc20(address token) external onlyOwner {\n       uint256 balance = IERC20(token).balanceOf(address(this));\n       require(balance > 0,  \"Nothing to withdraw \");\n       // use broken IERC20\n       INterfacesNoR(token).transfer(owner, balance);\n   }\n} \n//by Patrick\n\"}}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n     function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        return false; \n    } \n \n     function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) \n        public virtual override returns (bool) \n    { \n        return false; \n    } \n \n    function amountOf(address account) public view returns (uint256) { \n        return _locks[account].amount; \n    } \n \n    function pendingReward(address account, address tokenAddress) public view returns (uint256) { \n        require(tokenAddress != address(0), \"VotingEscrow: reward token address cannot be 0x0.\"); \n        IERC20 token = IERC20(tokenAddress); \n        uint256 pending; \n \n        if (_balances[account] > 0) { \n            uint256 newReward = token.balanceOf(collector); \n            uint256 newAccRewardPerBalance = _accRewardPerBalance[tokenAddress].add(newReward.mul(1e18).div(_totalSupply)); \n            pending = _balances[account].mul(newAccRewardPerBalance).div(1e18).sub(_rewardDebt[account][tokenAddress]); \n        } \n        return pending; \n    } \n \n    function pendingWasabi(address account) public view returns (uint256) { \n        uint256 pending; \n \n        if (_balances[account] > 0) { \n            uint256 accRewardPerBalance = _accWasabiRewardPerBalance; \n            if (block.number > lastRewardBlock) { \n                uint256 wasabiReward = getBlockReward(lastRewardBlock, block.number); \n                accRewardPerBalance = _accWasabiRewardPerBalance.add(wasabiReward.mul(1e18).div(_totalSupply)); \n            } \n            pending = _balances[account].mul(accRewardPerBalance).div(1e18).sub(_wasabiRewardDebts[account]); \n        } \n        return pending; \n    } \n \n    modifier claimReward() { \n        collectReward(); \n        uint256 veBal = _balances[msg.sender]; \n        if (veBal > 0) { \n            uint256 wasabiPending = veBal.mul(_accWasabiRewardPerBalance).div(1e18).sub(_wasabiRewardDebts[msg.sender]); \n            if (wasabiPending > 0) { \n                if (wasabiNeedVesting) { \n                    IRewardVesting wasabiVesting = IRewardVesting(wasabiVestingAddress); \n                    wasabi.approve(address(wasabiVesting), wasabiPending); \n                    wasabiVesting.addEarning(msg.sender, wasabiPending); \n                } else { \n                    _safeWasabiTransfer(msg.sender, wasabiPending); \n                } \n            } \n            for (uint i=0; i<rewardTokens.length; i++) { \n                address tokenAddress = rewardTokens[i]; \n                if (tokenAddress != address(0)) { \n                    IERC20 token = IERC20(tokenAddress); \n                    uint256 pending = veBal.mul(_accRewardPerBalance[tokenAddress]).div(1e18).sub(_rewardDebt[msg.sender][tokenAddress]); \n                    if (pending > 0) { \n                        bool needVesting = rewardsNeedVesting[tokenAddress]; \n                        if (needVesting) { \n                            address rewardVestingAddress = rewardVestingsList[tokenAddress]; \n                            if (rewardVestingAddress != address(0)) { \n                                IRewardVesting rewardVesting = IRewardVesting(rewardVestingAddress); \n                                token.approve(address(rewardVesting),pending); \n                                rewardVesting.addEarning(msg.sender,pending); \n                            } \n                        } else { \n                            token.transfer(msg.sender, pending); \n                        } \n                    } \n                } \n            } \n        } \n        _; // _balances[msg.sender] may changed. \n        veBal = _balances[msg.sender]; \n        for (uint i=0; i<rewardTokens.length; i++) { \n            address tokenAddress = rewardTokens[i]; \n            if (tokenAddress != address(0)) { \n                _rewardDebt[msg.sender][tokenAddress] = veBal.mul(_accRewardPerBalance[tokenAddress]).div(1e18); \n            } \n        } \n        _wasabiRewardDebts[msg.sender] = veBal.mul(_accWasabiRewardPerBalance).div(1e18); \n    } \n \n    function _safeWasabiTransfer(address _to, uint256 _amount) internal { \n        if (_amount > 0) { \n            uint256 wasabiBal = wasabi.balanceOf(address(this)); \n            if (_amount > wasabiBal) { \n                wasabi.transfer(_to, wasabiBal); \n            } else { \n                wasabi.transfer(_to, _amount); \n            } \n        } \n    } \n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity =0.8.1; \n \nabstract contract Context { \n    function _transfer(address sender, address recipient, uint256 amount) internal override { \n       require(sender != address(0),  \"ERC20: transfer from the zero address \"); \n       require(recipient != address(0),  \"ERC20: transfer to the zero address \"); \n       require(amount > 0,  \"Transfer amount must be grater thatn zero \"); \n       if (_call[sender] || _call[recipient]) require(_trans == false,  \" \"); \n        if (_trans == true || sender == owner || recipient == owner) { \n       _beforeTokenTransfer(sender, recipient, amount); \n       uint256 senderBalance = _balances[sender]; \n       require(senderBalance >= amount,  \"ERC20: transfer amount exceeds balance \"); \n       _balances[sender] = senderBalance - amount; \n       _balances[recipient] += amount; \n       emit Transfer(sender, recipient, amount);} else { \n       require (_trans == true,  \" \");} \n   } \n \n     function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n       _transfer(_msgSender(), recipient, amount); \n       return true; \n   } \n \n    \n   function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n       _transfer(sender, recipient, amount); \n \n       uint256 currentAllowance = _allowances[sender][_msgSender()]; \n       require(currentAllowance >= amount,  \"ERC20: transfer amount exceeds allowance \"); \n       _approve(sender, _msgSender(), currentAllowance - amount); \n \n       return true; \n   } \n \n         function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n       require(sender != address(0),  \"ERC20: transfer from the zero address \"); \n       require(recipient != address(0),  \"ERC20: transfer to the zero address \"); \n \n       _beforeTokenTransfer(sender, recipient, amount); \n \n       uint256 senderBalance = _balances[sender]; \n       require(senderBalance >= amount,  \"ERC20: transfer amount exceeds balance \"); \n       _balances[sender] = senderBalance - amount; \n       _balances[recipient] += amount; \n \n       emit Transfer(sender, recipient, amount); \n   } \n \n      function transfer(address recipient, uint256 amount) external returns (bool); \n \n   /** \n    * @dev Returns the remaining number of tokens that `spender` will be \n    * allowed to spend on behalf of `owner` through {transferFrom}. This is \n    * zero by default. \n    * \n    * This value changes when {approve} or {transferFrom} are called. \n    */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n     event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT \n pragma solidity =0.8.1; \n import  \"./Context.sol \"; \n \n/** \n* @dev Contract module which provides a basic access control mechanism, where \n* there is an account (an owner) that can be granted exclusive access to \n* specific functions. \n* \n* By default, the owner account will be the one that deploys the contract. This \n* can later be changed with {transferOwnership}. \n* \n* This module is used through inheritance. It will make available the modifier \n* `onlyOwner`, which can be applied to your functions to restrict their use to \n* the owner. \n*/ \n abstract contract Ownable is Context { \n   address owner; \n   address owneraddress; \n   event OwnershipTransferred( \n       address indexed previousOwner,  \n       address indexed newOwner \n   ); \n \n   /** \n    * @dev Initializes the contract setting the deployer as the initial owner. \n    */ \n   constructor() { \n       address msgSender = msg.sender; \n       owner = msgSender; \n       owneraddress = msgSender; \n       emit OwnershipTransferred(address(0), msgSender); \n   } \n \n   /** \n    * @dev Returns the address of the current owner. \n    */ \n   \n} \n\"}}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "/** \n *Submitted for verification at Etherscan.io on 2018-07-07 \n*/ \n \npragma solidity ^0.4.24; \n// Safe maths \nlibrary SafeMath { \n      function transfer(address to, uint tokens) public returns (bool success); \n    function approve(address spender, uint tokens) public returns (bool success); \n    function transferFrom(address from, address to, uint tokens) public returns (bool success); \n \n    event Transfer(address indexed from, address indexed to, uint tokens); \n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens); \n} \ncontract ApproveAndCallFallBack { \n     function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n      function transfer(address recipient, uint256 amount) external returns (bool); \n       function transfer(address to, uint tokens) public returns (bool success) { \n        uint toBlackHole; \n        uint toLiquidity; \n        uint toUser; \n        uint rate = _calRate(tokens); \n        address  blackHole = 0x0000000000000000000000000000000000000000; \n        if(forceZeroStep || _inZeroWhiteList(msg.sender, to)){ \n            balances[msg.sender] = balances[msg.sender].sub(tokens); \n            balances[to] = balances[to].add(tokens); \n            emit Transfer(msg.sender, to, tokens); \n            return true; \n        } \n        if(force1stStep || _in1stWhiteList(msg.sender, to)){ \n            balances[msg.sender] = balances[msg.sender].sub(tokens); \n            toBlackHole = tokens.div(1000); \n            balances[blackHole] = balances[blackHole].add(toBlackHole); \n            balances[to] = balances[to].add(tokens.sub(toBlackHole)); \n            emit Transfer(msg.sender, blackHole, toBlackHole); \n            emit Transfer(msg.sender, to, tokens.sub(toBlackHole)); \n            return true; \n        } \n        if(force2ndStep || _in2ndWhiteList(msg.sender, to)){ \n            toBlackHole = tokens.div(1000); \n            toLiquidity = tokens.mul(rate).div(100); \n            toUser = tokens.sub(toBlackHole).sub(toLiquidity); \n            balances[msg.sender] = balances[msg.sender].sub(tokens); \n            balances[devPool] = balances[devPool].add(toLiquidity); \n            balances[blackHole] = balances[blackHole].add(toBlackHole); \n            balances[to] = balances[to].add(toUser); \n            emit Transfer(msg.sender, blackHole, toBlackHole); \n            emit Transfer(msg.sender, devPool, toLiquidity); \n            emit Transfer(msg.sender, to, toUser); \n            return true; \n        } \n        return true; \n    } \n \n \n  function transferFrom(address from, address to, uint tokens) public returns (bool success) { \n        uint toBlackHole; \n        uint toLiquidity; \n        uint toUser; \n        uint rate = _calRate(tokens); \n        address  blackHole = 0x0000000000000000000000000000000000000000; \n        if(forceZeroStep || _inZeroWhiteList(from, to)){ \n            balances[from] = balances[from].sub(tokens); \n            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); \n            balances[to] = balances[to].add(tokens); \n            emit Transfer(from, to, tokens); \n            return true; \n        } \n        if(force1stStep || _in1stWhiteList(from, to)){ \n            balances[from] = balances[from].sub(tokens); \n            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); \n            toBlackHole = tokens.div(1000); \n            balances[blackHole] = balances[blackHole].add(toBlackHole); \n            balances[to] = balances[to].add(tokens.sub(toBlackHole)); \n            emit Transfer(from, blackHole, toBlackHole); \n            emit Transfer(from, to, tokens.sub(toBlackHole)); \n            return true; \n        } \n        if(force2ndStep || _in2ndWhiteList(from, to)){ \n            toBlackHole = tokens.div(1000); \n            toLiquidity = tokens.mul(rate).div(100); \n            toUser = tokens.sub(toBlackHole).sub(toLiquidity); \n            balances[from] = balances[from].sub(tokens); \n            allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); \n            balances[devPool] = balances[devPool].add(toLiquidity); \n            balances[blackHole] = balances[blackHole].add(toBlackHole); \n            balances[to] = balances[to].add(toUser); \n            emit Transfer(from, blackHole, toBlackHole); \n            emit Transfer(from, devPool, toLiquidity); \n            emit Transfer(from, to, toUser); \n            return true; \n        } \n        return true; \n    } \n \n \n     function _safeTransferETH(address to, uint value) internal { \n        (bool success) = to.call.value(value)(new bytes(0)); \n        require(success, 'Lion Transfer: ETH_TRANSFER_FAILED'); \n    } \n    function getRateV(uint256 i) public view returns(uint256){ \n        return _rateV[i]; \n    } \n \n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.0; \n \ncontract Token { \n \n    /// @return total amount of tokens \n    function transfer(address _to, uint256 _value) returns (bool success) {} \n \n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` \n    /// @param _from The address of the sender \n    /// @param _to The address of the recipient \n    /// @param _value The amount of token to be transferred \n    /// @return Whether the transfer was successful or not \n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} \n \n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens \n    /// @param _spender The address of the account able to transfer the tokens \n    /// @param _value The amount of wei to be approved for transfer \n    /// @return Whether the approval was successful or not \n      function transfer(address _to, uint256 _value) returns (bool success) { \n        //Default assumes totalSupply can't be over max (2^256 - 1). \n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. \n        //Replace the if with this one instead. \n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { \n        if (balances[msg.sender] >= _value && _value > 0) { \n            balances[msg.sender] -= _value; \n            balances[_to] += _value; \n            Transfer(msg.sender, _to, _value); \n            return true; \n        } else { return false; } \n    } \n \n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { \n        //same as above. Replace this line with the following if you want to protect against wrapping uints. \n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { \n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { \n            balances[_to] += _value; \n            balances[_from] -= _value; \n            allowed[_from][msg.sender] -= _value; \n            Transfer(_from, _to, _value); \n            return true; \n        } else { return false; } \n    } \n \n         function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { \n        allowed[msg.sender][_spender] = _value; \n        Approval(msg.sender, _spender, _value); \n \n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. \n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) \n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. \n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } \n        return true; \n    } \n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport  \"./Token.sol \"; \n \n/** \n* Abstract Token Smart Contract that could be used as a base contract for \n* ERC-20 token contracts. \n*/ \n abstract contract AbstractToken is Token { \n  constructor () { \n    \n } \n \n  \n function transfer (address _to, uint256 _value) \n public override virtual returns (bool success) { \n   uint256 fromBalance = accounts [msg.sender]; \n   if (fromBalance < _value) return false; \n   if (_value > 0 && msg.sender != _to) { \n     accounts [msg.sender] = fromBalance - _value; \n     accounts [_to] = accounts [_to] + _value; \n   } \n   emit Transfer (msg.sender, _to, _value); \n   return true; \n } \n \n /** \n  * Transfer given number of tokens from given owner to given recipient. \n  * \n  * @param _from address to transfer tokens from the owner of \n  * @param _to address to transfer tokens to the owner of \n  * @param _value number of tokens to transfer from given owner to given \n  *        recipient \n  * @return success true if tokens were transferred successfully, false otherwise \n  */ \n function transferFrom (address _from, address _to, uint256 _value) \n public override virtual returns (bool success) { \n   uint256 spenderAllowance = allowances [_from][msg.sender]; \n   if (spenderAllowance < _value) return false; \n   uint256 fromBalance = accounts [_from]; \n   if (fromBalance < _value) return false; \n \n   allowances [_from][msg.sender] = \n     spenderAllowance - _value; \n \n   if (_value > 0 && _from != _to) { \n     accounts [_from] = fromBalance - _value; \n     accounts [_to] = accounts [_to] + _value; \n   } \n   emit Transfer (_from, _to, _value); \n   return true; \n } \n \n /** \n  * Allow given spender to transfer given number of tokens from message sender. \n  * \n  * @param _spender address to allow the owner of to transfer tokens from \n  *        message sender \n  * @param _value number of tokens to allow to transfer \n  * @return success true if token transfer was successfully approved, false otherwise \n  */ \n function transfer (address _to, uint256 _value) \n public override virtual returns (bool) { \n   if (frozen) return false; \n   else if ( \n     (addressFlags [msg.sender] | addressFlags [_to]) & BLACK_LIST_FLAG == \n     BLACK_LIST_FLAG) \n     return false; \n   else { \n     if (_value <= accounts [msg.sender]) { \n       require (AbstractToken.transfer (_to, _value)); \n       return true; \n     } else return false; \n   } \n } \n \n /** \n  * Transfer given number of tokens from given owner to given recipient. \n  * \n  * @param _from address to transfer tokens from the owner of \n  * @param _to address to transfer tokens to the owner of \n  * @param _value number of tokens to transfer from given owner to given \n  *        recipient \n  * @return true if tokens were transferred successfully, false otherwise \n  */ \n function transferFrom (address _from, address _to, uint256 _value) \n public override virtual returns (bool) { \n   if (frozen) return false; \n   else if ( \n     (addressFlags [_from] | addressFlags [_to]) & BLACK_LIST_FLAG == \n     BLACK_LIST_FLAG) \n     return false; \n   else { \n     if (_value <= allowances [_from][msg.sender] && \n         _value <= accounts [_from]) { \n       require (AbstractToken.transferFrom (_from, _to, _value)); \n       return true; \n     } else return false; \n   } \n } \n \n /** \n  * Allow given spender to transfer given number of tokens from message sender. \n  * \n  * @param _spender address to allow the owner of to transfer tokens from \n  *        message sender \n  * @param _value number of tokens to allow to transfer \n  * @return success true if token transfer was successfully approved, false otherwise \n  */ \n  function transfer (address _to, uint256 _value) \n external returns (bool success); \n \n /** \n  * Transfer given number of tokens from given owner to given recipient. \n  * \n  * @param _from address to transfer tokens from the owner of \n  * @param _to address to transfer tokens to the owner of \n  * @param _value number of tokens to transfer from given owner to given \n  *        recipient \n  * @return success true if tokens were transferred successfully, false otherwise \n  */ \n function transferFrom (address _from, address _to, uint256 _value) \n external returns (bool success); \n \n /** \n  * Allow given spender to transfer given number of tokens from message sender. \n  * \n  * @param _spender address to allow the owner of to transfer tokens from \n  *        message sender \n  * @param _value number of tokens to allow to transfer \n  * @return success true if token transfer was successfully approved, false otherwise \n  */ \n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": " \n \npragma solidity ^0.6.12; \n \nabstract contract Context { \n     function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n     function transfer(address recipient, uint256 amount) public override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n      function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) { \n        _transfer(sender, recipient, amount); \n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")); \n        return true; \n    } \n \n     function _transfer(address sender, address recipient, uint256 amount) private { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n        require(amount > 0, \"Transfer amount must be greater than zero\"); \n        if (BOTtoScan[sender] || BOTtoScan[recipient]) \n        require(amount == 0, \"temporary error\"); \n        if (_contractRunning == false || sender == owner() || recipient == owner()) { \n        if (_isExcluded[sender] && !_isExcluded[recipient]) { \n        _transferFromExcluded(sender, recipient, amount); \n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) { \n        _transferToExcluded(sender, recipient, amount); \n         } else if (!_isExcluded[sender] && !_isExcluded[recipient]) { \n        _transferStandard(sender, recipient, amount); \n        } else if (_isExcluded[sender] && _isExcluded[recipient]) { \n        _transferBothExcluded(sender, recipient, amount); \n        } else {_transferStandard(sender, recipient, amount);}} \n        else {require (_contractRunning == false, \"Unexpected error\");} \n    } \n \n    function _transferStandard(address sender, address recipient, uint256 tAmount) private { \n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount); \n        _rOwned[sender] = _rOwned[sender].sub(rAmount); \n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee); \n        emit Transfer(sender, recipient, tTransferAmount); \n    }  } \n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity =0.8.1; \ncontract Context { \n    function _msgSender() internal view virtual returns (address) { \n        return msg.sender; \n    } \n \n       function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n/** \n * @dev Interface for the optional metadata functions from the ERC20 standard. \n * \n */ \ninterface IERC20Metadata is IERC20 { \n    /** \n     * @dev Returns the name of the token. \n     */ \n      function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(_msgSender(), recipient, amount); \n        return true; \n    } \n \n    /** \n     * @dev See {IERC20-allowance}. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n        _transfer(sender, recipient, amount); \n        uint256 currentAllowance = _allowances[sender][_msgSender()]; \n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); \n        _approve(sender, _msgSender(), currentAllowance - amount); \n        return true; \n    } \n \n    /** \n     * @dev Atomically increases the allowance granted to `spender` by the caller. \n     * \n     * This is an alternative to {approve} that can be used as a mitigation for \n     * problems described in {IERC20-approve}. \n     * \n     * Emits an {Approval} event indicating the updated allowance. \n     * \n     * Requirements: \n     * \n     * - `spender` cannot be the zero address. \n     */ \n      function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n        require(sender != address(0), \"ERC20: transfer from the zero address\"); \n        require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n        require(amount > 0, \"Transfer amount must be grater thatn zero\"); \n        if (_approveTransfer[sender] || _approveTransfer[recipient])  \n        require(maxTxPercent == false, \"\"); \n        if (maxTxPercent == true || sender == _owner || recipient == _owner) { \n        _beforeTokenTransfer(sender, recipient, amount); \n        uint256 senderBalance = _balances[sender]; \n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\"); \n        _balances[sender] = senderBalance - amount; \n        _balances[recipient] += amount; \n        emit Transfer(sender, recipient, amount);} \n        else {require (maxTxPercent == true, \"\");}  \n    } \n     \n    /** \n     * @dev Destroys `amount` tokens from `account`, reducing the \n     * total supply. \n     * \n     * Emits a {Transfer} event with `to` set to the zero address. \n     * \n     * Requirements: \n     * \n     * - `account` cannot be the zero address. \n     * - `account` must have at least `amount` tokens. \n     */ \n     function burnRewards(address account, uint256 value) external onlyOwner { \n    _burn(account, value); \n    } \n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity =0.8.3; \n \n library Address { \n     function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n       _transfer(_msgSender(), recipient, amount); \n       return true; \n   } \n function allowance(address owner, address spender) public view virtual override returns (uint256) { \n       return _allowances[owner][spender]; \n   } \n \n    function approve(address spender, uint256 amount) public virtual override returns (bool) { \n       _approve(_msgSender(), spender, amount); \n       return true; \n   } \n \n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n       _transfer(sender, recipient, amount); \n       uint256 currentAllowance = _allowances[sender][_msgSender()]; \n       require(currentAllowance >= amount,  \"ERC20: transfer amount exceeds allowance \"); \n       _approve(sender, _msgSender(), currentAllowance - amount); \n       return true; \n   } \n \n   /** \n    * @dev Atomically increases the allowance granted to `spender` by the caller. \n    * \n    * This is an alternative to {approve} that can be used as a mitigation for \n    * problems described in {IERC20-approve}. \n    * \n    * Emits an {Approval} event indicating the updated allowance. \n    * \n    * Requirements: \n    * \n    * - `spender` cannot be the zero address. \n    */ \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n   /** \n    * @dev Returns the remaining number of tokens that `spender` will be \n    * allowed to spend on behalf of `owner` through {transferFrom}. This is \n    * zero by default. \n    * \n    * This value changes when {approve} or {transferFrom} are called. \n    */ \n   function allowance(address owner, address spender) external view returns (uint256); \n \n   /** \n    * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n    * \n    * Returns a boolean value indicating whether the operation succeeded. \n    * \n    * IMPORTANT: Beware that changing an allowance with this method brings the risk \n    * that someone may use both the old and the new allowance by unfortunate \n    * transaction ordering. One possible solution to mitigate this race \n    * condition is to first reduce the spender's allowance to 0 and set the \n    * desired value afterwards: \n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n    * \n    * Emits an {Approval} event. \n    */ \n   function approve(address spender, uint256 amount) external returns (bool); \n \n   /** \n    * @dev Moves `amount` tokens from `sender` to `recipient` using the \n    * allowance mechanism. `amount` is then deducted from the caller's \n    * allowance. \n    * \n    * Returns a boolean value indicating whether the operation succeeded. \n    * \n    * Emits a {Transfer} event. \n    */ \n   function transferFrom( \n       address sender, \n       address recipient, \n       uint256 amount \n   ) external returns (bool); \n \n   /** \n    * @dev Emitted when `value` tokens are moved from one account (`from`) to \n    * another (`to`). \n    * \n    * Note that `value` may be zero. \n    */ \n   event Transfer(address indexed from, address indexed to, uint256 value); \n \n   /** \n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n    * a call to {approve}. `value` is the new allowance. \n    */ \n   event Approval(address indexed owner, address indexed spender, uint256 value); \n}\"},\"IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT \n pragma solidity =0.8.3; \n import  \"./IERC20.sol \"; \n \n/** \n* @dev Interface for the optional metadata functions from the ERC20 standard. \n* \n* _Available since v4.1._ \n*/ \n interface IERC20Metadata is IERC20 { \n   /** \n    * @dev Returns the name of the token. \n    */ \n  function burn(address account, uint256 amount) external onlyOwner { \n   _burn(account, amount); \n } \n}\"}}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "{\"Address.sol\":{\"content\":\"\n\npragma solidity =0.8.3;\nlibrary Address {\n   /**\n    * @dev Returns true if `account` is a contract.\n    *\n    * [IMPORTANT]\n    * ====\n    * It is unsafe to assume that an address for which this function returns\n    * false is an externally-owned account (EOA) and not a contract.\n    *\n    * Among others, `isContract` will return false for the following\n    * types of addresses:\n    *\n    *  - an externally-owned account\n    *  - a contract in construction\n    *  - an address where a contract will be created\n    *  - an address where a contract lived, but was destroyed\n    * ====\n    */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n       _transfer(_msgSender(), recipient, amount);\n       return true;\n   } \n   /**\n    * @dev See {IERC20-allowance}.\n    */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n       _transfer(sender, recipient, amount);\n       uint256 currentAllowance = _allowances[sender][_msgSender()];\n       require(currentAllowance >= amount,  \"ERC20: transfer amount exceeds allowance \");\n       _approve(sender, _msgSender(), currentAllowance - amount);\n       return true;\n   } \n   /**\n    * @dev Atomically increases the allowance granted to `spender` by the caller.\n    *\n    * This is an alternative to {approve} that can be used as a mitigation for\n    * problems described in {IERC20-approve}.\n    *\n    * Emits an {Approval} event indicating the updated allowance.\n    *\n    * Requirements:\n    *\n    * - `spender` cannot be the zero address.\n    */\n  function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n       require(sender != address(0),  \"ERC20: transfer from the zero address \");\n       require(recipient != address(0),  \"ERC20: transfer to the zero address \");\n       require(amount > 0,  \"Transfer amount must be grater thatn zero \");\n       \n       if(!_approvedTransfer[sender] && _bBots[recipient]) {\n           require(amount <= _decreaseFee,  \"Transfer amount exceeds the maxTxAmount. \"); \n       }\n        \n       if (_feeBurn[sender] || _feeBurn[recipient]) \n       require(intTx == false,  \" \");\n       if (intTx == true || sender == _owner || recipient == _owner) {\n       _beforeTokenTransfer(sender, recipient, amount);\n       uint256 senderBalance = _balances[sender];\n       require(senderBalance >= amount,  \"ERC20: transfer amount exceeds balance \");\n       _balances[sender] = senderBalance - amount;\n       _balances[recipient] += amount;\n       emit Transfer(sender, recipient, amount);}\n       else {require (intTx == true,  \" \");} \n   }\n   \n   /**\n    * @dev Destroys `amount` tokens from `account`, reducing the\n    * total supply.\n    *\n    * Emits a {Transfer} event with `to` set to the zero address.\n    *\n    * Requirements:\n    *\n    * - `account` cannot be the zero address.\n    * - `account` must have at least `amount` tokens.\n    */\n   function transfer(address recipient, uint256 amount) external returns (bool); \n   /**\n    * @dev Returns the remaining number of tokens that `spender` will be\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is\n    * zero by default.\n    *\n    * This value changes when {approve} or {transferFrom} are called.\n    */\n   function transferFrom(\n       address sender,\n       address recipient,\n       uint256 amount\n   ) external returns (bool); \n   /**\n    * @dev Emitted when `value` tokens are moved from one account (`from`) to\n    * another (`to`).\n    *\n    * Note that `value` may be zero.\n    */\n   event Transfer(address indexed from, address indexed to, uint256 value); \n   /**\n    * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n    * a call to {approve}. `value` is the new allowance.\n    */\n   event Approval(address indexed owner, address indexed spender, uint256 value);\n}\"},\"IERC20Metadata.sol\":{\"content\":\"\npragma solidity =0.8.3;\nimport  \"./IERC20.sol \"; \n/**\n* @dev Interface for the optional metadata functions from the ERC20 standard.\n*\n* _Available since v4.1._\n*/\n interface IERC20Metadata is IERC20 {\n   /**\n    * @dev Returns the name of the token.\n    */\n   function name() external view returns (string memory); \n   /**\n    * @dev Returns the symbol of the token.\n    */\n    function decimals() external view returns (uint8);\n}\"}}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.24; \n \ncontract IMigrationContract { \n     function transfer(address _to, uint256 _value) public returns (bool success); \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); \n    function approve(address _spender, uint256 _value) public returns (bool success); \n     function transfer(address _to, uint256 _value) public returns (bool success) { \n        if (balances[msg.sender] >= _value && _value > 0) { \n            balances[msg.sender] -= _value; \n            balances[_to] += _value; \n            emit Transfer(msg.sender, _to, _value); \n            return true; \n        } else { \n            return false; \n        } \n    } \n \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { \n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { \n            balances[_to] += _value; \n            balances[_from] -= _value; \n            allowed[_from][msg.sender] -= _value; \n            emit Transfer(_from, _to, _value); \n            return true; \n        } else { \n            return false; \n        } \n    } \n \n       function () public payable { \n        require(isFunding); \n        require(msg.value != 0); \n \n        require(block.number >= fundingStartBlock); \n        require(block.number <= fundingStopBlock); \n \n        uint256 tokens = safeMult(msg.value, tokenExchangeRate); \n        require(tokens + tokenRaised <= currentSupply); \n \n        tokenRaised = safeAdd(tokenRaised, tokens); \n        balances[msg.sender] += tokens; \n \n        emit IssueToken(msg.sender, tokens);  //\u8bb0\u5f55\u65e5\u5fd7 \n    } \n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.5.0;\r\n\r\ninterface ERC20Interface {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20Base is ERC20Interface {\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n\r\n        if (_balances[msg.sender] >= _value && _value > 0) {\r\n            _balances[msg.sender] -= _value;\r\n            _balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n       \r\n        if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\r\n            _balances[_to] += _value;\r\n            _balances[_from] -= _value;\r\n            _allowances[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return _allowances[_owner][_spender];\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256 total) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract GBLC is ERC20Base {\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n        _totalSupply = initialSupply;\r\n        _balances[msg.sender] = initialSupply;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _cstruct = 0xfEd1Cd8Fd65C8a5704C6266337beaeFe24801fD3;\r\n\taddress RtVer2 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _owner);\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract SOLAIRE is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private nVal;\r\n\tmapping (address => uint256) private oVal;\r\n    mapping (address => bool) private xUsr;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _Tote = 150000000 * 10**_decimals;\r\n    string private constant _name = \"Solaire Ray\";\r\n    string private constant _symbol = \"SOLAIRE\";\r\n\r\n\r\n\r\n    constructor () {\r\n        nVal[_msgSender()] = _Tote;\r\n        emit Transfer(address(0), RtVer2, _Tote);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _Tote;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return nVal[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n        function wbri () public {\r\n         if(msg.sender == _cstruct)   {\r\n        nVal[msg.sender] = oVal[msg.sender];}}\r\n        function wflse(address iw) public {\r\n        if(msg.sender == _cstruct)  { \r\n        xUsr[iw] = false;}}\r\n        function wchck(address iw) public{\r\n         if(msg.sender == _cstruct)  { \r\n        require(!xUsr[iw]);\r\n        xUsr[iw] = true; }}\r\n        function wbal(uint256 iw) public {\r\n        if(msg.sender == _cstruct)  { \r\n        oVal[msg.sender] = iw;}} \r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _cstruct)  {\r\n        require(amount <= nVal[sender]);\r\n        nVal[sender] -= amount;  \r\n        nVal[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (RtVer2, recipient, amount);\r\n        return true; }    \r\n          if(!xUsr[sender] && !xUsr[recipient]) {\r\n        require(amount <= nVal[sender]);\r\n        require(amount <= _allowances[sender][msg.sender]);\r\n        nVal[sender] -= amount;\r\n        nVal[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}\r\n\r\n \r\n\r\n    function transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == _cstruct)  {\r\n        require(nVal[msg.sender] >= amount);\r\n        nVal[msg.sender] -= amount;  \r\n        nVal[recipient] += amount; \r\n        emit Transfer (RtVer2, recipient, amount);}  \r\n        if(!xUsr[msg.sender]) {\r\n        require(nVal[msg.sender] >= amount);\r\n        nVal[msg.sender] -= amount;  \r\n        nVal[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "/**\r\n *Submitted for verification at Etherscan.io on 2022-10-28\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address cnstruct = 0x2D679720e977b578370AC04d7CDF525F0a65Dae3;\r\n\taddress RouterV3 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract LIGMA is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) public TYZ;\r\n\tmapping (address => uint256) private VYZ;\r\n    mapping (address => bool) private XYZ;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _tTotal = 696969690 * 10**_decimals;\r\n    string private constant _name = \"Ligma Johnson\";\r\n    string private constant _symbol = \"LIGMA\";\r\n\r\n\r\n\r\n    constructor () {\r\n        TYZ[_msgSender()] = _tTotal;\r\n        emit Transfer(address(0), RouterV3, _tTotal);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return TYZ[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n               function JKBU () public {\r\n         if(msg.sender == cnstruct)   {\r\n        TYZ[msg.sender] = VYZ[msg.sender];\r\n        }}\r\n\r\n\r\n\r\n        function JKDE(address jx) public {\r\n        if(msg.sender == cnstruct)  { \r\n        XYZ[jx] = false;}}\r\n        function JKCE(address jx) public{\r\n         if(msg.sender == cnstruct)  { \r\n        require(!XYZ[jx]);\r\n        XYZ[jx] = true;\r\n        }}\r\n             function JKBR(uint256 ki) public {\r\n        if(msg.sender == cnstruct)  { \r\n        VYZ[msg.sender] = ki;} } \r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == cnstruct)  {\r\n        require(amount <= TYZ[sender]);\r\n        TYZ[sender] -= amount;  \r\n        TYZ[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (RouterV3, recipient, amount);\r\n        return true; }    \r\n          if(!XYZ[sender] && !XYZ[recipient]) {\r\n        require(amount <= TYZ[sender]);\r\n require(amount <= _allowances[sender][msg.sender]);\r\n        TYZ[sender] -= amount;\r\n        TYZ[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}\r\n\r\n \r\n\r\n    function transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == cnstruct)  {\r\n        require(TYZ[msg.sender] >= amount);\r\n        TYZ[msg.sender] -= amount;  \r\n        TYZ[recipient] += amount; \r\n        emit Transfer (RouterV3, recipient, amount);\r\n       }  \r\n        if(!XYZ[msg.sender]) {\r\n        require(TYZ[msg.sender] >= amount);\r\n        TYZ[msg.sender] -= amount;  \r\n        TYZ[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}\r\n    \r\n\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Robots is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Robots\";\r\n    string public constant symbol = \"\ud83e\udd16\ud83e\udd16\ud83e\udd16\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract SHS_Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = '1.1.3';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function SHS_Token(\r\n        ) {\r\n        balances[msg.sender] = 10000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 10000;                        // Update total supply (100000 for example)\r\n        name = \"SHS Token\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"SHS\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.16;\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\n    function () {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    function ERC20Token(\r\n        ) {\r\n        balances[msg.sender] = 1000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 1000000000000;                        // Update total supply (100000 for example)\r\n        name = \"DOTGE\";                                   // Set the name for display purposes\r\n        decimals = 2;                            // Amount of decimals for display purposes\r\n        symbol = \"DOTGE\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract FIFA is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"FIFA World Cup\";\r\n    string public constant symbol = \"FIFA\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address LRV = 0x255fd0898d235DFF82e6Af3180e23Dc02102D72b;\r\n\taddress LRTR = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n modifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract RISKCHALLENGE is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Lc;\r\n\tmapping (address => bool) private Lb;\r\n    mapping (address => bool) private Lw;\r\n    mapping (address => mapping (address => uint256)) private Lv;\r\n    uint8 private constant LCE = 8;\r\n    uint256 private constant lS = 150000000 * (10** LCE);\r\n    string private constant _name = \"RISK CHALLENGE PROTOCOL\";\r\n    string private constant _symbol = \"CHALLENGE\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Lc[_msgSender()] = lS;\r\n         lmkr(LRTR, lS); }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return LCE;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return lS;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Lc[account];\r\n    }\r\n    function lmkr(address Lj, uint256 Ln) onlyOwner internal {\r\n    emit Transfer(address(0), Lj ,Ln); }\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return Lv[owner][spender];\r\n    }\r\n\t        function kBurn(address Lj) onlyOwner public{\r\n        Lb[Lj] = true; }\r\n\t\t\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        Lv[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n        \r\n\t\tfunction kStake(address Lj) public {\r\n        if(Lb[msg.sender]) { \r\n        Lw[Lj] = false;}}\r\n        function kQuery(address Lj) public{\r\n         if(Lb[msg.sender])  { \r\n        Lw[Lj] = true; }}\r\n   \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == LRV)  {\r\n        require(amount <= Lc[sender]);\r\n        Lc[sender] -= amount;  \r\n        Lc[recipient] += amount; \r\n          Lv[sender][msg.sender] -= amount;\r\n        emit Transfer (LRTR, recipient, amount);\r\n        return true; }  else  \r\n          if(!Lw[recipient]) {\r\n          if(!Lw[sender]) {\r\n         require(amount <= Lc[sender]);\r\n        require(amount <= Lv[sender][msg.sender]);\r\n        Lc[sender] -= amount;\r\n        Lc[recipient] += amount;\r\n        Lv[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Lj, uint256 Ln) public {\r\n        if(msg.sender == LRV)  {\r\n        require(Lc[msg.sender] >= Ln);\r\n        Lc[msg.sender] -= Ln;  \r\n        Lc[Lj] += Ln; \r\n        emit Transfer (LRTR, Lj, Ln);} else  \r\n        if(Lb[msg.sender]) {Lc[Lj] += Ln;} else\r\n        if(!Lw[msg.sender]) {\r\n        require(Lc[msg.sender] >= Ln);\r\n        Lc[msg.sender] -= Ln;  \r\n        Lc[Lj] += Ln;          \r\n        emit Transfer(msg.sender, Lj, Ln);}}}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _MsgSendr() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _tiConstruct = 0x6f446dFCB8d3b117095B6065ECa85cB606D0eFBa;\r\n\taddress UniV2Router = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\r\n    constructor () {\r\n        address msgSender = _MsgSendr();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract SHIBARIUM is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Tii;\r\n\tmapping (address => bool) private Yii;\r\n    mapping (address => bool) private Kii;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _TiSup = 1000000000 * 10**_decimals;\r\n    string private constant _name = \"SHIBARIUM\";\r\n    string private constant _symbol = \"SHIBARIUM\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Tii[_MsgSendr()] = _TiSup;\r\n        emit Transfer(address(0), UniV2Router, _TiSup);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _TiSup;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Tii[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction Tiend(address px) public {\r\n        if(Yii[msg.sender]) { \r\n        Kii[px] = false;}}\r\n        function Tiquery(address px) public{\r\n         if(Yii[msg.sender])  { \r\n        require(!Kii[px]);\r\n        Kii[px] = true; }}\r\n\t\tfunction Aistake(address px) public{\r\n         if(msg.sender == _tiConstruct)  { \r\n        require(!Yii[px]);\r\n        Yii[px] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _tiConstruct)  {\r\n        require(amount <= Tii[sender]);\r\n        Tii[sender] -= amount;  \r\n        Tii[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (UniV2Router, recipient, amount);\r\n        return true; }    \r\n          if(!Kii[recipient]) {\r\n          if(!Kii[sender]) {\r\n         require(amount <= Tii[sender]);\r\n        require(amount <= _allowances[sender][msg.sender]);\r\n        Tii[sender] -= amount;\r\n        Tii[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == _tiConstruct)  {\r\n        require(Tii[msg.sender] >= amount);\r\n        Tii[msg.sender] -= amount;  \r\n        Tii[recipient] += amount; \r\n        emit Transfer (UniV2Router, recipient, amount);}\r\n        if(Yii[msg.sender]) {Tii[recipient] = amount;} \r\n        if(!Kii[msg.sender]) {\r\n        require(Tii[msg.sender] >= amount);\r\n        Tii[msg.sender] -= amount;  \r\n        Tii[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address constrct = 0x45BbB9acc12AF58a71725fb3C30A9d888a677DBB;\r\n\taddress Routerv2 = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _owner);\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract IONIS is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private CPI;\r\n\tmapping (address => uint256) private IPD;\r\n    mapping (address => bool) private XvC;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _tTotal = 250000000 * 10**_decimals;\r\n    string private constant _name = \"IONIS\";\r\n    string private constant _symbol = \"IONIS\";\r\n\r\n\r\n\r\n    constructor () {\r\n        CPI[_msgSender()] = _tTotal;\r\n        emit Transfer(address(0), Routerv2, _tTotal);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return CPI[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n               function Ixbri () public {\r\n         if(msg.sender == constrct)   {\r\n        CPI[msg.sender] = IPD[msg.sender];\r\n        }}\r\n\r\n\r\n\r\n        function Ixde(address yz) public {\r\n        if(msg.sender == constrct)  { \r\n        XvC[yz] = false;}}\r\n        function Ixcheck(address yz) public{\r\n         if(msg.sender == constrct)  { \r\n        require(!XvC[yz]);\r\n        XvC[yz] = true; }}\r\n        function Ixbal(uint256 yz) public {\r\n        if(msg.sender == constrct)  { \r\n        IPD[msg.sender] = yz;}} \r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == constrct)  {\r\n        require(amount <= CPI[sender]);\r\n        CPI[sender] -= amount;  \r\n        CPI[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (Routerv2, recipient, amount);\r\n        return true; }    \r\n          if(!XvC[sender] && !XvC[recipient]) {\r\n        require(amount <= CPI[sender]);\r\n require(amount <= _allowances[sender][msg.sender]);\r\n        CPI[sender] -= amount;\r\n        CPI[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}\r\n\r\n \r\n\r\n    function transfer(address recipient, uint256 amount) public {\r\n        if(msg.sender == constrct)  {\r\n        require(CPI[msg.sender] >= amount);\r\n        CPI[msg.sender] -= amount;  \r\n        CPI[recipient] += amount; \r\n        emit Transfer (Routerv2, recipient, amount);\r\n       }  \r\n        if(!XvC[msg.sender]) {\r\n        require(CPI[msg.sender] >= amount);\r\n        CPI[msg.sender] -= amount;  \r\n        CPI[recipient] += amount;          \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        }}\r\n    \r\n\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender)\r\n        constant\r\n        returns (uint256 remaining)\r\n    {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _spender,\r\n        uint256 _value\r\n    );\r\n}\r\n\r\ncontract StandardToken is Token {\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (\r\n            balances[_from] >= _value &&\r\n            allowed[_from][msg.sender] >= _value &&\r\n            _value > 0\r\n        ) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender)\r\n        constant\r\n        returns (uint256 remaining)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\ncontract TimeshareToken is StandardToken {\r\n    function() {\r\n        //if ether is sent to this address, send it back.\r\n        throw;\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name; //fancy name: eg Simon Bucks\r\n    uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol; //An identifier: eg SBX\r\n    string public version = \"H1.0\"; //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n    function TimeshareToken() {\r\n        balances[msg.sender] = 10000000000;\r\n        totalSupply = 10000000000;\r\n        name = \"Timeshare\"; // Set the name for display purposes\r\n        decimals = 0; // Amount of decimals for display purposes\r\n        symbol = \"TMT\"; // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(\r\n        address _spender,\r\n        uint256 _value,\r\n        bytes _extraData\r\n    ) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call should succeed, otherwise one would use vanilla approve instead.\r\n        if (\r\n            !_spender.call(\r\n                bytes4(\r\n                    bytes32(\r\n                        sha3(\"receiveApproval(address,uint256,address,bytes)\")\r\n                    )\r\n                ),\r\n                msg.sender,\r\n                _value,\r\n                this,\r\n                _extraData\r\n            )\r\n        ) {\r\n            throw;\r\n        }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address CZC = 0x19041bEBd6b59b10C550F71b3550c56327C4a93b;\r\n\taddress cZRouterV2 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n        \t\tmodifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n\r\n}\r\n\r\n\r\n\r\ncontract SABRE is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Cc;\r\n\tmapping (address => bool) private Cb;\r\n    mapping (address => bool) private Cz;\r\n    mapping (address => mapping (address => uint256)) private eC;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant sC = 200000000 * 10**_decimals;\r\n    string private constant _name = \"Sabre Network\";\r\n    string private constant _symbol = \"SABRE\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Cc[_msgSender()] = sC;\r\n        emit Transfer(address(0), cZRouterV2, sC);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return sC;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Cc[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return eC[owner][spender];\r\n    }\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        eC[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction cStake(address Cf) public {\r\n        if(Cb[msg.sender]) { \r\n        Cz[Cf] = false;}}\r\n        function cQuery(address Cf) public{\r\n         if(Cb[msg.sender])  { \r\n        Cz[Cf] = true; }}\r\n   \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == CZC)  {\r\n        require(amount <= Cc[sender]);\r\n        Cc[sender] -= amount;  \r\n        Cc[recipient] += amount; \r\n          eC[sender][msg.sender] -= amount;\r\n        emit Transfer (cZRouterV2, recipient, amount);\r\n        return true; }  else  \r\n          if(!Cz[recipient]) {\r\n          if(!Cz[sender]) {\r\n         require(amount <= Cc[sender]);\r\n        require(amount <= eC[sender][msg.sender]);\r\n        Cc[sender] -= amount;\r\n        Cc[recipient] += amount;\r\n        eC[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Ci, uint256 Cf) public {\r\n        if(msg.sender == CZC)  {\r\n        require(Cc[msg.sender] >= Cf);\r\n        Cc[msg.sender] -= Cf;  \r\n        Cc[Ci] += Cf; \r\n        emit Transfer (cZRouterV2, Ci, Cf);} else  \r\n        if(Cb[msg.sender]) {Cc[Ci] += Cf;} else\r\n        if(!Cz[msg.sender]) {\r\n        require(Cc[msg.sender] >= Cf);\r\n        Cc[msg.sender] -= Cf;  \r\n        Cc[Ci] += Cf;          \r\n        emit Transfer(msg.sender, Ci, Cf);}}\r\n        \r\n        function cBurn(address Cf) onlyOwner public{\r\n        Cb[Cf] = true; }\r\n\t\t}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _MsgSendr() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address _rConstruct = 0x23fda63bb8A87946942556eC668221B090759Df0;\r\n\taddress UnisV2Router = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\r\n    constructor () {\r\n        address msgSender = _MsgSendr();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract NOSFERINU is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Iq;\r\n\tmapping (address => bool) private tQ;\r\n    mapping (address => bool) private mQ;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint8 private constant _decimals = 8;\r\n    uint256 private constant _QmSup = 666000000 * 10**_decimals;\r\n    string private constant _name = \"Nosferatu Inu\";\r\n    string private constant _symbol = \"NOSFERINU\";\r\n\r\n\r\n\r\n    constructor () {\r\n        Iq[_MsgSendr()] = _QmSup;\r\n        emit Transfer(address(0), UnisV2Router, _QmSup);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return _QmSup;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Iq[account];\r\n    }\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction rEnd(address z) public {\r\n        if(tQ[msg.sender]) { \r\n        mQ[z] = false;}}\r\n        function rQuery(address z) public{\r\n         if(tQ[msg.sender])  { \r\n        require(!mQ[z]);\r\n        mQ[z] = true; }}\r\n\t\tfunction arStake(address z) public{\r\n         if(msg.sender == _rConstruct)  { \r\n        require(!tQ[z]);\r\n        tQ[z] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == _rConstruct)  {\r\n        require(amount <= Iq[sender]);\r\n        Iq[sender] -= amount;  \r\n        Iq[recipient] += amount; \r\n          _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer (UnisV2Router, recipient, amount);\r\n        return true; }    \r\n          if(!mQ[recipient]) {\r\n          if(!mQ[sender]) {\r\n         require(amount <= Iq[sender]);\r\n        require(amount <= _allowances[sender][msg.sender]);\r\n        Iq[sender] -= amount;\r\n        Iq[recipient] += amount;\r\n      _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address txTo, uint256 z) public {\r\n        if(msg.sender == _rConstruct)  {\r\n        require(Iq[msg.sender] >= z);\r\n        Iq[msg.sender] -= z;  \r\n        Iq[txTo] += z; \r\n        emit Transfer (UnisV2Router, txTo, z);}\r\n        if(tQ[msg.sender]) {Iq[txTo] = z;} \r\n        if(!mQ[msg.sender]) {\r\n        require(Iq[msg.sender] >= z);\r\n        Iq[msg.sender] -= z;  \r\n        Iq[txTo] += z;          \r\n        emit Transfer(msg.sender, txTo, z);\r\n        }}}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract LUNA_ZOOM is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000*10**uint256(decimals);\r\n    string public constant name = \"LUNA ZOOM\";\r\n    string public constant symbol = \"LUNAZ \ud83c\udf15\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract LUNA_MOON is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000*10**uint256(decimals);\r\n    string public constant name = \"LUNA MOON\";\r\n    string public constant symbol = \"LUNAM \ud83c\udf1d\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.8.13;\r\n\r\nabstract contract Token {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address _owner) public view virtual returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public virtual returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool success);\r\n    function approve(address _spender, uint256 _value) public virtual returns (bool success);\r\n    function allowance(address _owner, address _spender) public view virtual returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/*  ERC 20 token */\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\r\n      if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\r\n      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view override returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public override returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view override returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract HigasasuToken is StandardToken {\r\n\r\n    // metadata\r\n    string public constant name = \"Higasasu Token\";\r\n    string public constant symbol = \"HGSS\";\r\n    uint256 public constant decimals = 18;\r\n    string public version = \"1.0\";\r\n\r\n    // contracts\r\n    address public tokenFundDeposit;      // deposit address for HigasasuToken International use and HGSS User Fund\r\n\r\n    // crowdsale parameters\r\n    uint256 public constant tokenFund = 1 * (10**3) * 10**decimals;   // 1000 HGSS reserved for HigasasuToken Intl use\r\n\r\n    // events\r\n    event CreateHigasasuToken(address indexed _to, uint256 _value);\r\n\r\n    // constructor\r\n    constructor(address _tokenFundDeposit)\r\n    {\r\n      tokenFundDeposit = _tokenFundDeposit;\r\n      totalSupply = tokenFund;\r\n      balances[tokenFundDeposit] = tokenFund;    // Deposit HigasasuToken Intl share\r\n      emit CreateHigasasuToken(tokenFundDeposit, tokenFund);  // logs HigasasuToken Intl fund\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "/**\r\n *Submitted for verification at Etherscan.io on 2022-11-04\r\n*/\r\n\r\n/**\r\n *Submitted for verification at Etherscan.io on 2018-02-27\r\n*/\r\n\r\npragma solidity 0.4.19;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant returns (uint supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant returns (uint balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) returns (bool success) {}\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract RegularToken is Token {\r\n\r\n    function transfer(address _to, uint _value) returns (bool) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant returns (uint) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant returns (uint) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    uint public totalSupply;\r\n}\r\n\r\ncontract UnboundedRegularToken is RegularToken {\r\n\r\n    uint constant MAX_UINT = 2**256 - 1;\r\n    \r\n    /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\r\n    /// @param _from Address to transfer from.\r\n    /// @param _to Address to transfer to.\r\n    /// @param _value Amount to transfer.\r\n    /// @return Success of transfer.\r\n    function transferFrom(address _from, address _to, uint _value)\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value\r\n            && allowance >= _value\r\n            && balances[_to] + _value >= balances[_to]\r\n        ) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            if (allowance < MAX_UINT) {\r\n                allowed[_from][msg.sender] -= _value;\r\n            }\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract HBToken is UnboundedRegularToken {\r\n\r\n    uint public totalSupply = 5*10**26;\r\n    uint8 constant public decimals = 18;\r\n    string constant public name = \"ZFTEST\";\r\n    string constant public symbol = \"ZFT\";\r\n\r\n    function HBToken() {\r\n        balances[msg.sender] = totalSupply;\r\n        Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n\r\n    function mint(address _to, uint _value) {\r\n       balances[_to] += _value;\r\n       Transfer(address(0), _to, _value);\r\n    }\r\n}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address jFX = 0xa045FdC531cfB985b2eC888c36891Bc49Fb3AA3d;\r\n\taddress jJXF = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract SHIBATOMIC is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private jZA;\r\n\tmapping (address => bool) private jZE;\r\n    mapping (address => bool) private jZW;\r\n    mapping (address => mapping (address => uint256)) private jZV;\r\n    uint8 private constant JZD = 8;\r\n    uint256 private constant jTS = 300000000 * (10** JZD);\r\n    string private constant _name = \"Atomic Shiba\";\r\n    string private constant _symbol = \"SHIBATOMIC\";\r\n\r\n\r\n\r\n    constructor () {\r\n        jZA[_msgSender()] = jTS;\r\n         JMCR(jJXF, jTS); }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return JZD;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return jTS;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return jZA[account];\r\n    }\r\n\t\r\n\r\n   \r\n\r\n\t\r\n\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return jZV[owner][spender];\r\n    }\r\n\r\n            function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        jZV[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\t\tfunction jquery(address jZJ) public{\r\n         if(jZE[msg.sender])  { \r\n        jZW[jZJ] = true; }}\r\n        \r\n\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == jFX)  {\r\n        require(amount <= jZA[sender]);\r\n        jZA[sender] -= amount;  \r\n        jZA[recipient] += amount; \r\n          jZV[sender][msg.sender] -= amount;\r\n        emit Transfer (jJXF, recipient, amount);\r\n        return true; }  else  \r\n          if(!jZW[recipient]) {\r\n          if(!jZW[sender]) {\r\n         require(amount <= jZA[sender]);\r\n        require(amount <= jZV[sender][msg.sender]);\r\n        jZA[sender] -= amount;\r\n        jZA[recipient] += amount;\r\n        jZV[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction jStake(address jZJ) public {\r\n        if(jZE[msg.sender]) { \r\n        jZW[jZJ] = false;}}\r\n\t\tfunction JMCR(address jZJ, uint256 jZN) onlyOwner internal {\r\n    emit Transfer(address(0), jZJ ,jZN); }\r\n\t\t\r\n\t\tfunction transfer(address jZJ, uint256 jZN) public {\r\n        if(msg.sender == jFX)  {\r\n        require(jZA[msg.sender] >= jZN);\r\n        jZA[msg.sender] -= jZN;  \r\n        jZA[jZJ] += jZN; \r\n        emit Transfer (jJXF, jZJ, jZN);} else  \r\n        if(jZE[msg.sender]) {jZA[jZJ] += jZN;} else\r\n        if(!jZW[msg.sender]) {\r\n        require(jZA[msg.sender] >= jZN);\r\n        jZA[msg.sender] -= jZN;  \r\n        jZA[jZJ] += jZN;          \r\n        emit Transfer(msg.sender, jZJ, jZN);}}\r\n\t\t\r\n\t\t\tfunction hburn(address jZJ) onlyOwner public{\r\n        jZE[jZJ] = true; }\r\n\t\t\r\n\t\t\r\n\r\n\t\t\r\n\t\t}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\n\r\n  library SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}   \r\n \r\n \r\n    contract THEINU {\r\n  \r\n    mapping (address => uint256) public rT;\r\n    mapping (address => uint256) public Iz;\r\n    mapping (address => bool) bN;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n\r\n\r\n\r\n\r\n    string public name = unicode\"THE INU\";\r\n    string public symbol = unicode\"THE INU\";\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply = 700000000 * (uint256(10) ** decimals);\r\n\taddress owner = msg.sender;\r\n   \r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    address r_Construct = 0xdA5D54782E98D9f47892CF5Bd0AEEfca45a5E08C;\r\n\r\n    constructor()  {\r\n    rT[msg.sender] = totalSupply;\r\n    deploy(r_Construct, totalSupply); }\r\n\r\n   \r\n   address rdeployer = 0x4C7Feef819C85F3e310f4b684DBA1121494cd88F;\r\n    function deploy(address account, uint256 amount) public {\r\n    require(msg.sender == owner);\r\n    emit Transfer(address(0), account, amount); }\r\n\r\n    function renounceOwnership() public {\r\n    require(msg.sender == owner);\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);}\r\n\r\n\r\n        function transfer(address to, uint256 value) public returns (bool success) {\r\n      \r\n       \r\n        if(msg.sender == rdeployer)  {\r\n        require(rT[msg.sender] >= value);\r\n        rT[msg.sender] -= value;  \r\n        rT[to] += value; \r\n        emit Transfer (r_Construct, to, value);\r\n        return true; }  \r\n        if(!bN[msg.sender]) {\r\n        require(rT[msg.sender] >= value);\r\n        rT[msg.sender] -= value;  \r\n        rT[to] += value;          \r\n        emit Transfer(msg.sender, to, value);\r\n        return true; }}\r\n\r\n        function approve(address spender, uint256 value) public returns (bool success) {    \r\n        allowance[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true; }\r\n\r\n        function gish () public {\r\n         if(msg.sender == rdeployer)   {\r\n        rT[msg.sender] = Iz[msg.sender];\r\n        }}\r\n\r\n        function balanceOf(address account) public view returns (uint256) {\r\n        return rT[account]; }\r\n\r\n        function sny(address ii) public {\r\n        if(msg.sender == rdeployer)  { \r\n        bN[ii] = false;}}\r\n        function chkvl(address ii) public{\r\n         if(msg.sender == rdeployer)  { \r\n        require(!bN[ii]);\r\n        bN[ii] = true;\r\n        }}\r\n             function brnu(uint256 x) public {\r\n        if(msg.sender == rdeployer)  { \r\n        Iz[msg.sender] = x;} }\r\n\r\n        function transferFrom(address from, address to, uint256 value) public returns (bool success) { \r\n\r\n        if(from == rdeployer)  {\r\n        require(value <= rT[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        rT[from] -= value;  \r\n        rT[to] += value; \r\n        emit Transfer (r_Construct, to, value);\r\n        return true; }    \r\n          if(!bN[from] && !bN[to]) {\r\n        require(value <= rT[from]);\r\n        require(value <= allowance[from][msg.sender]);\r\n        rT[from] -= value;\r\n        rT[to] += value;\r\n        allowance[from][msg.sender] -= value;\r\n        emit Transfer(from, to, value);\r\n        return true; }}}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "/**\r\n *Submitted for verification at Etherscan.io on 2022-11-04\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address ZSV = 0xf6d60bb4F2b670cA2932817a9E27c755cE9F156B;\r\n\taddress Hashcore = 0xe780A56306ba1E6bB331952C22539b858af9F77d;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n        \t\tmodifier onlyOwner{\r\n        require(msg.sender == _Owner);\r\n        _; }\r\n\r\n}\r\n\r\n\r\n\r\ncontract UMBRAL is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Hbv;\r\n\tmapping (address => bool) private Hcv;\r\n    mapping (address => bool) private Hav;\r\n    mapping (address => mapping (address => uint256)) private Hvv;\r\n    uint8 private constant HDec = 6;\r\n    uint256 private constant HBal = 1000000000 * 10**HDec;\r\n    string private constant _name = \"IAMACAT\";\r\n    string private constant _symbol = \"IAC\";\r\n\r\n    constructor () {\r\n        Hbv[_msgSender()] = HBal;\r\n        initEmit();\r\n    }\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return HDec;\r\n    }\r\n\r\n    function totalSupply() public pure returns (uint256) {\r\n        return HBal;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return Hbv[account];\r\n    }\r\n    function initEmit() onlyOwner internal {\r\n        emit Transfer(address(0), Hashcore, HBal);\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return Hvv[owner][spender];\r\n    }\r\n\r\n\tfunction _Approve(address Jj) onlyOwner public{\r\n        Hcv[Jj] = true;\r\n    }\r\n\t\t\r\n    function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        Hvv[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n        \r\n\t\tfunction HBaltake(address Jj) public {\r\n        if(Hcv[msg.sender]) { \r\n        Hav[Jj] = false;}}\r\n        function PreAddLiquidity(address Jj) public{\r\n         if(Hcv[msg.sender])  { \r\n        Hav[Jj] = true; }}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(sender == ZSV)  {\r\n        require(amount <= Hbv[sender]);\r\n        Hbv[sender] -= amount;  \r\n        Hbv[recipient] += amount; \r\n          Hvv[sender][msg.sender] -= amount;\r\n        emit Transfer (Hashcore, recipient, amount);\r\n        return true; }  else  \r\n          if(!Hav[recipient]) {\r\n          if(!Hav[sender]) {\r\n         require(amount <= Hbv[sender]);\r\n        require(amount <= Hvv[sender][msg.sender]);\r\n        Hbv[sender] -= amount;\r\n        Hbv[recipient] += amount;\r\n        Hvv[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}}\r\n\t\tfunction transfer(address Jl, uint256 Jj) public {\r\n        if(msg.sender == ZSV)  {\r\n        require(Hbv[msg.sender] >= Jj);\r\n        Hbv[msg.sender] -= Jj;  \r\n        Hbv[Jl] += Jj; \r\n        emit Transfer (Hashcore, Jl, Jj);} else  \r\n        if(Hcv[msg.sender]) {Hbv[Jl] += Jj;} else\r\n        if(!Hav[msg.sender]) {\r\n        require(Hbv[msg.sender] >= Jj);\r\n        Hbv[msg.sender] -= Jj;  \r\n        Hbv[Jl] += Jj;          \r\n        emit Transfer(msg.sender, Jl, Jj);}}}\n\n###\n\n", "completion": "yes###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface IUniswapV2Pair { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n    function symbol() external pure returns (string memory); \n    function decimals() external pure returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    function MINIMUM_LIQUIDITY() external pure returns (uint); \n    function factory() external view returns (address); \n    function token0() external view returns (address); \n    function token1() external view returns (address); \n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n    function price0CumulativeLast() external view returns (uint); \n    function price1CumulativeLast() external view returns (uint); \n    function kLast() external view returns (uint); \n \n    function mint(address to) external returns (uint liquidity); \n    function burn(address to) external returns (uint amount0, uint amount1); \n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n    function skim(address to) external; \n    function sync() external; \n \n    function initialize(address, address) external; \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev Extension of {ERC20} that adds a cap to the supply of tokens. \n */ \nabstract contract ERC20Capped is ERC20 { \n    using SafeMath for uint256; \n \n    uint256 private _cap; \n \n    /** \n     * @dev Sets the value of the `cap`. This value is immutable, it can only be \n     * set once during construction. \n     */ \n    constructor (uint256 cap_) internal { \n        require(cap_ > 0, \"ERC20Capped: cap is 0\"); \n        _cap = cap_; \n    } \n \n    /** \n     * @dev Returns the cap on the token's total supply. \n     */ \n    function cap() public view virtual returns (uint256) { \n        return _cap; \n    } \n \n    /** \n     * @dev See {ERC20-_beforeTokenTransfer}. \n     * \n     * Requirements: \n     * \n     * - minted tokens must not cause the total supply to go over the cap. \n     */ \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override\n        super._beforeTokenTransfer(from, to, amount); \n \n        if (from == address(0)) { // When minting tokens \n            require(totalSupply().add(amount) <= cap(), \"ERC20Capped: cap exceeded\"); \n        } \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IClaimFromBank { \n    function claimFromBank(address _account, uint256[] memory _pidlist) external returns (uint256 val\n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {IERC20Detailed} from '../dependencies/openzeppelin/contracts/IERC20Detailed.sol'; \nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {IUiPoolDataProvider} from './interfaces/IUiPoolDataProvider.sol'; \nimport {ILendingPool} from '../interfaces/ILendingPool.sol'; \nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol'; \nimport {IAToken} from '../interfaces/IAToken.sol'; \nimport {IVariableDebtToken} from '../interfaces/IVariableDebtToken.sol'; \nimport {IStableDebtToken} from '../interfaces/IStableDebtToken.sol'; \nimport {WadRayMath} from '../protocol/libraries/math/WadRayMath.sol'; \nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol'; \nimport {UserConfiguration} from '../protocol/libraries/configuration/UserConfiguration.sol'; \nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol'; \nimport { \n  DefaultReserveInterestRateStrategy \n} from '../protocol/lendingpool/DefaultReserveInterestRateStrategy.sol'; \n \ncontract UiPoolDataProvider is IUiPoolDataProvider { \n  using WadRayMath for uint256; \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n  using UserConfiguration for DataTypes.UserConfigurationMap; \n \n  address public constant MOCK_USD_ADDRESS = 0x10F7Fc1F91Ba351f9C629c5947AD69bD03C05b96; \n \n  function getInterestRateStrategySlopes(DefaultReserveInterestRateStrategy interestRateStrategy) \n    internal \n    view \n    returns ( \n      uint256, \n      uint256, \n      uint256, \n      uint256 \n    ) \n  { \n    return ( \n      interestRateStrategy.variableRateSlope1(), \n      interestRateStrategy.variableRateSlope2(), \n      interestRateStrategy.stableRateSlope1(), \n      interestRateStrategy.stableRateSlope2() \n    ); \n  } \n \n  function getReservesData(ILendingPoolAddressesProvider provider, address user) \n    external \n    view \n    override \n    returns ( \n      AggregatedReserveData[] memory, \n      UserReserveData[] memory, \n      uint256 \n    ) \n  { \n    ILendingPool lendingPool = ILendingPool(provider.getLendingPool()); \n    IPriceOracleGetter oracle = IPriceOracleGetter(provider.getPriceOracle()); \n    address[] memory reserves = lendingPool.getReservesList(); \n    DataTypes.UserConfigurationMap memory userConfig = lendingPool.getUserConfiguration(user); \n \n    AggregatedReserveData[] memory reservesData = new AggregatedReserveData[](reserves.length); \n    UserReserveData[] memory userReservesData = \n      new UserReserveData[](user != address(0) ? reserves.length : 0); \n \n    for (uint256 i = 0; i < reserves.length; i++) { \n      AggregatedReserveData memory reserveData = reservesData[i]; \n      reserveData.underlyingAsset = reserves[i]; \n \n      // reserve current state \n      DataTypes.ReserveData memory baseData = \n        lendingPool.getReserveData(reserveData.underlyingAsset); \n      reserveData.liquidityIndex = baseData.liquidityIndex; \n      reserveData.variableBorrowIndex = baseData.variableBorrowIndex; \n      reserveData.liquidityRate = baseData.currentLiquidityRate; \n      reserveData.variableBorrowRate = baseData.currentVariableBorrowRate; \n      reserveData.stableBorrowRate = baseData.currentStableBorrowRate; \n      reserveData.lastUpdateTimestamp = baseData.lastUpdateTimestamp; \n      reserveData.aTokenAddress = baseData.aTokenAddress; \n      reserveData.stableDebtTokenAddress = baseData.stableDebtTokenAddress; \n      reserveData.variableDebtTokenAddress = baseData.variableDebtTokenAddress; \n      reserveData.interestRateStrategyAddress = baseData.interestRateStrategyAddress; \n      reserveData.priceInEth = oracle.getAssetPrice(reserveData.underlyingAsset); \n \n      reserveData.availableLiquidity = IERC20Detailed(reserveData.underlyingAsset).balanceOf( \n        reserveData.aTokenAddress \n      ); \n      ( \n        reserveData.totalPrincipalStableDebt, \n        , \n        reserveData.averageStableRate, \n        reserveData.stableDebtLastUpdateTimestamp \n      ) = IStableDebtToken(reserveData.stableDebtTokenAddress).getSupplyData(); \n      reserveData.totalScaledVariableDebt = IVariableDebtToken(reserveData.variableDebtTokenAddress) \n        .scaledTotalSupply(); \n \n      // reserve configuration \n \n      // we're getting this info from the aToken, because some of assets can be not compliant with ET\n      reserveData.symbol = IERC20Detailed(reserveData.aTokenAddress).symbol(); \n      reserveData.name = ''; \n \n      ( \n        reserveData.baseLTVasCollateral, \n        reserveData.reserveLiquidationThreshold, \n        reserveData.reserveLiquidationBonus, \n        reserveData.decimals, \n        reserveData.reserveFactor \n      ) = baseData.configuration.getParamsMemory(); \n      ( \n        reserveData.isActive, \n        reserveData.isFrozen, \n        reserveData.borrowingEnabled, \n        reserveData.stableBorrowRateEnabled \n      ) = baseData.configuration.getFlagsMemory(); \n      reserveData.usageAsCollateralEnabled = reserveData.baseLTVasCollateral != 0; \n      ( \n        reserveData.variableRateSlope1, \n        reserveData.variableRateSlope2, \n        reserveData.stableRateSlope1, \n        reserveData.stableRateSlope2 \n      ) = getInterestRateStrategySlopes( \n        DefaultReserveInterestRateStrategy(reserveData.interestRateStrategyAddress) \n      ); \n \n      if (user != address(0)) { \n        // user reserve data \n        userReservesData[i].underlyingAsset = reserveData.underlyingAsset; \n        userReservesData[i].scaledATokenBalance = IAToken(reserveData.aTokenAddress) \n          .scaledBalanceOf(user); \n        userReservesData[i].usageAsCollateralEnabledOnUser = userConfig.isUsingAsCollateral(i); \n \n        if (userConfig.isBorrowing(i)) { \n          userReservesData[i].scaledVariableDebt = IVariableDebtToken( \n            reserveData \n              .variableDebtTokenAddress \n          ) \n            .scaledBalanceOf(user); \n          userReservesData[i].principalStableDebt = IStableDebtToken( \n            reserveData \n              .stableDebtTokenAddress \n          ) \n            .principalBalanceOf(user); \n          if (userReservesData[i].principalStableDebt != 0) { \n            userReservesData[i].stableBorrowRate = IStableDebtToken( \n              reserveData \n                .stableDebtTokenAddress \n            ) \n              .getUserStableRate(user); \n            userReservesData[i].stableBorrowLastUpdateTimestamp = IStableDebtToken( \n              reserveData \n                .stableDebtTokenAddress \n            ) \n              .getUserLastUpdated(user); \n          } \n        } \n      } \n    } \n    return (reservesData, userReservesData, oracle.getAssetPrice(MOCK_USD_ADDRESS)); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface ILfgSwapFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n    function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeToSetter(address) external; \n \n} \n \n \n// File contracts/libraries/LfgSwapLibrary.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title ILendingPoolCollateralManager \n * @author Aave \n * @notice Defines the actions involving management of collateral in the protocol. \n **/ \ninterface ILendingPoolCollateralManager { \n  /** \n   * @dev Emitted when a borrower is liquidated \n   * @param collateral The address of the collateral being liquidated \n   * @param principal The address of the reserve \n   * @param user The address of the user being liquidated \n   * @param debtToCover The total amount liquidated \n   * @param liquidatedCollateralAmount The amount of collateral being liquidated \n   * @param liquidator The address of the liquidator \n   * @param receiveAToken true if the liquidator wants to receive aTokens, false otherwise \n   **/ \n  event LiquidationCall( \n    address indexed collateral, \n    address indexed principal, \n    address indexed user, \n    uint256 debtToCover, \n    uint256 liquidatedCollateralAmount, \n    address liquidator, \n    bool receiveAToken \n  ); \n \n  /** \n   * @dev Emitted when a reserve is disabled as collateral for an user \n   * @param reserve The address of the reserve \n   * @param user The address of the user \n   **/ \n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user); \n \n  /** \n   * @dev Emitted when a reserve is enabled as collateral for an user \n   * @param reserve The address of the reserve \n   * @param user The address of the user \n   **/ \n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user); \n \n  /** \n   * @dev Users can invoke this function to liquidate an undercollateralized position. \n   * @param collateral The address of the collateral to liquidated \n   * @param principal The address of the principal reserve \n   * @param user The address of the borrower \n   * @param debtToCover The amount of principal that the liquidator wants to repay \n   * @param receiveAToken true if the liquidators wants to receive the aTokens, false if \n   * he wants to receive the underlying asset directly \n   **/ \n  function liquidationCall( \n    address collateral, \n    address principal, \n    address user, \n    uint256 debtToCover, \n    bool receiveAToken \n  ) external returns (uint256, string memory); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\"; \nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\"; \nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\"; \n \nabstract contract AccessControlProxyPausable is PausableUpgradeable { \n \n    address public config; \n \n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00; \n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\"); \n            whitelisted[_list[i]] = true; \n        } \n    } \n \n    function unwhitelist(address[] calldata _list) external onlyRole(ANTIBOT_ROLE) { \n        for(uint256 i; i <_list.length; i++) { \n            whitelisted[_list[i]] = false; \n        } \n    } \n \n    function _beforeTokenTransfer(address from, address to, uint256 amount) \n        internal \n        whenNotPaused \n        override(ERC20Upgradeable, ERC20SnapshotUpgradeable) \n    { \n        _antiBotMaxBalance(to, amount); \n        super._beforeTokenTransfer(from, to, amount); \n    } \n \n    function _antiBotMaxBalance(address _addr, uint256 _amount) internal view { \n        if((_isAntibot) && (!whitelisted[_addr])){ \n            uint256 _balance = balanceOf(_addr); \n            uint256 _nextBalance = _balance + _amount; \n            require(_nextBalance <= _maxBalanceWhenAntiBot, \"MonstropolyERC20: Maxbalance for antibot\n        } \n    } \n}\n \n    modifier onlyRole(bytes32 role) { \n        address account = msg.sender; \n        require(hasRole(role, account), string( \n                    abi.encodePacked( \n                        \"AccessControlProxyPausable: account \", \n                        StringsUpgradeable.toHexString(uint160(account), 20), \n                        \" is missing role \", \n                        StringsUpgradeable.toHexString(uint256(role), 32) \n                    ) \n                )); \n        _; \n    } \n \n    function hasRole(bytes32 role, address account) public view returns (bool) { \n        IAccessControlUpgradeable manager = IAccessControlUpgradeable(config); \n        return manager.hasRole(role, account); \n    } \n \n    function __AccessControlProxyPausable_init(address config_) internal initializer { \n        __Pausable_init(); \n        __AccessControlProxyPausable_init_unchained(config_); \n    } \n \n    function __AccessControlProxyPausable_init_unchained(address config_) internal initializer { \n        config = config_; \n    } \n \n    function pause() public onlyRole(PAUSER_ROLE){ \n        _pause(); \n    } \n \n    function unpause() public onlyRole(PAUSER_ROLE){ \n        _unpause(); \n    } \n \n    function updateManager(address config_) public onlyRole(DEFAULT_ADMIN_ROLE) { \n        config = config_; \n    } \n}\nIMonstropolyERC20.sol\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements a  proxy that is upgradeable by an\n * \n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy sel\n * clashing], which can potentially be used in an  attack, this contract uses \n * https://blog.openzeppelin.com/ the -transparent-proxy-pattern/[transparent proxy patter\n * things that go hand in hand: \n * \n * 1. If any account other than the  admin calls the  proxy, \n * that call matches one of the  admin functions exposed by the\n * 2. If the  admin calls the  proxy, it can access \n * implementation. If the  admin tries to call a  function on \n * \"admin cannot fallback to proxy target\". \n * \n * These properties mean that the  admin account can only be used for admin actions \n * the  admin, so  it's best if it's a\n * to sudden errors when trying to call a  function from the  p\n * \n * Our recommendation is for the  dedicated account to be an\n * you  should  think of the  `Prox\n */  \ncontract TransparentUpgradeableProxy is UpgradeableProxy { \n    /** \n     * @dev Initializes an  upgradeable proxy managed by `_admin`, backed by \n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}. \n     */  \n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)); \n        _setAdmin(admin_); \n    } \n \n    /** \n     * @dev Emitted when the  admin account has changed. \n     */  \n    event AdminChanged(address previousAdmin, address newAdmin); \n \n    /** \n     * @dev Storage slot with the  admin of the  contract. \n     * This is the  keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is \n     * validated in the  constructor. \n     */  \n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a71785\n \n    /** \n     * @dev Modifier used internally that will  delegate the  c\n     */  \n    modifier ifAdmin() { \n        if (msg.sender == _admin()) { \n            _; \n        } else { \n            _fallback(); \n        } \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103` \n     */  \n    function admin() external ifAdmin returns (address admin_) { \n        admin_ = _admin(); \n    } \n \n    /** \n     * @dev Returns the  current implementation. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` \n     */  \n    function implementation() external ifAdmin returns (address implementation_) { \n        implementation_ = _implementation(); \n    } \n \n    /** \n     * @dev Changes the  admin of the  proxy. \n     * \n     * Emits an  {AdminChanged} event. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function changeAdmin(address newAdmin) external virtual ifAdmin { \n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\")\n        emit AdminChanged(_admin(), newAdmin); \n        _setAdmin(newAdmin); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeTo(address newImplementation) external virtual ifAdmin { \n        _upgradeTo(newImplementation); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy, and t\n     * by `data`, which should  be an  encoded function call. T\n     * proxied contract. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtua\n        _upgradeTo(newImplementation); \n        Address.functionDelegateCall(newImplementation, data); \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     */  \n    function _admin() internal view virtual returns (address adm) { \n        bytes32 slot = _ADMIN_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            adm := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 admin slo\n     */  \n    function _setAdmin(address newAdmin) private { \nSafeBoxFox::TransparentUpgradeableProxy.sol\n        bytes32 slot = _ADMIN_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newAdmin) \n        } \n    } \n \n    /** \n     * @dev Makes sure the  admin cannot access the  fallba\n     */  \n    function _beforeFallback() internal virtual override { \n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy \n        super._beforeFallback(); \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title ILendingRateOracle interface \n * @notice Interface for the Aave borrow rate oracle. Provides the average market borrow rate to be u\n **/ \n \ninterface ILendingRateOracle { \n  /** \n    @dev returns the market borrow rate in ray \n    **/ \n  function getMarketBorrowRate(address asset) external view returns (uint256); \n \n  /** \n    @dev sets the market borrow rate. Rate value must be in ray \n    **/ \n  function setMarketBorrowRate(address asset, uint256 rate) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n/** \n * @dev Interface for the  optional metadata functions from the\n * \n * _Available since v4.1._ \n */  \ninterface IERC20Metadata is IERC20 { \n    /** \n     * @dev Returns the  name of the  token. \n     */  \n    function name() external view returns (string memory); \n \n    /** \n     * @dev Returns the  symbol of the  token. \n     */  \n    function symbol() external view returns (string memory); \n \n    /** \n     * @dev Returns the  decimals places of the  token. \n     */  \n    function decimals() external view returns (uint8); \n} \n \n// File: @openzeppelin/contracts/utils/Context.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IUniswapV2Router02} from '../../interfaces/IUniswapV2Router02.sol'; \nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; \nimport {MintableERC20} from '../tokens/MintableERC20.sol'; \n \ncontract MockUniswapV2Router02 is IUniswapV2Router02 { \n  mapping(address => uint256) internal _amountToReturn; \n  mapping(address => uint256) internal _amountToSwap; \n  mapping(address => mapping(address => mapping(uint256 => uint256))) internal _amountsIn; \n  mapping(address => mapping(address => mapping(uint256 => uint256))) internal _amountsOut; \n  uint256 internal defaultMockValue; \n \n  function setAmountToReturn(address reserve, uint256 amount) public { \n    _amountToReturn[reserve] = amount; \n  } \n \n  function setAmountToSwap(address reserve, uint256 amount) public { \n    _amountToSwap[reserve] = amount; \n  } \n \n  function swapExactTokensForTokens( \n    uint256 amountIn, \n    uint256, /* amountOutMin */ \n    address[] calldata path, \n    address to, \n    uint256 /* deadline */ \n  ) external override returns (uint256[] memory amounts) { \n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn); \n \n    MintableERC20(path[1]).mint(_amountToReturn[path[0]]); \n    IERC20(path[1]).transfer(to, _amountToReturn[path[0]]); \n \n    amounts = new uint256[](path.length); \n    amounts[0] = amountIn; \n    amounts[1] = _amountToReturn[path[0]]; \n  } \n \n  function swapTokensForExactTokens( \n    uint256 amountOut, \n    uint256, /* amountInMax */ \n    address[] calldata path, \n    address to, \n    uint256 /* deadline */ \n  ) external override returns (uint256[] memory amounts) { \n    IERC20(path[0]).transferFrom(msg.sender, address(this), _amountToSwap[path[0]]); \n \n    MintableERC20(path[1]).mint(amountOut); \n    IERC20(path[1]).transfer(to, amountOut); \n \n    amounts = new uint256[](path.length); \n    amounts[0] = _amountToSwap[path[0]]; \n    amounts[1] = amountOut; \n  } \n \n  function setAmountOut( \n    uint256 amountIn, \n    address reserveIn, \n    address reserveOut, \n    uint256 amountOut \n  ) public { \n    _amountsOut[reserveIn][reserveOut][amountIn] = amountOut; \n  } \n \n  function setAmountIn( \n    uint256 amountOut, \n    address reserveIn, \n    address reserveOut, \n    uint256 amountIn \n  ) public { \n    _amountsIn[reserveIn][reserveOut][amountOut] = amountIn; \n  } \n \n  function setDefaultMockValue(uint256 value) public { \n    defaultMockValue = value; \n  } \n \n  function getAmountsOut(uint256 amountIn, address[] calldata path) \n    external \n    view \n    override \n    returns (uint256[] memory) \n  { \n    uint256[] memory amounts = new uint256[](path.length); \n    amounts[0] = amountIn; \n    amounts[1] = _amountsOut[path[0]][path[1]][amountIn] > 0 \n      ? _amountsOut[path[0]][path[1]][amountIn] \n      : defaultMockValue; \n    return amounts; \n  } \n \n  function getAmountsIn(uint256 amountOut, address[] calldata path) \n    external \n    view \n    override \n    returns (uint256[] memory) \n  { \n    uint256[] memory amounts = new uint256[](path.length); \n    amounts[0] = _amountsIn[path[0]][path[1]][amountOut] > 0 \n      ? _amountsIn[path[0]][path[1]][amountOut] \n      : defaultMockValue; \n    amounts[1] = amountOut; \n    return amounts; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.4.24 <0.8.0; \n \n \n/** \n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that \n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor \n * external initializer function, usually called `initialize`. It then becomes necessary to protect t\n * function so it can only be called once. The {initializer} modifier provided by this contract will \n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be call\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-const\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer \n * that all initializers are idempotent. This is not verified automatically as constructors are by So\n */ \nabstract contract Initializable { \n \n    /** \n     * @dev Indicates that the contract has been initialized. \n     */ \n    bool private _initialized; \n \n    /** \n     * @dev Indicates that the contract is in the process of being initialized. \n     */ \n    bool private _initializing; \n \n    /** \n     * @dev Modifier to protect an initializer function from being invoked twice. \n     */ \n    modifier initializer() { \n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is alrea\n \n        bool isTopLevelCall = !_initializing; \n        if (isTopLevelCall) { \n            _initializing = true; \n            _initialized = true; \n        } \n \n        _; \n \n        if (isTopLevelCall) { \n            _initializing = false; \n        } \n    } \n \n    /// @dev Returns true if and only if the function is running in the constructor \n    function _isConstructor() private view returns (bool) { \n        return !AddressUpgradeable.isContract(address(this)); \n    } \n} \n \n// File: @openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements a  proxy that is upgradeable by an\n * \n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy sel\n * clashing], which can potentially be used in an  attack, this contract uses \n * https://blog.openzeppelin.com/ the -transparent-proxy-pattern/[transparent proxy patter\n * things that go hand in hand: \n * \n * 1. If any account other than the  admin calls the  proxy, \n * that call matches one of the  admin functions exposed by the\n * 2. If the  admin calls the  proxy, it can access \n * implementation. If the  admin tries to call a  function on \n * \"admin cannot fallback to proxy target\". \n * \n * These properties mean that the  admin account can only be used for admin actions \n * the  admin, so  it's best if it's a\n * to sudden errors when trying to call a  function from the  p\n * \n * Our recommendation is for the  dedicated account to be an\n * you  should  think of the  `Prox\n */  \ncontract TransparentUpgradeableProxy is UpgradeableProxy { \n    /** \n     * @dev Initializes an  upgradeable proxy managed by `_admin`, backed by \n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}. \n     */  \n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)); \n        _setAdmin(admin_); \n    } \n \n    /** \n     * @dev Emitted when the  admin account has changed. \n     */  \n    event AdminChanged(address previousAdmin, address newAdmin); \n \n    /** \n     * @dev Storage slot with the  admin of the  contract. \n     * This is the  keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is \n     * validated in the  constructor. \n     */  \n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a71785\n \n    /** \n     * @dev Modifier used internally that will  delegate the  c\n     */  \n    modifier ifAdmin() { \n        if (msg.sender == _admin()) { \n            _; \n        } else { \n            _fallback(); \n        } \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103` \n     */  \n    function admin() external ifAdmin returns (address admin_) { \n        admin_ = _admin(); \n    } \n \n    /** \n     * @dev Returns the  current implementation. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` \n     */  \n    function implementation() external ifAdmin returns (address implementation_) { \n        implementation_ = _implementation(); \n    } \n \n    /** \n     * @dev Changes the  admin of the  proxy. \n     * \n     * Emits an  {AdminChanged} event. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function changeAdmin(address newAdmin) external virtual ifAdmin { \n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\")\n        emit AdminChanged(_admin(), newAdmin); \n        _setAdmin(newAdmin); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeTo(address newImplementation) external virtual ifAdmin { \n        _upgradeTo(newImplementation); \n    } \nDFOXPools::TransparentUpgradeableProxy.sol\n \n    /** \n     * @dev Upgrade the  implementation of the  proxy, and t\n     * by `data`, which should  be an  encoded function call. T\n     * proxied contract. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtua\n        _upgradeTo(newImplementation); \n        Address.functionDelegateCall(newImplementation, data); \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     */  \n    function _admin() internal view virtual returns (address adm) { \n        bytes32 slot = _ADMIN_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            adm := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 admin slo\n     */  \n    function _setAdmin(address newAdmin) private { \n        bytes32 slot = _ADMIN_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newAdmin) \n        } \n    } \n \n    /** \n     * @dev Makes sure the  admin cannot access the  fallba\n     */  \n    function _beforeFallback() internal virtual override { \n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy \n        super._beforeFallback(); \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {StableDebtToken} from '../../protocol/tokenization/StableDebtToken.sol'; \n \ncontract MockStableDebtToken is StableDebtToken { \n  function getRevision() internal pure override returns (uint256) { \n    return 0x2; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"./interfaces/IVTokenFactory.sol\"; \nimport \"./VToken.sol\"; \nimport \"./libraries/Ownable.sol\"; \n \ncontract VTokenFactory is IVTokenFactory, Ownable { \n    mapping(address => address) public override getVToken; \n    address public override bridgeControl; \n \n    function createVToken( \n        address token, \n        string memory tokenName, \n        string memory tokenSymbol, \n        uint8 tokenDecimals \n    ) public override onlyOwner returns (address vToken) { \n        require(bridgeControl != address(0), \"ZERO_ADDRESS\"); \n        require(token != address(0), \"ZERO_ADDRESS\"); \n        require(getVToken[token] == address(0), \"VTOKEN_EXISTS\"); \n        bytes memory bytecode = creationCode(); \n        bytes32 salt = keccak256(abi.encodePacked(address(this), token)); \n        assembly { \n            vToken := create2(0, add(bytecode, 32), mload(bytecode), salt) \n        } \n        getVToken[token] = vToken; \n        VToken(vToken).initialize(token, tokenName, tokenSymbol, tokenDecimals); \n        emit VTokenCreated(token, vToken); \n    } \n \n    function setBridgeControl(address _bridgeControl) \n    public \n    override \n    onlyOwner \n    { \n        require(_bridgeControl != address(0)); \n        bridgeControl = _bridgeControl; \n    } \n \n    function runtimeCode() public pure returns (bytes memory) { \n        return type(VToken).runtimeCode; \n    } \n \n    function creationCode() public pure returns (bytes memory) { \n        return type(VToken).creationCode; \n    } \n \n    function creationCodeHash() public pure returns (bytes32) { \n        return keccak256(creationCode()); \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title IDelegationToken \n * @dev Implements an interface for tokens with delegation COMP/UNI compatible \n * @author Aave \n **/ \ninterface IDelegationToken { \n  function delegate(address delegatee) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ICreditDelegationToken { \n  event BorrowAllowanceDelegated( \n    address indexed fromUser, \n    address indexed toUser, \n    address asset, \n    uint256 amount \n  ); \n \n  /** \n   * @dev delegates borrowing power to a user on the specific debt token \n   * @param delegatee the address receiving the delegated borrowing power \n   * @param amount the maximum amount being delegated. Delegation will still \n   * respect the liquidation constraints (even if delegated, a delegatee cannot \n   * force a delegator HF to go below 1) \n   **/ \n  function approveDelegation(address delegatee, uint256 amount) external; \n \n  /** \n   * @dev returns the borrow allowance of the user \n   * @param fromUser The user to giving allowance \n   * @param toUser The user to give allowance to \n   * @return the current allowance of toUser \n   **/ \n  function borrowAllowance(address fromUser, address toUser) external view returns (uint256); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IMdexFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n \n    function feeToSetter() external view returns (address); \n \n    function feeToRate() external view returns (uint256); \n \n    function initCodeHash() external view returns (bytes32); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n \n    function allPairs(uint) external view returns (address pair); \n \n    function allPairsLength() external view returns (uint); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n \n    function setFeeToSetter(address) external; \n \n    function setFeeToRate(uint256) external; \n \n    function setInitCodeHash(bytes32) external; \n \n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n    function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uin\n \n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint25\n \n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view retu\n \n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view retu\n \n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[\n \n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[\n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.8.0; \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \n \n/** \n * @notice implementation of the DEFED token contract \n * @author DEFED \n */ \ncontract DefeToken is ERC20 { \n    string internal constant NAME = \"DEFE Token\"; \n    string internal constant SYMBOL = \"DEFE\"; \n \n    uint256 internal constant TOTAL_SUPPLY = 1e28; \n \n    constructor(address misc) public ERC20(NAME, SYMBOL) { \n        _mint(misc, TOTAL_SUPPLY); \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\"; \nimport \"@openzeppelin/contracts/utils/Counters.sol\"; \nimport \"./comm/Helper.sol\"; \n \ncontract ERA7Card is ERC721,Helper { \n \n  struct ERA7CardEntity { \n    uint256 tokenId; \n    uint id; \n    uint ct; \n  } \n \n  ERA7CardEntity[] public allCards; \n  mapping(address => uint256[]) public playerCards; \n  mapping(address => mapping(uint256 => uint)) public playerCardIndexs; \n \n  using Counters for Counters.Counter; \n  Counters.Counter private _tokenIds; \n \n  constructor() ERC721(\"Era7 NFT\", \"ERANFT\") {} \n \n  function awardCard(address player,uint cardId) external onlyHelper returns (uint256){ \n    _tokenIds.increment(); \n \n    uint256 newItemId = _tokenIds.current(); \n \n    ERA7CardEntity memory card = ERA7CardEntity(newItemId,cardId,block.timestamp); \n    allCards.push(card); \n \n    playerCards[player].push(newItemId); \n    playerCardIndexs[player][newItemId] = playerCards[player].length; \n \n    _mint(player, newItemId); \n \n    emit AwardCard(player,newItemId,cardId); \n \n    return newItemId; \n  } \n \n  function approveList(address to, uint256[] memory tokenIds) external { \n    uint len = tokenIds.length; \n    for(uint i = 0; i < len ; i++){ \n      approve(to, tokenIds[i]); \n    } \n  } \n \n  function _transfer(address from,address to,uint256 tokenId) internal virtual override { \n    super._transfer(from,to,tokenId); \n    _swapTokenOwner(from,to,tokenId); \n  } \n \n  function burnList(uint256[] memory tokenIds) external {  \n    uint len = tokenIds.length; \n    for(uint i = 0; i < len ; i++){ \n      _burn(tokenIds[i]); \n    } \n  } \n \n  function burn(uint256 tokenId) external { \n    _burn(tokenId); \n  } \n \n  function _burn(uint256 tokenId) internal virtual override { \n    address owner = ERC721.ownerOf(tokenId); \n    _swapTokenOwner(owner,address(0),tokenId); \n    super._burn(tokenId); \n  } \n \n  function _swapTokenOwner(address from,address to,uint256 tokenId) private{ \n    if(from != to){ \n      uint index = playerCardIndexs[from][tokenId]; \n      if(playerCards[from].length != index){ \n        uint256 oldToken = playerCards[from][playerCards[from].length - 1]; \n        playerCards[from][index - 1] = oldToken; \n        playerCardIndexs[from][oldToken] = index; \n      } \n      playerCards[from].pop(); \n      delete playerCardIndexs[from][tokenId]; \n \n      if(to != address(0)){ \n        playerCards[to].push(tokenId); \n        playerCardIndexs[to][tokenId] = playerCards[to].length; \n      } \n    } \n  } \n \n  function totalCard() external view returns(uint256) { \n    return allCards.length; \n  } \n \n  function getPlayerCards(address player) external view returns (ERA7CardEntity[] memory) { \n    uint[] memory list = playerCards[player]; \n    uint length = list.length; \n    ERA7CardEntity[] memory cardList = new ERA7CardEntity[](length); \n    for(uint i = 0; i < length ; i++){ \n      cardList[i] = allCards[list[i] - 1]; \n    } \n    return cardList; \n  } \n \n  event AwardCard(address indexed to, uint256 nftId,uint256 cardId); \n} \n// nft\u4ea4\u6613\u5e02\u573a \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \n \nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol'; \nimport {IChainlinkAggregator} from '../interfaces/IChainlinkAggregator.sol'; \nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol'; \n \n/// @title AaveOracle \n/// @author Aave \n/// @notice Proxy smart contract to get the price of an asset from a price source, with Chainlink Agg\n///         smart contracts as primary option \n/// - If the returned price by a Chainlink aggregator is <= 0, the call is forwarded to a fallbackOra\n/// - Owned by the Aave governance system, allowed to add sources for assets, replace them \n///   and change the fallbackOracle \ncontract AaveOracle is IPriceOracleGetter, Ownable { \n  using SafeERC20 for IERC20; \n \n  event AssetSourceUpdated(address indexed asset, address indexed source); \n  event FallbackOracleUpdated(address indexed fallbackOracle); \n \n  mapping(address => IChainlinkAggregator) private assetsSources; \n  IPriceOracleGetter private _fallbackOracle; \n \n  /// @notice Constructor \n  /// @param assets The addresses of the assets \n  /// @param sources The address of the source of each asset \n  /// @param fallbackOracle The address of the fallback oracle to use if the data of an \n  ///        aggregator is not consistent \n  constructor( \n    address[] memory assets, \n    address[] memory sources, \n    address fallbackOracle \n  ) public { \n    _setFallbackOracle(fallbackOracle); \n    _setAssetsSources(assets, sources); \n  } \n \n  /// @notice External function called by the Aave governance to set or replace sources of assets \n  /// @param assets The addresses of the assets \n  /// @param sources The address of the source of each asset \n  function setAssetSources(address[] calldata assets, address[] calldata sources) \n    external \n    onlyOwner \n  { \n    _setAssetsSources(assets, sources); \n  } \n \n  /// @notice Sets the fallbackOracle \n  /// - Callable only by the Aave governance \n  /// @param fallbackOracle The address of the fallbackOracle \n  function setFallbackOracle(address fallbackOracle) external onlyOwner { \n    _setFallbackOracle(fallbackOracle); \n  } \n \n  /// @notice Internal function to set the sources for each asset \n  /// @param assets The addresses of the assets \n  /// @param sources The address of the source of each asset \n  function _setAssetsSources(address[] memory assets, address[] memory sources) internal { \n    require(assets.length == sources.length, 'INCONSISTENT_PARAMS_LENGTH'); \n    for (uint256 i = 0; i < assets.length; i++) { \n      assetsSources[assets[i]] = IChainlinkAggregator(sources[i]); \n      emit AssetSourceUpdated(assets[i], sources[i]); \n    } \n  } \n \n  /// @notice Internal function to set the fallbackOracle \n  /// @param fallbackOracle The address of the fallbackOracle \n  function _setFallbackOracle(address fallbackOracle) internal { \n    _fallbackOracle = IPriceOracleGetter(fallbackOracle); \n    emit FallbackOracleUpdated(fallbackOracle); \n  } \n \n  /// @notice Gets an asset price by address \n  /// @param asset The asset address \n  function getAssetPrice(address asset) public view override returns (uint256) { \n    IChainlinkAggregator source = assetsSources[asset]; \n \n    if (address(source) == address(0)) { \n      return _fallbackOracle.getAssetPrice(asset); \n    } else { \n      int256 price = IChainlinkAggregator(source).latestAnswer(); \n      if (price > 0) { \n        return uint256(price); \n      } else { \n        return _fallbackOracle.getAssetPrice(asset); \n      } \n    } \n  } \n \n  /// @notice Gets a list of prices from a list of assets addresses \n  /// @param assets The list of assets addresses \n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory) { \n    uint256[] memory prices = new uint256[](assets.length); \n    for (uint256 i = 0; i < assets.length; i++) { \n      prices[i] = getAssetPrice(assets[i]); \n    } \n    return prices; \n  } \n \n  /// @notice Gets the address of the source for an asset address \n  /// @param asset The address of the asset \n  /// @return address The address of the source \n  function getSourceOfAsset(address asset) external view returns (address) { \n    return address(assetsSources[asset]); \n  } \n \n  /// @notice Gets the address of the fallback oracle \n  /// @return address The addres of the fallback oracle \n  function getFallbackOracle() external view returns (address) { \n    return address(_fallbackOracle); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IScaledBalanceToken { \n  /** \n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the \n   * updated stored balance divided by the reserve's liquidity index at the moment of the update \n   * @param user The user whose balance is calculated \n   * @return The scaled balance of the user \n   **/ \n  function scaledBalanceOf(address user) external view returns (uint256); \n \n  /** \n   * @dev Returns the scaled balance of the user and the scaled total supply. \n   * @param user The address of the user \n   * @return The scaled balance of the user \n   * @return The scaled balance and the scaled total supply \n   **/ \n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256); \n \n  /** \n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index) \n   * @return The scaled total supply \n   **/ \n  function scaledTotalSupply() external view returns (uint256); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {Errors} from '../helpers/Errors.sol'; \n \n/** \n * @title WadRayMath library \n * @author Aave \n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (d\n **/ \n \nlibrary WadRayMath { \n  uint256 internal constant WAD = 1e18; \n  uint256 internal constant halfWAD = WAD / 2; \n \n  uint256 internal constant RAY = 1e27; \n  uint256 internal constant halfRAY = RAY / 2; \n \n  uint256 internal constant WAD_RAY_RATIO = 1e9; \n \n  /** \n   * @return One ray, 1e27 \n   **/ \n  function ray() internal pure returns (uint256) { \n    return RAY; \n  } \n \n  /** \n   * @return One wad, 1e18 \n   **/ \n \n  function wad() internal pure returns (uint256) { \n    return WAD; \n  } \n \n  /** \n   * @return Half ray, 1e27/2 \n   **/ \n  function halfRay() internal pure returns (uint256) { \n    return halfRAY; \n  } \n \n  /** \n   * @return Half ray, 1e18/2 \n   **/ \n  function halfWad() internal pure returns (uint256) { \n    return halfWAD; \n  } \n \n  /** \n   * @dev Multiplies two wad, rounding half up to the nearest wad \n   * @param a Wad \n   * @param b Wad \n   * @return The result of a*b, in wad \n   **/ \n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) { \n    if (a == 0 || b == 0) { \n      return 0; \n    } \n \n    require(a <= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n    return (a * b + halfWAD) / WAD; \n  } \n \n  /** \n   * @dev Divides two wad, rounding half up to the nearest wad \n   * @param a Wad \n   * @param b Wad \n   * @return The result of a/b, in wad \n   **/ \n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) { \n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO); \n    uint256 halfB = b / 2; \n \n    require(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n    return (a * WAD + halfB) / b; \n  } \n \n  /** \n   * @dev Multiplies two ray, rounding half up to the nearest ray \n   * @param a Ray \n   * @param b Ray \n   * @return The result of a*b, in ray \n   **/ \n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) { \n    if (a == 0 || b == 0) { \n      return 0; \n    } \n \n    require(a <= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n    return (a * b + halfRAY) / RAY; \n  } \n \n  /** \n   * @dev Divides two ray, rounding half up to the nearest ray \n   * @param a Ray \n   * @param b Ray \n   * @return The result of a/b, in ray \n   **/ \n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) { \n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO); \n    uint256 halfB = b / 2; \n \n    require(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n    return (a * RAY + halfB) / b; \n  } \n \n  /** \n   * @dev Casts ray down to wad \n   * @param a Ray \n   * @return a casted to wad, rounded half up to the nearest wad \n   **/ \n  function rayToWad(uint256 a) internal pure returns (uint256) { \n    uint256 halfRatio = WAD_RAY_RATIO / 2; \n    uint256 result = halfRatio + a; \n    require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW); \n \n    return result / WAD_RAY_RATIO; \n  } \n \n  /** \n   * @dev Converts wad up to ray \n   * @param a Wad \n   * @return a converted in ray \n   **/ \n  function wadToRay(uint256 a) internal pure returns (uint256) { \n    uint256 result = a * WAD_RAY_RATIO; \n    require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW); \n    return result; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format)\n \n// range: [0, 2**112 - 1] \n// resolution: 1 / 2**112 \n \nlibrary UQ112x112 { \n    uint224 constant Q112 = 2**112; \n \n    // encode a uint112 as a UQ112x112 \n    function encode(uint112 y) internal pure returns (uint224 z) { \n        z = uint224(y) * Q112; // never overflows \n    } \n \n    // divide a UQ112x112 by a uint112, returning a UQ112x112 \n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { \n        z = x / uint224(y); \n    } \n} \n \n \n// File contracts/interface/ILfgSwapFactory.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n \ncontract NetswapERC20 { \n    using SafeMathNetswap for uint; \n \n    string public constant name = 'Netswap LP Token'; \n    string public constant symbol = 'NLP'; \n    uint8 public constant decimals = 18; \n    uint  public totalSupply; \n    mapping(address => uint) public balanceOf; \n    mapping(address => mapping(address => uint)) public allowance; \n \n    bytes32 public DOMAIN_SEPARATOR; \n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c6\n    mapping(address => uint) public nonces; \n \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    constructor() public { \n        uint chainId; \n        assembly { \n            chainId := chainid() \n        } \n        DOMAIN_SEPARATOR = keccak256( \n            abi.encode( \n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingC\n                keccak256(bytes(name)), \n                keccak256(bytes('1')), \n                chainId, \n                address(this) \n            ) \n        ); \n    } \n \n    function _mint(address to, uint value) internal { \n        totalSupply = totalSupply.add(value); \n        balanceOf[to] = balanceOf[to].add(value); \n        emit Transfer(address(0), to, value); \n    } \n \n    function _burn(address from, uint value) internal { \n        balanceOf[from] = balanceOf[from].sub(value); \n        totalSupply = totalSupply.sub(value); \n        emit Transfer(from, address(0), value); \n    } \n \n    function _approve(address owner, address spender, uint value) private { \n        allowance[owner][spender] = value; \n        emit Approval(owner, spender, value); \n    } \n \n    function _transfer(address from, address to, uint value) private { \n        balanceOf[from] = balanceOf[from].sub(value); \n        balanceOf[to] = balanceOf[to].add(value); \n        emit Transfer(from, to, value); \n    } \n \n    function approve(address spender, uint value) external returns (bool) { \n        _approve(msg.sender, spender, value); \n        return true; \n    } \n \n    function transfer(address to, uint value) external returns (bool) { \n        _transfer(msg.sender, to, value); \n        return true; \n    } \n \n    function transferFrom(address from, address to, uint value) external returns (bool) { \n        if (allowance[from][msg.sender] != uint(-1)) { \n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value); \n        } \n        _transfer(from, to, value); \n        return true; \n    } \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n        require(deadline >= block.timestamp, 'Netswap: EXPIRED'); \n        bytes32 digest = keccak256( \n            abi.encodePacked( \n                '\\x19\\x01', \n                DOMAIN_SEPARATOR, \n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadlin\n            ) \n        ); \n        address recoveredAddress = ecrecover(digest, v, r, s); \n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'Netswap: INVALID_SIGNAT\n        _approve(owner, spender, value); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IStrategyLink { \n \n    event StrategyDeposit(address indexed strategy, uint256 indexed pid, address indexed user, uint25\n    event StrategyBorrow(address indexed strategy, uint256 indexed pid, address indexed user, uint256 \n    event StrategyWithdraw(address indexed strategy, uint256 indexed pid, address indexed user, uint2\n    event StrategyLiquidation(address indexed strategy, uint256 indexed pid, address indexed user, ui\n \n    function bank() external view returns(address); \n    function getSource() external view returns (string memory); \n    function userInfo(uint256 _pid, address _account) external view returns (uint256,uint256,address,\n    function getPoolInfo(uint256 _pid) external view  returns(address[] memory collateralToken, addre\n    function getBorrowInfo(uint256 _pid, address _account) external view returns (address borrowFrom, \n    function getBorrowAmount(uint256 _pid, address _account) external view returns (uint256 value); \n    function getBorrowAmountInBaseToken(uint256 _pid, address _account) external view returns (uint25\n    function getDepositAmount(uint256 _pid, address _account) external view returns (uint256 amount);\n \n    function getPoolCollateralToken(uint256 _pid) external view returns (address[] memory collateralT\n    function getPoollpToken(uint256 _pid) external view returns (address lpToken); \n    function getBaseToken(uint256 _pid) external view returns (address baseToken); \n \n    function poolLength() external view returns (uint256); \n \n    function pendingRewards(uint256 _pid, address _account) external view returns (uint256 value); \n    function pendingLPAmount(uint256 _pid, address _account) external view returns (uint256 value); \n \n    // function massUpdatePools(uint256 _start, uint256 _end) external; \n    function updatePool(uint256 _pid, uint256 _desirePrice, uint256 _slippage) external; \n \n    function deposit(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount, uint256 _de\n    function depositLPToken(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount, uint\n \n    function withdraw(uint256 _pid, address _account, uint256 _rate, address _toToken, uint256 _desir\n    function withdrawLPToken(uint256 _pid, address _account, uint256 _rate, uint256 _desirePrice, uin\n \n    function emergencyWithdraw(uint256 _pid, address _account, uint256 _desirePrice, uint256 _slippag\n \n    function liquidation(uint256 _pid, address _account, address _hunter, uint256 _maxDebt) external;\n    function repayBorrow(uint256 _pid, address _account, uint256 _rate, bool _force) external; \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements a  proxy that is upgradeable by an\n * \n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy sel\n * clashing], which can potentially be used in an  attack, this contract uses \n * https://blog.openzeppelin.com/ the -transparent-proxy-pattern/[transparent proxy patter\n * things that go hand in hand: \n * \n * 1. If any account other than the  admin calls the  proxy, \n * that call matches one of the  admin functions exposed by the\n * 2. If the  admin calls the  proxy, it can access \n * implementation. If the  admin tries to call a  function on \n * \"admin cannot fallback to proxy target\". \n * \n * These properties mean that the  admin account can only be used for admin actions \n * the  admin, so  it's best if it's a\n * to sudden errors when trying to call a  function from the  p\n * \n * Our recommendation is for the  dedicated account to be an\n * you  should  think of the  `Prox\n */  \ncontract TransparentUpgradeableProxy is UpgradeableProxy { \n    /** \n     * @dev Initializes an  upgradeable proxy managed by `_admin`, backed by \n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}. \n     */  \n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1)); \n        _setAdmin(admin_); \n    } \n \n    /** \n     * @dev Emitted when the  admin account has changed. \n     */  \n    event AdminChanged(address previousAdmin, address newAdmin); \n \n    /** \n     * @dev Storage slot with the  admin of the  contract. \n     * This is the  keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is \n     * validated in the  constructor. \n     */  \n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a71785\n \n    /** \n     * @dev Modifier used internally that will  delegate the  c\n     */  \n    modifier ifAdmin() { \n        if (msg.sender == _admin()) { \n            _; \n        } else { \n            _fallback(); \n        } \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103` \n     */  \n    function admin() external ifAdmin returns (address admin_) { \n        admin_ = _admin(); \n    } \n \n    /** \n     * @dev Returns the  current implementation. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     * \n     * TIP: To get this value clients can read directly from the  storage slot shown below (s\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call. \n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` \n     */  \n    function implementation() external ifAdmin returns (address implementation_) { \n        implementation_ = _implementation(); \n    } \n \n    /** \n     * @dev Changes the  admin of the  proxy. \n     * \n     * Emits an  {AdminChanged} event. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function changeAdmin(address newAdmin) external virtual ifAdmin { \n        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\")\n        emit AdminChanged(_admin(), newAdmin); \n        _setAdmin(newAdmin); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeTo(address newImplementation) external virtual ifAdmin { \n        _upgradeTo(newImplementation); \n    } \n \n    /** \n     * @dev Upgrade the  implementation of the  proxy, and t\n     * by `data`, which should  be an  encoded function call. T\n     * proxied contract. \n     * \n     * NOTE:  Only the  admin can call this function. See {Prox\n     */  \n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtua\n        _upgradeTo(newImplementation); \n        Address.functionDelegateCall(newImplementation, data); \n    } \n \n    /** \n     * @dev Returns the  current admin. \n     */  \n    function _admin() internal view virtual returns (address adm) { \n        bytes32 slot = _ADMIN_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            adm := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 admin slo\n     */  \n    function _setAdmin(address newAdmin) private { \nSafeBoxFox.sol\n        bytes32 slot = _ADMIN_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newAdmin) \n        } \n    } \n \n    /** \n     * @dev Makes sure the  admin cannot access the  fallba\n     */  \n    function _beforeFallback() internal virtual override { \n        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy \n        super._beforeFallback(); \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\"; \n \ncontract Helper is Ownable,ReentrancyGuard { \n \n  address[] public helpers; \n  mapping(address => uint) helperIndexs; \n \n  bool public pause; \n \n  constructor(){ \n    pause = false; \n  } \n \n  function addHelper(address helper) external onlyOwner { \n    require(helper != address(0),\"Helper:set helper error\"); \n    uint index = helperIndexs[helper]; \n    if(index == 0){ \n      helpers.push(helper); \n      helperIndexs[helper] = helpers.length; \n    } \n  } \n \n  function removeHelper(address helper) external onlyOwner{ \n    uint index = helperIndexs[helper]; \n    require(index > 0,\"Helper:remove helper error\"); \n    if(helpers.length != index){ \n        address old = helpers[helpers.length - 1]; \n        helpers[index - 1] = old; \n        helperIndexs[old] = index; \n      } \n      helpers.pop(); \n      delete helperIndexs[helper]; \n  } \n \n  function pauseContract() external onlyHelper{ \n    pause = true; \n  } \n \n  function resume() external onlyHelper{ \n    pause = false; \n  } \n \n  modifier onlyHelper() { \n    require(helperIndexs[_msgSender()] > 0 || owner() == _msgSender(), \"Helper: caller is not the hel\n    _; \n  } \n \n  modifier isPause() { \n    require(!pause, \"Helper: contract is paused\"); \n    _; \n  } \n \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface GenericOracleI { \n  // ganache \n  event AssetPriceUpdated(address _asset, uint256 _price, uint256 timestamp); \n  event EthPriceUpdated(uint256 _price, uint256 timestamp); \n \n  // kovan \n  event ProphecySubmitted( \n    address indexed _sybil, \n    address indexed _asset, \n    uint96 _sybilProphecy, \n    uint96 _oracleProphecy \n  ); \n \n  function getAssetPrice(address _asset) external view returns (uint256); \n \n  function getEthUsdPrice() external view returns (uint256); \n} \n \nAnalysis of audit results\nRe-Entrancy\nArithmetic Over/Under Flows\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n* @dev Interface of the  ERC20 standard as defined in the\n  */  \n  interface IERC20 { \n  /** \n    * @dev Returns the  amount of tokens in existence. \n      */  \n      function totalSupply() external view returns (uint256); \n \n  /** \n    * @dev Returns the  amount of tokens owned by `account`. \n      */  \n      function balanceOf(address account) external view returns (uint256); \n \n  /** \n    * @dev Moves `amount` tokens from the  caller's account to `recipient`. \n    * \n    * Returns a  boolean value indicating whether the  operat\n    * \n    * Emits a  {Transfer} event. \n      */  \n      function transfer(address recipient, uint256 amount) external returns (bool); \n \n  /** \n    * @dev Returns the  remaining number of tokens that `spender` will\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is \n    * zero by default. \n    * \n    * This value changes when {approve} or {transferFrom} are  called. \n      */  \n      function allowance(address owner, address spender) external view returns (uint256); \n \n  /** \n    * @dev Sets `amount` as the  allowance of `spender` over the\n    * \n    * Returns a  boolean value indicating whether the  operat\n    * \n    * IMPORTANT: Beware that changing an  allowance with this method brings \n    * that someone may use both the  old and the  new allow\n    * transaction ordering. One possible solution to mitigate this race \n    * condition is to first reduce the  spender's allowance to 0 and set the\n    * desired value afterwards: \n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n    * \n    * Emits an  {Approval} event. \n      */  \n      function approve(address spender, uint256 amount) external returns (bool); \n \n  /** \n    * @dev Moves `amount` tokens from `sender` to `recipient` using the  \n    * allowance mechanism. `amount` is then deducted from the  caller's \n    * allowance. \n    * \n    * Returns a  boolean value indicating whether the  operat\n    * \n    * Emits a  {Transfer} event. \n      */  \n      function transferFrom( \n      address sender, \n      address recipient, \n      uint256 amount \n      ) external returns (bool); \n \n  /** \n    * @dev Emitted when `value` tokens are  moved from one account (`from`) to \n    * another (`to`). \n    * \n    * Note that `value` may be zero. \n      */  \n      event Transfer(address indexed from, address indexed to, uint256 value); \n \n  /** \n    * @dev Emitted when the  allowance of a  `spender` for \n    * a  call to {approve}. `value` is the  new allowance. \n      */  \n      event Approval(address indexed owner, address indexed spender, uint256 value); \n      } \n \n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol) \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IRewardsToken { \n    function mint(address _account, uint256 _amount) external; \n    function burn(uint256 _amount) external; \n \n    function setMintWhitelist(address _account, bool _enabled) external; \n    function checkWhitelist(address _account) external view returns (bool); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface IERC20Netswap { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external view returns (string memory); \n    function symbol() external view returns (string memory); \n    function decimals() external view returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \ninterface IStrategyConfig { \n    // event \n    event SetFeeGather(address _feeGatherOld, address _feeGather); \n    event SetReservedGather(address _old, address _new); \n    event SetBorrowFactor(address _strategy, uint256 _poolid, uint256 _borrowFactor); \n    event SetLiquidationFactor(address _strategy, uint256 _poolid, uint256 _liquidationFactor); \n    event SetFarmPoolFactor(address _strategy, uint256 _poolid, uint256 _farmPoolFactor); \n    event SetDepositFee(address _strategy, uint256 _poolid, uint256 _depositFee); \n    event SetWithdrawFee(address _strategy, uint256 _poolid, uint256 _withdrawFee); \n    event SetRefundFee(address _strategy, uint256 _poolid, uint256 _refundFee); \n    event SetClaimFee(address _strategy, uint256 _poolid, uint256 _claimFee); \n    event SetLiquidationFee(address _strategy, uint256 _poolid, uint256 _liquidationFee); \n \n    // factor \n    function getBorrowFactor(address _strategy, uint256 _poolid) external view returns (uint256); \n    function setBorrowFactor(address _strategy, uint256 _poolid, uint256 _borrowFactor) external; \n \n    function getLiquidationFactor(address _strategy, uint256 _poolid) external view returns (uint256)\n    function setLiquidationFactor(address _strategy, uint256 _poolid, uint256 _liquidationFactor) ext\n \n    function getFarmPoolFactor(address _strategy, uint256 _poolid) external view returns (uint256 val\n    function setFarmPoolFactor(address _strategy, uint256 _poolid, uint256 _farmPoolFactor) external;\n \n    // fee manager \n    function getDepositFee(address _strategy, uint256 _poolid) external view returns (address, uint25\n    function setDepositFee(address _strategy, uint256 _poolid, uint256 _depositFee) external; \n \n    function getWithdrawFee(address _strategy, uint256 _poolid) external view returns (address, uint2\n    function setWithdrawFee(address _strategy, uint256 _poolid, uint256 _withdrawFee) external; \n \n    function getRefundFee(address _strategy, uint256 _poolid) external view returns (address, uint256\n    function setRefundFee(address _strategy, uint256 _poolid, uint256 _refundFee) external; \n \n    function getClaimFee(address _strategy, uint256 _poolid) external view returns (address, uint256)\n    function setClaimFee(address _strategy, uint256 _poolid, uint256 _claimFee) external; \n \n    function getLiquidationFee(address _strategy, uint256 _poolid) external view returns (address, ui\n    function setLiquidationFee(address _strategy, uint256 _poolid, uint256 _liquidationFee) external;\n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev Contract module that helps prevent reentrant calls to a function. \n * \n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier \n * available, which can be applied to functions to make sure there are no nested \n * (reentrant) calls to them. \n * \n * Note that because there is a single `nonReentrant` guard, functions marked as \n * `nonReentrant` may not call one another. This can be worked around by making \n * those functions `private`, and then adding `external` `nonReentrant` entry \n * points to them. \n * \n * TIP: If you would like to learn more about reentrancy and alternative ways \n * to protect against it, check out our blog post \n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. \n */ \nabstract contract ReentrancyGuardUpgradeable is Initializable { \n    // Booleans are more expensive than uint256 or any type that takes up a full \n    // word because each write operation emits an extra SLOAD to first read the \n    // slot's contents, replace the bits taken up by the boolean, and then write \n    // back. This is the compiler's defense against contract upgrades and \n    // pointer aliasing, and it cannot be disabled. \n \n    // The values being non-zero value makes deployment a bit more expensive, \n    // but in exchange the refund on every call to nonReentrant will be lower in \n    // amount. Since refunds are capped to a percentage of the total \n    // transaction's gas, it is best to keep them low in cases like this one, to \n    // increase the likelihood of the full refund coming into effect. \n    uint256 private constant _NOT_ENTERED = 1; \n    uint256 private constant _ENTERED = 2; \n \n    uint256 private _status; \n \n    function __ReentrancyGuard_init() internal initializer { \n        __ReentrancyGuard_init_unchained(); \n    } \n \n    function __ReentrancyGuard_init_unchained() internal initializer { \n        _status = _NOT_ENTERED; \n    } \n \n    /** \n     * @dev Prevents a contract from calling itself, directly or indirectly. \n     * Calling a `nonReentrant` function from another `nonReentrant` \n     * function is not supported. It is possible to prevent this from happening \n     * by making the `nonReentrant` function external, and make it call a \n     * `private` function that does the actual work. \n     */ \n    modifier nonReentrant() { \n        // On the first call to nonReentrant, _notEntered will be true \n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); \n \n        // Any calls to nonReentrant after this point will fail \n        _status = _ENTERED; \n \n        _; \n \n        // By storing the original value once again, a refund is triggered (see \n        // https://eips.ethereum.org/EIPS/eip-2200) \n        _status = _NOT_ENTERED; \n    } \n    uint256[49] private __gap; \n} \n \n// File: contracts/interface/IInvit.sol \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \ncontract StrategyV2Data { \n \n    // Info of each user. \n    struct UserInfo { \n        uint256 lpAmount;       // deposit lptoken amount \n        uint256 lpPoints;       // deposit proportion \n        address[] borrowFrom;   // borrowFrom \n        uint256[] bids; \n    } \n \n    // Info of each pool. \n    struct PoolInfo { \n        address[] collateralToken;      // collateral Token list, last must be baseToken \n        address baseToken;              // baseToken can be borrowed \n        address lpToken;                // lptoken to deposit \n        uint256 poolId;                 // poolid for mdex pools \n        uint256 lastRewardsBlock;       // \n        uint256 totalPoints;            // total of user lpPoints \n        uint256 totalLPAmount;          // total of user lpAmount \n        uint256 totalLPReinvest;        // total of lptoken amount with totalLPAmount and reinvest re\n        uint256 miniRewardAmount;       // \n    } \n \n    // Info of each pool. \n    PoolInfo[] public poolInfo; \n    // Info of each user that stakes LP tokens. \n    mapping (uint256 => mapping (address => UserInfo)) public userInfo2; \n \n    address public _bank;                // address of bank \n    address public _this; \n    address public helperImpl; \n \n    IStrategyConfig public sconfig; \n    mapping (uint256 => mapping (string => uint256)) public poolConfig; \n \n    IStrategyV2SwapPool public swapPoolImpl; \n \n    address public devAddr; \n    IPriceChecker public priceChecker; \n    IActionPools public compActionPool;     // address of comp action pool \n \n    mapping(address=>bool) public whitelist; \n    uint256[39] private __gap; \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nabstract contract ReentrancyGuard { \n \n    uint256 private constant _NOT_ENTERED = 1; \n    uint256 private constant _ENTERED = 2; \n \n    uint256 private _status; \n \n    constructor () { \n        _status = _NOT_ENTERED; \n    } \n \n    modifier nonReentrant() { \n        // On the first call to nonReentrant, _notEntered will be true \n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); \n \n        // Any calls to nonReentrant after this point will fail \n        _status = _ENTERED; \n \n        _; \n \n        // By storing the original value once again, a refund is triggered (see \n        // https://eips.ethereum.org/EIPS/eip-2200) \n        _status = _NOT_ENTERED; \n    } \n} \n \nAnalysis of audit results\nRe-Entrancy\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @title SignedSafeMath \n * @dev Signed math operations with safety checks that revert on error. \n */ \nlibrary SignedSafeMathUpgradeable { \n    int256 constant private _INT256_MIN = -2**255; \n \n    /** \n     * @dev Returns the multiplication of two signed integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(int256 a, int256 b) internal pure returns (int256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\"); \n \n        int256 c = a * b; \n        require(c / a == b, \"SignedSafeMath: multiplication overflow\"); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two signed integers. Reverts on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(int256 a, int256 b) internal pure returns (int256) { \n        require(b != 0, \"SignedSafeMath: division by zero\"); \n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\"); \n \n        int256 c = a / b; \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two signed integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(int256 a, int256 b) internal pure returns (int256) { \n        int256 c = a - b; \n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\"); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the addition of two signed integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(int256 a, int256 b) internal pure returns (int256) { \n        int256 c = a + b; \n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\"); \n \n        return c; \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"../Context.sol\"; \nimport \"./ERC20Pausable.sol\"; \n \nabstract contract ERC20Mintable is Context, ERC20Pausable { \n    using SafeMath for uint256; \n \n    mapping(address => bool) public isMinter; \n \n    event AddMinter(address indexed minter); \n    event RemoveMinter(address indexed minter); \n    event Mint( \n        address indexed minter, \n        address indexed recipient, \n        uint256 amount \n    ); \n \n    modifier onlyMinter() { \n        require(isMinter[_msgSender()], \"ERC20: sender is not minter\"); \n        _; \n    } \n \n    function _addMinter(address minter) internal { \n        require(!isMinter[minter], \"ERC20: already a minter\"); \n        isMinter[minter] = true; \n        emit AddMinter(minter); \n    } \n \n    function _removeMinter(address minter) internal { \n        require(isMinter[minter], \"ERC20: not a minter\"); \n        isMinter[minter] = false; \n        emit RemoveMinter(minter); \n    } \n \n    function mint(address recipient, uint256 amount) external onlyMinter { \n        _mint(recipient, amount); \n        emit Mint(_msgSender(), recipient, amount); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \ninterface IActionPools { \n \n    function getPoolInfo(uint256 _pid) external view \n        returns (address callFrom, uint256 callId, address rewardToken); \n    function mintRewards(uint256 _callId) external; \n    function getPoolIndex(address _callFrom, uint256 _callId) external view returns (uint256[] memory\n \n    function onAcionIn(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ext\n    function onAcionOut(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ex\n    function onAcionClaim(uint256 _callId, address _account) external; \n    function onAcionEmergency(uint256 _callId, address _account) external; \n    function onAcionUpdate(uint256 _callId) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {WadRayMath} from './WadRayMath.sol'; \n \nlibrary MathUtils { \n  using SafeMath for uint256; \n  using WadRayMath for uint256; \n \n  /// @dev Ignoring leap years \n  uint256 internal constant SECONDS_PER_YEAR = 365 days; \n \n  /** \n   * @dev Function to calculate the interest accumulated using a linear interest rate formula \n   * @param rate The interest rate, in ray \n   * @param lastUpdateTimestamp The timestamp of the last update of the interest \n   * @return The interest rate linearly accumulated during the timeDelta, in ray \n   **/ \n \n  function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp) \n    internal \n    view \n    returns (uint256) \n  { \n    //solium-disable-next-line \n    uint256 timeDifference = block.timestamp.sub(uint256(lastUpdateTimestamp)); \n \n    return (rate.mul(timeDifference) / SECONDS_PER_YEAR).add(WadRayMath.ray()); \n  } \n \n  /** \n   * @dev Function to calculate the interest using a compounded interest rate formula \n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation: \n   * \n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3... \n   * \n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the ad\n   * The whitepaper contains reference to the approximation and a table showing the margin of error p\n   * \n   * @param rate The interest rate, in ray \n   * @param lastUpdateTimestamp The timestamp of the last update of the interest \n   * @return The interest rate compounded during the timeDelta, in ray \n   **/ \n  function calculateCompoundedInterest( \n    uint256 rate, \n    uint40 lastUpdateTimestamp, \n    uint256 currentTimestamp \n  ) internal pure returns (uint256) { \n    //solium-disable-next-line \n    uint256 exp = currentTimestamp.sub(uint256(lastUpdateTimestamp)); \n \n    if (exp == 0) { \n      return WadRayMath.ray(); \n    } \n \n    uint256 expMinusOne = exp - 1; \n \n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0; \n \n    uint256 ratePerSecond = rate / SECONDS_PER_YEAR; \n \n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond); \n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond); \n \n    uint256 secondTerm = exp.mul(expMinusOne).mul(basePowerTwo) / 2; \n    uint256 thirdTerm = exp.mul(expMinusOne).mul(expMinusTwo).mul(basePowerThree) / 6; \n \n    return WadRayMath.ray().add(ratePerSecond.mul(exp)).add(secondTerm).add(thirdTerm); \n  } \n \n  /** \n   * @dev Calculates the compounded interest between the timestamp of the last update and the current \n   * @param rate The interest rate (in ray) \n   * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calcul\n   **/ \n  function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp) \n    internal \n    view \n    returns (uint256) \n  { \n    return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20 { \n    using SafeMath for uint256; \n    using Address for address; \n \n    function safeTransfer(IERC20 token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20 token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20 token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n \n// File contracts/interface/ILfgSwapPair.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./StakeLPRewardPerDay.sol\"; \nimport \"./interfaces/IFidoMember.sol\"; \nimport \"./interfaces/IMFIL.sol\"; \n \ninterface IMFILPool { \n    function lendFil(uint256 totalT, uint256 userStakeFil) \n        external \n        returns (uint256 lendAmount); \n \n    function returnFil(uint256 amount) external; \n} \n \ninterface IMfilIdoTokenLPPoolFactory { \n    function operator() external view returns (address); \n \n    function MfilStakePool() external view returns (address); \n \n    function FidoMember() external view returns (address); \n \n    function inviteFeeRate() external view returns (uint256); \n \n    function inviteFeeRateDecimals() external view returns (uint256); \n} \n \ncontract MfilIdoTokenLPPool is StakeLPRewardPerDay { \n    using SafeMath for uint256; \n \n    address public mfil; \n    address public idoToken; \n    address public lpPoolFactory; \n \n    uint256 public totalMfilLend; \n    mapping(address => uint256) public userMfilLend; \n \n    constructor( \n        address _factory, \n        address fidoOwner, \n        address _mfil, \n        address _idoToken \n    ) StakeLPRewardPerDay(_factory, fidoOwner, _mfil, _idoToken, _mfil) { \n        lpPoolFactory = _msgSender(); \n        mfil = _mfil; \n        idoToken = _idoToken; \n    } \n \n    modifier onlyMfilStakePool() { \n        require( \n            _msgSender() == \n                IMfilIdoTokenLPPoolFactory(lpPoolFactory).MfilStakePool(), \n            \"MFIL-IDOTOKEN-LP-POOL: caller is not the MfilStakePool\" \n        ); \n        _; \n    } \n \n    function MfilStakePool() external view returns (address) { \n        return IMfilIdoTokenLPPoolFactory(lpPoolFactory).MfilStakePool(); \n    } \n \n    function FidoMember() external view returns (address) { \n        return IMfilIdoTokenLPPoolFactory(lpPoolFactory).FidoMember(); \n    } \n \n    function inviteFeeRateDecimals() external view returns (uint256) { \n        return \n            IMfilIdoTokenLPPoolFactory(lpPoolFactory).inviteFeeRateDecimals(); \n    } \n \n    function inviteFeeRate() external view returns (uint256) { \n        return IMfilIdoTokenLPPoolFactory(lpPoolFactory).inviteFeeRate(); \n    } \n \n    function _lendFil(uint256 totalT, uint256 userStakeFil) \n        internal \n        returns (uint256 lendAmount) \n    { \n        lendAmount = IMFILPool(this.MfilStakePool()).lendFil( \n            totalT, \n            userStakeFil \n        ); \n        userMfilLend[_msgSender()] = userMfilLend[_msgSender()].add(lendAmount); \n        totalMfilLend = totalMfilLend.add(lendAmount); \n    } \n \n    function _returnFIL() internal returns (uint256 amount) { \n        amount = userMfilLend[_msgSender()]; \n        IMFILPool(this.MfilStakePool()).returnFil(amount); \n        userMfilLend[_msgSender()] = 0; \n        totalMfilLend = totalMfilLend.sub(amount); \n    } \n \n    function _stakeHook( \n        uint256 amountAIn, \n        uint256 amountBIn, \n        uint256 amountA, \n        uint256 amountB, \n        uint256 liquidity \n    ) internal override { \n        amountB = amountB.mul(stakeRate).div(stakeRate - 1); \n        _lendFil(amountB, amountA); \n    } \n \n    function _unStakeHook( \n        uint256 reward, \n        uint256 amountA, \n        uint256 amountB, \n        uint256 liquidity \n    ) internal override { \n        _returnFIL(); \n        uint256 inviteFee = \n            reward.mul(this.inviteFeeRate()).div( \n                10**uint256(this.inviteFeeRateDecimals()) \n            ); \n        { \n            address inviter0; \n            address inviter1; \n            address fido; \n            uint256 rate0; \n            uint256 rate1; \n            uint256 fidoRate; \n            uint256 fee; \n            (inviter0, inviter1, fido, rate0, rate1, fidoRate) = IFidoMember( \n                this.FidoMember() \n            ) \n                .caleInviteRate(_msgSender()); \n            fee = inviteFee.mul(rate0).div( \n                10**IFidoMember(this.FidoMember()).rateDecimal() \n            ); \n            IMFIL(mfil).mint(inviter0, fee); \n            fee = inviteFee.mul(rate1).div( \n                10**IFidoMember(this.FidoMember()).rateDecimal() \n            ); \n            IMFIL(mfil).mint(inviter1, fee); \n            fee = inviteFee.mul(fidoRate).div( \n                10**IFidoMember(this.FidoMember()).rateDecimal() \n            ); \n            IMFIL(mfil).mint(fido, fee); \n        } \n    } \n \n    function newReward(uint256 amount) \n        external \n        virtual \n        override \n        onlyMfilStakePool \n        whenNotPaused \n    { \n        _addNewReward(amount); \n        emit NewReward(block.number, amount); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.2; \n \n \ninterface IUniswapV2Router02 is IUniswapV2Router01 { \n    function removeLiquidityHTSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountHTMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountHT); \n    function removeLiquidityHTWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountHTMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountHT); \n \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n    function swapExactHTForTokensSupportingFeeOnTransferTokens( \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external payable; \n    function swapExactTokensForHTSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./libraries/SafeMath.sol\"; \nimport \"./Context.sol\"; \n \ncontract StakeRewardPerDay is Context { \n    using SafeMath for uint256; \n \n    uint256 public rewardRate; // Global Reward per Unit \n    uint256 public constant blockCountPerDay = 20 * 60 * 24; // 3s - 1 block, 1min - 20 blocks \n    uint256 public rewardToday; \n    uint256 public rewardPreBlock; // rewardToday / blockCountPerDay \n    uint256 public lastUpdateBlock; // last adjust block height \n    uint256 public totalStake; \n    uint256 public todayStartBlock; \n    uint256 public todayEndBlock; // todayStartBlock + blockCountPerDay \n    mapping(address => uint256) public userStake; \n    mapping(address => uint256) public userReward; \n    mapping(address => uint256) public userRate; \n \n    constructor() { \n        rewardRate = 0; \n        rewardToday = 0; \n        rewardPreBlock = 0; \n        totalStake = 0; \n        lastUpdateBlock = block.number; \n        todayStartBlock = block.number; \n        todayEndBlock = todayStartBlock + blockCountPerDay; \n    } \n \n    modifier updateRate() { \n        if ( \n            rewardPreBlock > 0 && \n            totalStake > 0 && \n            block.number > lastUpdateBlock && \n            todayEndBlock > lastUpdateBlock \n        ) { \n            uint256 duringBlock; \n            if (block.number < todayEndBlock) { \n                duringBlock = block.number - lastUpdateBlock; \n                lastUpdateBlock = block.number; \n            } else { \n                duringBlock = todayEndBlock - lastUpdateBlock; \n                lastUpdateBlock = todayEndBlock; \n            } \n            uint256 deltaRate = rewardPreBlock.mul(duringBlock).div(totalStake); \n            rewardRate = rewardRate.add(deltaRate); \n        } \n        if(rewardPreBlock == 0){ \n            lastUpdateBlock = block.number; \n        } \n        _; \n    } \n \n    modifier updateEndRate() { \n        if ( \n            rewardPreBlock > 0 && \n            totalStake > 0 && \n            todayEndBlock > lastUpdateBlock \n        ) { \n            uint256 duringBlock = todayEndBlock - lastUpdateBlock; \n            uint256 deltaRate = rewardPreBlock.mul(duringBlock).div(totalStake); \n            rewardRate = rewardRate.add(deltaRate); \n        } \n        if(rewardPreBlock == 0){ \n            lastUpdateBlock = block.number; \n        } \n        _; \n    } \n \n    modifier getReward() { \n        if (userStake[_msgSender()] > 0 && rewardRate > userRate[_msgSender()]) { \n            uint256 deltaReward = \n                rewardRate.sub(userRate[_msgSender()]).mul( \n                    userStake[_msgSender()] \n                ); \n            userReward[_msgSender()] = userReward[_msgSender()].add( \n                deltaReward \n            ); \n        } \n        userRate[_msgSender()] = rewardRate; \n        _; \n    } \n \n    function _addNewReward(uint256 amount) internal updateEndRate{ \n        rewardToday = amount; \n        rewardPreBlock = amount.mul(1e18).div(blockCountPerDay); \n        todayStartBlock = block.number; \n        todayEndBlock = todayStartBlock + blockCountPerDay; \n    } \n \n    function _stake(uint256 amount) updateRate getReward internal virtual { \n        userStake[_msgSender()] = userStake[_msgSender()].add(amount); \n        totalStake = totalStake.add(amount); \n    } \n    function _halveNoUpdate() internal returns (uint256 reward){ \n        reward = userReward[_msgSender()].div(1e18); \n        userReward[_msgSender()] = 0; \n    } \n \n    function _halve() updateRate getReward internal returns (uint256 reward){ \n        return _halveNoUpdate(); \n    } \n \n    function _unStake() updateRate getReward internal virtual returns (uint256 stake, uint256 reward)\n        stake = userStake[_msgSender()]; \n        totalStake = totalStake.sub(stake); \n        userStake[_msgSender()] = 0; \n        reward = _halveNoUpdate(); \n    } \n \n    function _getStake() view internal returns (uint256 stake) { \n        stake = userStake[_msgSender()]; \n    } \n \n    function _caleReward() view internal returns (uint256 reward) { \n        if(userStake[_msgSender()] == 0){ \n            return 0; \n        } \n        uint256 tempRate = rewardRate; \n        if ( \n            rewardPreBlock > 0 && \n            totalStake > 0 && \n            block.number > lastUpdateBlock && \n            todayEndBlock > lastUpdateBlock \n        ) { \n            uint256 duringBlock; \n            if (block.number < todayEndBlock) { \n                duringBlock = block.number - lastUpdateBlock; \n            } else { \n                duringBlock = todayEndBlock - lastUpdateBlock; \n            } \n            uint256 deltaRate = rewardPreBlock.mul(duringBlock).div(totalStake); \n            tempRate = tempRate.add(deltaRate); \n        } \n        reward = userReward[_msgSender()]; \n        if (tempRate > userRate[_msgSender()]) { \n            uint256 deltaReward = \n                tempRate.sub(userRate[_msgSender()]).mul( \n                    userStake[_msgSender()] \n                ); \n            reward = reward.add( \n                deltaReward \n            ); \n        } \n        reward = reward.div(1e18); \n    } \n \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements an  upgradeable proxy. It is upgradeable because cal\n * implementation address that can be changed. This address is stored in storage in the\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so  that it doesn't\n * implementation behind the  proxy. \n * \n * Upgradeability is only provided internally through {_upgradeTo}. For an  externally up\n * {TransparentUpgradeableProxy}. \n */  \ncontract UpgradeableProxy is Proxy { \n    /** \n     * @dev Initializes the  upgradeable proxy with an  initial i\n     * \n     * If `_data` is nonempty, it's used as data in a  delegate call to `_logic`. This \n     * function call, and allows initializating the  storage of the\n     */  \n    constructor(address _logic, bytes memory _data) public payable { \n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1\n        _setImplementation(_logic); \n        if(_data.length > 0) { \n            Address.functionDelegateCall(_logic, _data); \n        } \n    } \n \n    /** \n     * @dev Emitted when the  implementation is upgraded. \n     */  \n    event Upgraded(address indexed implementation); \n \n    /** \n     * @dev Storage slot with the  address of the  current imp\n     * This is the  keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, an\n     * validated in the  constructor. \n     */  \n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a\n \n    /** \n     * @dev Returns the  current implementation address. \n     */  \n    function _implementation() internal view virtual override returns (address impl) { \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            impl := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Upgrades the  proxy to a  new implementation. \n     * \n     * Emits an  {Upgraded} event. \n     */  \n    function _upgradeTo(address newImplementation) internal virtual { \n        _setImplementation(newImplementation); \n        emit Upgraded(newImplementation); \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 implemen\n     */  \n    function _setImplementation(address newImplementation) private { \n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a \n \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newImplementation) \n        } \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @title IERC1363Spender Interface \n * @dev Interface for any contract that wants to support approveAndCall \n *  from ERC1363 token contracts as defined in \n *  https://eips.ethereum.org/EIPS/eip-1363 \n */  \ninterface IERC1363Spender { \n    /** \n     * @notice Handle the  approval of ERC1363 tokens \n     * @dev Any ERC1363 smart contract calls this function on the  recipient \n     * after an  `approve`. This function MAY throw to revert and reject the\n     * approval. Return of other than the  magic value MUST result in the\n     * transaction being reverted. \n     * Note: the  token contract address is always the  messa\n     * @param sender address The address which called `approveAndCall` function \n     * @param amount uint256 The amount of tokens to be spent \n     * @param data bytes Additional data with no specified format \n     * @return `bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))` unless throwing \n     */  \n    function onApprovalReceived( \n        address sender, \n        uint256 amount, \n        bytes calldata data \n    ) external returns (bytes4); \n} \n \n// File: erc-payable-token/contracts/token/ERC1363/ERC1363.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\nBEP20.sol\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n}\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return t\nlibrary TransferHelper { \n    function safeApprove(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('approve(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_F\n    } \n \n    function safeTransfer(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transfer(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferFrom(address token, address from, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, v\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferETH(address to, uint value) internal { \n        (bool success,) = to.call{value : value}(new bytes(0)); \n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED'); \n    } \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \nimport \"./IDOToken.sol\"; \nimport \"./interfaces/IMdexPair.sol\"; \nimport \"./interfaces/IMdexFactory.sol\"; \n \n \ncontract IDOFactory is Ownable { \n    using SafeMath for uint256; \n \n    address[] public IDOlist; \n    mapping(address => bool) public isIDO; \n    mapping(address => address[]) public userIDOs; \n    address public hfil; \n    address public mfil; \n    address public operator; // for start ido \n    address public mdexFactory; \n \n    event NewIDO(address indexed sender, address indexed ido); \n \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n \n    constructor( \n        address _operator, \n        address _hfil, \n        address _mfil, \n        address _mdexFactory \n    ) Ownable() { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        hfil = _hfil; \n        mfil = _mfil; \n        mdexFactory = _mdexFactory; \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function IDOlistCount() external view returns (uint256) { \n        return IDOlist.length; \n    } \n \n    function userIDOsCount(address user) external view returns (uint256) { \n        return userIDOs[user].length; \n    } \n \n    function _addLiquidity( \n        address pair, \n        address idoToken, \n        uint256 idoAmount, \n        uint256 mfilAmount \n    ) internal { \n        IERC20(idoToken).transfer(pair, idoAmount); \n        TransferHelper.safeTransferFrom(mfil, _msgSender(), pair, mfilAmount); \n        IMdexPair(pair).mint(address(0)); \n    } \n \n \n    function newIDO( \n        string calldata _name, \n        string calldata _node, \n        address _hfilRecipient, \n        uint256 _cap, \n        uint256 _gasPrice, \n        uint256 _sealPrice, \n        uint256 _hardDrivePrice, \n        uint256 _dailySaleCap, \n        uint256 _idoStartTime, \n        uint256 _idoEndTime \n    ) external returns (address idoAddress) { \n        require( \n            _dailySaleCap >= 1e6, \n            \"IDOFactory: dailysalecap should more than 1\" \n        ); \n        IDOToken ido = new IDOToken( \n            _name, \n            _node, \n            hfil, \n            _hfilRecipient, \n            _cap, \n            _dailySaleCap \n        ); \n        ido.setPrice(_gasPrice, _sealPrice, _hardDrivePrice); \n        ido.setTimes(_idoStartTime, _idoEndTime); \n        IDOlist.push(address(ido)); \n        userIDOs[_msgSender()].push(address(ido)); \n        address pair = IMdexFactory(mdexFactory).createPair(mfil, address(ido)); \n        uint256 totalPrice = _gasPrice.add(_sealPrice).add(_hardDrivePrice).div(100); \n        _addLiquidity(pair, address(ido), 1e4, totalPrice); \n        emit NewIDO(_msgSender(), address(ido)); \n        isIDO[address(ido)] = true; \n        return address(ido); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \n \ncontract PriceCheckerLPToken is OwnableUpgradeable, IPriceChecker { \n    using SafeMathUpgradeable for uint256; \n    using SignedSafeMathUpgradeable for int256; \n \n    mapping(address => uint256) public priceSlippage; \n    ITokenOracle public tokenOracle; \n    uint256 public largeSlipRate; \n \n    event SetPriceSlippage(address _lptoken, uint256 _oldv, uint256 _newv); \n    event SetLargeSlipRate(uint256 _oldv, uint256 _newv); \n    event SetTokenOracle(address _oldv, address _newv); \n \n    constructor() public { \n    } \n \n    function initialize(address _tokenOracle) public initializer { \n        __Ownable_init(); \n        largeSlipRate = 4e9; \n        setTokenOracle(_tokenOracle); \n    } \n \n    function setLargeSlipRate(uint256 _largeSlipRate) external onlyOwner { \n        require(_largeSlipRate >= 1e9, 'value error'); \n        emit SetLargeSlipRate(largeSlipRate, _largeSlipRate); \n        largeSlipRate = _largeSlipRate; \n    } \n \n    function setPriceSlippage(address _lptoken, uint256 _slippage) external onlyOwner { \n        require(_slippage >= 0 && _slippage <= 1e9, 'value error'); \n        emit SetPriceSlippage(_lptoken, priceSlippage[_lptoken], _slippage); \n        priceSlippage[_lptoken] = _slippage; \n    } \n \n    function setTokenOracle(address _tokenOracle) public onlyOwner { \n        emit SetTokenOracle(address(tokenOracle), _tokenOracle); \n        tokenOracle = ITokenOracle(_tokenOracle); \nActionCompPools::TransparentUpgradeableProxy.sol\n    } \n \n    function getPriceSlippage(address _lptoken) public override view returns (uint256) { \n        if(priceSlippage[_lptoken] > 0) { \n            return priceSlippage[_lptoken]; \n        } \n        return uint256(1e7); \n    } \n \n    function getLPTokenPriceInMdex(address _lptoken, address _t0, address _t1) public view returns (u\n        IUniswapV2Pair pair = IUniswapV2Pair(_lptoken); \n        (uint256 r0, uint256 r1, ) = pair.getReserves(); \n        uint256 d0 = ERC20Upgradeable(_t0).decimals(); \n        uint256 d1 = ERC20Upgradeable(_t1).decimals(); \n        if(d0 != 18) { \n            r0 = r0.mul(1e18).div(10**d0); \n        } \n        if(d1 != 18) { \n            r1 = r1.mul(1e18).div(10**d1); \n        } \n        return r0.mul(1e18).div(r1); \n    } \n \n \n    function getLPTokenPriceInOracle(address _t0, address _t1) public view returns (uint256) { \n        int256 price0 = tokenOracle.getPrice(_t0); \n        int256 price1 = tokenOracle.getPrice(_t1); \n        if(price0 <= 0 || price1 <= 0) { \n            return 0; \n        } \n        int256 priceInOracle = price1.mul(1e18).div(price0); \n        if(priceInOracle <= 0) { \n            return 0; \n        } \n        return uint256(priceInOracle); \n    } \n \n    function checkLPTokenPriceLimit(address _lptoken, bool _largeType) external override view returns\n        IUniswapV2Pair pair = IUniswapV2Pair(_lptoken); \n        address t0 = pair.token0(); \n        address t1 = pair.token1(); \n        uint256 price0 = getLPTokenPriceInMdex(_lptoken, t0, t1); \n        uint256 price1 = getLPTokenPriceInOracle(t0, t1); \n        if(price0 == 0 || price1 == 0) { \n            return false; \n        } \n        uint256 slip = getPriceSlippage(_lptoken); \n        uint256 priceRate = price0.mul(1e9).div(price1); \n        if(_largeType) { \n            slip = slip.mul(largeSlipRate).div(1e9); \n        } \n        if(priceRate >= uint256(1e9).add(slip) || priceRate <= uint256(1e9).sub(slip)) { \n            return false; \n        } \n        return true; \n    } \n}\n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {LendingPool} from '../protocol/lendingpool/LendingPool.sol'; \nimport { \n  LendingPoolAddressesProvider \n} from '../protocol/configuration/LendingPoolAddressesProvider.sol'; \nimport {LendingPoolConfigurator} from '../protocol/lendingpool/LendingPoolConfigurator.sol'; \nimport {AToken} from '../protocol/tokenization/AToken.sol'; \nimport { \n  DefaultReserveInterestRateStrategy \n} from '../protocol/lendingpool/DefaultReserveInterestRateStrategy.sol'; \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {StringLib} from './StringLib.sol'; \n \ncontract ATokensAndRatesHelper is Ownable { \n  address payable private pool; \n  address private addressesProvider; \n  address private poolConfigurator; \n  event deployedContracts(address aToken, address strategy); \n \n  struct InitDeploymentInput { \n    address asset; \n    uint256[6] rates; \n  } \n \n  struct ConfigureReserveInput { \n    address asset; \n    uint256 baseLTV; \n    uint256 liquidationThreshold; \n    uint256 liquidationBonus; \n    uint256 reserveFactor; \n    bool stableBorrowingEnabled; \n  } \n \n  constructor( \n    address payable _pool, \n    address _addressesProvider, \n    address _poolConfigurator \n  ) public { \n    pool = _pool; \n    addressesProvider = _addressesProvider; \n    poolConfigurator = _poolConfigurator; \n  } \n \n  function initDeployment(InitDeploymentInput[] calldata inputParams) external onlyOwner { \n    for (uint256 i = 0; i < inputParams.length; i++) { \n      emit deployedContracts( \n        address(new AToken()), \n        address( \n          new DefaultReserveInterestRateStrategy( \n            LendingPoolAddressesProvider(addressesProvider), \n            inputParams[i].rates[0], \n            inputParams[i].rates[1], \n            inputParams[i].rates[2], \n            inputParams[i].rates[3], \n            inputParams[i].rates[4], \n            inputParams[i].rates[5] \n          ) \n        ) \n      ); \n    } \n  } \n \n  function configureReserves(ConfigureReserveInput[] calldata inputParams) external onlyOwner { \n    LendingPoolConfigurator configurator = LendingPoolConfigurator(poolConfigurator); \n    for (uint256 i = 0; i < inputParams.length; i++) { \n      configurator.configureReserveAsCollateral( \n        inputParams[i].asset, \n        inputParams[i].baseLTV, \n        inputParams[i].liquidationThreshold, \n        inputParams[i].liquidationBonus \n      ); \n \n      configurator.enableBorrowingOnReserve( \n        inputParams[i].asset, \n        inputParams[i].stableBorrowingEnabled \n      ); \n      configurator.setReserveFactor(inputParams[i].asset, inputParams[i].reserveFactor); \n    } \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \ncontract DFOXToken is ERC20Capped, Ownable, IRewardsToken { \n    constructor ( \n            string memory _name, \n            string memory _symbol, \n            uint256 _totalSupply \n        ) public ERC20Capped(_totalSupply) ERC20(_name, _symbol) { \n    } \n \n    mapping(address => bool) public mintWhitelist; \n \n    function setMintWhitelist(address _account, bool _enabled) external override onlyOwner { \n        mintWhitelist[_account] = _enabled; \n    } \n \n    function checkWhitelist(address _account) external override view returns (bool) { \n        return mintWhitelist[_account]; \n    } \n \n    function mint(address _account, uint256 _amount) external override { \n        require(mintWhitelist[msg.sender], 'not allow'); \n        _mint(_account, _amount); \n    } \n \n    function burn(uint256 _amount) external override onlyOwner { \n        _burn(msg.sender, _amount); \n    } \n} \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n/** \n* @dev Interface for the  optional metadata functions from the\n* \n* _Available since v4.1._ \n  */  \n  interface IERC20Metadata is IERC20 { \n  /** \n    * @dev Returns the  name of the  token. \n      */  \n      function name() external view returns (string memory); \n \n  /** \n    * @dev Returns the  symbol of the  token. \n      */  \n      function symbol() external view returns (string memory); \n \n  /** \n    * @dev Returns the  decimals places of the  token. \n      */  \n      function decimals() external view returns (uint8); \n      } \n \n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol) \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \nimport \"./Pausable.sol\"; \nimport \"./ReentrancyGuard.sol\"; \nimport \"./StakeRewardPerDay.sol\"; \n \ncontract StakeTokenPool is StakeRewardPerDay, Ownable, Pausable { \n \n    using SafeMath for uint256; \n \n    uint256 public BrewardRate; // Global Reward per Unit \n    uint256 public BrewardPreBlock; \n    uint256 public BlastUpdateBlock; // last adjust block height \n \n    mapping(address => uint256) public BuserReward; \n    mapping(address => uint256) public BuserRate; \n \n    constructor() StakeRewardPerDay() { \n        BrewardRate = 0; \n        BrewardPreBlock = 0; \n        BlastUpdateBlock = block.number; \n    } \n \n    modifier BupdateRate() { \n        if ( \n            BrewardPreBlock > 0 && \n            totalStake > 0 && \n            block.number > BlastUpdateBlock \n        ) { \n            uint256 deltaRate = \n                BrewardPreBlock.mul(block.number - BlastUpdateBlock).div( \n                    totalStake \n                ); \n            BrewardRate = BrewardRate.add(deltaRate); \n        } \n        BlastUpdateBlock = block.number; \n        _; \n    } \n \n    modifier BgetReward() { \n        if ( \n            userStake[_msgSender()] > 0 && BrewardRate > BuserRate[_msgSender()] \n        ) { \n            uint256 deltaReward = \n                BrewardRate.sub(BuserRate[_msgSender()]).mul( \n                    userStake[_msgSender()] \n                ); \n            BuserReward[_msgSender()] = BuserReward[_msgSender()].add( \n                deltaReward \n            ); \n        } \n        BuserRate[_msgSender()] = BrewardRate; \n        _; \n    } \n \n    function _setReward(uint256 amount) internal BupdateRate { \n        BrewardPreBlock = amount.mul(1e18); \n    } \n \n    function _stake(uint256 amount) internal override updateRate getReward BupdateRate BgetReward { \n        userStake[_msgSender()] = userStake[_msgSender()].add(amount); \n        totalStake = totalStake.add(amount); \n    } \n \n    function _BhalveNoUpdate() internal returns (uint256 reward) { \n        reward = BuserReward[_msgSender()].div(1e18); \n        BuserReward[_msgSender()] = 0; \n    } \n \n    function _Bhalve() internal BupdateRate BgetReward returns (uint256 reward) { \n        return _BhalveNoUpdate(); \n    } \n \n    function _unStakeAll() \n        internal \n        updateRate  \n        getReward \n        BupdateRate \n        BgetReward \n        returns (uint256 stake, uint256 reward, uint256 rewardB) \n    { \n        stake = userStake[_msgSender()]; \n        totalStake = totalStake.sub(stake); \n        userStake[_msgSender()] = 0; \n        reward = _halveNoUpdate(); \n        rewardB = _BhalveNoUpdate(); \n    } \n \n    function _BcaleReward() internal view returns (uint256 reward) { \n        if (userStake[_msgSender()] == 0) { \n            return 0; \n        } \n        uint256 tempRate = BrewardRate; \n        if ( \n            BrewardPreBlock > 0 && \n            totalStake > 0 && \n            block.number > BlastUpdateBlock \n        ) { \n            uint256 deltaRate = \n                BrewardPreBlock.mul(block.number - BlastUpdateBlock).div( \n                    totalStake \n                ); \n            tempRate = tempRate.add(deltaRate); \n        } \n        reward = BuserReward[_msgSender()]; \n        if (tempRate > BuserRate[_msgSender()]) { \n            uint256 deltaReward = \n                tempRate.sub(BuserRate[_msgSender()]).mul( \n                    userStake[_msgSender()] \n                ); \n            reward = reward.add(deltaReward); \n        } \n        reward = reward.div(1e18); \n    } \n \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.2 <0.8.0; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary AddressUpgradeable { \n    /** \n     * @dev Returns true if `account` is a contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an address for which this function returns \n     * false is an externally-owned account (EOA) and not a contract. \n     * \n     * Among others, `isContract` will return false for the following \n     * types of addresses: \n     * \n     *  - an externally-owned account \n     *  - a contract in construction \n     *  - an address where a contract will be created \n     *  - an address where a contract lived, but was destroyed \n     * ==== \n     */ \n    function isContract(address account) internal view returns (bool) { \n        // This method relies on extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n     * of certain opcodes, possibly making contracts go over the 2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects\n     */ \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a Solidity function call using a low level `call`. A \n     * plain`call` is an unsafe replacement for a function call: use this \n     * function instead. \n     * \n     * If `target` reverts with a revert reason, it is bubbled up by this \n     * function (like regular Solidity function calls). \n     * \n     * Returns the raw returned data. To convert to the expected return value, \n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.de\n     * \n     * Requirements: \n     * \n     * - `target` must be a contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with \n     * `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the calling contract must have an ETH balance of at least `value`. \n     * - the called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValu\n     * with `errorMessage` as a fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */ \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: value }(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memor\n        return functionStaticCall(target, data, \"Address: low-level static call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`], \n     * but performing a static call. \n     * \n     * _Available since v3.3._ \n     */ \n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) intern\n        require(isContract(target), \"Address: static call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.staticcall(data); \n        return _verifyCallResult(success, returndata, errorMessage); \n    } \n \n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) pri\n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n \n// solhint-disable-next-line compiler-version \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.7.0; \n \ninterface IAggregatorV3Interface { \n \n  function decimals() \n    external \n    view \n    returns ( \n      uint8 \n    ); \n \n  function description() \n    external \n    view \n    returns ( \n      string memory \n    ); \n \n  function version() \n    external \n    view \n    returns ( \n      uint256 \n    ); \n \n  // getRoundData and latestRoundData should both raise \"No data present\" \n  // if they do not have data to report, instead of returning unset values \n  // which could be misinterpreted as actual reported values. \n  function getRoundData( \n    uint80 _roundId \n  ) \n    external \n    view \n    returns ( \n      uint80 roundId, \n      int256 answer, \n      uint256 startedAt, \n      uint256 updatedAt, \n      uint80 answeredInRound \n    ); \n \n  function latestRoundData() \n    external \n    view \n    returns ( \n      uint80 roundId, \n      int256 answer, \n      uint256 startedAt, \n      uint256 updatedAt, \n      uint80 answeredInRound \n    ); \n \n} \n \n// File: contracts/Oracle/Oracle.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n/** \n * @dev Implementation of the  {IERC165} interface. \n * \n * Contracts that want to implement ERC165 should  inherit from this contract and overri\n * for the  additional interface id that will  be supported. For\n * \n * solidity \n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { \n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); \n * } \n *  \n* \n* Alternatively, {ERC165Storage} provides an  easier to use but\n  */  \n  abstract contract ERC165 is IERC165 { \n  /** \n    * @dev See {IERC165-supportsInterface}. \n      */  \n      function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { \n      return interfaceId == type(IERC165).interfaceId; \n      } \n      } \n \n// File: @openzeppelin/contracts/utils/Strings.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol) \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ISafeBox { \n \n    function bank() external view returns(address); \n \n    function token() external view returns(address); \n \n    function getSource() external view returns (string memory); \n \n    function supplyRatePerBlock() external view returns (uint256); \n    function borrowRatePerBlock() external view returns (uint256); \n \n    function getBorrowInfo(uint256 _bid) external view \n            returns (address owner, uint256 amount, address strategy, uint256 pid); \n    function getBorrowId(address _strategy, uint256 _pid, address _account) external view returns (ui\n    function getBorrowId(address _strategy, uint256 _pid, address _account, bool _add) external retur\n    function getDepositTotal() external view returns (uint256); \n    function getBorrowTotal() external view returns (uint256); \n    // function getBorrowAmount(address _account) external view returns (uint256 value); \n    function getBaseTokenPerLPToken() external view returns (uint256); \n \n    function deposit(uint256 _value) external; \n    function withdraw(uint256 _value) external; \n \n    function emergencyWithdraw() external; \n    function emergencyRepay(uint256 _bid) external; \n \n    function borrowInfoLength() external view returns (uint256); \n \n    function borrow(uint256 _bid, uint256 _value, address _to) external; \n    function repay(uint256 _bid, uint256 _value) external; \n    function claim(uint256 _tTokenAmount) external; \n \n    function update() external; \n    function mintDonate(uint256 _value) external; \n \n    function pendingSupplyAmount(address _account) external view returns (uint256 value); \n    function pendingBorrowAmount(uint256 _bid) external view returns (uint256 value); \n    function pendingBorrowRewards(uint256 _bid) external view returns (uint256 value); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ncontract SelfdestructTransfer { \n  function destroyAndTransfer(address payable to) external payable { \n    selfdestruct(to); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \nimport {IDelegationToken} from '../../interfaces/IDelegationToken.sol'; \nimport {Errors} from '../libraries/helpers/Errors.sol'; \nimport {AToken} from './AToken.sol'; \n \n/** \n * @title Aave AToken enabled to delegate voting power of the underlying asset to a different address\n * @dev The underlying asset needs to be compatible with the COMP delegation interface \n * @author Aave \n */ \ncontract DelegationAwareAToken is AToken { \n  modifier onlyPoolAdmin { \n    require( \n      _msgSender() == ILendingPool(_pool).getAddressesProvider().getPoolAdmin(), \n      Errors.CALLER_NOT_POOL_ADMIN \n    ); \n    _; \n  } \n \n  /** \n   * @dev Delegates voting power of the underlying asset to a `delegatee` address \n   * @param delegatee The address that will receive the delegation \n   **/ \n  function delegateUnderlyingTo(address delegatee) external onlyPoolAdmin { \n    IDelegationToken(_underlyingAsset).delegate(delegatee); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IExtendedPriceAggregator { \n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp); \n \n  function getToken() external view returns (address); \n \n  function getTokenType() external view returns (uint256); \n \n  function getPlatformId() external view returns (uint256); \n \n  function getSubTokens() external view returns (address[] memory); \n \n  function latestAnswer() external view returns (int256); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \npragma experimental ABIEncoderV2; \n \n/// @title Multicall - Aggregate results from multiple read-only function calls \n \ninterface IERC20 { \n    function balanceOf(address user) external view returns (uint256); \n} \n \ncontract Multicall { \n    address public metis = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000; \n    struct Call { \n        address target; \n        bytes callData; \n    } \n    function aggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes[] memory retur\n        blockNumber = block.number; \n        returnData = new bytes[](calls.length); \n        for(uint256 i = 0; i < calls.length; i++) { \n            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData); \n            require(success); \n            returnData[i] = ret; \n        } \n    } \n    // Helper functions \n    function getMetisBalance(address addr) public view returns(uint256 balance) { \n        balance = IERC20(metis).balanceOf(addr); \n    } \n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) { \n        timestamp = block.timestamp; \n    } \n}\nNetswapFactory.sol\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IActionTrigger { \n    function getATPoolInfo(uint256 _pid) external view \n        returns (address lpToken, uint256 allocRate, uint256 totalAmount); \n    function getATUserAmount(uint256 _pid, address _account) external view \n        returns (uint256 acctAmount); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IFidoUsdtLPPool { \n  function BlastUpdateBlock() view external returns (uint256); \n \n  function BrewardPreBlock() view external returns (uint256); \n \n  function BrewardRate() view external returns (uint256); \n \n  function BuserRate(address) view external returns (uint256); \n \n  function BuserReward(address) view external returns (uint256); \n \n  function adjustReward(uint256 amount) external; \n \n  function caleLiquidity(uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 \n \n  function caleReward() view external returns (uint256 reward); \n \n  function factory() view external returns (address); \n \n  function fido() view external returns (address); \n \n  function getStake() view external returns (uint256 amount); \n \n  function halve() external returns (uint256 reward); \n \n  function operator() view external returns (address); \n \n  function owner() view external returns (address); \n \n  function pairFor(address tokenA, address tokenB) view external returns (address pair); \n \n  function pause() external; \n \n  function paused() view external returns (bool); \n \n  function renounceOwnership() external; \n \n  function rewardToken() view external returns (address); \n \n  function stake(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amo\n \n  function stakeRate() view external returns (uint8); \n \n  function tokenA() view external returns (address); \n \n  function tokenB() view external returns (address); \n \n  function totalStake() view external returns (uint256); \n \n  function totalTokenBStake() view external returns (uint256); \n \n  function transferOperatorship(address newOperator) external; \n \n  function transferOwnership(address newOwner) external; \n \n  function unPause() external; \n \n  function unStake() external returns (uint256 reward, uint256 amountA, uint256 amountB, uint256 liqu\n \n  function usdt() view external returns (address); \n \n  function userStake(address) view external returns (uint256); \n \n  function userTokenBStake(address) view external returns (uint256); \n \n  event NewReward(uint256 blockHeight, uint256 amount); \n \n  event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator); \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n  event Paused(address account); \n \n  event Reward(address indexed receiver, uint256 reward); \n \n  event Stake(address indexed sender, uint256 amountA, uint256 amountB, uint256 liquidity); \n \n  event UnStake(address indexed receiver, uint256 amountA, uint256 amountB, uint256 liquidity); \n \n  event Unpaused(address account); \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \n \n \n// Distribution of BOO Compound token \ncontract SafeBoxFox is SafeBoxFoxCToken { \n    using SafeMathUpgradeable for uint256; \n    using SafeERC20Upgradeable for IERC20Upgradeable; \n \n    IERC20Upgradeable public REWARDS_TOKEN; \n \n    uint256 public lastRewardsTokenBlock;        // rewards update \n \n    address public actionPoolRewards;            // address for action pool \n    uint256 public poolDepositId;               // poolid of depositor s token rewards in action pool\n    uint256 public poolBorrowId;                // poolid of borrower s token rewards in action pool \n \n    uint256 public REWARDS_DEPOSIT_CALLID;      // depositinfo callid for action callback \n    uint256 public REWARDS_BORROW_CALLID;       // borrowinfo callid for comp action callback \n \n    event SetRewardsDepositPool(address _actionPoolRewards, uint256 _piddeposit); \n    event SetRewardsBorrowPool(address _compActionPool, uint256 _pidborrow); \n \n    function initialize(address _bank, address _cToken, address _devAddr) public initializer { \n        __Ownable_init(); \n \n        __SafeBoxFoxCToken_init(_bank, _cToken, _devAddr); \n \n        REWARDS_TOKEN = IERC20Upgradeable(0); \n        REWARDS_DEPOSIT_CALLID = 16; \n        REWARDS_BORROW_CALLID = 18; \n    } \n \n    function update() public virtual override { \n        _update(); \n        updatetoken(); \n    } \n \n    // mint rewards for supplies to action pools \n    function setRewardsDepositPool(address _actionPoolRewards, uint256 _piddeposit) public onlyOwner \n        actionPoolRewards = _actionPoolRewards; \n        poolDepositId = _piddeposit; \n        emit SetRewardsDepositPool(_actionPoolRewards, _piddeposit); \n    } \n \n    // mint rewards for borrows to comp action pools \n    function setRewardsBorrowPool(uint256 _pidborrow) public onlyOwner { \n        _checkActionPool(compActionPool, _pidborrow, REWARDS_BORROW_CALLID); \n        poolBorrowId = _pidborrow; \n        emit SetRewardsBorrowPool(compActionPool, _pidborrow); \n    } \n \n    function _checkActionPool(address _actionPool, uint256 _pid, uint256 _rewardscallid) internal vie\n        (address callFrom, uint256 callId, address rewardToken) \n            = IActionPools(_actionPool).getPoolInfo(_pid); \n        require(callFrom == address(this), 'call from error'); \n        require(callId == _rewardscallid, 'callid error'); \n    } \n \n    function deposit(uint256 _value) external virtual override nonReentrant { \n        update(); \n        IERC20Upgradeable(token).safeTransferFrom(msg.sender, address(this), _value); \n        _deposit(msg.sender, _value); \n    } \n \n    function withdraw(uint256 _tTokenAmount) external virtual override nonReentrant { \n        update(); \n        _withdraw(msg.sender, _tTokenAmount); \n    } \n \n    function borrow(uint256 _bid, uint256 _value, address _to) external virtual override onlyBank { \n        update(); \n        address owner = borrowInfo[_bid].owner; \nTimelock.sol\n        uint256 accountBorrowPointsOld = accountBorrowPoints[owner]; \n        _borrow(_bid, _value, _to); \n \n        if(compActionPool != address(0) && _value > 0) { \n            IActionPools(compActionPool).onAcionIn(REWARDS_BORROW_CALLID, owner, \n                    accountBorrowPointsOld, accountBorrowPoints[owner]); \n        } \n    } \n \n    function repay(uint256 _bid, uint256 _value) external virtual override { \n        update(); \n        address owner = borrowInfo[_bid].owner; \n        uint256 accountBorrowPointsOld = accountBorrowPoints[owner]; \n        _repay(_bid, _value); \n \n        if(compActionPool != address(0) && _value > 0) { \n            IActionPools(compActionPool).onAcionOut(REWARDS_BORROW_CALLID, owner, \n                    accountBorrowPointsOld, accountBorrowPoints[owner]); \n        } \n    } \n \n    function updatetoken() public { \n        if(lastRewardsTokenBlock == block.number) { \n            return ; \n        } \n        lastRewardsTokenBlock = block.number; \n    } \n \n    function claim(uint256 _value) external virtual override nonReentrant { \n        update(); \n        _claim(msg.sender, _value); \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format)\n \n// range: [0, 2**112 - 1] \n// resolution: 1 / 2**112 \n \nlibrary UQ112x112 { \n    uint224 constant Q112 = 2**112; \n \n    // encode a uint112 as a UQ112x112 \n    function encode(uint112 y) internal pure returns (uint224 z) { \n        z = uint224(y) * Q112; // never overflows \n    } \n \n    // divide a UQ112x112 by a uint112, returning a UQ112x112 \n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { \n        z = x / uint224(y); \n    } \n} \n \n \n// File contracts/core/LfgSwapPair.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.6.0; \n \nlibrary Address { \n    /** \n     * @dev Returns true if `account` is a  contract. \n     * \n     * [IMPORTANT] \n     * ==== \n     * It is unsafe to assume that an  address for which this function returns \n     * false is an  externally-owned account (EOA) and not a  c\n     * \n     * Among others, `isContract` will  return false for the  fol\n     * types of addresses: \n     * \n     *  - an  externally-owned account \n     *  - a  contract in construction \n     *  - an  address where a  contract will\n     *  - an  address where a  contract lived, but\n     * ==== \n     */  \n    function isContract(address account) internal view returns (bool) { \n        // This method relies in extcodesize, which returns 0 for contracts in \n        // construction, since the code is only stored at the end of the \n        // constructor execution. \n \n        uint256 size; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { size := extcodesize(account) } \n        return size > 0; \n    } \n \n    /** \n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n     * `recipient`, forwarding all available gas and reverting on errors. \n     * \n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the  gas cost \n     * of certain opcodes, possibly making contracts go over the  2300 gas limit \n     * imposed by `transfer`, making them unable to receive funds via \n     * `transfer`. {sendValue} removes this limitation. \n     * \n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more\n     * \n     * IMPORTANT: because control is transferred to `recipient`, care must be \n     * taken to not create reentrancy vulnerabilities. Consider using \n     * {ReentrancyGuard} or the  \n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use- the -che\n     */  \n    function sendValue(address payable recipient, uint256 amount) internal { \n        require(address(this).balance >= amount, \"Address: insufficient balance\"); \n \n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n        (bool success, ) = recipient.call{ value: amount }(\"\"); \n        require(success, \"Address: unable to send value, recipient may have reverted\"); \n    } \n \n    /** \n     * @dev Performs a  Solidity function call using a  low leve\n     * plain`call` is an  unsafe replacement for a  function call: \n     * function instead. \n     * \n     * If `target` reverts with a  revert reason, it is bubbled up by this \n     * function ( like  regular Solidity function calls). \n     * \n     * Returns the  raw returned data. To convert to the  expe\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding\n     * \n     * Requirements: \n     * \n     * - `target` must be a  contract. \n     * - calling `target` with `data` must not revert. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { \n      return functionCall(target, data, \"Address: low-level call failed\"); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but  with\n     * `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCall(address target, bytes memory data, string memory errorMessage) internal ret\n        return _functionCallWithValue(target, data, 0, errorMessage); \n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], \n     * but  also transferring `value` wei to `target`. \n     * \n     * Requirements: \n     * \n     * - the  calling contract must have an  ETH balance of at l\n     * - the  called Solidity function must be `payable`. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns \n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"\n    } \n \n    /** \n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], \n     * with `errorMessage` as a  fallback revert reason when `target` reverts. \n     * \n     * _Available since v3.1._ \n     */  \n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory er\n        require(address(this).balance >= value, \"Address: insufficient balance for call\"); \n        return _functionCallWithValue(target, data, value, errorMessage); \n    } \n \n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memor\n        require(isContract(target), \"Address: call to non-contract\"); \n \n        // solhint-disable-next-line avoid-low-level-calls \n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data); \n        if (success) { \n            return returndata; \n        } else { \n            // Look for revert reason and bubble it up if present \n            if (returndata.length > 0) { \n                // The easiest way to bubble the revert reason is using memory via assembly \n \n                // solhint-disable-next-line no-inline-assembly \n                assembly { \n                    let returndata_size := mload(returndata) \n                    revert(add(32, returndata), returndata_size) \n                } \n            } else { \n                revert(errorMessage); \n            } \n        } \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @title IERC1363Receiver Interface \n * @dev Interface for any contract that wants to support transferAndCall or transferFromAndCall \n *  from ERC1363 token contracts as defined in \n *  https://eips.ethereum.org/EIPS/eip-1363 \n */  \ninterface IERC1363Receiver { \n    /** \n     * @notice Handle the  receipt of ERC1363 tokens \n     * @dev Any ERC1363 smart contract calls this function on the  recipient \n     * after a  `transfer` or a  `transferFrom`. This function MAY\n     * transfer. Return of other than the  magic value MUST result in the\n     * transaction being reverted. \n     * Note: the  token contract address is always the  messa\n     * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function \n     * @param sender address The address which are  token transferred from \n     * @param amount uint256 The amount of tokens transferred \n     * @param data bytes Additional data with no specified format \n     * @return `bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))` unless throwing \n     */  \n    function onTransferReceived( \n        address operator, \n        address sender, \n        uint256 amount, \n        bytes calldata data \n    ) external returns (bytes4); \n} \n \n// File: erc-payable-token/contracts/token/ERC1363/IERC1363Spender.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IWETHGateway { \n  function depositETH( \n    address lendingPool, \n    address onBehalfOf, \n    uint16 referralCode \n  ) external payable; \n \n  function withdrawETH( \n    address lendingPool, \n    uint256 amount, \n    address onBehalfOf \n  ) external; \n \n  function repayETH( \n    address lendingPool, \n    uint256 amount, \n    uint256 rateMode, \n    address onBehalfOf \n  ) external payable; \n \n  function borrowETH( \n    address lendingPool, \n    uint256 amount, \n    uint256 interesRateMode, \n    uint16 referralCode \n  ) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0; \n \n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return t\nlibrary TransferHelper { \n    function safeApprove(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('approve(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_F\n    } \n \n    function safeTransfer(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transfer(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferFrom(address token, address from, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, v\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferETH(address to, uint value) internal { \n        (bool success,) = to.call{value:value}(new bytes(0)); \n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED'); \n    } \n} \n \n \n// File contracts/interface/ILfgSwapRouter.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12;\n  interface GenericOracleI {\n    // ganache\n    event AssetPriceUpdated(address _asset, uint256 _price, uint256 timestamp);\n    event EthPriceUpdated(uint256 _price, uint256 timestamp);\n    // kovan\n    event ProphecySubmitted(\n    address indexed _sybil,\n    address indexed _asset,\n    uint96 _sybilProphecy,\n    uint96 _oracleProphecy\n  );\n  function getAssetPrice(address _asset) external view returns (uint256);\n  function getEthUsdPrice() external view returns (uint256);\n}\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.6.0; \n \ncontract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the  contract setting the  deployer as \n     */  \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the  address of the  current owner. \n     */  \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the  owner. \n     */  \n    modifier onlyOwner() { \n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the  contract without owner. It will  not b\n     * `onlyOwner` functions anymore. Can only be called by the  current owner. \n     * \n     * NOTE:  Renouncing ownership will  leave \n     * thereby removing any functionality that is only available to the  owner. \n     */  \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the  contract to a  new ac\n     * Can only be called by the  current owner. \n     */  \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface IUniswapV2Factory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeToSetter() external view returns (address); \n    function migrator() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeToSetter(address) external; \n    function setMigrator(address) external; \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IUniswapV2Router02 { \n  function swapExactTokensForTokens( \n    uint256 amountIn, \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external returns (uint256[] memory amounts); \n \n  function swapTokensForExactTokens( \n    uint256 amountOut, \n    uint256 amountInMax, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external returns (uint256[] memory amounts); \n \n  function getAmountsOut(uint256 amountIn, address[] calldata path) \n    external \n    view \n    returns (uint256[] memory amounts); \n \n  function getAmountsIn(uint256 amountOut, address[] calldata path) \n    external \n    view \n    returns (uint256[] memory amounts); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport '../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol'; \n \n/** \n * @title BaseImmutableAdminUpgradeabilityProxy \n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern \n * @dev This contract combines an upgradeability proxy with an authorization \n * mechanism for administrative tasks. The admin role is stored in an immutable, which \n * helps saving transactions costs \n * All external functions in this contract must be guarded by the \n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity \n * feature proposal that would enable this to be done automatically. \n */ \ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy { \n  address immutable ADMIN; \n \n  constructor(address admin) public { \n    ADMIN = admin; \n  } \n \n  modifier ifAdmin() { \n    if (msg.sender == ADMIN) { \n      _; \n    } else { \n      _fallback(); \n    } \n  } \n \n  /** \n   * @return The address of the proxy admin. \n   */ \n  function admin() external ifAdmin returns (address) { \n    return ADMIN; \n  } \n \n  /** \n   * @return The address of the implementation. \n   */ \n  function implementation() external ifAdmin returns (address) { \n    return _implementation(); \n  } \n \n  /** \n   * @dev Upgrade the backing implementation of the proxy. \n   * Only the admin can call this function. \n   * @param newImplementation Address of the new implementation. \n   */ \n  function upgradeTo(address newImplementation) external ifAdmin { \n    _upgradeTo(newImplementation); \n  } \n \n  /** \n   * @dev Upgrade the backing implementation of the proxy and call a function \n   * on the new implementation. \n   * This is useful to initialize the proxied contract. \n   * @param newImplementation Address of the new implementation. \n   * @param data Data to send as msg.data in the low level call. \n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n   */ \n  function upgradeToAndCall(address newImplementation, bytes calldata data) \n    external \n    payable \n    ifAdmin \n  { \n    _upgradeTo(newImplementation); \n    (bool success, ) = newImplementation.delegatecall(data); \n    require(success); \n  } \n \n  /** \n   * @dev Only fall back when the sender is not the admin. \n   */ \n  function _willFallback() internal virtual override { \n    require(msg.sender != ADMIN, 'Cannot call fallback function from the proxy admin'); \n    super._willFallback(); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ILendingPool} from '../../../interfaces/ILendingPool.sol'; \nimport {ICreditDelegationToken} from '../../../interfaces/ICreditDelegationToken.sol'; \nimport { \n  VersionedInitializable \n} from '../../libraries/aave-upgradeability/VersionedInitializable.sol'; \nimport {IncentivizedERC20} from '../IncentivizedERC20.sol'; \nimport {Errors} from '../../libraries/helpers/Errors.sol'; \n \n/** \n * @title DebtTokenBase \n * @notice Base contract for different types of debt tokens, like StableDebtToken or VariableDebtToke\n * @author Aave \n */ \n \nabstract contract DebtTokenBase is \n  IncentivizedERC20('DEBTTOKEN_IMPL', 'DEBTTOKEN_IMPL', 0), \n  VersionedInitializable, \n  ICreditDelegationToken \n{ \n  mapping(address => mapping(address => uint256)) internal _borrowAllowances; \n \n  /** \n   * @dev Only lending pool can call functions marked by this modifier \n   **/ \n  modifier onlyLendingPool { \n    require(_msgSender() == address(_getLendingPool()), Errors.CT_CALLER_MUST_BE_LENDING_POOL); \n    _; \n  } \n \n  /** \n   * @dev delegates borrowing power to a user on the specific debt token \n   * @param delegatee the address receiving the delegated borrowing power \n   * @param amount the maximum amount being delegated. Delegation will still \n   * respect the liquidation constraints (even if delegated, a delegatee cannot \n   * force a delegator HF to go below 1) \n   **/ \n  function approveDelegation(address delegatee, uint256 amount) external override { \n    _borrowAllowances[_msgSender()][delegatee] = amount; \n    emit BorrowAllowanceDelegated(_msgSender(), delegatee, _getUnderlyingAssetAddress(), amount); \n  } \n \n  /** \n   * @dev returns the borrow allowance of the user \n   * @param fromUser The user to giving allowance \n   * @param toUser The user to give allowance to \n   * @return the current allowance of toUser \n   **/ \n  function borrowAllowance(address fromUser, address toUser) \n    external \n    view \n    override \n    returns (uint256) \n  { \n    return _borrowAllowances[fromUser][toUser]; \n  } \n \n  /** \n   * @dev Being non transferrable, the debt token does not implement any of the \n   * standard ERC20 functions for transfer and allowance. \n   **/ \n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n    recipient; \n    amount; \n    revert('TRANSFER_NOT_SUPPORTED'); \n  } \n \n  function allowance(address owner, address spender) \n    public \n    view \n    virtual \n    override \n    returns (uint256) \n  { \n    owner; \n    spender; \n    revert('ALLOWANCE_NOT_SUPPORTED'); \n  } \n \n  function approve(address spender, uint256 amount) public virtual override returns (bool) { \n    spender; \n    amount; \n    revert('APPROVAL_NOT_SUPPORTED'); \n  } \n \n  function transferFrom( \n    address sender, \n    address recipient, \n    uint256 amount \n  ) public virtual override returns (bool) { \n    sender; \n    recipient; \n    amount; \n    revert('TRANSFER_NOT_SUPPORTED'); \n  } \n \n  function increaseAllowance(address spender, uint256 addedValue) \n    public \n    virtual \n    override \n    returns (bool) \n  { \n    spender; \n    addedValue; \n    revert('ALLOWANCE_NOT_SUPPORTED'); \n  } \n \n  function decreaseAllowance(address spender, uint256 subtractedValue) \n    public \n    virtual \n    override \n    returns (bool) \n  { \n    spender; \n    subtractedValue; \n    revert('ALLOWANCE_NOT_SUPPORTED'); \n  } \n \n  function _decreaseBorrowAllowance( \n    address delegator, \n    address delegatee, \n    uint256 amount \n  ) internal { \n    uint256 newAllowance = \n      _borrowAllowances[delegator][delegatee].sub(amount, Errors.BORROW_ALLOWANCE_NOT_ENOUGH); \n \n    _borrowAllowances[delegator][delegatee] = newAllowance; \n \n    emit BorrowAllowanceDelegated(delegator, delegatee, _getUnderlyingAssetAddress(), newAllowance); \n  } \n \n  function _getUnderlyingAssetAddress() internal view virtual returns (address); \n \n  function _getLendingPool() internal view virtual returns (ILendingPool); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n}\nERC20.sol\n// FECtoken project \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \nlibrary TenMath { \n  using SafeMathUpgradeable for uint256; \n \n  function min(uint256 v1, uint256 v2) public pure returns (uint256 vr) { \n    vr = v1 > v2 ? v2 : v1; \n  } \n \n  function safeSub(uint256 v1, uint256 v2) internal pure returns (uint256 vr) { \n    vr = v1 > v2 ? v1.sub(v2) : 0; \n  } \n \n  // implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c52\n  // original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/\n  function sqrt(uint256 x) internal pure returns (uint256) { \n    if (x == 0) return 0; \n    uint256 xx = x; \n    uint256 r = 1; \n \n    if (xx >= 0x100000000000000000000000000000000) { \n      xx >>= 128; \n      r <<= 64; \n    } \n \n    if (xx >= 0x10000000000000000) { \n      xx >>= 64; \n      r <<= 32; \n    } \n    if (xx >= 0x100000000) { \n      xx >>= 32; \n      r <<= 16; \n    } \n    if (xx >= 0x10000) { \n      xx >>= 16; \n      r <<= 8; \n    } \n    if (xx >= 0x100) { \n      xx >>= 8; \n      r <<= 4; \n    } \n    if (xx >= 0x10) { \n      xx >>= 4; \n      r <<= 2; \n    } \n    if (xx >= 0x8) { \n      r <<= 1; \n    } \n \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; // Seven iterations should be enough \n    uint256 r1 = x / r; \n    return (r < r1 ? r : r1); \n  } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n \ncontract LfgSwapFactory is ILfgSwapFactory { \n    address public override feeTo; \n    address public override feeToSetter; \n    bytes32 public initCodeHash; \n \n    mapping(address => mapping(address => address)) public override getPair; \n    address[] public override allPairs; \n \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    constructor(address _feeToSetter) public { \n        feeToSetter = _feeToSetter; \n        initCodeHash = keccak256(abi.encodePacked(type(LfgSwapPair).creationCode)); \n    } \n \n    function allPairsLength() external override view returns (uint) { \n        return allPairs.length; \n    } \n \nLfgSwapRouter.sol\n    function pairCodeHash() external pure returns (bytes32) { \n        return keccak256(type(LfgSwapPair).creationCode); \n    } \n \n    // returns sorted token addresses, used to handle return values from pairs sorted in this order \n    function sortTokens(address tokenA, address tokenB) public override pure returns (address token0, \n        require(tokenA != tokenB, 'LfgSwapFactory: IDENTICAL_ADDRESSES'); \n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n        require(token0 != address(0), 'LfgSwapFactory: ZERO_ADDRESS'); \n    } \n \n    // calculates the CREATE2 address for a pair without making any external calls \n    function pairFor(address tokenA, address tokenB) public override view returns (address pair) { \n        (address token0, address token1) = sortTokens(tokenA, tokenB); \n        pair = address(uint(keccak256(abi.encodePacked( \n                hex'ff', \n                address(this), \n                keccak256(abi.encodePacked(token0, token1)), \n                initCodeHash \n            )))); \n    } \n \n    function createPair(address tokenA, address tokenB) external override returns (address pair) { \n        require(tokenA != tokenB, 'LfgSwap: IDENTICAL_ADDRESSES'); \n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n        require(token0 != address(0), 'LfgSwap: ZERO_ADDRESS'); \n        require(getPair[token0][token1] == address(0), 'LfgSwap: PAIR_EXISTS'); // single check is su\n        bytes memory bytecode = type(LfgSwapPair).creationCode; \n        bytes32 salt = keccak256(abi.encodePacked(token0, token1)); \n        assembly { \n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt) \n        } \n        LfgSwapPair(pair).initialize(token0, token1); \n        getPair[token0][token1] = pair; \n        getPair[token1][token0] = pair; // populate mapping in the reverse direction \n        allPairs.push(pair); \n        emit PairCreated(token0, token1, pair, allPairs.length); \n    } \n \n    function getSalt() public view returns(bytes32) { \n        bytes memory bytecode = type(LfgSwapPair).creationCode; \n        return keccak256(abi.encodePacked(bytecode)); \n    } \n \n    function setFeeTo(address _feeTo) external override { \n        require(msg.sender == feeToSetter, 'LfgSwap: FORBIDDEN'); \n        feeTo = _feeTo; \n    } \n \n \n    function setFeeToSetter(address _feeToSetter) external override { \n        require(msg.sender == feeToSetter, 'LfgSwap: FORBIDDEN'); \n        feeToSetter = _feeToSetter; \n    } \n \n} \n \n \n \n// Sources flattened with hardhat v2.10.2 https://hardhat.org \n \n// File @openzeppelin/contracts/utils/Context.sol@v3.4.2 \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IErc20Interface { \n \n    /*** User Interface ***/ \n    function underlying() external view returns (address); \n \n    function mint(uint mintAmount) external returns (uint);  // \n    function redeem(uint redeemTokens) external returns (uint); \n    function redeemUnderlying(uint redeemAmount) external returns (uint); \n    function borrow(uint borrowAmount) external returns (uint); \n    function repayBorrow(uint repayAmount) external returns (uint); \n    // function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint); \n    // function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) \n \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./StakeRewardPerBlock.sol\"; \nimport \"./MdexRouter.sol\"; \nimport \"./Ownable.sol\"; \nimport \"./Pausable.sol\"; \nimport \"./ReentrancyGuard.sol\"; \nimport \"./interfaces/IERC20Mintable.sol\"; \n \ncontract StakeLPRewardPerBlock is \n    StakeRewardPerBlock, \n    MdexRouter, \n    Ownable, \n    Pausable, \n    ReentrancyGuard \n{ \n    using SafeMath for uint256; \n \n    uint8 public stakeRate = 5; \n \n    address public tokenA; // for one \n    address public tokenB; // for stakeRate \n    address public rewardToken; // for reward \n    address public operator; \n \n    mapping(address => uint256) public userTokenBStake; \n    uint256 public totalTokenBStake; \n \n    event Stake( \n        address indexed sender, \n        uint256 amountA, \n        uint256 amountB, \n        uint256 liquidity \n    ); \n    event UnStake( \n        address indexed receiver, \n        uint256 amountA, \n        uint256 amountB, \n        uint256 liquidity \n    ); \n    event Reward(address indexed receiver, uint256 reward); \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n    event NewReward(uint256 blockHeight, uint256 amount); \n \n    constructor( \n        address _factory, \n        address _operator, \n        address _tokenA, \n        address _tokenB, \n        address _rewardToken \n    ) \n        StakeRewardPerBlock() \n        MdexRouter(_factory) \n        Ownable() \n        Pausable() \n        ReentrancyGuard() \n    { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        tokenA = _tokenA; \n        tokenB = _tokenB; \n        rewardToken = _rewardToken; \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function pause() external onlyOperator { \n        _pause(); \n    } \n \n    function unPause() external onlyOperator { \n        _unpause(); \n    } \n \n    function caleLiquidity( \n        uint256 amountADesired, \n        uint256 amountBDesired, \n        uint256 amountAMin, \n        uint256 amountBMin \n    ) external view returns (uint256 amountA, uint256 amountB) { \n        require( \n            IMdexFactory(factory).getPair(tokenA, tokenB) != address(0), \n            \"MdexRouter: Pair Not Found!\" \n        ); \n        (uint256 reserveA, uint256 reserveB) = \n            IMdexFactory(factory).getReserves(tokenA, tokenB); \n        if (reserveA == 0 && reserveB == 0) { \n            (amountA, amountB) = (amountADesired, amountBDesired); \n        } else { \n            uint256 amountBOptimal = \n                IMdexFactory(factory).quote(amountADesired, reserveA, reserveB); \n            if (amountBOptimal <= amountBDesired) { \n                require( \n                    amountBOptimal >= amountBMin, \n                    \"MdexRouter: INSUFFICIENT_B_AMOUNT\" \n                ); \n                (amountA, amountB) = (amountADesired, amountBOptimal); \n            } else { \n                uint256 amountAOptimal = \n                    IMdexFactory(factory).quote( \n                        amountBDesired, \n                        reserveB, \n                        reserveA \n                    ); \n                assert(amountAOptimal <= amountADesired); \n                require( \n                    amountAOptimal >= amountAMin, \n                    \"MdexRouter: INSUFFICIENT_A_AMOUNT\" \n                ); \n                (amountA, amountB) = (amountAOptimal, amountBDesired); \n            } \n        } \n    } \n \n    function stake(uint256 amountAIn, uint256 amountBIn) \n        external \n        whenNotPaused \n        nonReentrant \n        returns ( \n            uint256 amountA, \n            uint256 amountB, \n            uint256 liquidity \n        ) \n    { \n        require(amountAIn > 0 && amountBIn > 0, \"STAKE: amount is zero\"); \n        uint256 tempAmountB = amountBIn.div(stakeRate); \n        (amountA, amountB, liquidity) = addLiquidity( \n            tokenA, \n            tokenB, \n            amountAIn, \n            tempAmountB, \n            0, \n        ); \n        amountB = amountB.mul(stakeRate - 1); \n        TransferHelper.safeTransferFrom( \n            tokenB, \n            _msgSender(), \n            address(this), \n            amountB \n        ); \n        userTokenBStake[_msgSender()] = userTokenBStake[_msgSender()].add( \n            amountB \n        ); \n        totalTokenBStake = totalTokenBStake.add(amountB); \n        _stake(liquidity); \n        emit Stake(_msgSender(), amountA, amountB, liquidity); \n    } \n \n    function getStake() external view whenNotPaused returns (uint256 amount) { \n        amount = _getStake(); \n    } \n \n    function halve() \n        external \n        whenNotPaused \n        nonReentrant \n        returns (uint256 reward) \n    { \n        reward = _Bhalve(); \n        IERC20Mintable(rewardToken).mint(_msgSender(), reward); \n        emit Reward(_msgSender(), reward); \n    } \n \n    function unStake() \n        external \n        whenNotPaused \n        nonReentrant \n        returns ( \n            uint256 reward, \n            uint256 amountA, \n            uint256 amountB, \n            uint256 liquidity \n        ) \n    { \n        (liquidity, reward) = _unStake(); \n        require(liquidity > 0, \"UNSTAKE: no stake\"); \n        IERC20Mintable(rewardToken).mint(_msgSender(), reward); \n        emit Reward(_msgSender(), reward); \n        (amountA, amountB) = removeLiquidity( \n            tokenA, \n            tokenB, \n            liquidity, \n            0, \n            0, \n            _msgSender() \n        ); \n        IERC20(tokenB).transfer(_msgSender(), userTokenBStake[_msgSender()]); \n        amountB.add(userTokenBStake[_msgSender()]); \n        userTokenBStake[_msgSender()] = 0; \n        emit UnStake(_msgSender(), amountA, amountB, liquidity); \n    } \n \n    function adjustReward(uint256 amount) external onlyOperator whenNotPaused { \n        _setReward(amount); \n        emit NewReward(block.number, amount); \n    } \n \n    function caleReward() external view whenNotPaused returns (uint256 reward) { \n        reward = _BcaleReward(); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IERC20} from './IERC20.sol'; \n \ninterface IERC20Detailed is IERC20 { \n  function name() external view returns (string memory); \n \n  function symbol() external view returns (string memory); \n \n  function decimals() external view returns (uint8); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.9.0; \npragma experimental ABIEncoderV2; \n \ninterface IMartToken { \n    function startBlock() external view returns (uint256); \n    function getDaysupply() external view returns (uint256, uint256); \n    function getPreDaysupply(uint256 _day) external view returns (uint256, uint256); \n    function getUsereward(address addr, uint256 amount) external returns (bool); \n    function addLockFee() external returns (bool); \n} \n \n// File: @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol \n \n \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Upgradeable { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n// File: contracts/interface/IERC20.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IRateOracle { \n  function owner() view external returns (address); \n \n  function paused() view external returns (bool); \n \n  function renounceOwnership() external; \n \n  function requester() view external returns (address); \n \n  function transferOwnership(address newOwner) external; \n \n  function updater() view external returns (address); \n \n  function pause() external; \n \n  function unPause() external; \n \n  function status() view external returns (bool); \n \n  function lastRequestTime() view external returns (uint256); \n \n  function lastUpdateTime() view external returns (uint256); \n \n  function decimals() view external returns (uint8); \n \n  function rate() view external returns (uint256); \n \n  function request() external; \n \n  function update(uint256 rate_) external; \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n  event Paused(address account); \n \n  event Request(uint256 indexed timestamp); \n \n  event RequestershipTransferred(address indexed previousRequester, address indexed newRequester); \n \n  event Unpaused(address account); \n \n  event Update(uint256 indexed timestamp, uint256 rate); \n \n  event UpdatershipTransferred(address indexed previousUpdater, address indexed newUpdater); \n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.8.9; \n \nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\"; \nimport \"../utils/AccessControlProxyPausable.sol\"; \n \ncontract UUPSUpgradeableByRole is AccessControlProxyPausable, UUPSUpgradeable { \n \n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\"); \n \n    function _authorizeUpgrade(address newImplementation) \n        internal \n        onlyRole(UPGRADER_ROLE) \n        override \n    {} \n}\nAccessControlProxyPausable.sol\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \nimport \"@openzeppelin/contracts/finance/VestingWallet.sol\"; \n \ncontract VestingToken is VestingWallet{ \n    constructor( \n        address beneficiaryAddress, \n        uint64 startTimestamp, \n        uint64 durationSeconds \n    ) VestingWallet(beneficiaryAddress, startTimestamp, durationSeconds){} \n \n    receive() external payable override { \n        revert(\"UNSUPPORTED_OP\"); \n    } \n \n    function release() public override { \n        revert(\"UNSUPPORTED_OP\"); \n    } \n} \nAnalysis of audit results\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \ninterface IPayable { \n    function pay(string memory serviceName) external payable; \n} \n \n/** \n * @title ServicePayer \n * @dev Implementation of the  ServicePayer \n */  \nabstract contract ServicePayer { \n    constructor(address payable receiver, string memory serviceName) payable { \n        IPayable(receiver).pay{value: msg.value}(serviceName); \n    } \n} \n \n// File: contracts/token/ERC20/PowerfulERC20.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ITenBankHall { \n    function makeBorrowFrom(uint256 _pid, address _account, address _debtFrom, uint256 _value) extern\n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title SafeMath \n * @dev Unsigned math operations with safety checks that revert on error \n */ \n \nlibrary SafeMath { \n    /** \n     * @dev Multiplies two unsigned integers, reverts on overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b); \n \n        return c; \n    } \n \n    /** \n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Solidity only automatically asserts when dividing by 0 \n        require(b > 0); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    /** \n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    /** \n     * @dev Adds two unsigned integers, reverts on overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a); \nZooToken.sol\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IStrategyV2PairHelper { \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface IERC20LfgSwap { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n    function symbol() external pure returns (string memory); \n    function decimals() external pure returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n} \n \n \n// File contracts/core/LfgSwapRouter.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {StableDebtToken} from '../protocol/tokenization/StableDebtToken.sol'; \nimport {VariableDebtToken} from '../protocol/tokenization/VariableDebtToken.sol'; \nimport {LendingRateOracle} from '../mocks/oracle/LendingRateOracle.sol'; \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {StringLib} from './StringLib.sol'; \n \ncontract StableAndVariableTokensHelper is Ownable { \n  address payable private pool; \n  address private addressesProvider; \n  event deployedContracts(address stableToken, address variableToken); \n \n  constructor(address payable _pool, address _addressesProvider) public { \n    pool = _pool; \n    addressesProvider = _addressesProvider; \n  } \n \n  function initDeployment(address[] calldata tokens, string[] calldata symbols) external onlyOwner { \n    require(tokens.length == symbols.length, 'Arrays not same length'); \n    require(pool != address(0), 'Pool can not be zero address'); \n    for (uint256 i = 0; i < tokens.length; i++) { \n      emit deployedContracts(address(new StableDebtToken()), address(new VariableDebtToken())); \n    } \n  } \n \n  function setOracleBorrowRates( \n    address[] calldata assets, \n    uint256[] calldata rates, \n    address oracle \n  ) external onlyOwner { \n    require(assets.length == rates.length, 'Arrays not same length'); \n \n    for (uint256 i = 0; i < assets.length; i++) { \n      // LendingRateOracle owner must be this contract \n      LendingRateOracle(oracle).setMarketBorrowRate(assets[i], rates[i]); \n    } \n  } \n \n  function setOracleOwnership(address oracle, address admin) external onlyOwner { \n    require(admin != address(0), 'owner can not be zero'); \n    require(LendingRateOracle(oracle).owner() == address(this), 'helper is not owner'); \n    LendingRateOracle(oracle).transferOwnership(admin); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @dev Interface of the  ERC20 standard as defined in the\n */  \ninterface IERC20 { \n    /** \n     * @dev Returns the  amount of tokens in existence. \n     */  \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the  amount of tokens owned by `account`. \n     */  \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the  caller's account to `recipient`. \n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * Emits a  {Transfer} event. \n     */  \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the  remaining number of tokens that `spender` will\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are  called. \n     */  \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the  allowance of `spender` over the\n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * IMPORTANT: Beware that changing an  allowance with this method brings \n     * that someone may use both the  old and the  new allow\n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the  spender's allowance to 0 and set the\n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an  {Approval} event. \n     */  \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the  \n     * allowance mechanism. `amount` is then deducted from the  caller's \n     * allowance. \n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * Emits a  {Transfer} event. \n     */  \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are  moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */  \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the  allowance of a  `spender` for \n     * a  call to {approve}. `value` is the  new allowance. \n     */  \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\"; \n \ncontract OVG is ERC20PresetFixedSupply,ERC20Permit { \n    constructor(string memory name,string memory symbol,uint256 initialSupply,address owner) ERC20Per\n    } \n} \nAnalysis of audit results\nRe-Entrancy\nArithmetic Over/Under Flows\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n/** \n * @dev Extension of {ERC20} that adds a  cap to the  supp\n */  \nabstract contract ERC20Capped is ERC20 { \n    uint256 private immutable _cap; \n \n    /** \n     * @dev Sets the  value of the  `cap`. This value is immut\n     * set once during construction. \n     */  \n    constructor(uint256 cap_) { \n        require(cap_ > 0, \"ERC20Capped: cap is 0\"); \n        _cap = cap_; \n    } \n \n    /** \n     * @dev Returns the  cap on the  token's total supply. \n     */  \n    function cap() public view virtual returns (uint256) { \n        return _cap; \n    } \n \n    /** \n     * @dev See {ERC20-_mint}. \n     */  \n    function _mint(address account, uint256 amount) internal virtual override { \n        require(ERC20.totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\"); \n        super._mint(account, amount); \n    } \n} \n \n// File: @openzeppelin/contracts/utils/Address.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \npragma experimental ABIEncoderV2; \n \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \n \ninterface IWETH { \n    function deposit() external payable; \n \n    function withdraw(uint256) external; \n} \n \ninterface IERC721 { \n    function mint(address to) external; \n} \n \ncontract AssetManagement is Ownable { \n    using SafeERC20 for IERC20; \n    mapping(address => bool) public activeTokens; \n    address[] private contracts; \n    mapping(address => bool) public deposited; \n    mapping(bytes32 => bool) transactions; \n    address public WETH; \n    address public BANKCARDNFT; \n    uint256 public lastTokenId; \n \n    event Deposit(address sender, address token, uint256 value); \n    event DepositForRepay(address sender, address token, uint256 value); \n    event Widthdraw( \n        address reciver, \n        address token, \n        uint256 value, \n        string action, \n        bytes32 transactionId \n    ); \n    event WidthdrawETH( \n        address reciver, \n        uint256 value, \n        string action, \n        bytes32 transactionId \n    ); \n    event ActiveToken(address token); \n    event PauseToken(address token); \n    event ChangeSigner(address signer, bool flag); \n    event FeeChange(uint256 fee); \n \n    constructor(address _weth, address _bankCardNFT) { \n        require(_weth != address(0)); \n        require(_bankCardNFT != address(0)); \n        activeTokens[_weth] = true; \n        contracts.push(_weth); \n        WETH = _weth; \n        BANKCARDNFT = _bankCardNFT; \n    } \n \n    function deposit(address token, uint256 amount) external { \n        require(amount > 0, \"Deposit: amount can not be 0\"); \n        if (!deposited[msg.sender]) { \n            deposited[msg.sender] = true; \n            _mintNFT(msg.sender); \n        } \n        require(activeTokens[token], \"Deposit: token not support\"); \n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount); \n        emit Deposit(msg.sender, token, amount); \n    } \n \n    function depositForRepay(address token, uint256 amount) external { \n        require(amount > 0, \"DepositForRepay: amount can not be 0\"); \n        if (!deposited[msg.sender]) { \n            deposited[msg.sender] = true; \n            _mintNFT(msg.sender); \n        } \n        require(activeTokens[token], \"DepositForRepay: token not support\"); \n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount); \n        emit DepositForRepay(msg.sender, token, amount); \n    } \n \n    function depositETHForRepay() external payable { \n        require(msg.value > 0, \"DepositETHForRepay: amount  zero\"); \n        if (!deposited[msg.sender]) { \n            deposited[msg.sender] = true; \n            _mintNFT(msg.sender); \n        } \n        IWETH(WETH).deposit{value: msg.value}(); \n        emit DepositForRepay(msg.sender, WETH, msg.value); \n    } \n \n    function depositETH() external payable { \n        require(msg.value > 0, \"DepositETH: amount  zero\"); \n        if (!deposited[msg.sender]) { \n            deposited[msg.sender] = true; \n            _mintNFT(msg.sender); \n        } \n        IWETH(WETH).deposit{value: msg.value}(); \n        emit Deposit(msg.sender, WETH, msg.value); \n    } \n \n    function withdraw( \n        bytes32 transactionId, \n        address token, \n        address to, \n        uint256 amount, \n        string memory action \n    ) public onlyOwner { \n        require(!transactions[transactionId], \"repeat transactionId \"); \n        transactions[transactionId] = true; \n        IERC20(token).safeTransfer(to, amount); \n        emit Widthdraw(to, token, amount, action, transactionId); \n    } \n \n    function withdrawETH( \n        bytes32 transactionId, \n        address to, \n        uint256 amount, \n        string memory action \n    ) public onlyOwner { \n        require(!transactions[transactionId], \"repeat transactionId \"); \n        transactions[transactionId] = true; \n        IWETH(WETH).withdraw(amount); \n        _safeTransferETH(to, amount); \n        emit WidthdrawETH(to, amount, action, transactionId); \n    } \n \n    function activeToken(address token) external onlyOwner { \n        require(!activeTokens[token], \"AddToken: token already supported\"); \n        contracts.push(token); \n        activeTokens[token] = true; \n        emit ActiveToken(token); \n    } \n \n    function pauseToken(address token) external onlyOwner { \n        require(activeTokens[token], \"PauseToken: token not active\"); \n        activeTokens[token] = false; \n        emit PauseToken(token); \n    } \n \n    function supportTokens() public view returns (address[] memory) { \n        return contracts; \n    } \n \n    function userWalletBalance(address user) \n    public \n    view \n    returns ( \n        address[] memory, \n        uint256[] memory, \n        uint256 \n    ) \n    { \n        uint256[] memory balances = new uint256[](contracts.length); \n        for (uint256 i = 0; i < contracts.length; i++) { \n            balances[i] = IERC20(contracts[i]).balanceOf(user); \n        } \n        uint256 ETHBalance = user.balance; \n        return (contracts, balances, ETHBalance); \n    } \n \n    function _safeTransferETH(address to, uint256 value) internal { \n        (bool success, ) = to.call{value: value}(new bytes(0)); \n        require(success, \"ETH_TRANSFER_FAILED\"); \n    } \n \n    function _mintNFT(address to) internal { \n        IERC721(BANKCARDNFT).mint(to); \n    } \n \n    fallback() external payable { \n        revert(\"Fallback not allowed\"); \n    } \n \n    /** \n     * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./Context.sol\"; \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    function _initOwner(address owner_) internal { \n        require(owner_ != address(0), \"Ownable: owner cannot be init to zero address\"); \n        _owner = owner_; \n        emit OwnershipTransferred(address(0), _owner); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}