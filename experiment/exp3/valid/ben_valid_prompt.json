{"prompt": "pragma solidity ^0.8.0; \n \n \ncontract Roles is AccessControl { \n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER\"); \n \n    constructor() { \n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); \n        _setupRole(MINTER_ROLE, _msgSender()); \n    } \n \n    modifier onlyMinter() { \n        require(hasRole(MINTER_ROLE, _msgSender()), \"Roles: caller does not have the MINTER role\"); \n        _; \n    } \n} \n \n// File: contracts/service/ServicePayer.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./Context.sol\"; \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address _owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n}\nSafeBEP20.sol\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n// \n// \n//                    \u250c\u2500\u2510       \u250c\u2500\u2510 + + \n//                    \u250c\u2500\u2500\u2518 \u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2534\u2500\u2500\u2510++ \n//                    \u2502                 \u2502 \n//                    \u2502       \u2500\u2500\u2500       \u2502++ + + + \n//                    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502+ \n//                    \u2502                 \u2502+ \n//                    \u2502       \u2500\u2534\u2500       \u2502 \n//                    \u2502                 \u2502 \n//                    \u2514\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2518 \n//                    \u2502         \u2502 \n//                    \u2502         \u2502   + + \n//                    \u2502         \u2502 \n//                    \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \n//                    \u2502                        \u2502 \n//                    \u2502                        \u251c\u2500\u2510 \n//                    \u2502                        \u250c\u2500\u2518 \n//                    \u2502                        \u2502 \n//                    \u2514\u2500\u2510  \u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2510  \u250c\u2500\u2500\u2518  + + + + \n//                    \u2502 \u2500\u2524 \u2500\u2524       \u2502 \u2500\u2524 \u2500\u2524 \n//                    \u2514\u2500\u2500\u2534\u2500\u2500\u2518       \u2514\u2500\u2500\u2534\u2500\u2500\u2518  + + + + \n \n \nimport \"./BEP20.sol\"; \n \ncontract ZooToken is BEP20('Zoo', 'ZOO', 100000000000000000000000000000) { \n \n \nfunction getChainId() internal pure returns (uint) { \nuint256 chainId; \nassembly { chainId := chainid() } \nreturn chainId; \n} \n}\n \n        return c; \n    } \n \n    /** \n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo), \n     * reverts when dividing by zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b != 0); \n        return a % b; \n    } \n}\nAnalysis of audit results\nRe-Entrancy\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title SafeMath \n * @dev Unsigned math operations with safety checks that revert on error \n */ \n \nlibrary SafeMath { \n    /** \n     * @dev Multiplies two unsigned integers, reverts on overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b); \n \nZooToken.sol\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n// \n// \n//                    \u250c\u2500\u2510       \u250c\u2500\u2510 + + \n//                    \u250c\u2500\u2500\u2518 \u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2534\u2500\u2500\u2510++ \n//                    \u2502                 \u2502 \n//                    \u2502       \u2500\u2500\u2500       \u2502++ + + + \n//                    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502+ \n//                    \u2502                 \u2502+ \n//                    \u2502       \u2500\u2534\u2500       \u2502 \n//                    \u2502                 \u2502 \n//                    \u2514\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2518 \n//                    \u2502         \u2502 \n        return c; \n    } \n \n    /** \n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Solidity only automatically asserts when dividing by 0 \n        require(b > 0); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    /** \n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    /** \n     * @dev Adds two unsigned integers, reverts on overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a); \n \n        return c; \n    } \n \n    /** \n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo), \n     * reverts when dividing by zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b != 0); \n        return a % b; \n    } \n}\n//                    \u2502         \u2502   + + \n//                    \u2502         \u2502 \n//                    \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \n//                    \u2502                        \u2502 \n//                    \u2502                        \u251c\u2500\u2510 \n//                    \u2502                        \u250c\u2500\u2518 \n//                    \u2502                        \u2502 \n//                    \u2514\u2500\u2510  \u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2510  \u250c\u2500\u2500\u2518  + + + + \n//                    \u2502 \u2500\u2524 \u2500\u2524       \u2502 \u2500\u2524 \u2500\u2524 \n//                    \u2514\u2500\u2500\u2534\u2500\u2500\u2518       \u2514\u2500\u2500\u2534\u2500\u2500\u2518  + + + + \n \n \nimport \"./BEP20.sol\"; \n \ncontract ZooToken is BEP20('Zoo', 'ZOO', 100000000000000000000000000000) { \n \n \nfunction getChainId() internal pure returns (uint) { \nuint256 chainId; \nassembly { chainId := chainid() } \nreturn chainId; \n} \n}\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ncontract VariableDebtToken is DebtTokenBase, IVariableDebtToken { \n  using WadRayMath for uint256; \n \n  uint256 public constant DEBT_TOKEN_REVISION = 0x1; \n \n  ILendingPool internal _pool; \n  address internal _underlyingAsset; \n  IAaveIncentivesController internal _incentivesController; \n \n  function initialize( \n    ILendingPool pool, \n    address underlyingAsset, \n    IAaveIncentivesController incentivesController, \n    uint8 debtTokenDecimals, \n    string memory debtTokenName, \n    string memory debtTokenSymbol, \n    bytes calldata params \n  ) public override initializer { \n    _setName(debtTokenName); \n    _setSymbol(debtTokenSymbol); \n    _setDecimals(debtTokenDecimals); \n \n    _pool = pool; \n    _underlyingAsset = underlyingAsset; \n    _incentivesController = incentivesController; \n \n    emit Initialized( \n      underlyingAsset, \n      address(pool), \n      address(incentivesController), \n      debtTokenDecimals, \n      debtTokenName, \n      debtTokenSymbol, \n      params \n    ); \n  } \n\n  function getRevision() internal pure virtual override returns (uint256) { \n    return DEBT_TOKEN_REVISION; \n  } \n \n  function balanceOf(address user) public view virtual override returns (uint256) { \n    uint256 scaledBalance = super.balanceOf(user); \n \n    if (scaledBalance == 0) { \n      return 0; \n    } \n \n    return scaledBalance.rayMul(_pool.getReserveNormalizedVariableDebt(_underlyingAsset)); \n  } \n \n  function mint( \n    address user, \n    address onBehalfOf, \n    uint256 amount, \n    uint256 index \n  ) external override onlyLendingPool returns (bool) { \n    if (user != onBehalfOf) { \n      _decreaseBorrowAllowance(onBehalfOf, user, amount); \n    } \n \n    uint256 previousBalance = super.balanceOf(onBehalfOf); \n    uint256 amountScaled = amount.rayDiv(index); \n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT); \n \n    _mint(onBehalfOf, amountScaled); \n \n    emit Transfer(address(0), onBehalfOf, amount); \n    emit Mint(user, onBehalfOf, amount, index); \n \n    return previousBalance == 0; \n  } \n \n  function burn( \n    address user, \n    uint256 amount, \n    uint256 index \n  ) external override onlyLendingPool { \n    uint256 amountScaled = amount.rayDiv(index); \n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT); \n \n    _burn(user, amountScaled); \n \n    emit Transfer(user, address(0), amount); \n    emit Burn(user, amount, index); \n  } \n \n  function scaledBalanceOf(address user) public view virtual override returns (uint256) { \n    return super.balanceOf(user); \n  } \n \n  function totalSupply() public view virtual override returns (uint256) { \n    return super.totalSupply().rayMul(_pool.getReserveNormalizedVariableDebt(_underlyingAsset)); \n  } \n \n  /** \n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index) \n   * @return the scaled total supply \n   **/ \n  function scaledTotalSupply() public view virtual override returns (uint256) { \n    return super.totalSupply(); \n  } \n \n  function getScaledUserBalanceAndSupply(address user) \n    external \n    view \n    override \n    returns (uint256, uint256) \n  { \n    return (super.balanceOf(user), super.totalSupply()); \n  } \n \n  function UNDERLYING_ASSET_ADDRESS() public view returns (address) { \n    return _underlyingAsset; \n  } \n \n  function getIncentivesController() external view override returns (IAaveIncentivesController) { \n    return _getIncentivesController(); \n  } \n  function POOL() public view returns (ILendingPool) { \n    return _pool; \n  } \n \n  function _getIncentivesController() internal view override returns (IAaveIncentivesController) { \n    return _incentivesController; \n  } \n \n  function _getUnderlyingAssetAddress() internal view override returns (address) { \n    return _underlyingAsset; \n  } \n \n  function _getLendingPool() internal view override returns (ILendingPool) { \n    return _pool; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nlibrary SafeMath { \n\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nlibrary SafeMath { \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            uint256 c = a + b; \n            if (c < a) return (false, 0); \n            return (true, c); \n        } \n    } \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            if (b > a) return (false, 0); \n            return (true, a - b); \n        } \n    } \n\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            if (a == 0) return (true, 0); \n            uint256 c = a * b; \n            if (c / a != b) return (false, 0); \n            return (true, c); \n        } \n    } \n \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            if (b == 0) return (false, 0); \n            return (true, a / b); \n        } \n    } \n\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            if (b == 0) return (false, 0); \n            return (true, a % b); \n        } \n    } \n \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a + b; \n    } \n \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a - b; \n    } \n \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a * b; \n    } \n \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a / b; \n    } \n \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a % b; \n    } \n \n    function sub( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        unchecked { \n            require(b <= a, errorMessage); \n            return a - b; \n        } \n    } \n \n    function div( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        unchecked { \n            require(b > 0, errorMessage); \n            return a / b; \n        } \n    } \n \n    function mod( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        unchecked { \n            require(b > 0, errorMessage); \n            return a % b; \n        } \n    } \n} \n \n \n// File contracts/IBep20.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \ncontract WETHGateway is IWETHGateway, Ownable { \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n  using UserConfiguration for DataTypes.UserConfigurationMap; \n \n  IWETH internal immutable WETH; \n \n  constructor(address weth) public { \n    WETH = IWETH(weth); \n  } \n \n  function authorizeLendingPool(address lendingPool) external onlyOwner { \n    WETH.approve(lendingPool, uint256(-1)); \n  } \n \n   \n  function depositETH( \n    address lendingPool, \n    address onBehalfOf, \n    uint16 referralCode \n  ) external payable override { \n    WETH.deposit{value: msg.value}(); \n    ILendingPool(lendingPool).deposit(address(WETH), msg.value, onBehalfOf, referralCode); \n  } \n\n  function withdrawETH( \n    address lendingPool, \n    uint256 amount, \n    address to \n  ) external override { \n    IAToken aWETH = IAToken(ILendingPool(lendingPool).getReserveData(address(WETH)).aTokenAddress); \n    uint256 userBalance = aWETH.balanceOf(msg.sender); \n    uint256 amountToWithdraw = amount; \n\n    if (amount == type(uint256).max) { \n      amountToWithdraw = userBalance; \n    } \n    aWETH.transferFrom(msg.sender, address(this), amountToWithdraw); \n    ILendingPool(lendingPool).withdraw(address(WETH), amountToWithdraw, address(this)); \n    WETH.withdraw(amountToWithdraw); \n    _safeTransferETH(to, amountToWithdraw); \n  } \n \n  function repayETH( \n    address lendingPool, \n    uint256 amount, \n    uint256 rateMode, \n    address onBehalfOf \n  ) external payable override { \n    (uint256 stableDebt, uint256 variableDebt) = \n      Helpers.getUserCurrentDebtMemory( \n        onBehalfOf, \n        ILendingPool(lendingPool).getReserveData(address(WETH)) \n      ); \n \n    uint256 paybackAmount = \n      DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE \n        ? stableDebt \n        : variableDebt; \n \n    if (amount < paybackAmount) { \n      paybackAmount = amount; \n    } \n    require(msg.value >= paybackAmount, 'msg.value is less than repayment amount'); \n    WETH.deposit{value: paybackAmount}(); \n    ILendingPool(lendingPool).repay(address(WETH), msg.value, rateMode, onBehalfOf); \n \n    // refund remaining dust eth \n    if (msg.value > paybackAmount) _safeTransferETH(msg.sender, msg.value - paybackAmount); \n  } \n \n  function borrowETH( \n    address lendingPool, \n    uint256 amount, \n    uint256 interesRateMode, \n    uint16 referralCode \n  ) external override { \n    ILendingPool(lendingPool).borrow( \n      address(WETH), \n      amount, \n      interesRateMode, \n      referralCode, \n      msg.sender \n    ); \n    WETH.withdraw(amount); \n    _safeTransferETH(msg.sender, amount); \n  } \n \n   \n  function _safeTransferETH(address to, uint256 value) internal { \n    (bool success, ) = to.call{value: value}(new bytes(0)); \n    require(success, 'ETH_TRANSFER_FAILED'); \n  } \n \n  function emergencyTokenTransfer( \n    address token, \n    address to, \n    uint256 amount \n  ) external onlyOwner { \n    IERC20(token).transfer(to, amount); \n  } \n \n  function emergencyEtherTransfer(address to, uint256 amount) external onlyOwner { \n    _safeTransferETH(to, amount); \n  } \n \n  function getWETHAddress() external view returns (address) { \n    return address(WETH); \n  } \n \n\n  receive() external payable { \n    require(msg.sender == address(WETH), 'Receive not allowed'); \n  } \n \n\n  fallback() external payable { \n    revert('Fallback not allowed'); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \nabstract contract AccessControl is Context, IAccessControl, ERC165 { \n    struct RoleData { \n        mapping(address => bool) members; \n        bytes32 adminRole; \n    } \n \n    mapping(bytes32 => RoleData) private _roles; \n \n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00; \n \n    modifier onlyRole(bytes32 role) { \n        _checkRole(role, _msgSender()); \n        _; \n    } \n       \n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { \n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId\n    } \n \n      \n    function hasRole(bytes32 role, address account) public view override returns (bool) { \n        return _roles[role].members[account]; \n    } \n      \n    function _checkRole(bytes32 role, address account) internal view { \n        if (!hasRole(role, account)) { \n            revert( \n                string( \n                    abi.encodePacked( \n                        \"AccessControl: account \", \n                        Strings.toHexString(uint160(account), 20), \n                        \" is missing role \", \n                        Strings.toHexString(uint256(role), 32) \n                    ) \n                ) \n            ); \n        } \n    } \n \n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) { \n        return _roles[role].adminRole; \n    } \n \n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(r\n        _grantRole(role, account); \n    } \n \n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(\n        _revokeRole(role, account); \n    } \n \n    function renounceRole(bytes32 role, address account) public virtual override { \n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\"); \n \n        _revokeRole(role, account); \n    } \n\n    function _setupRole(bytes32 role, address account) internal virtual { \n        _grantRole(role, account); \n    } \n \n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual { \n        bytes32 previousAdminRole = getRoleAdmin(role); \n        _roles[role].adminRole = adminRole; \n        emit RoleAdminChanged(role, previousAdminRole, adminRole); \n    } \n \n    function _grantRole(bytes32 role, address account) private { \n        if (!hasRole(role, account)) { \n            _roles[role].members[account] = true; \n            emit RoleGranted(role, account, _msgSender()); \n        } \n    } \n \n    function _revokeRole(bytes32 role, address account) private { \n        if (hasRole(role, account)) { \n            _roles[role].members[account] = false; \n            emit RoleRevoked(role, account, _msgSender()); \n        } \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}