{"prompt": "pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface ERC20Interface {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20Base is ERC20Interface {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    // constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n    uint256 public _totalSupply;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (_balances[msg.sender] >= _value && _value > 0) {\r\n            _balances[msg.sender] -= _value;\r\n            _balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\r\n            _balances[_to] += _value;\r\n            _balances[_from] -= _value;\r\n            _allowances[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        _allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return _allowances[_owner][_spender];\r\n    }\r\n    \r\n    function totalSupply() public view returns (uint256 total) {\r\n        return _totalSupply;\r\n    }\r\n}\r\n\r\ncontract ProMind is ERC20Base {\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    \r\n    constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n        _totalSupply = initialSupply *  10  ** uint256(decimals);\r\n        _balances[msg.sender] = initialSupply  *  10  ** uint256(decimals);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract ElonTweets is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Elon Tweets\";\r\n    string public constant symbol = \"ELONT \ud83d\udc26\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n/// @return total amount of tokens\r\nfunction totalSupply() constant returns (uint256 supply) {}\r\n\r\n/// @param _owner The address from which the balance will be retrieved\r\n/// @return The balance\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n/// @notice send `_value` token to `_to` from `msg.sender`\r\n/// @param _to The address of the recipient\r\n/// @param _value The amount of token to be transferred\r\n/// @return Whether the transfer was successful or not\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n/// @param _from The address of the sender\r\n/// @param _to The address of the recipient\r\n/// @param _value The amount of token to be transferred\r\n/// @return Whether the transfer was successful or not\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n/// @param _spender The address of the account able to transfer the tokens\r\n/// @param _value The amount of wei to be approved for transfer\r\n/// @return Whether the approval was successful or not\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n/// @param _owner The address of the account owning tokens\r\n/// @param _spender The address of the account able to transfer the tokens\r\n/// @return Amount of remaining tokens allowed to spent\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {\r\n//Default assumes totalSupply can't be over max (2^256 - 1).\r\n//If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n//Replace the if with this one instead.\r\n//if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\nif (balances[msg.sender] >= _value && _value > 0) {\r\nbalances[msg.sender] -= _value;\r\nbalances[_to] += _value;\r\nTransfer(msg.sender, _to, _value);\r\nreturn true;\r\n} else { return false; }\r\n}\r\n\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n//same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n//if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\nif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\nbalances[_to] += _value;\r\nbalances[_from] -= _value;\r\nallowed[_from][msg.sender] -= _value;\r\nTransfer(_from, _to, _value);\r\nreturn true;\r\n} else { return false; }\r\n}\r\n\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\nreturn balances[_owner];\r\n}\r\n\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {\r\nallowed[msg.sender][_spender] = _value;\r\nApproval(msg.sender, _spender, _value);\r\nreturn true;\r\n}\r\n\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\nreturn allowed[_owner][_spender];\r\n}\r\n\r\nmapping (address => uint256) balances;\r\nmapping (address => mapping (address => uint256)) allowed;\r\nuint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract ERC20Token is StandardToken {\r\n\r\nfunction () {\r\n//if ether is sent to this address, send it back.\r\nthrow;\r\n}\r\n\r\n/* Public variables of the token */\r\n\r\n/*\r\nNOTE:\r\nThe following variables are OPTIONAL vanities. One does not have to include them.\r\nThey allow one to customise the token contract & in no way influences the core functionality.\r\nSome wallets/interfaces might not even bother to look at this information.\r\n*/\r\nstring public name; //fancy name: eg Simon Bucks\r\nuint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\nstring public symbol; //An identifier: eg SBX\r\nstring public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\nfunction ERC20Token(\r\n) {\r\nbalances[msg.sender] = 1000; // Give the creator all initial tokens (100000 for example)\r\ntotalSupply = 1000; // Update total supply (100000 for example)\r\nname = \"Cryptogate\"; // Set the name for display purposes\r\ndecimals = 0; // Amount of decimals for display purposes\r\nsymbol = \"CG\"; // Set the symbol for display purposes\r\n}\r\n\r\n/* Approves and then calls the receiving contract */\r\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\nallowed[msg.sender][_spender] = _value;\r\nApproval(msg.sender, _spender, _value);\r\n\r\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n//receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n//it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\nreturn true;\r\n}\r\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\ncontract Arzdigital {\r\n/// @return total amount of tokens\r\n function totalSupply() constant returns (uint256 supply) {}\r\n/// @param _owner The address from which the balance will be retrieved\r\n /// @return The balance\r\n function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n/// @notice send `_value` token to `_to` from `msg.sender`\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transfer(address _to, uint256 _value) returns (bool success) {}\r\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n /// @param _from The address of the sender\r\n /// @param _to The address of the recipient\r\n /// @param _value The amount of token to be transferred\r\n /// @return Whether the transfer was successful or not\r\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @param _value The amount of wei to be approved for transfer\r\n /// @return Whether the approval was successful or not\r\n function approve(address _spender, uint256 _value) returns (bool success) {}\r\n/// @param _owner The address of the account owning tokens\r\n /// @param _spender The address of the account able to transfer the tokens\r\n /// @return Amount of remaining tokens allowed to spent\r\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n \r\n}\r\ncontract StandardToken is Arzdigital {\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {\r\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\r\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\r\n //Replace the if with this one instead.\r\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[msg.sender] >= _value && _value > 0) {\r\n balances[msg.sender] -= _value;\r\n balances[_to] += _value;\r\n Transfer(msg.sender, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n balances[_to] += _value;\r\n balances[_from] -= _value;\r\n allowed[_from][msg.sender] -= _value;\r\n Transfer(_from, _to, _value);\r\n return true;\r\n } else { return false; }\r\n }\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\n return balances[_owner];\r\n }\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);\r\n return true;\r\n }\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n return allowed[_owner][_spender];\r\n }\r\nmapping (address => uint256) balances;\r\n mapping (address => mapping (address => uint256)) allowed;\r\n uint256 public totalSupply;\r\n}\r\n//name this contract whatever you\u2019d like\r\ncontract Token is StandardToken {\r\nfunction () {\r\n //if ether is sent to this address, send it back.\r\n throw;\r\n }\r\n/* Public variables of the token */\r\n/*\r\n NOTE:\r\n The following variables are OPTIONAL vanities. One does not have to include them.\r\n They allow one to customise the token contract & in no way influences the core functionality.\r\n Some wallets/interfaces might not even bother to look at this information.\r\n */\r\n string public name; //fancy name: eg Simon Bucks\r\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It\u2019s like comparing 1 wei to 1 ether.\r\n string public symbol; //An identifier: eg SBX\r\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\r\n//\r\n// \u0628\u0631\u0627\u06cc \u062a\u0648\u06a9\u0646 \u062e\u0648\u062f \u0645\u0642\u062f\u0627\u0631\u0647\u0627\u06cc \u0632\u06cc\u0631 \u0631\u0627 \u062a\u063a\u06cc\u06cc\u0631 \u062f\u0647\u06cc\u062f\r\n//\r\n//make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\nfunction Token(\r\n ) {\r\n balances[msg.sender] = 1000000000000; // \u062a\u0645\u0627\u0645 \u062a\u0648\u06a9\u0646\u0647\u0627\u06cc \u0633\u0627\u062e\u062a\u0647 \u0634\u062f\u0647 \u0633\u0627\u0632\u0646\u062f\u0647 \u0628\u0631\u0633\u062f -\u0639\u062f\u062f\u06cc \u0648\u0627\u0631\u062f \u06a9\u0646\u06cc\u062f \u0645\u062b\u0644\u0627 100000\r\n totalSupply = 1000000000000; // \u062a\u0645\u0627\u0645 \u0639\u0631\u0636\u0647\r\n name = 'HAZEM & AMIR'; // \u0646\u0627\u0645 \u062a\u0648\u06a9\u0646\r\n decimals = 5; // \u0627\u0639\u0634\u0627\u0631\r\n symbol = 'HMR'; // \u0646\u0645\u0627\u062f \u062a\u0648\u06a9\u0646\r\n }\r\n/* Approves and then calls the receiving contract */\r\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n allowed[msg.sender][_spender] = _value;\r\n Approval(msg.sender, _spender, _value);\r\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\r\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n if(!_spender.call(bytes4(bytes32(sha3('receiveApproval(address,uint256,address,bytes)'))), msg.sender, _value, this, _extraData)) { throw; }\r\n return true;\r\n }\r\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n    /// @return total amount of tokens\r\n    function totalSupply() constant public returns (uint256 supply) {}\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) view public returns (uint256 balance) {}\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success) { return true; }\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { return true;}\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success) { return true; }\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    \r\n}\r\n\r\n\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) constant public returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    uint256 public totalSupply;\r\n}\r\n\r\n\r\n//name this contract whatever you'd like\r\ncontract Papillon is StandardToken {\r\n\r\n    function () public {\r\n        //if ether is sent to this address, send it back.\r\n        revert();\r\n    }\r\n\r\n    /* Public variables of the token */\r\n\r\n    /*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets/interfaces might not even bother to look at this information.\r\n    */\r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme.\r\n\r\n//\r\n// CHANGE THESE VALUES FOR YOUR TOKEN\r\n//\r\n\r\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\r\n\r\n    constructor() public {\r\n        balances[msg.sender] = 1000000000000000000000000000000000;               // Give the creator all initial tokens (100000 for example)\r\n        totalSupply = 1000000000000000000000000000000000;                        // Update total supply (100000 for example)\r\n        name = \"Papillon\";                                   // Set the name for display purposes\r\n        decimals = 18;                            // Amount of decimals for display purposes\r\n        symbol = \"PAPI\";                               // Set the symbol for display purposes\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n        if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\r\n        return true;\r\n    }\r\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}