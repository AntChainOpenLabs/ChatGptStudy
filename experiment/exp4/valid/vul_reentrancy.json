{"prompt": "pragma solidity =0.7.6;\ncontract BathToken {\n using SafeMath for uint256;\n bool public initialized;\n string public symbol;\n string public name;\n uint8 public decimals;\n address public RubiconMarketAddress;\n address public bathHouse;\n address public feeTo;\n IERC20 public underlyingToken;\n uint256 public feeBPS;\n uint256 public totalSupply;\n uint256 public outstandingAmount;\n uint256[] deprecatedStorageArray; \n mapping(uint256 => uint256) deprecatedMapping; \n mapping(address => uint256) public balanceOf;\n mapping(address => mapping(address => uint256)) public allowance;\n bytes32 public DOMAIN_SEPARATOR;\n bytes32 public constant PERMIT_TYPEHASH =\n  0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n mapping(address => uint256) public nonces;\n address[] public bonusTokens;\n IBathBuddy public rewardsVestingWallet;\n function initialize(\n  ERC20 token,\n  address market,\n  address _feeTo\n ) external {\n  require(!initialized);\n  string memory _symbol = string(\nabi.encodePacked((\"bath\"), token.symbol())\n  );\n  symbol = _symbol;\n  underlyingToken = token;\n  RubiconMarketAddress = market;\n  bathHouse = msg.sender; //NOTE: assumed admin is creator on BathHouse\n\n  uint256 chainId;\n  assembly {\nchainId := chainid()\n  }\n  DOMAIN_SEPARATOR = keccak256(\nabi.encode(\n keccak256(\n  \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n ),\n keccak256(bytes(name)),\n keccak256(bytes(\"1\")),\n chainId,\n address(this)\n)\n  );\n  name = string(abi.encodePacked(_symbol, (\" v1\")));\n  decimals = token.decimals(); // v1 Change - 4626 Adherence\n\n  // Add infinite approval of Rubicon Market for this asset\n  IERC20(address(token)).approve(RubiconMarketAddress, 2**256 - 1);\n  emit LogInit(block.timestamp);\n\n  feeTo = address(this); /\n  feeBPS = 3; \n  initialized = true;\n }\n modifier onlyPair() {\n  require(\nIBathHouse(bathHouse).isApprovedPair(msg.sender) == true,\n\"not an approved pair - bathToken\"\n  );\n  _;\n }\n modifier onlyBathHouse() {\n  require(\nmsg.sender == bathHouse,\n\"caller is not bathHouse - BathToken.sol\"\n  );\n  _;\n }\n function permit(\n  address owner,\n  address spender,\n  uint256 value,\n  uint256 deadline,\n  uint8 v,\n  bytes32 r,\n  bytes32 s\n ) external {\n  require(deadline >= block.timestamp, \"bathToken: EXPIRED\");\n  bytes32 digest = keccak256(\nabi.encodePacked(\n \"\\x19\\x01\",\n DOMAIN_SEPARATOR,\n keccak256(\n  abi.encode(\nPERMIT_TYPEHASH,\nowner,\nspender,\nvalue,\nnonces[owner]++,\ndeadline\n  )\n )\n)\n  );\n  address recoveredAddress = ecrecover(digest, v, r, s);\n  require(\nrecoveredAddress != address(0) && recoveredAddress == owner,\n\"bathToken: INVALID_SIGNATURE\"\n  );\n  _approve(owner, spender, value);\n }\n\n function underlyingERC20() external view returns (address) {\n  return address(underlyingToken);\n }\n\n function underlyingBalance() public view returns (uint256) {\n  uint256 _pool = IERC20(underlyingToken).balanceOf(address(this));\n  return _pool.add(outstandingAmount);\n }\n}\n\n###\n\n", "completion": "yes,Reentrancy###\n###"}
{"prompt": "pragma solidity 0.8.10;\ncontract MIMOAutoRebalance is MIMOAutoAction, MIMOFlashloan, IMIMOAutoRebalance {\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  address public immutable mimoRebalance;\n  constructor(\n IAddressProvider _a,\n IPool _lendingPool,\n IMIMOProxyRegistry _proxyRegistry,\n address _mimoRebalance\n  ) MIMOAutoAction(_a, _proxyRegistry) MIMOFlashloan(_lendingPool) {\n if (_mimoRebalance == address(0)) {\nrevert CustomErrors.CANNOT_SET_TO_ADDRESS_ZERO();\n }\n mimoRebalance = _mimoRebalance;\n  }\n\n  function rebalance(uint256 vaultId, IMIMOSwap.SwapData calldata swapData) external override {\n AutomatedVault memory autoVault = _automatedVaults[vaultId];\n\n (uint256 vaultARatioBefore, VaultState memory vaultAState) = _getVaultStats(vaultId);\n\n _preRebalanceChecks(autoVault, vaultId, vaultARatioBefore);\n\n IVaultsDataProvider vaultsData = a.vaultsData();\n address vaultOwner = vaultsData.vaultOwner(vaultId);\n uint256 vaultBId = vaultsData.vaultId(address(autoVault.toCollateral), vaultOwner);\n uint256 vaultBBalanceBefore = vaultsData.vaultCollateralBalance(vaultBId);\n\n (IMIMORebalance.RebalanceData memory rbData, FlashLoanData memory flData, uint256 autoFee) = _getRebalanceParams(\nautoVault,\nvaultAState,\nIERC20(autoVault.toCollateral),\nvaultId\n );\n\n _takeFlashLoan(flData, abi.encode(vaultOwner, autoFee, rbData, swapData));\n _postRebalanceChecks(autoVault, flData.amount, vaultBBalanceBefore, vaultId, vaultOwner, vaultsData);\n\n _operationTracker[vaultId] = block.timestamp;\n\n IERC20(a.stablex()).safeTransfer(msg.sender, autoFee);\n  }\n\n  function executeOperation(\n address[] calldata assets,\n uint256[] calldata amounts,\n uint256[] calldata premiums,\n address initiator,\n bytes calldata params\n  ) external override returns (bool) {\n (\naddress mimoProxy,\nuint256 managerFee,\nIMIMORebalance.RebalanceData memory rbData,\nIMIMOSwap.SwapData memory swapData\n ) = abi.decode(params, (address, uint256, IMIMORebalance.RebalanceData, IMIMOSwap.SwapData));\n\n if (initiator != address(this)) {\nrevert CustomErrors.INITIATOR_NOT_AUTHORIZED(initiator, address(this));\n }\n if (msg.sender != address(lendingPool)) {\nrevert CustomErrors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n }\n\n IERC20 fromCollateral = IERC20(assets[0]);\n uint256 amount = amounts[0];\n fromCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n\n IMIMOProxy(mimoProxy).execute(\nmimoRebalance,\nabi.encodeWithSignature(\n  \"rebalanceOperation(address,uint256,uint256,uint256,(address,uint256,uint256),(uint256,bytes))\",\n  fromCollateral,\n  amount,\n  flashloanRepayAmount,\n  managerFee,\n  rbData,\n  swapData\n)\n );\n\n fromCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n return true;\n  }\n\n  function _getAmounts(\n AutomatedVault memory autoVault,\n VaultState memory vaultState,\n address toCollateral\n  )\n internal\n view\n returns (\nuint256 rebalanceAmount,\nuint256 mintAmount,\nuint256 autoFee\n )\n  {\n IAddressProvider _a = a;\n\n uint256 targetRatio = autoVault.targetRatio + 1e15; // add 0.1% to account for rounding\n uint256 toVaultMcr = _a.config().collateralMinCollateralRatio(address(toCollateral));\n uint256 rebalanceValue = (targetRatio.wadMul(vaultState.vaultDebt + autoVault.fixedFee) -\nvaultState.collateralValue).wadDiv(\n  (targetRatio.wadDiv(toVaultMcr + autoVault.mcrBuffer) - targetRatio.wadMul(autoVault.varFee) - WadRayMath.WAD)\n);\n autoFee = autoVault.fixedFee + rebalanceValue.wadMul(autoVault.varFee);\n rebalanceAmount = _a.priceFeed().convertTo(vaultState.collateralType, rebalanceValue);\n mintAmount = rebalanceValue.wadDiv(toVaultMcr + autoVault.mcrBuffer) - autoFee;\n  }\n  function _preRebalanceChecks(\n AutomatedVault memory autoVault,\n uint256 vaultId,\n uint256 vaultARatio\n  ) internal view {\n if (!autoVault.isAutomated) {\nrevert CustomErrors.VAULT_NOT_AUTOMATED();\n }\n if (_operationTracker[vaultId] > block.timestamp - 1 days) {\nrevert CustomErrors.MAX_OPERATIONS_REACHED();\n }\n if (vaultARatio > autoVault.triggerRatio) {\nrevert CustomErrors.VAULT_TRIGGER_RATIO_NOT_REACHED(vaultARatio, autoVault.triggerRatio);\n }\n  }\n}\n\n###\n\n", "completion": "yes,Reentrancy###\n###"}
{"prompt": "pragma solidity ^0.8.13;\ncontract Market {\n\n address public gov;\n address public lender;\n address public pauseGuardian;\n address public immutable escrowImplementation;\n IDolaBorrowingRights public immutable dbr;\n IBorrowController public borrowController;\n IERC20 public immutable dola = IERC20(0x865377367054516e17014CcdED1e7d814EDC9ce4);\n IERC20 public immutable collateral;\n IOracle public oracle;\n uint public collateralFactorBps;\n uint public replenishmentIncentiveBps;\n uint public liquidationIncentiveBps;\n uint public liquidationFeeBps;\n uint public liquidationFactorBps = 5000; // 50% by default\n bool immutable callOnDepositCallback;\n bool public borrowPaused;\n uint public totalDebt;\n uint256 internal immutable INITIAL_CHAIN_ID;\n bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n mapping (address => IEscrow) public escrows; // user => escrow\n mapping (address => uint) public debts; // user => debt\n mapping(address => uint256) public nonces; // user => nonce\n constructor (\n  address _gov,\n  address _lender,\n  address _pauseGuardian,\n  address _escrowImplementation,\n  IDolaBorrowingRights _dbr,\n  IERC20 _collateral,\n  IOracle _oracle,\n  uint _collateralFactorBps,\n  uint _replenishmentIncentiveBps,\n  uint _liquidationIncentiveBps,\n  bool _callOnDepositCallback\n ) {\n  require(_collateralFactorBps < 10000, \"Invalid collateral factor\");\n  require(_liquidationIncentiveBps > 0 && _liquidationIncentiveBps < 10000, \"Invalid liquidation incentive\");\n  require(_replenishmentIncentiveBps < 10000, \"Replenishment incentive must be less than 100%\");\n  gov = _gov;\n  lender = _lender;\n  pauseGuardian = _pauseGuardian;\n  escrowImplementation = _escrowImplementation;\n  dbr = _dbr;\n  collateral = _collateral;\n  oracle = _oracle;\n  collateralFactorBps = _collateralFactorBps;\n  replenishmentIncentiveBps = _replenishmentIncentiveBps;\n  liquidationIncentiveBps = _liquidationIncentiveBps;\n  callOnDepositCallback = _callOnDepositCallback;\n  INITIAL_CHAIN_ID = block.chainid;\n  INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n }\n modifier onlyGov {\n  require(msg.sender == gov, \"Only gov can call this function\");\n  _;\n }\n function withdrawInternal(address from, address to, uint amount) internal {\n  uint limit = getWithdrawalLimitInternal(from);\n  require(limit >= amount, \"Insufficient withdrawal limit\");\n  IEscrow escrow = getEscrow(from);\n  escrow.pay(to, amount);\n  emit Withdraw(from, to, amount);\n }\n function withdraw(uint amount) public {\n  withdrawInternal(msg.sender, msg.sender, amount);\n }\n function withdrawOnBehalf(address from, uint amount, uint deadline, uint8 v, bytes32 r, bytes32 s) public {\n  require(deadline >= block.timestamp, \"DEADLINE_EXPIRED\");\n  unchecked {\naddress recoveredAddress = ecrecover(\n keccak256(\n  abi.encodePacked(\n\"\\x19\\x01\",\nDOMAIN_SEPARATOR(),\nkeccak256(\n abi.encode(\n  keccak256(\n\"WithdrawOnBehalf(address caller,address from,uint256 amount,uint256 nonce,uint256 deadline)\"\n  ),\n  msg.sender,\n  from,\n  amount,\n  nonces[from]++,\n  deadline\n )\n)\n  )\n ),\n v,\n r,\n s\n);\nrequire(recoveredAddress != address(0) && recoveredAddress == from, \"INVALID_SIGNER\");\nwithdrawInternal(from, msg.sender, amount);\n  }\n }\n\n}\n\n###\n\n", "completion": "yes,Reentrancy###\n###"}
{"prompt": "pragma solidity ^0.8.13;\ncontract LiquidStakingManager is ILiquidStakingManager, Initializable, ReentrancyGuard, StakehouseAPI {\n event WhitelistingStatusChanged(address indexed dao, bool updatedStatus);\n event NodeRunnerWhitelistingStatusChanged(address indexed nodeRunner, bool updatedStatus);\n event SmartWalletCreated(address indexed smartWallet, address indexed nodeRunner);\n event RepresentativeAppointed(address indexed smartWallet, address indexed eoaRepresentative);\n event WalletCredited(address indexed smartWallet, uint256 amount);\n event KnotStaked(bytes _blsPublicKeyOfKnot, address indexed trigerringAddress);\n event StakehouseCreated(string stakehouseTicker, address indexed stakehouse);\n event StakehouseJoined(bytes blsPubKey);\n event RepresentativeRemoved(address indexed smartWallet, address indexed eoaRepresentative);\n event DormantRepresentative(address indexed associatedSmartWallet, address representative);\n event ETHWithdrawnFromSmartWallet(address indexed associatedSmartWallet, bytes blsPublicKeyOfKnot, address nodeRunner);\n event NetworkTickerUpdated(string newTicker);\n event NodeRunnerRewardsClaimed(address indexed nodeRunner, address indexed recipient);\n event NodeRunnerOfSmartWalletRotated(address indexed wallet, address indexed oldRunner, address indexed newRunner);\n event NodeRunnerBanned(address indexed nodeRunner);\n event UpdateDAOAddress(address indexed oldAddress, address indexed newAddress);\n event DAOCommissionUpdated(uint256 old, uint256 newCommission);\n event NewLSDValidatorRegistered(address indexed nodeRunner, bytes blsPublicKey);\n address public brand;\n address public override stakehouse;\n address public syndicate;\n address public dao;\n OptionalHouseGatekeeper public gatekeeper;\n ISyndicateFactory public syndicateFactory;\n IOwnableSmartWalletFactory public smartWalletFactory;\n string public stakehouseTicker;\n StakingFundsVault public stakingFundsVault;\n SavETHVault public savETHVault;\n bool public enableWhitelisting;\n mapping(address => bool) public isNodeRunnerWhitelisted;\n mapping(address => address) public smartWalletRepresentative;\n mapping(bytes => address) public smartWalletOfKnot;\n mapping(address => address) public smartWalletOfNodeRunner;\n mapping(address => address) public nodeRunnerOfSmartWallet;\n mapping(address => uint256) public stakedKnotsOfSmartWallet;\n mapping(address => address) public smartWalletDormantRepresentative;\n mapping(bytes => address) public bannedBLSPublicKeys;\n mapping(address => bool) public bannedNodeRunners;\n uint256 public numberOfKnots;\n uint256 public daoCommissionPercentage;\n uint256 public MODULO = 100_00000;\n modifier onlyDAO() {\n  require(msg.sender == dao, \"Must be DAO\");\n  _;\n }\n\n /// @custom:oz-upgrades-unsafe-allow constructor\n constructor() initializer {}\n\n /// @inheritdoc ILiquidStakingManager\n function init(\n  address _dao,\n  address _syndicateFactory,\n  address _smartWalletFactory,\n  address _lpTokenFactory,\n  address _brand,\n  address _savETHVaultDeployer,\n  address _stakingFundsVaultDeployer,\n  address _optionalGatekeeperDeployer,\n  uint256 _optionalCommission,\n  bool _deployOptionalGatekeeper,\n  string calldata _stakehouseTicker\n ) external virtual override initializer {\n  _init(\n_dao,\n_syndicateFactory,\n_smartWalletFactory,\n_lpTokenFactory,\n_brand,\n_savETHVaultDeployer,\n_stakingFundsVaultDeployer,\n_optionalGatekeeperDeployer,\n_optionalCommission,\n_deployOptionalGatekeeper,\n_stakehouseTicker\n  );\n }\n\n\n function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {\n  require(_recipient != address(0), \"Zero address\");\n  require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");\n\n  address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];\n  require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");\n  require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");\n  require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");\n  require(\ngetAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,\n\"Initials not registered\"\n  );\n\n  // refund 4 ether from smart wallet to node runner's EOA\n  IOwnableSmartWallet(associatedSmartWallet).rawExecute(\n_recipient,\n\"\",\n4 ether\n  );\n\n  // update the mapping\n  bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;\n\n  emit ETHWithdrawnFromSmartWallet(associatedSmartWallet, _blsPublicKeyOfKnot, msg.sender);\n }\n\n \n function _initSavETHVault(address _savETHVaultDeployer, address _lpTokenFactory) internal virtual {\n  // Use an external deployer to reduce the size of the liquid staking manager\n  savETHVault = SavETHVault(\nSavETHVaultDeployer(_savETHVaultDeployer).deploySavETHVault(address(this), _lpTokenFactory)\n  );\n }\n}\n\n###\n\n", "completion": "yes,Reentrancy###\n###"}
{"prompt": "pragma solidity ^0.8.0; \ncontract BondNFT is ERC721Enumerable, Ownable {  \n uint constant private DAY = 24 * 60 * 60; \n struct Bond { \n  uint id; \n  address owner; \n  address asset; \n  uint amount; \n  uint mintEpoch; \n  uint mintTime; \n  uint expireEpoch; \n  uint pending; \n  uint shares; \n  uint period; \n  bool expired; \n } \n mapping(address => uint256) public epoch; \n uint private totalBonds; \n string public baseURI; \n address public manager; \n address[] public assets; \n mapping(address => bool) public allowedAsset; \n mapping(address => uint) private assetsIndex; \n mapping(uint256 => mapping(address => uint256)) private bondPaid; \n mapping(address => mapping(uint256 => uint256)) private accRewardsPerShare; // tigAsset => epoch => accRewardsPerShare \n mapping(uint => Bond) private _idToBond; \n mapping(address => uint) public totalShares; \n mapping(address => mapping(address => uint)) public userDebt; // user => tigAsset => amount \n constructor( \n  string memory _setBaseURI, \n  string memory _name, \n  string memory _symbol \n ) ERC721(_name, _symbol) { \n  baseURI = _setBaseURI; \n } \n function claim( \n  uint _id, \n  address _claimer \n ) public onlyManager() returns(uint amount, address tigAsset) { \n  Bond memory bond = idToBond(_id); \n  require(_claimer == bond.owner, \"!owner\"); \n  amount = bond.pending; \n  tigAsset = bond.asset; \n  unchecked { \nif (bond.expired) { \n uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e18 - bondPaid[_id][bond.asset]); \n if (totalShares[bond.asset] > 0) { \n  accRewardsPerShare[bond.asset][epoch[bond.asset]] += _pendingDelta*1e18/totalShares[bond.asset]; \n } \n} \nbondPaid[_id][bond.asset] += amount; \n  } \n  IERC20(tigAsset).transfer(manager, amount); \n  emit ClaimFees(tigAsset, amount, _claimer, _id); \n } \n \n\n function claimDebt( \n  address _user, \n  address _tigAsset \n ) public onlyManager() returns(uint amount) { \n  amount = userDebt[_user][_tigAsset]; \n  userDebt[_user][_tigAsset] = 0; \n  IERC20(_tigAsset).transfer(manager, amount); \n  emit ClaimDebt(_tigAsset, amount, _user); \n } \n function _mint( \n  address to, \n  Bond memory bond \n ) internal { \n  unchecked { \nbondPaid[bond.id][bond.asset] = accRewardsPerShare[bond.asset][epoch[bond.asset]] * bond.shares / 1e18; \n  } \n  _mint(to, bond.id); \n } \n \n function _burn( \n  uint256 _id \n ) internal override { \n  delete _idToBond[_id]; \n  super._burn(_id); \n } \n function _transfer( \n  address from, \n  address to, \n  uint256 _id \n ) internal override { \n  Bond memory bond = idToBond(_id); \n  require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\"); \n  require(!bond.expired, \"Expired!\"); \n  unchecked { \nrequire(block.timestamp > bond.mintTime + 300, \"Recent update\"); \nuserDebt[from][bond.asset] += bond.pending; \nbondPaid[_id][bond.asset] += bond.pending; \n  } \n  super._transfer(from, to, _id); \n } \n function setBaseURI(string calldata _newBaseURI) external onlyOwner { \n  baseURI = _newBaseURI; \n } \n modifier onlyManager() { \n  require(msg.sender == manager, \"!manager\"); \n  _; \n } \n event Distribution(address _tigAsset, uint256 _amount); \n event Lock(address _tigAsset, uint256 _amount, uint256 _period, address _owner, uint256 _id); \n event ExtendLock(uint256 _period, uint256 _amount, address _owner, uint256 _id); \n event Release(address _tigAsset, uint256 _amount, address _owner, uint256 _id); \n event ClaimFees(address _tigAsset, uint256 _amount, address _claimer, uint256 _id); \n event ClaimDebt(address _tigAsset, uint256 _amount, address _owner); \n} \n\n###\n\n", "completion": "yes,Reentrancy###\n###"}
