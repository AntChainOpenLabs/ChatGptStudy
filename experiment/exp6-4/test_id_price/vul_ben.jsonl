{"prompt":"pragma solidity ^0.6.0; \n \nimport '.\/Context.sol'; \n \n\/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n *\/ \ncontract Ownable is Context { \n address private _owner; \n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n \/** \n * @dev Initializes the contract setting the deployer as the initial owner. \n *\/ \n constructor() internal { \n address msgSender = _msgSender(); \n _owner = msgSender; \n emit OwnershipTransferred(address(0), msgSender); \n } \n \n \/** \n * @dev Returns the address of the current owner. \n *\/ \n function owner() public view returns (address) { \n return _owner; \n } \n \n \/** \n * @dev Throws if called by any account other than the owner. \n *\/ \n modifier onlyOwner() { \n require(_owner == _msgSender(), 'Ownable: caller is not the owner'); \n _; \n } \n \n \/** \n * @dev Leaves the contract without owner. It will not be possible to call \n * `onlyOwner` functions anymore. Can only be called by the current owner. \n * \n * NOTE: Renouncing ownership will leave the contract without an owner, \n * thereby removing any functionality that is only available to the owner. \n *\/ \n function renounceOwnership() public virtual onlyOwner { \n emit OwnershipTransferred(_owner, address(0)); \n _owner = address(0); \n } \n \n \/** \n * @dev Transfers ownership of the contract to a new account (`newOwner`). \n * Can only be called by the current owner. \n *\/ \n function transferOwnership(address newOwner) public virtual onlyOwner { \n require(newOwner != address(0), 'Ownable: new owner is the zero address'); \n emit OwnershipTransferred(_owner, newOwner); \n _owner = newOwner; \n } \n} \n\n\n###\n\n","completion":" no###\n###"}
{"prompt":"pragma solidity 0.6.12; \n \n\/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n *\/ \nlibrary SafeMath { \n \/** \n * @dev Returns the addition of two unsigned integers, reverting on \n * overflow. \n * \n * Counterpart to Solidity's `+` operator. \n * \n * Requirements: \n * - Addition cannot overflow. \n *\/ \n function add(uint256 a, uint256 b) internal pure returns (uint256) { \n uint256 c = a + b; \n require(c >= a, 'SafeMath: addition overflow'); \n \n return c; \n } \n \n \/** \n * @dev Returns the subtraction of two unsigned integers, reverting on \n * overflow (when the result is negative). \n * \n * Counterpart to Solidity's `-` operator. \n * \n * Requirements: \n * - Subtraction cannot overflow. \n *\/ \n function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n return sub(a, b, 'SafeMath: subtraction overflow'); \n } \n \n \/** \n * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n * overflow (when the result is negative). \n * \n * Counterpart to Solidity's `-` operator. \n * \n * Requirements: \n * - Subtraction cannot overflow. \n *\/ \n function sub( \n uint256 a, \n uint256 b, \n string memory errorMessage \n ) internal pure returns (uint256) { \n require(b <= a, errorMessage); \n uint256 c = a - b; \n \n return c; \n } \n \n \/** \n * @dev Returns the multiplication of two unsigned integers, reverting on \n * overflow. \n * \n * Counterpart to Solidity's `*` operator. \n * \n * Requirements: \n * - Multiplication cannot overflow. \n *\/ \n function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n \/\/ Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n \/\/ benefit is lost if 'b' is also tested. \n \/\/ See: https:\/\/github.com\/OpenZeppelin\/openzeppelin-contracts\/pull\/522 \n if (a == 0) { \n return 0; \n } \n \n uint256 c = a * b; \n require(c \/ a == b, 'SafeMath: multiplication overflow'); \n \n return c; \n } \n \n \/** \n * @dev Returns the integer division of two unsigned integers. Reverts on \n * division by zero. The result is rounded towards zero. \n * \n * Counterpart to Solidity's `\/` operator. Note: this function uses a \n * `revert` opcode (which leaves remaining gas untouched) while Solidity \n * uses an invalid opcode to revert (consuming all remaining gas). \n * \n * Requirements: \n * - The divisor cannot be zero. \n *\/ \n function div(uint256 a, uint256 b) internal pure returns (uint256) { \n return div(a, b, 'SafeMath: division by zero'); \n } \n \n \/** \n * @dev Returns the integer division of two unsigned integers. Reverts with custom message on \n * division by zero. The result is rounded towards zero. \n * \n * Counterpart to Solidity's `\/` operator. Note: this function uses a \n * `revert` opcode (which leaves remaining gas untouched) while Solidity \n * uses an invalid opcode to revert (consuming all remaining gas). \n * \n * Requirements: \n * - The divisor cannot be zero. \n *\/ \n function div( \n uint256 a, \n uint256 b, \n string memory errorMessage \n ) internal pure returns (uint256) { \n \/\/ Solidity only automatically asserts when dividing by 0 \n require(b > 0, errorMessage); \n uint256 c = a \/ b; \n \/\/ assert(a == b * c + a % b); \/\/ There is no case in which this doesn't hold \n \n return c; \n } \n \n \/** \n * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n * Reverts when dividing by zero. \n * \n * Counterpart to Solidity's `%` operator. This function uses a `revert` \n * opcode (which leaves remaining gas untouched) while Solidity uses an \n * invalid opcode to revert (consuming all remaining gas). \n * \n * Requirements: \n * - The divisor cannot be zero. \n *\/ \n function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n return mod(a, b, 'SafeMath: modulo by zero'); \n } \n \n \/** \n * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n * Reverts with custom message when dividing by zero. \n * \n * Counterpart to Solidity's `%` operator. This function uses a `revert` \n * opcode (which leaves remaining gas untouched) while Solidity uses an \n * invalid opcode to revert (consuming all remaining gas). \n * \n * Requirements: \n * - The divisor cannot be zero. \n *\/ \n function mod( \n uint256 a, \n uint256 b, \n string memory errorMessage \n ) internal pure returns (uint256) { \n require(b != 0, errorMessage); \n return a % b; \n } \n} \n\n\n###\n\n","completion":" no###\n###"}
{"prompt":"pragma solidity 0.6.12; \n \n\/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n *\/ \nabstract contract Context { \n function _msgSender() internal view virtual returns (address payable) { \n return msg.sender; \n } \n \n function _msgData() internal view virtual returns (bytes memory) { \n this; \/\/ silence state mutability warning without generating bytecode - see https:\/\/github.com\/et\n return msg.data; \n } \n} \n \n\n\n###\n\n","completion":" no###\n###"}
{"prompt":"pragma solidity 0.6.12; \n \nimport {IERC20} from '.\/IERC20.sol'; \nimport {SafeMath} from '.\/SafeMath.sol'; \nimport {Address} from '.\/Address.sol'; \n \n\/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n *\/ \nlibrary SafeERC20 { \n using SafeMath for uint256; \n using Address for address; \n \n function safeTransfer( \n IERC20 token, \n address to, \n uint256 value \n ) internal { \n callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n } \n \n function safeTransferFrom( \n IERC20 token, \n address from, \n address to, \n uint256 value \n ) internal { \n callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value)); \n } \n \n function safeApprove( \n IERC20 token, \n address spender, \n uint256 value \n ) internal { \n require( \n (value == 0) || (token.allowance(address(this), spender) == 0), \n 'SafeERC20: approve from non-zero to non-zero allowance' \n ); \n callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n } \n \n function callOptionalReturn(IERC20 token, bytes memory data) private { \n require(address(token).isContract(), 'SafeERC20: call to non-contract'); \n \n \/\/ solhint-disable-next-line avoid-low-level-calls \n (bool success, bytes memory returndata) = address(token).call(data); \n require(success, 'SafeERC20: low-level call failed'); \n \n if (returndata.length > 0) { \n \/\/ Return data is optional \n \/\/ solhint-disable-next-line max-line-length \n require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed'); \n } \n } \n} \n\n\n###\n\n","completion":" no###\n###"}
{"prompt":"pragma solidity 0.6.12; \n \nimport {ILendingPoolAddressesProvider} from '..\/..\/interfaces\/ILendingPoolAddressesProvider.sol'; \nimport {ILendingPool} from '..\/..\/interfaces\/ILendingPool.sol'; \n \n\/** \n * @title IFlashLoanReceiver interface \n * @notice Interface for the Aave fee IFlashLoanReceiver. \n * @author Aave \n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract \n **\/ \ninterface IFlashLoanReceiver { \n function executeOperation( \n address[] calldata assets, \n uint256[] calldata amounts, \n uint256[] calldata premiums, \n address initiator, \n bytes calldata params \n ) external returns (bool); \n \n function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider); \n \n function LENDING_POOL() external view returns (ILendingPool); \n} \n\n\n###\n\n","completion":" no###\n###"}