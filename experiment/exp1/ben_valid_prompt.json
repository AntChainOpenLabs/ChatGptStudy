{"prompt": "pragma solidity ^0.8.0; \n \n \ncontract Roles is AccessControl { \n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER\"); \n \n    constructor() { \n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); \n        _setupRole(MINTER_ROLE, _msgSender()); \n    } \n \n    modifier onlyMinter() { \n        require(hasRole(MINTER_ROLE, _msgSender()), \"Roles: caller does not have the MINTER role\"); \n        _; \n    } \n} \n \n// File: contracts/service/ServicePayer.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./Context.sol\"; \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address _owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n}\nSafeBEP20.sol\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n// \n// \n//                    \u250c\u2500\u2510       \u250c\u2500\u2510 + + \n//                    \u250c\u2500\u2500\u2518 \u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2534\u2500\u2500\u2510++ \n//                    \u2502                 \u2502 \n//                    \u2502       \u2500\u2500\u2500       \u2502++ + + + \n//                    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502+ \n//                    \u2502                 \u2502+ \n//                    \u2502       \u2500\u2534\u2500       \u2502 \n//                    \u2502                 \u2502 \n//                    \u2514\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2518 \n//                    \u2502         \u2502 \n//                    \u2502         \u2502   + + \n//                    \u2502         \u2502 \n//                    \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \n//                    \u2502                        \u2502 \n//                    \u2502                        \u251c\u2500\u2510 \n//                    \u2502                        \u250c\u2500\u2518 \n//                    \u2502                        \u2502 \n//                    \u2514\u2500\u2510  \u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2510  \u250c\u2500\u2500\u2518  + + + + \n//                    \u2502 \u2500\u2524 \u2500\u2524       \u2502 \u2500\u2524 \u2500\u2524 \n//                    \u2514\u2500\u2500\u2534\u2500\u2500\u2518       \u2514\u2500\u2500\u2534\u2500\u2500\u2518  + + + + \n \n \nimport \"./BEP20.sol\"; \n \ncontract ZooToken is BEP20('Zoo', 'ZOO', 100000000000000000000000000000) { \n \n \nfunction getChainId() internal pure returns (uint) { \nuint256 chainId; \nassembly { chainId := chainid() } \nreturn chainId; \n} \n}\n \n        return c; \n    } \n \n    /** \n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo), \n     * reverts when dividing by zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b != 0); \n        return a % b; \n    } \n}\nAnalysis of audit results\nRe-Entrancy\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title SafeMath \n * @dev Unsigned math operations with safety checks that revert on error \n */ \n \nlibrary SafeMath { \n    /** \n     * @dev Multiplies two unsigned integers, reverts on overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b); \n \nZooToken.sol\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n// \n// \n//                    \u250c\u2500\u2510       \u250c\u2500\u2510 + + \n//                    \u250c\u2500\u2500\u2518 \u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2534\u2500\u2500\u2510++ \n//                    \u2502                 \u2502 \n//                    \u2502       \u2500\u2500\u2500       \u2502++ + + + \n//                    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502+ \n//                    \u2502                 \u2502+ \n//                    \u2502       \u2500\u2534\u2500       \u2502 \n//                    \u2502                 \u2502 \n//                    \u2514\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2518 \n//                    \u2502         \u2502 \n        return c; \n    } \n \n    /** \n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Solidity only automatically asserts when dividing by 0 \n        require(b > 0); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    /** \n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    /** \n     * @dev Adds two unsigned integers, reverts on overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a); \n \n        return c; \n    } \n \n    /** \n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo), \n     * reverts when dividing by zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b != 0); \n        return a % b; \n    } \n}\n//                    \u2502         \u2502   + + \n//                    \u2502         \u2502 \n//                    \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \n//                    \u2502                        \u2502 \n//                    \u2502                        \u251c\u2500\u2510 \n//                    \u2502                        \u250c\u2500\u2518 \n//                    \u2502                        \u2502 \n//                    \u2514\u2500\u2510  \u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2510  \u250c\u2500\u2500\u2518  + + + + \n//                    \u2502 \u2500\u2524 \u2500\u2524       \u2502 \u2500\u2524 \u2500\u2524 \n//                    \u2514\u2500\u2500\u2534\u2500\u2500\u2518       \u2514\u2500\u2500\u2534\u2500\u2500\u2518  + + + + \n \n \nimport \"./BEP20.sol\"; \n \ncontract ZooToken is BEP20('Zoo', 'ZOO', 100000000000000000000000000000) { \n \n \nfunction getChainId() internal pure returns (uint) { \nuint256 chainId; \nassembly { chainId := chainid() } \nreturn chainId; \n} \n}\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IVariableDebtToken} from '../../interfaces/IVariableDebtToken.sol'; \nimport {WadRayMath} from '../libraries/math/WadRayMath.sol'; \nimport {Errors} from '../libraries/helpers/Errors.sol'; \nimport {DebtTokenBase} from './base/DebtTokenBase.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol'; \n \n/** \n \ncontract VariableDebtToken is DebtTokenBase, IVariableDebtToken { \n  using WadRayMath for uint256; \n \n  uint256 public constant DEBT_TOKEN_REVISION = 0x1; \n \n  ILendingPool internal _pool; \n  address internal _underlyingAsset; \n  IAaveIncentivesController internal _incentivesController; \n \n  /** \n     * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's \n   * @param debtTokenName The name of the token \n   * @param debtTokenSymbol The symbol of the token \n   */ \n  function initialize( \n    ILendingPool pool, \n    address underlyingAsset, \n    IAaveIncentivesController incentivesController, \n    uint8 debtTokenDecimals, \n    string memory debtTokenName, \n    string memory debtTokenSymbol, \n    bytes calldata params \n  ) public override initializer { \n    _setName(debtTokenName); \n    _setSymbol(debtTokenSymbol); \n    _setDecimals(debtTokenDecimals); \n \n    _pool = pool; \n    _underlyingAsset = underlyingAsset; \n    _incentivesController = incentivesController; \n \n    emit Initialized( \n      underlyingAsset, \n      address(pool), \n      address(incentivesController), \n      debtTokenDecimals, \n      debtTokenName, \n      debtTokenSymbol, \n      params \n    ); \n  } \n \n  /** \n   * @dev Gets the revision of the stable debt token implementation \n   * @return The debt token implementation revision \n   **/ \n  function getRevision() internal pure virtual override returns (uint256) { \n    return DEBT_TOKEN_REVISION; \n  } \n \n  /** \n   * @dev Calculates the accumulated debt balance of the user \n   * @return The debt balance of the user \n   **/ \n  function balanceOf(address user) public view virtual override returns (uint256) { \n    uint256 scaledBalance = super.balanceOf(user); \n \n    if (scaledBalance == 0) { \n      return 0; \n    } \n \n    return scaledBalance.rayMul(_pool.getReserveNormalizedVariableDebt(_underlyingAsset)); \n  } \n \n  /** \n   * @dev Mints debt token to the `onBehalfOf` address \n   * -  Only callable by the LendingPool \n   * @param user The address receiving the borrowed underlying, being the delegatee in case \n   * of credit delegate, or same as `onBehalfOf` otherwise \n   * @param onBehalfOf The address receiving the debt tokens \n   * @param amount The amount of debt being minted \n   * @param index The variable debt index of the reserve \n   * @return `true` if the the previous balance of the user is 0 \n   **/ \n  function mint( \n    address user, \n    address onBehalfOf, \n    uint256 amount, \n    uint256 index \n  ) external override onlyLendingPool returns (bool) { \n    if (user != onBehalfOf) { \n      _decreaseBorrowAllowance(onBehalfOf, user, amount); \n    } \n \n    uint256 previousBalance = super.balanceOf(onBehalfOf); \n    uint256 amountScaled = amount.rayDiv(index); \n    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT); \n \n    _mint(onBehalfOf, amountScaled); \n \n    emit Transfer(address(0), onBehalfOf, amount); \n    emit Mint(user, onBehalfOf, amount, index); \n \n    return previousBalance == 0; \n  } \n \n  /** \n   * @dev Burns user variable debt \n   * - Only callable by the LendingPool \n   * @param user The user whose debt is getting burned \n   * @param amount The amount getting burned \n   * @param index The variable debt index of the reserve \n   **/ \n  function burn( \n    address user, \n    uint256 amount, \n    uint256 index \n  ) external override onlyLendingPool { \n    uint256 amountScaled = amount.rayDiv(index); \n    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT); \n \n    _burn(user, amountScaled); \n \n    emit Transfer(user, address(0), amount); \n    emit Burn(user, amount, index); \n  } \n \n  /** \n   * @dev Returns the principal debt balance of the user from \n   * @return The debt balance of the user since the last burn/mint action \n   **/ \n  function scaledBalanceOf(address user) public view virtual override returns (uint256) { \n    return super.balanceOf(user); \n  } \n \n  /** \n   * @dev Returns the total supply of the variable debt token. Represents the total debt accrued by t\n   * @return The total supply \n   **/ \n  function totalSupply() public view virtual override returns (uint256) { \n    return super.totalSupply().rayMul(_pool.getReserveNormalizedVariableDebt(_underlyingAsset)); \n  } \n \n  /** \n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index) \n   * @return the scaled total supply \n   **/ \n  function scaledTotalSupply() public view virtual override returns (uint256) { \n    return super.totalSupply(); \n  } \n \n  /** \n   * @dev Returns the principal balance of the user and principal total supply. \n   * @param user The address of the user \n   * @return The principal balance of the user \n   * @return The principal total supply \n   **/ \n  function getScaledUserBalanceAndSupply(address user) \n    external \n    view \n    override \n    returns (uint256, uint256) \n  { \n    return (super.balanceOf(user), super.totalSupply()); \n  } \n \n  /** \n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH) \n   **/ \n  function UNDERLYING_ASSET_ADDRESS() public view returns (address) { \n    return _underlyingAsset; \n  } \n \n  /** \n   * @dev Returns the address of the incentives controller contract \n   **/ \n  function getIncentivesController() external view override returns (IAaveIncentivesController) { \n    return _getIncentivesController(); \n  } \n \n  /** \n   * @dev Returns the address of the lending pool where this aToken is used \n   **/ \n  function POOL() public view returns (ILendingPool) { \n    return _pool; \n  } \n \n  function _getIncentivesController() internal view override returns (IAaveIncentivesController) { \n    return _incentivesController; \n  } \n \n  function _getUnderlyingAssetAddress() internal view override returns (address) { \n    return _underlyingAsset; \n  } \n \n  function _getLendingPool() internal view override returns (ILendingPool) { \n    return _pool; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n *  \n \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n    /** \n     \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        uint256 c = a + b; \n        if (c < a) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the substraction of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b > a) return (false, 0); \n        return (true, a - b); \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) return (true, 0); \n        uint256 c = a * b; \n        if (c / a != b) return (false, 0); \n        return (true, c); \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a / b); \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        if (b == 0) return (false, 0); \n        return (true, a % b); \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's + operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's - operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a, \"SafeMath: subtraction overflow\"); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's * operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        if (a == 0) return 0; \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's / operator. Note: this function uses a \n     * revert opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: division by zero\"); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's % operator. This function uses a revert \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b > 0, \"SafeMath: modulo by zero\"); \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's - operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryDiv}. \n     * \n     * Counterpart to Solidity's / operator. Note: this function uses a \n     * revert opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's % operator. This function uses a revert \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        return a % b; \n    } \n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n//  \n @dev Wrappers over Solidity's arithmetic operations. \n * \n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler \n * now has built in overflow checking. \n */ \nlibrary SafeMath { \n    /** \n     * @dev Returns the addition of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            uint256 c = a + b; \n            if (c < a) return (false, 0); \n            return (true, c); \n        } \n    } \n \n    /** \n    \n     * _Available since v3.4._ \n     */ \n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            if (b > a) return (false, 0); \n            return (true, a - b); \n        } \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n            // benefit is lost if 'b' is also tested. \n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n            if (a == 0) return (true, 0); \n            uint256 c = a * b; \n            if (c / a != b) return (false, 0); \n            return (true, c); \n        } \n    } \n \n    /** \n     * @dev Returns the division of two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            if (b == 0) return (false, 0); \n            return (true, a / b); \n        } \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag. \n     * \n     * _Available since v3.4._ \n     */ \n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \n        unchecked { \n            if (b == 0) return (false, 0); \n            return (true, a % b); \n        } \n    } \n \n    /** \n     * @dev Returns the addition of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a + b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting on \n     * overflow (when the result is negative). \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a - b; \n    } \n \n    /** \n     * @dev Returns the multiplication of two unsigned integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a * b; \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a / b; \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting when dividing by zero. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return a % b; \n    } \n \n    /** \n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n     * overflow (when the result is negative). \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {trySub}. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        unchecked { \n            require(b <= a, errorMessage); \n            return a - b; \n        } \n    } \n \n    /** \n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        unchecked { \n            require(b > 0, errorMessage); \n            return a / b; \n        } \n    } \n \n    /** \n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n     * reverting with custom message when dividing by zero. \n     * \n     * CAUTION: This function is deprecated because it requires allocating memory for the error \n     * message unnecessarily. For custom revert reasons use {tryMod}. \n     * \n     * Counterpart to Solidity's `%` operator. This function uses a `revert` \n     * opcode (which leaves remaining gas untouched) while Solidity uses an \n     * invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function mod( \n        uint256 a, \n        uint256 b, \n        string memory errorMessage \n    ) internal pure returns (uint256) { \n        unchecked { \n            require(b > 0, errorMessage); \n            return a % b; \n        } \n    } \n} \n \n \n// File contracts/IBep20.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {IWETH} from './interfaces/IWETH.sol'; \nimport {IWETHGateway} from './interfaces/IWETHGateway.sol'; \nimport {ILendingPool} from '../interfaces/ILendingPool.sol'; \nimport {IAToken} from '../interfaces/IAToken.sol'; \nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol'; \nimport {UserConfiguration} from '../protocol/libraries/configuration/UserConfiguration.sol'; \nimport {Helpers} from '../protocol/libraries/helpers/Helpers.sol'; \nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol'; \n \ncontract WETHGateway is IWETHGateway, Ownable { \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n  using UserConfiguration for DataTypes.UserConfigurationMap; \n \n  IWETH internal immutable WETH; \n \n  /** \n   * @dev Sets the WETH address and the LendingPoolAddressesProvider address. Infinite approves lendi\n   * @param weth Address of the Wrapped Ether contract \n   **/ \n  constructor(address weth) public { \n    WETH = IWETH(weth); \n  } \n \n  function authorizeLendingPool(address lendingPool) external onlyOwner { \n    WETH.approve(lendingPool, uint256(-1)); \n  } \n \n  /** \n \n   * @param lendingPool address of the targeted underlying lending pool \n   * @param onBehalfOf address of the user who will receive the aTokens representing the deposit \n   \n  function depositETH( \n    address lendingPool, \n    address onBehalfOf, \n    uint16 referralCode \n  ) external payable override { \n    WETH.deposit{value: msg.value}(); \n    ILendingPool(lendingPool).deposit(address(WETH), msg.value, onBehalfOf, referralCode); \n  } \n \n  /** \n   * @dev withdraws the WETH _reserves of msg.sender. \n  * @param to address of the user who will receive native ETH \n   */ \n  function withdrawETH( \n    address lendingPool, \n    uint256 amount, \n    address to \n  ) external override { \n    IAToken aWETH = IAToken(ILendingPool(lendingPool).getReserveData(address(WETH)).aTokenAddress); \n    uint256 userBalance = aWETH.balanceOf(msg.sender); \n    uint256 amountToWithdraw = amount; \n \n    // if amount is equal to uint(-1), the user wants to redeem everything \n    if (amount == type(uint256).max) { \n      amountToWithdraw = userBalance; \n    } \n    aWETH.transferFrom(msg.sender, address(this), amountToWithdraw); \n    ILendingPool(lendingPool).withdraw(address(WETH), amountToWithdraw, address(this)); \n    WETH.withdraw(amountToWithdraw); \n    _safeTransferETH(to, amountToWithdraw); \n  } \n \n  /** \n   * @dev repays a borrow on the WETH reserve, for the specified amount (or for the whole amount, if \n   * @param lendingPool address of the targeted underlying lending pool \n   * @param amount the amount to repay, or uint256(-1) if the user wants to repay everything \n   * @param rateMode the rate mode to repay \n   * @param onBehalfOf the address for which msg.sender is repaying \n   */ \n  function repayETH( \n    address lendingPool, \n    uint256 amount, \n    uint256 rateMode, \n    address onBehalfOf \n  ) external payable override { \n    (uint256 stableDebt, uint256 variableDebt) = \n      Helpers.getUserCurrentDebtMemory( \n        onBehalfOf, \n        ILendingPool(lendingPool).getReserveData(address(WETH)) \n      ); \n \n    uint256 paybackAmount = \n      DataTypes.InterestRateMode(rateMode) == DataTypes.InterestRateMode.STABLE \n        ? stableDebt \n        : variableDebt; \n \n    if (amount < paybackAmount) { \n      paybackAmount = amount; \n    } \n    require(msg.value >= paybackAmount, 'msg.value is less than repayment amount'); \n    WETH.deposit{value: paybackAmount}(); \n    ILendingPool(lendingPool).repay(address(WETH), msg.value, rateMode, onBehalfOf); \n \n    // refund remaining dust eth \n    if (msg.value > paybackAmount) _safeTransferETH(msg.sender, msg.value - paybackAmount); \n  } \n \n  /** \n   * @dev borrow WETH, unwraps to ETH and send both the ETH and DebtTokens to msg.sender, via `approv\n   * @param lendingPool address of the targeted underlying lending pool \n   * @param amount the amount of ETH to borrow \n   * @param interesRateMode the interest rate mode \n   * @param referralCode integrators are assigned a referral code and can potentially receive rewards\n   */ \n  function borrowETH( \n    address lendingPool, \n    uint256 amount, \n    uint256 interesRateMode, \n    uint16 referralCode \n  ) external override { \n    ILendingPool(lendingPool).borrow( \n      address(WETH), \n      amount, \n      interesRateMode, \n      referralCode, \n      msg.sender \n    ); \n    WETH.withdraw(amount); \n    _safeTransferETH(msg.sender, amount); \n  } \n \n  /** \n   * @dev transfer ETH to an address, revert if it fails. \n   * @param to recipient of the transfer \n   \n  function _safeTransferETH(address to, uint256 value) internal { \n    (bool success, ) = to.call{value: value}(new bytes(0)); \n    require(success, 'ETH_TRANSFER_FAILED'); \n  } \n \n  /** \n   * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due \n   * direct transfers to the contract address. \n   * @param token token to transfer \n   * @param to recipient of the transfer \n   * @param amount amount to send \n   */ \n  function emergencyTokenTransfer( \n    address token, \n    address to, \n    uint256 amount \n  ) external onlyOwner { \n    IERC20(token).transfer(to, amount); \n  } \n \n  /** \n   * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck \n   * due selfdestructs or transfer ether to pre-computated contract address before deployment. \n   * @param to recipient of the transfer \n   * @param amount amount to send \n   */ \n  function emergencyEtherTransfer(address to, uint256 amount) external onlyOwner { \n    _safeTransferETH(to, amount); \n  } \n \n  /** \n   * @dev Get WETH address used by WETHGateway \n   */ \n  function getWETHAddress() external view returns (address) { \n    return address(WETH); \n  } \n \n  /** \n   * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether t\n   */ \n  receive() external payable { \n    require(msg.sender == address(WETH), 'Receive not allowed'); \n  } \n \n  /** \n   * @dev Revert fallback calls \n   */ \n  fallback() external payable { \n    revert('Fallback not allowed'); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n \n \n \n/** \n * control mechanisms. This is a  lightweight version that doesn't\n * members except through off-chain means by accessing the  contract event logs. Som\n * applications may benefit from on-chain enumerability, for those cases see \n * {AccessControlEnumerable}. \n * \n * Roles are  referred to by their `bytes32` identifier. These should\n * in the  external API and be unique. The best way to achieve this is by \n * using `public constant` hash digests: \n * \n * `` \n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\"); \n * `` \n * \n * Roles can be used to represent a  set of permissions. To restrict access to \n * function call, use {hasRole}: \n * \n * `` \n * function foo() public { \n *     require(hasRole(MY_ROLE, msg.sender)); \n *     ... \n * } \n * `` \n * \n * Roles can be granted and revoked dynamically via the  {grantRole} and \n * {revokeRole} functions. Each role has an  associated admin role, and only \n * accounts that have a  role's admin role can call {grantRole} and {revokeRole}. \n * \n * By default, the  admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means \n * that only accounts with this role will  be able to grant or revoke other \n * roles. More complex role relationships can be created by using \n * {_setRoleAdmin}. \n * \n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to \n * grant and revoke this role. Extra precautions should  be taken to secure \n * accounts that have been granted it. \n */  \nabstract contract AccessControl is Context, IAccessControl, ERC165 { \n    struct RoleData { \n        mapping(address => bool) members; \n        bytes32 adminRole; \n    } \n \n    mapping(bytes32 => RoleData) private _roles; \n \n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00; \n \n    /** \n    *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/ \n     * \n     * _Available since v4.1._ \n     */  \n    modifier onlyRole(bytes32 role) { \n        _checkRole(role, _msgSender()); \n        _; \n    } \n \n    /** \n       \n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { \n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId\n    } \n \n    /** \n      \n    function hasRole(bytes32 role, address account) public view override returns (bool) { \n        return _roles[role].members[account]; \n    } \n \n    /** \n      \n    \n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/ \n     */  \n    function _checkRole(bytes32 role, address account) internal view { \n        if (!hasRole(role, account)) { \n            revert( \n                string( \n                    abi.encodePacked( \n                        \"AccessControl: account \", \n                        Strings.toHexString(uint160(account), 20), \n                        \" is missing role \", \n                        Strings.toHexString(uint256(role), 32) \n                    ) \n                ) \n            ); \n        } \n    } \n \n    /** \n     * @dev Returns the  admin role that controls `role`. See {grantRole} and \n     * {revokeRole}. \n     * \n     * To change a  role's admin, use {_setRoleAdmin}. \n     */  \n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) { \n        return _roles[role].adminRole; \n    } \n \n    /** \n     * @dev Grants `role` to `account`. \n     * \n     * If `account` had not been already granted `role`, emits a  {RoleGranted} \n     * event. \n     * \n     * Requirements: \n     * \n     * - the  caller must have ``role``'s admin role. \n     */  \n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(r\n        _grantRole(role, account); \n    } \n \n    /** \n     * @dev Revokes `role` from `account`. \n     * \n     * If `account` had been granted `role`, emits a  {RoleRevoked} event. \n     * \n     * Requirements: \n     * \n     * - the  caller must have ``role``'s admin role. \n     */  \n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(\n        _revokeRole(role, account); \n    } \n \n    /** \n     * @dev Revokes `role` from the  calling account. \n     * \n     * Roles are  often managed via {grantRole} and {revokeRole}: this function's \n     * purpose is to provide a  mechanism for accounts to lose their privileges \n     * if they  are  compromised ( such\n     * \n     * If the  calling account had been granted `role`, emits a  \n     * event. \n     * \n     * Requirements: \n     * \n     * - the  caller must be `account`. \n     */  \n    function renounceRole(bytes32 role, address account) public virtual override { \n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\"); \n \n        _revokeRole(role, account); \n    } \n \n    /** \n     * @dev Grants `role` to `account`. \n     * \n     * If `account` had not been already granted `role`, emits a  {RoleGranted} \n     * event. Note that unlike {grantRole}, this function doesn't  perform any \n     * checks on the  calling account. \n     * \n     * [WARNING] \n     * ==== \n     * This function should  only be called from the  constructo\n     * up the  initial roles for the  system. \n     * \n     * Using this function in any other way is effectively circumventing the  admin \n     * system imposed by {AccessControl}. \n     * ==== \n     */  \n    function _setupRole(bytes32 role, address account) internal virtual { \n        _grantRole(role, account); \n    } \n \n    /** \n     * @dev Sets `adminRole` as ``role``'s admin role. \n     * \n     * Emits a  {RoleAdminChanged} event. \n     */  \n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual { \n        bytes32 previousAdminRole = getRoleAdmin(role); \n        _roles[role].adminRole = adminRole; \n        emit RoleAdminChanged(role, previousAdminRole, adminRole); \n    } \n \n    function _grantRole(bytes32 role, address account) private { \n        if (!hasRole(role, account)) { \n            _roles[role].members[account] = true; \n            emit RoleGranted(role, account, _msgSender()); \n        } \n    } \n \n    function _revokeRole(bytes32 role, address account) private { \n        if (hasRole(role, account)) { \n            _roles[role].members[account] = false; \n            emit RoleRevoked(role, account, _msgSender()); \n        } \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
