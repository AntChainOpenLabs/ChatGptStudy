{"prompt": "pragma solidity 0.6.12; \n \n \n \n// Safebox vault, deposit, withdrawal, borrowing, repayment \ncontract SafeBoxFoxCTokenImpl is ERC20Upgradeable { \n    using SafeMathUpgradeable for uint256; \n    using SafeERC20Upgradeable for IERC20Upgradeable; \n \n    IErc20Interface public eToken; \n    ICTokenInterface public cToken; \n \n    function __SafeBoxFoxCTokenImpl__init(address _cToken) public initializer { \n        __ERC20_init(string(abi.encodePacked(\"d \", ERC20Upgradeable(IErc20Interface(_cToken).underlyi\n            string(abi.encodePacked(\"d\", ERC20Upgradeable(IErc20Interface(_cToken).underlying()).symb\n        _setupDecimals(ERC20Upgradeable(_cToken).decimals()); \n        eToken = IErc20Interface(_cToken); \n        cToken = ICTokenInterface(_cToken); \n        require(cToken.isCToken(), 'not ctoken address'); \n        IERC20Upgradeable(baseToken()).approve(_cToken, uint256(-1)); \n    } \n \n    function baseToken() public virtual view returns (address) { \n        return eToken.underlying(); \n    } \n \n    function ctokenSupplyRatePerBlock() public virtual view returns (uint256) { \n        return cToken.supplyRatePerBlock(); \n    } \n \n    function ctokenBorrowRatePerBlock() public virtual view returns (uint256) { \n        return cToken.borrowRatePerBlock(); \n    } \n \n    function call_balanceOf(address _token, address _account) public virtual view returns (uint256 ba\n        balance = IERC20Upgradeable(_token).balanceOf(_account); \n    } \n \n    function call_balanceOfCToken_this() public virtual view returns (uint256 balance) { \n        balance = call_balanceOf(address(cToken), address(this)); \n    } \n \n    function call_balanceOfBaseToken_this() public virtual returns (uint256) { \n        return call_balanceOfCToken_this().mul(cToken.exchangeRateCurrent()).div(1e18); \n    } \n \n    function call_borrowBalanceCurrent_this() public virtual returns (uint256) { \n        return cToken.borrowBalanceCurrent(address(this)); \n    } \n \n    function getBaseTokenPerCToken() public virtual view returns (uint256) { \n        return cToken.exchangeRateStored(); \n    } \n \n    // deposit \n    function ctokenDeposit(uint256 _value) internal virtual returns (uint256 lpAmount) { \n        uint256 cBalanceBefore = call_balanceOf(address(cToken), address(this)); \n        require(eToken.mint(uint256(_value)) == 0, 'deposit token error'); \n        uint256 cBalanceAfter = call_balanceOf(address(cToken), address(this)); \n        lpAmount = cBalanceAfter.sub(cBalanceBefore); \n    } \n \n    function ctokenWithdraw(uint256 _lpAmount) internal virtual returns (uint256 value) { \n        uint256 cBalanceBefore = call_balanceOf(baseToken(), address(this)); \n        require(eToken.redeem(_lpAmount) == 0, 'withdraw supply ctoken error'); \n        uint256 cBalanceAfter = call_balanceOf(baseToken(), address(this)); \n        value = cBalanceAfter.sub(cBalanceBefore); \n    } \n \n    function ctokenClaim(uint256 _lpAmount) internal virtual returns (uint256 value) { \n        value = ctokenWithdraw(_lpAmount); \n    } \n \n    function ctokenBorrow(uint256 _value) internal virtual returns (uint256 value) { \n        uint256 cBalanceBefore = call_balanceOf(baseToken(), address(this)); \n        require(eToken.borrow(_value) == 0, 'borrow ubalance error'); \n        uint256 cBalanceAfter = call_balanceOf(baseToken(), address(this)); \n        value = cBalanceAfter.sub(cBalanceBefore); \n    } \n \n    function ctokenRepayBorrow(uint256 _value) internal virtual { \n        require(eToken.repayBorrow(_value) == 0, 'repayBorrow ubalance error'); \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \ninterface ITenBankHallV2 is ITenBankHall { \n    function boxInfo(uint256 _boxid) external view returns (address); \n    function boxIndex(address _boxaddr) external view returns (uint256); \n    function boxlisted(address _boxaddr) external view returns (bool); \n \n    function strategyInfo(uint256 _sid) external view returns (bool, address, uint256); \n    function strategyIndex(address _strategy, uint256 _sid) external view returns (uint256); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ILendingPool} from './ILendingPool.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \n/** \n * @title IInitializableAToken \n * @notice Interface for the initialize function on AToken \n * @author Aave \n **/ \ninterface IInitializableAToken { \n  /** \n   * @dev Emitted when an aToken is initialized \n   * @param underlyingAsset The address of the underlying asset \n   * @param pool The address of the associated lending pool \n   * @param treasury The address of the treasury \n   * @param incentivesController The address of the incentives controller for this aToken \n   * @param aTokenDecimals the decimals of the underlying \n   * @param aTokenName the name of the aToken \n   * @param aTokenSymbol the symbol of the aToken \n   * @param params A set of encoded parameters for additional initialization \n   **/ \n  event Initialized( \n    address indexed underlyingAsset, \n    address indexed pool, \n    address treasury, \n    address incentivesController, \n    uint8 aTokenDecimals, \n    string aTokenName, \n    string aTokenSymbol, \n    bytes params \n  ); \n \n  /** \n   * @dev Initializes the aToken \n   * @param pool The address of the lending pool where this aToken will be used \n   * @param treasury The address of the Aave treasury, receiving the fees on this aToken \n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH) \n   * @param incentivesController The smart contract managing potential incentives distribution \n   * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's \n   * @param aTokenName The name of the aToken \n   * @param aTokenSymbol The symbol of the aToken \n   */ \n  function initialize( \n    ILendingPool pool, \n    address treasury, \n    address underlyingAsset, \n    IAaveIncentivesController incentivesController, \n    uint8 aTokenDecimals, \n    string calldata aTokenName, \n    string calldata aTokenSymbol, \n    bytes calldata params \n  ) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IIDOToken { \n  function allowance(address owner, address spender) view external returns (uint256); \n \n  function approve(address spender, uint256 amount) external returns (bool); \n \n  function balanceOf(address account) view external returns (uint256); \n \n  function burn(uint256 amount) external; \n \n  function burnFrom(address account, uint256 amount) external; \n \n  function dailySaleCap() view external returns (uint256); \n \n  function decimals() view external returns (uint8); \n \n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool); \n \n  function factory() view external returns (address); \n \n  function gasPrice() view external returns (uint256); \n \n  function hardDrivePrice() view external returns (uint256); \n \n  function hfil() view external returns (address); \n \n  function hfilRecipient() view external returns (address); \n \n  function idoEndTime() view external returns (uint256); \n \n  function idoStartTime() view external returns (uint256); \n \n  function idoStatus() view external returns (bool); \n \n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool); \n \n  function name() view external returns (string memory); \n \n  function node() view external returns (string memory); \n \n  function paused() view external returns (bool); \n \n  function price() view external returns (uint256); \n \n  function router() view external returns (address); \n \n  function sealPrice() view external returns (uint256); \n \n  function sender() view external returns (address); \n \n  function symbol() view external returns (string memory); \n \n  function todayStartTime() view external returns (uint256); \n \n  function totalSupply() view external returns (uint256); \n \n  function transfer(address recipient, uint256 amount) external returns (bool); \n \n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n  function operator() view external returns (address); \n \n  function setPrice(uint256 gasPrice_, uint256 sealPrice_, uint256 hardDrivePrice_) external; \n \n  function setTimes(uint256 idoStartTime_, uint256 idoEndTime_) external; \n \n  function changerouter(address _router) external; \n \n  function stopIdo() external; \n \n  function stopIdoBySender() external; \n \n  function todayRemaind() view external returns (uint256); \n \n  function pause() external; \n \n  function unPause() external; \n \n  function cap() view external returns (uint256); \n \n  function startIdo(address _router) external; \n \n  function ido(address recipient) external returns (uint256 amount); \n \n  event Approval(address indexed owner, address indexed spender, uint256 value); \n \n  event IDO(address indexed to, uint256 cost, uint256 amount); \n \n  event IDOStart(uint256 timestamp); \n \n  event IDOStop(uint256 timestamp, address sender); \n \n  event Paused(address account); \n \n  event Transfer(address indexed from, address indexed to, uint256 value); \n \n  event Unpaused(address account); \n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module that helps prevent reentrant calls to a function. \n * \n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier \n * available, which can be applied to functions to make sure there are no nested \n * (reentrant) calls to them. \n * \n * Note that because there is a single `nonReentrant` guard, functions marked as \n * `nonReentrant` may not call one another. This can be worked around by making \n * those functions `private`, and then adding `external` `nonReentrant` entry \n * points to them. \n * \n * TIP: If you would like to learn more about reentrancy and alternative ways \n * to protect against it, check out our blog post \n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. \n */ \nabstract contract ReentrancyGuardUpgradeable is Initializable { \n    // Booleans are more expensive than uint256 or any type that takes up a full \n    // word because each write operation emits an extra SLOAD to first read the \n    // slot's contents, replace the bits taken up by the boolean, and then write \n    // back. This is the compiler's defense against contract upgrades and \n    // pointer aliasing, and it cannot be disabled. \n \n    // The values being non-zero value makes deployment a bit more expensive, \n    // but in exchange the refund on every call to nonReentrant will be lower in \n    // amount. Since refunds are capped to a percentage of the total \n    // transaction's gas, it is best to keep them low in cases like this one, to \n    // increase the likelihood of the full refund coming into effect. \n    uint256 private constant _NOT_ENTERED = 1; \n    uint256 private constant _ENTERED = 2; \n \n    uint256 private _status; \n \n    function __ReentrancyGuard_init() internal initializer { \n        __ReentrancyGuard_init_unchained(); \n    } \n \n    function __ReentrancyGuard_init_unchained() internal initializer { \n        _status = _NOT_ENTERED; \n    } \n \n    /** \n     * @dev Prevents a contract from calling itself, directly or indirectly. \n     * Calling a `nonReentrant` function from another `nonReentrant` \n     * function is not supported. It is possible to prevent this from happening \n     * by making the `nonReentrant` function external, and make it call a \n     * `private` function that does the actual work. \n     */ \n    modifier nonReentrant() { \n        // On the first call to nonReentrant, _notEntered will be true \n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); \n \n        // Any calls to nonReentrant after this point will fail \n        _status = _ENTERED; \n \n        _; \n \n        // By storing the original value once again, a refund is triggered (see \n        // https://eips.ethereum.org/EIPS/eip-2200) \n        _status = _NOT_ENTERED; \n    } \n    uint256[49] private __gap; \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n// File contracts/libraries/UQ112x112.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface IERC20Netswap { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external view returns (string memory); \n    function symbol() external view returns (string memory); \n    function decimals() external view returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n} \n \ninterface ISwapMining { \n    function swap(address account, address input, address output, uint256 amount) external returns (b\n} \n \ncontract Ownable { \n    address private _owner; \n \n    constructor () internal { \n        _owner = msg.sender; \n        emit OwnershipTransferred(address(0), _owner); \n    } \n \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    function isOwner(address account) public view returns (bool) { \n        return account == _owner; \n    } \n \n    function renounceOwnership() public onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    function _transferOwnership(address newOwner) internal { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n \n    function transferOwnership(address newOwner) public onlyOwner { \n        _transferOwnership(newOwner); \n    } \n \n \n    modifier onlyOwner() { \n        require(isOwner(msg.sender), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IStrategyV2SwapPool { \n \n    function setStrategy(address _strategy) external; \n \n    // get strategy \n    function getName() external view returns (string memory); \n \n    // swap functions \n    function getPair(address _t0, address _t1) external view returns (address pairs); \n    function getReserves(address _lpToken) external view returns (uint256 a, uint256 b); \n    function getToken01(address _pairs) external view returns (address token0, address token1); \n    function getAmountOut(address _tokenIn, address _tokenOut, uint256 _amountOut) external view retu\n    function getAmountIn(address _tokenIn, uint256 _amountIn, address _tokenOut) external view return\n    function getLPTokenAmountInBaseToken(address _lpToken, uint256 _lpTokenAmount, address _baseToken\n    function swapTokenTo(address _tokenIn, uint256 _amountIn, address _tokenOut, address _toAddress) \n \n    function optimalBorrowAmount(address _lpToken, uint256 _amount0, uint256 _amount1) external view \n    function optimalDepositAmount(address lpToken, uint amtA, uint amtB) external view returns (uint \n \n    // pool functions \n    function getDepositToken(uint256 _poolId) external view returns (address lpToken); \n    function getRewardToken(uint256 _poolId) external view returns (address rewardToken); \n    function getPending(uint256 _poolId) external view returns (uint256 rewards); \n    function deposit(uint256 _poolId, bool _autoPool) external returns (uint256 liquidity); \n    function withdraw(uint256 _poolId, uint256 _liquidity, bool _autoPool) external returns (uint256 \n    function claim(uint256 _poolId) external returns (uint256 rewards); \n    function extraRewards() external returns (address token, uint256 rewards); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IMFIL { \n  function allowance(address owner, address spender) view external returns (uint256); \n \n  function approve(address spender, uint256 amount) external returns (bool); \n \n  function balanceOf(address account) view external returns (uint256); \n \n  function burn(uint256 amount) external; \n \n  function burnFrom(address account, uint256 amount) external; \n \n  function decimals() view external returns (uint8); \n \n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool); \n \n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool); \n \n  function isMinter(address) view external returns (bool); \n \n  function mint(address recipient, uint256 amount) external; \n \n  function name() view external returns (string memory); \n \n  function operator() view external returns (address); \n \n  function owner() view external returns (address); \n \n  function paused() view external returns (bool); \n \n  function renounceOwnership() external; \n \n  function symbol() view external returns (string memory); \n \n  function totalSupply() view external returns (uint256); \n \n  function transfer(address recipient, uint256 amount) external returns (bool); \n \n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n  function transferOwnership(address newOwner) external; \n \n  function transferOperatorship(address newOperator) external; \n \n  function pause() external; \n \n  function unPause() external; \n \n  function addMinter(address minter) external; \n \n  function removeMinter(address minter) external; \n \n  function cap() view external returns (uint256); \n \n  event AddMinter(address indexed minter); \n \n  event Approval(address indexed owner, address indexed spender, uint256 value); \n \n  event Mint(address indexed minter, address indexed recipient, uint256 amount); \n \n  event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator); \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n  event Paused(address account); \n \n  event RemoveMinter(address indexed minter); \n \n  event Transfer(address indexed from, address indexed to, uint256 value); \n \n  event Unpaused(address account); \n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"./comm/SafeMath.sol\"; \nimport \"./comm/Helper.sol\"; \nimport \"./IERA7Card.sol\"; \n \ncontract ERA7CardMarketPlace is Helper { \n \n  address public coin; \n  address public nft; \n \n  uint256[] public sellingNfts; \n  mapping(uint256 => uint256) public sellingNftIndexs; \n \n  struct MarketPlaceNftInfo{ \n    uint256 tokenId; \n    uint price; \n    address owner; \n    uint upTime; \n  } \n  mapping(uint256 => MarketPlaceNftInfo) public nftMap; \n \n  constructor() {} \n \n  function initAddress(address coin_,address nft_) external onlyHelper { \n    require((coin_ != address(0) && nft_ != address(0)), \"ERA7CardMarketPlace initAddress: address er\n \n    coin = coin_; \n    nft = nft_; \n  } \n \n  function withdraw(address taxWallet) external onlyHelper returns(bool){ \n    require(taxWallet != address(0), \"ERA7CardMarketPlace withdraw: taxWallet error\"); \n \n    uint256 val = IERC20(coin).balanceOf(address(this)); \n    require(val > 0, \"ERA7CardMarketPlace withdraw: val error\"); \n \n    IERC20(coin).transfer(taxWallet,val); \n    return true; \n  } \n \n  function uploadNft(uint256 nftId,uint256 price) external nonReentrant isPause{ \n      address ownerAddress = IERA7Card(nft).ownerOf(nftId); \n      address uploadAddress = _msgSender(); \n      require(ownerAddress == uploadAddress, \"ERA7CardMarketPlace uploadNft: not owner\"); \n      require(price > 10000, \"ERA7CardMarketPlace uploadNft: price error\"); \n \n      uint index = sellingNftIndexs[nftId]; \n      if(index == 0){ \n        MarketPlaceNftInfo memory newInfo = MarketPlaceNftInfo(nftId,price,ownerAddress,block.timesta\n        nftMap[nftId] = newInfo; \n        sellingNfts.push(nftId); \n        sellingNftIndexs[nftId] = sellingNfts.length; \n      }else{ \n        MarketPlaceNftInfo storage oldInfo = nftMap[nftId]; \n        oldInfo.price = price; \n        oldInfo.upTime = block.timestamp; \n      } \n \n      emit UploadNft(ownerAddress,nftId,price); \n  } \n \n  function stopSell(uint256 nftId) external nonReentrant isPause{ \n    uint index = sellingNftIndexs[nftId]; \n    require(index > 0, \"ERA7CardMarketPlace stopSell: nftId error\"); \n \n    address ownerAddress = IERA7Card(nft).ownerOf(nftId); \n    require(ownerAddress == _msgSender(), \"ERA7CardMarketPlace stopSell: stop error\"); \n \n    _removeNftFromList(nftId); \n \n    emit StopSell(nftId); \n  } \n \n  function _removeNftFromList(uint256 nftId) private{ \n    uint index = sellingNftIndexs[nftId]; \n      if(sellingNfts.length != index){ \n        uint oldNftId = sellingNfts[sellingNfts.length - 1]; \n        sellingNfts[index - 1] = oldNftId; \n        sellingNftIndexs[oldNftId] = index; \n      } \n      sellingNfts.pop(); \n      delete sellingNftIndexs[nftId]; \n      delete nftMap[nftId]; \n  } \n \n  function getTotalNft() external view returns(uint){ \n    return sellingNfts.length; \n  } \n \n  function getSellList(uint start,uint end) external view returns(MarketPlaceNftInfo[] memory){ \n      require(start >= 0 && end >= start,\"ERA7CardMarketPlace getSellList:params error\"); \n \n      uint total = sellingNfts.length; \n      if(total == 0){ \n        return new MarketPlaceNftInfo[](0); \n      } \n      if(start >= total){ \n        start = total - 1; \n      } \n      if(end >= total){ \n        end = total - 1; \n      } \n      uint size = end - start; \n      require(size <= 100,\"ERA7CardMarketPlace getSellList:size error\"); \n \n      MarketPlaceNftInfo[] memory list = new MarketPlaceNftInfo[](size + 1); \n      for(uint i = start; i <= end ; i++){ \n        list[i - start] = nftMap[sellingNfts[i]]; \n      } \n      return list; \n  } \n \n  function buy(uint256 nftId) external nonReentrant isPause { \n    MarketPlaceNftInfo memory info = nftMap[nftId]; \n    require(info.tokenId > 0, \"ERA7CardMarketPlace buy: nftId error\"); \n \n    address ownerAddress = IERA7Card(nft).ownerOf(nftId); \n    require(ownerAddress == info.owner, \"ERA7CardMarketPlace buy: nftId owner change\"); \n \n    SafeERC20.safeTransferFrom(IERC20(coin),_msgSender(),address(this),info.price); \n    IERA7Card(nft).transferFrom(info.owner,address(this),nftId); \n \n    uint256 get = SafeMath.mul(SafeMath.div(info.price,100),95); \n    SafeERC20.safeTransfer(IERC20(coin),info.owner,get); \n    IERA7Card(nft).transferFrom(address(this),_msgSender(),nftId); \n \n    _removeNftFromList(nftId); \n \n    emit Buy(info.owner,_msgSender(),info.tokenId,info.price); \n  } \n \n  event UploadNft(address indexed from, uint256 nftId,uint256 price); \n  event StopSell(uint256 nftId); \n  event Buy(address indexed from, address indexed to, uint256 nftId,uint256 price); \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n} \n// Nft \u9884\u552e\u5408\u7ea6 \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface ILfgSwapPair { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n    function symbol() external pure returns (string memory); \n    function decimals() external pure returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    function MINIMUM_LIQUIDITY() external pure returns (uint); \n    function factory() external view returns (address); \n    function token0() external view returns (address); \n    function token1() external view returns (address); \n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n    function price0CumulativeLast() external view returns (uint); \n    function price1CumulativeLast() external view returns (uint); \n    function kLast() external view returns (uint); \n \n    function mint(address to) external returns (uint liquidity); \n    function burn(address to) external returns (uint amount0, uint amount1); \n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n    function skim(address to) external; \n    function sync() external; \n \n    function initialize(address, address) external; \n} \n \n \n// File contracts/interface/ILfgSwapFactory.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \ncontract MultiSourceOracle is OwnableUpgradeable, ITokenOracle { \n    using SafeMathUpgradeable for uint256; \n \n    struct PriceData { \n        uint price; \n        uint lastUpdate; \n    } \n \n    bool public constant isPriceOracle = true; \n    mapping(address => bool) public opers; \n    mapping(address => address) public priceFeeds; \n    mapping(address => PriceData) public store; \n \n    event PriceUpdate(address indexed _token, uint price); \n    event PriceFeed(address indexed _token, address _feed); \n \n    constructor() public { \n    } \n \n    function initialize() public initializer { \n        __Ownable_init(); \n        opers[msg.sender] = true; \n    } \n \n    function setPriceOperator(address _oper, bool _enable) public onlyOwner { \n        opers[_oper] = _enable; \n    } \n \n    function setFeeds(address[] memory _tokens, address[] memory _feeds) public onlyOwner { \n        require(_tokens.length == _feeds.length, 'bad token length'); \n        for (uint idx = 0; idx < _tokens.length; idx++) { \n            address token0 = _tokens[idx]; \n            address feed = _feeds[idx]; \n            emit PriceFeed(token0, feed); \n            require(ITokenOracle(feed).getPrice(token0) > 0, 'token no price'); \n            priceFeeds[token0] = feed; \n        } \n    } \n \n    /// @dev Set the prices of the token token pairs. Must be called by the oper. \n    // price (scaled by 1e18). \n    function setPrices( \n        address[] memory tokens, \n        uint[] memory prices \n    ) external { \n        require(opers[msg.sender], 'only oper'); \n        require(tokens.length == prices.length, 'bad token length'); \n        for (uint idx = 0; idx < tokens.length; idx++) { \n            address token0 = tokens[idx]; \n            uint price = prices[idx]; \n            store[token0] = PriceData({price: price, lastUpdate: now}); \n            emit PriceUpdate(token0, price); \n        } \nStrategyV2Pair::TransparentUpgradeableProxy.sol\n    } \n \n    function getPrice(address _token) public override view returns (int) { \n        address feed = priceFeeds[_token]; \n        if(feed != address(0)) { \n            return ITokenOracle(feed).getPrice(_token); \n        } \n        require(store[_token].price >= 0, 'price to lower'); \n        return int(store[_token].price); \n    } \n \n \n    /** \n      * @notice Get the underlying price of a cToken asset \n      * @param cToken The cToken to get the underlying price of \n      * @return The underlying asset price mantissa (scaled by 1e18). \n      *  Zero means the price is unavailable. \n      */ \n    function getUnderlyingPrice(address cToken) external view returns (uint) { \n        address token = ICTokenInterface(cToken).underlying(); \n        int price = getPrice(token); \n        require(price >= 0, 'price to lower'); \n        return uint(price).mul(uint(1e18).div(1e8)); \n    } \n}\n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n \n/** \n * @title TokenRecover \n * @dev Allows owner to recover any ERC20 sent into the  contract \n */  \ncontract TokenRecover is Ownable { \n    /** \n     * @dev Remember that only owner can call so  be careful when use on contracts gen\n     * @param tokenAddress The token contract address \n     * @param tokenAmount Number of tokens to be sent \n     */  \n    function recoverERC20(address tokenAddress, uint256 tokenAmount) public virtual onlyOwner { \n        IERC20(tokenAddress).transfer(owner(), tokenAmount); \n    } \n} \n \n// File: contracts/token/ERC20/behaviours/ERC20Decimals.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n/** \n * @dev Implementation of the  {IERC165} interface. \n * \n * Contracts that want to implement ERC165 should  inherit from this contract and overri\n * for the  additional interface id that will  be supported. For\n * \n * ``solidity \n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { \n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); \n * } \n * `` \n * \n * Alternatively, {ERC165Storage} provides an  easier to use but\n */  \nabstract contract ERC165 is IERC165 { \n    /** \n     * @dev See {IERC165-supportsInterface}. \n     */  \n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { \n        return interfaceId == type(IERC165).interfaceId; \n    } \n} \n \n// File: erc-payable-token/contracts/token/ERC1363/IERC1363.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev This abstract contract provides a  fallback function that delegates all calls to an\n * instruction `delegatecall`. We refer to the  second contract as the\n * be specified by overriding the  virtual {_implementation} function. \n * \n * Additionally, delegation to the  implementation can be triggered manually through \n * different contract through the  {_delegate} function. \n * \n * The success and return data of the  delegated call will  b\n */  \nabstract contract Proxy { \n    /** \n     * @dev Delegates the  current call to `implementation`. \n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _delegate(address implementation) internal virtual { \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            // Copy msg.data. We take full control of memory in this inline assembly \n            // block because it will not return to Solidity code. We overwrite the \n            // Solidity scratch pad at memory position 0. \n            calldatacopy(0, 0, calldatasize()) \n \n            // Call the implementation. \n            // out and outsize are 0 because we don't know the size yet. \n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) \n \n            // Copy the returned data. \n            returndatacopy(0, 0, returndatasize()) \n \n            switch result \n            // delegatecall returns 0 on error. \n            case 0 { revert(0, returndatasize()) } \n            default { return(0, returndatasize()) } \n        } \n    } \n \n    /** \n     * @dev This is a  virtual function that should  be override\n     * and {_fallback} should  delegate. \n     */  \n    function _implementation() internal view virtual returns (address); \n \n    /** \n     * @dev Delegates the  current call to the  address return\n     * \n     * This function does not return to its internall call site, it will  return directly to \n     */  \n    function _fallback() internal virtual { \n        _beforeFallback(); \n        _delegate(_implementation()); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * function in the  contract matches the  call data. \n     */  \n    fallback () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Fallback function that delegates calls to the  address returned by `_implemen\n     * is empty. \n     */  \n    receive () external payable virtual { \n        _fallback(); \n    } \n \n    /** \n     * @dev Hook that is called before falling back to the  implementation. Can happen a\n     * call, or as part of the  Solidity `fallback` or `receive` functions. \n     * \n     * If overriden should  call `super._beforeFallback()`. \n     */  \n    function _beforeFallback() internal virtual { \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol'; \nimport {IUniswapV2Router02} from '../../interfaces/IUniswapV2Router02.sol'; \n \ninterface IBaseUniswapAdapter { \n  event Swapped(address fromAsset, address toAsset, uint256 fromAmount, uint256 receivedAmount); \n \n  struct PermitSignature { \n    uint256 amount; \n    uint256 deadline; \n    uint8 v; \n    bytes32 r; \n    bytes32 s; \n  } \n \n  struct AmountCalc { \n    uint256 calculatedAmount; \n    uint256 relativePrice; \n    uint256 amountInUsd; \n    uint256 amountOutUsd; \n    address[] path; \n  } \n \n  function WETH_ADDRESS() external returns (address); \n \n  function MAX_SLIPPAGE_PERCENT() external returns (uint256); \n \n  function FLASHLOAN_PREMIUM_TOTAL() external returns (uint256); \n \n  function USD_ADDRESS() external returns (address); \n \n  function ORACLE() external returns (IPriceOracleGetter); \n \n  function UNISWAP_ROUTER() external returns (IUniswapV2Router02); \n \n  /** \n   * @dev Given an input asset amount, returns the maximum output amount of the other asset and the p\n   * @param amountIn Amount of reserveIn \n   * @param reserveIn Address of the asset to be swap from \n   * @param reserveOut Address of the asset to be swap to \n   * @return uint256 Amount out of the reserveOut \n   * @return uint256 The price of out amount denominated in the reserveIn currency (18 decimals) \n   * @return uint256 In amount of reserveIn value denominated in USD (8 decimals) \n   * @return uint256 Out amount of reserveOut value denominated in USD (8 decimals) \n   * @return address[] The exchange path \n   */ \n  function getAmountsOut( \n    uint256 amountIn, \n    address reserveIn, \n    address reserveOut \n  ) \n    external \n    view \n    returns ( \n      uint256, \n      uint256, \n      uint256, \n      uint256, \n      address[] memory \n    ); \n \n  /** \n   * @dev Returns the minimum input asset amount required to buy the given output asset amount and th\n   * @param amountOut Amount of reserveOut \n   * @param reserveIn Address of the asset to be swap from \n   * @param reserveOut Address of the asset to be swap to \n   * @return uint256 Amount in of the reserveIn \n   * @return uint256 The price of in amount denominated in the reserveOut currency (18 decimals) \n   * @return uint256 In amount of reserveIn value denominated in USD (8 decimals) \n   * @return uint256 Out amount of reserveOut value denominated in USD (8 decimals) \n   * @return address[] The exchange path \n   */ \n  function getAmountsIn( \n    uint256 amountOut, \n    address reserveIn, \n    address reserveOut \n  ) \n    external \n    view \n    returns ( \n      uint256, \n      uint256, \n      uint256, \n      uint256, \n      address[] memory \n    ); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \ninterface ILendingPoolConfigurator { \n  struct InitReserveInput { \n    address aTokenImpl; \n    address stableDebtTokenImpl; \n    address variableDebtTokenImpl; \n    uint8 underlyingAssetDecimals; \n    address interestRateStrategyAddress; \n    address underlyingAsset; \n    address treasury; \n    address incentivesController; \n    string underlyingAssetName; \n    string aTokenName; \n    string aTokenSymbol; \n    string variableDebtTokenName; \n    string variableDebtTokenSymbol; \n    string stableDebtTokenName; \n    string stableDebtTokenSymbol; \n    bytes params; \n  } \n \n  struct UpdateATokenInput { \n    address asset; \n    address treasury; \n    address incentivesController; \n    string name; \n    string symbol; \n    address implementation; \n    bytes params; \n  } \n \n  struct UpdateDebtTokenInput { \n    address asset; \n    address incentivesController; \n    string name; \n    string symbol; \n    address implementation; \n    bytes params; \n  } \n \n  /** \n   * @dev Emitted when a reserve is initialized. \n   * @param asset The address of the underlying asset of the reserve \n   * @param aToken The address of the associated aToken contract \n   * @param stableDebtToken The address of the associated stable rate debt token \n   * @param variableDebtToken The address of the associated variable rate debt token \n   * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve \n   **/ \n  event ReserveInitialized( \n    address indexed asset, \n    address indexed aToken, \n    address stableDebtToken, \n    address variableDebtToken, \n    address interestRateStrategyAddress \n  ); \n \n  /** \n   * @dev Emitted when borrowing is enabled on a reserve \n   * @param asset The address of the underlying asset of the reserve \n   * @param stableRateEnabled True if stable rate borrowing is enabled, false otherwise \n   **/ \n  event BorrowingEnabledOnReserve(address indexed asset, bool stableRateEnabled); \n \n  /** \n   * @dev Emitted when borrowing is disabled on a reserve \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  event BorrowingDisabledOnReserve(address indexed asset); \n \n  /** \n   * @dev Emitted when the collateralization risk parameters for the specified asset are updated. \n   * @param asset The address of the underlying asset of the reserve \n   * @param ltv The loan to value of the asset when used as collateral \n   * @param liquidationThreshold The threshold at which loans using this asset as collateral will be \n   * @param liquidationBonus The bonus liquidators receive to liquidate this asset \n   **/ \n  event CollateralConfigurationChanged( \n    address indexed asset, \n    uint256 ltv, \n    uint256 liquidationThreshold, \n    uint256 liquidationBonus \n  ); \n \n  /** \n   * @dev Emitted when stable rate borrowing is enabled on a reserve \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  event StableRateEnabledOnReserve(address indexed asset); \n \n  /** \n   * @dev Emitted when stable rate borrowing is disabled on a reserve \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  event StableRateDisabledOnReserve(address indexed asset); \n \n  /** \n   * @dev Emitted when a reserve is activated \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  event ReserveActivated(address indexed asset); \n \n  /** \n   * @dev Emitted when a reserve is deactivated \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  event ReserveDeactivated(address indexed asset); \n \n  /** \n   * @dev Emitted when a reserve is frozen \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  event ReserveFrozen(address indexed asset); \n \n  /** \n   * @dev Emitted when a reserve is unfrozen \n   * @param asset The address of the underlying asset of the reserve \n   **/ \n  event ReserveUnfrozen(address indexed asset); \n \n  /** \n   * @dev Emitted when a reserve factor is updated \n   * @param asset The address of the underlying asset of the reserve \n   * @param factor The new reserve factor \n   **/ \n  event ReserveFactorChanged(address indexed asset, uint256 factor); \n \n  /** \n   * @dev Emitted when the reserve decimals are updated \n   * @param asset The address of the underlying asset of the reserve \n   * @param decimals The new decimals \n   **/ \n  event ReserveDecimalsChanged(address indexed asset, uint256 decimals); \n \n  /** \n   * @dev Emitted when a reserve interest strategy contract is updated \n   * @param asset The address of the underlying asset of the reserve \n   * @param strategy The new address of the interest strategy contract \n   **/ \n  event ReserveInterestRateStrategyChanged(address indexed asset, address strategy); \n \n  /** \n   * @dev Emitted when an aToken implementation is upgraded \n   * @param asset The address of the underlying asset of the reserve \n   * @param proxy The aToken proxy address \n   * @param implementation The new aToken implementation \n   **/ \n  event ATokenUpgraded( \n    address indexed asset, \n    address indexed proxy, \n    address indexed implementation \n  ); \n \n  /** \n   * @dev Emitted when the implementation of a stable debt token is upgraded \n   * @param asset The address of the underlying asset of the reserve \n   * @param proxy The stable debt token proxy address \n   * @param implementation The new aToken implementation \n   **/ \n  event StableDebtTokenUpgraded( \n    address indexed asset, \n    address indexed proxy, \n    address indexed implementation \n  ); \n \n  /** \n   * @dev Emitted when the implementation of a variable debt token is upgraded \n   * @param asset The address of the underlying asset of the reserve \n   * @param proxy The variable debt token proxy address \n   * @param implementation The new aToken implementation \n   **/ \n  event VariableDebtTokenUpgraded( \n    address indexed asset, \n    address indexed proxy, \n    address indexed implementation \n  ); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \nIBEP20.sol\n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n}\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n// a library for performing various math operations \n \nlibrary Math { \n    function min(uint x, uint y) internal pure returns (uint z) { \n        z = x < y ? x : y; \n    } \n \n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_\n    function sqrt(uint y) internal pure returns (uint z) { \n        if (y > 3) { \n            z = y; \n            uint x = y / 2 + 1; \n            while (x < z) { \n                z = x; \n                x = (y / x + x) / 2; \n            } \n        } else if (y != 0) { \n            z = 1; \n        } \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.6.0; \n \n/** \n * @title Proxy \n * @dev Implements delegation of calls to other contracts, with proper \n * forwarding of return values and bubbling of failures. \n * It defines a fallback function that delegates all calls to the address \n * returned by the abstract _implementation() internal function. \n */ \nabstract contract Proxy { \n  /** \n   * @dev Fallback function. \n   * Implemented entirely in `_fallback`. \n   */ \n  fallback() external payable { \n    _fallback(); \n  } \n \n  /** \n   * @return The Address of the implementation. \n   */ \n  function _implementation() internal view virtual returns (address); \n \n  /** \n   * @dev Delegates execution to an implementation contract. \n   * This is a low level function that doesn't return to its internal call site. \n   * It will return to the external caller whatever the implementation returns. \n   * @param implementation Address to delegate. \n   */ \n  function _delegate(address implementation) internal { \n    //solium-disable-next-line \n    assembly { \n      // Copy msg.data. We take full control of memory in this inline assembly \n      // block because it will not return to Solidity code. We overwrite the \n      // Solidity scratch pad at memory position 0. \n      calldatacopy(0, 0, calldatasize()) \n \n      // Call the implementation. \n      // out and outsize are 0 because we don't know the size yet. \n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) \n \n      // Copy the returned data. \n      returndatacopy(0, 0, returndatasize()) \n \n      switch result \n        // delegatecall returns 0 on error. \n        case 0 { \n          revert(0, returndatasize()) \n        } \n        default { \n          return(0, returndatasize()) \n        } \n    } \n  } \n \n  /** \n   * @dev Function that is run as the first thing in the fallback function. \n   * Can be redefined in derived contracts to add functionality. \n   * Redefinitions must call super._willFallback(). \n   */ \n  function _willFallback() internal virtual {} \n \n  /** \n   * @dev fallback implementation. \n   * Extracted to enable manual triggering. \n   */ \n  function _fallback() internal { \n    _willFallback(); \n    _delegate(_implementation()); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ChainlinkUSDETHOracleI { \n  event AnswerUpdated(int256 indexed current, uint256 indexed answerId); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.8.10; \n \ninterface IBEP20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the token decimals. \n     */ \n    function decimals() external view returns (uint8); \n \n    /** \n     * @dev Returns the token symbol. \n     */ \n    function symbol() external view returns (string memory); \n \n    /** \n     * @dev Returns the token name. \n     */ \n    function name() external view returns (string memory); \n \n    /** \n     * @dev Returns the bep token owner. \n     */ \n    function getOwner() external view returns (address); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address _owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n// File contracts/Token.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.2; \n \ninterface IUniswapV2Router01 { \n    function factory() external pure returns (address); \n    function WHT() external pure returns (address); \n \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB, uint liquidity); \n    function addLiquidityHT( \n        address token, \n        uint amountTokenDesired, \n        uint amountTokenMin, \n        uint amountHTMin, \n        address to, \n        uint deadline \n    ) external payable returns (uint amountToken, uint amountHT, uint liquidity); \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityHT( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountHTMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountToken, uint amountHT); \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityHTWithPermit( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountHTMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountToken, uint amountHT); \n    function swapExactTokensForTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapTokensForExactTokens( \n        uint amountOut, \n        uint amountInMax, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapExactHTForTokens(uint amountOutMin, address[] calldata path, address to, uint deadli\n        external \n        payable \n        returns (uint[] memory amounts); \n    function swapTokensForExactHT(uint amountOut, uint amountInMax, address[] calldata path, address \n        external \n        returns (uint[] memory amounts); \n    function swapExactTokensForHT(uint amountIn, uint amountOutMin, address[] calldata path, address \n        external \n        returns (uint[] memory amounts); \n    function swapHTForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external \n        payable \n        returns (uint[] memory amounts); \n \n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB); \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint \n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint \n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memo\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memo\n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./ERC20.sol\"; \nimport \"../Pausable.sol\"; \n \n/** \n * @dev ERC20 token with pausable token transfers, minting and burning. \n * \n * Useful for scenarios such as preventing trades until the end of an evaluation \n * period, or having an emergency switch for freezing all token transfers in the \n * event of a large bug. \n */ \nabstract contract ERC20Pausable is ERC20, Pausable { \n    /** \n     * @dev See {ERC20-_beforeTokenTransfer}. \n     * \n     * Requirements: \n     * \n     * - the contract must not be paused. \n     */ \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override\n        super._beforeTokenTransfer(from, to, amount); \n \n        require(!paused(), \"ERC20Pausable: token transfer while paused\"); \n    } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol'; \n \nimport {FlashLoanReceiverBase} from '../../flashloan/base/FlashLoanReceiverBase.sol'; \nimport {MintableERC20} from '../tokens/MintableERC20.sol'; \nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \n \ncontract MockFlashLoanReceiver is FlashLoanReceiverBase { \n  using SafeERC20 for IERC20; \n \n  ILendingPoolAddressesProvider internal _provider; \n \n  event ExecutedWithFail(address[] _assets, uint256[] _amounts, uint256[] _premiums); \n  event ExecutedWithSuccess(address[] _assets, uint256[] _amounts, uint256[] _premiums); \n \n  bool _failExecution; \n  uint256 _amountToApprove; \n  bool _simulateEOA; \n \n  constructor(ILendingPoolAddressesProvider provider) public FlashLoanReceiverBase(provider) {} \n \n  function setFailExecutionTransfer(bool fail) public { \n    _failExecution = fail; \n  } \n \n  function setAmountToApprove(uint256 amountToApprove) public { \n    _amountToApprove = amountToApprove; \n  } \n \n  function setSimulateEOA(bool flag) public { \n    _simulateEOA = flag; \n  } \n \n  function amountToApprove() public view returns (uint256) { \n    return _amountToApprove; \n  } \n \n  function simulateEOA() public view returns (bool) { \n    return _simulateEOA; \n  } \n \n  function executeOperation( \n    address[] memory assets, \n    uint256[] memory amounts, \n    uint256[] memory premiums, \n    address initiator, \n    bytes memory params \n  ) public override returns (bool) { \n    params; \n    initiator; \n \n    if (_failExecution) { \n      emit ExecutedWithFail(assets, amounts, premiums); \n      return !_simulateEOA; \n    } \n \n    for (uint256 i = 0; i < assets.length; i++) { \n      //mint to this contract the specific amount \n      MintableERC20 token = MintableERC20(assets[i]); \n \n      //check the contract has the specified balance \n      require( \n        amounts[i] <= IERC20(assets[i]).balanceOf(address(this)), \n        'Invalid balance for the contract' \n      ); \n \n      uint256 amountToReturn = \n        (_amountToApprove != 0) ? _amountToApprove : amounts[i].add(premiums[i]); \n      //execution does not fail - mint tokens and return them to the _destination \n \n      token.mint(premiums[i]); \n \n      IERC20(assets[i]).approve(address(LENDING_POOL), amountToReturn); \n    } \n \n    emit ExecutedWithSuccess(assets, amounts, premiums); \n \n    return true; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IWETH { \n  function deposit() external payable; \n \n  function withdraw(uint256) external; \n \n  function approve(address guy, uint256 wad) external returns (bool); \n \n  function transferFrom( \n    address src, \n    address dst, \n    uint256 wad \n  ) external returns (bool); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n}\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes calldata) { \n        return msg.data; \n    } \n} \n \n \n// File @openzeppelin/contracts/access/Ownable.sol@v4.3.3 \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./libraries/SafeMath.sol\"; \nimport \"./Context.sol\"; \n \ncontract StakeRewardPerBlock is Context { \n    using SafeMath for uint256; \n \n    uint256 public BrewardRate; // Global Reward per Unit \n    uint256 public BrewardPreBlock; \n    uint256 public BlastUpdateBlock; // last adjust block height \n    uint256 public totalStake; \n \n    mapping(address => uint256) public userStake; \n    mapping(address => uint256) public BuserReward; \n    mapping(address => uint256) public BuserRate; \n \n    constructor() { \n        BrewardRate = 0; \n        BrewardPreBlock = 0; \n        totalStake = 0; \n        BlastUpdateBlock = block.number; \n    } \n \n    modifier BupdateRate() { \n        if ( \n            BrewardPreBlock > 0 && \n            totalStake > 0 && \n            block.number > BlastUpdateBlock \n        ) { \n            uint256 deltaRate = \n                BrewardPreBlock.mul(block.number - BlastUpdateBlock).div( \n                    totalStake \n                ); \n            BrewardRate = BrewardRate.add(deltaRate); \n        } \n        BlastUpdateBlock = block.number; \n        _; \n    } \n \n    modifier BgetReward() { \n        if ( \n            userStake[_msgSender()] > 0 && BrewardRate > BuserRate[_msgSender()] \n        ) { \n            uint256 deltaReward = \n                BrewardRate.sub(BuserRate[_msgSender()]).mul( \n                    userStake[_msgSender()] \n                ); \n            BuserReward[_msgSender()] = BuserReward[_msgSender()].add( \n                deltaReward \n            ); \n        } \n        BuserRate[_msgSender()] = BrewardRate; \n        _; \n    } \n \n    function _setReward(uint256 amount) internal BupdateRate { \n        BrewardPreBlock = amount.mul(1e18); \n    } \n \n    function _stake(uint256 amount) internal BupdateRate BgetReward { \n        userStake[_msgSender()] = userStake[_msgSender()].add(amount); \n        totalStake = totalStake.add(amount); \n    } \n \n    function _BhalveNoUpdate() internal returns (uint256 reward) { \n        reward = BuserReward[_msgSender()].div(1e18); \n        BuserReward[_msgSender()] = 0; \n    } \n \n    function _Bhalve() internal BupdateRate BgetReward returns (uint256 reward) { \n        return _BhalveNoUpdate(); \n    } \n \n    function _unStake() \n        internal \n        BupdateRate \n        BgetReward \n        returns (uint256 stake, uint256 reward) \n    { \n        stake = userStake[_msgSender()]; \n        totalStake = totalStake.sub(stake); \n        userStake[_msgSender()] = 0; \n        reward = _BhalveNoUpdate(); \n    } \n \n    function _getStake() internal view returns (uint256 stake) { \n        stake = userStake[_msgSender()]; \n    } \n \n    function _BcaleReward() internal view returns (uint256 reward) { \n        if (userStake[_msgSender()] == 0) { \n            return 0; \n        } \n        uint256 tempRate = BrewardRate; \n        if ( \n            BrewardPreBlock > 0 && \n            totalStake > 0 && \n            block.number > BlastUpdateBlock \n        ) { \n            uint256 deltaRate = \n                BrewardPreBlock.mul(block.number - BlastUpdateBlock).div( \n                    totalStake \n                ); \n            tempRate = tempRate.add(deltaRate); \n        } \n        reward = BuserReward[_msgSender()]; \n        if (tempRate > BuserRate[_msgSender()]) { \n            uint256 deltaReward = \n                tempRate.sub(BuserRate[_msgSender()]).mul( \n                    userStake[_msgSender()] \n                ); \n            reward = reward.add(deltaReward); \n        } \n        reward = reward.div(1e18); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.6.0; \n \nlibrary SafeMath { \n \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a, \"SafeMath: addition overflow\"); \n \n        return c; \n    } \n \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        return sub(a, b, \"SafeMath: subtraction overflow\"); \n    } \n \n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b <= a, errorMessage); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b, \"SafeMath: multiplication overflow\"); \n \n        return c; \n    } \n \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        return div(a, b, \"SafeMath: division by zero\"); \n    } \n \n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b > 0, errorMessage); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        return mod(a, b, \"SafeMath: modulo by zero\"); \n    } \n \n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \n        require(b != 0, errorMessage); \n        return a % b; \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Mintable { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) \n        external \n        returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) \n        external \n        view \n        returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external returns (bool); \n \n    function mint(address recipient, uint256 amount) external; \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval( \n        address indexed owner, \n        address indexed spender, \n        uint256 value \n    ); \n \n    event AddMinter(address indexed minter); \n    event RemoveMinter(address indexed minter); \n    event Mint( \n        address indexed minter, \n        address indexed recipient, \n        uint256 amount \n    ); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes calldata) { \n        return msg.data; \n    } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n  /** \n   * @dev Returns the addition of two unsigned integers, reverting on \n   * overflow. \n   * \n   * Counterpart to Solidity's `+` operator. \n   * \n   * Requirements: \n   * - Addition cannot overflow. \n   */ \n  function add(uint256 a, uint256 b) internal pure returns (uint256) { \n    uint256 c = a + b; \n    require(c >= a, 'SafeMath: addition overflow'); \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the subtraction of two unsigned integers, reverting on \n   * overflow (when the result is negative). \n   * \n   * Counterpart to Solidity's `-` operator. \n   * \n   * Requirements: \n   * - Subtraction cannot overflow. \n   */ \n  function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n    return sub(a, b, 'SafeMath: subtraction overflow'); \n  } \n \n  /** \n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n   * overflow (when the result is negative). \n   * \n   * Counterpart to Solidity's `-` operator. \n   * \n   * Requirements: \n   * - Subtraction cannot overflow. \n   */ \n  function sub( \n    uint256 a, \n    uint256 b, \n    string memory errorMessage \n  ) internal pure returns (uint256) { \n    require(b <= a, errorMessage); \n    uint256 c = a - b; \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the multiplication of two unsigned integers, reverting on \n   * overflow. \n   * \n   * Counterpart to Solidity's `*` operator. \n   * \n   * Requirements: \n   * - Multiplication cannot overflow. \n   */ \n  function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n    // benefit is lost if 'b' is also tested. \n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n    if (a == 0) { \n      return 0; \n    } \n \n    uint256 c = a * b; \n    require(c / a == b, 'SafeMath: multiplication overflow'); \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the integer division of two unsigned integers. Reverts on \n   * division by zero. The result is rounded towards zero. \n   * \n   * Counterpart to Solidity's `/` operator. Note: this function uses a \n   * `revert` opcode (which leaves remaining gas untouched) while Solidity \n   * uses an invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function div(uint256 a, uint256 b) internal pure returns (uint256) { \n    return div(a, b, 'SafeMath: division by zero'); \n  } \n \n  /** \n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on \n   * division by zero. The result is rounded towards zero. \n   * \n   * Counterpart to Solidity's `/` operator. Note: this function uses a \n   * `revert` opcode (which leaves remaining gas untouched) while Solidity \n   * uses an invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function div( \n    uint256 a, \n    uint256 b, \n    string memory errorMessage \n  ) internal pure returns (uint256) { \n    // Solidity only automatically asserts when dividing by 0 \n    require(b > 0, errorMessage); \n    uint256 c = a / b; \n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n    return c; \n  } \n \n  /** \n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n   * Reverts when dividing by zero. \n   * \n   * Counterpart to Solidity's `%` operator. This function uses a `revert` \n   * opcode (which leaves remaining gas untouched) while Solidity uses an \n   * invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n    return mod(a, b, 'SafeMath: modulo by zero'); \n  } \n \n  /** \n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n   * Reverts with custom message when dividing by zero. \n   * \n   * Counterpart to Solidity's `%` operator. This function uses a `revert` \n   * opcode (which leaves remaining gas untouched) while Solidity uses an \n   * invalid opcode to revert (consuming all remaining gas). \n   * \n   * Requirements: \n   * - The divisor cannot be zero. \n   */ \n  function mod( \n    uint256 a, \n    uint256 b, \n    string memory errorMessage \n  ) internal pure returns (uint256) { \n    require(b != 0, errorMessage); \n    return a % b; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title VersionedInitializable \n * \n * @dev Helper contract to implement initializer functions. To use it, replace \n * the constructor with a function that has the `initializer` modifier. \n * WARNING: Unlike constructors, initializer functions must be manually \n * invoked. This applies both to deploying an Initializable contract, as well \n * as extending an Initializable contract via inheritance. \n * WARNING: When used with inheritance, manual care must be taken to not invoke \n * a parent initializer twice, or ensure that all initializers are idempotent, \n * because this is not dealt with automatically as with constructors. \n * \n * @author Aave, inspired by the OpenZeppelin Initializable contract \n */ \nabstract contract VersionedInitializable { \n  /** \n   * @dev Indicates that the contract has been initialized. \n   */ \n  uint256 private lastInitializedRevision = 0; \n \n  /** \n   * @dev Indicates that the contract is in the process of being initialized. \n   */ \n  bool private initializing; \n \n  /** \n   * @dev Modifier to use in the initializer function of a contract. \n   */ \n  modifier initializer() { \n    uint256 revision = getRevision(); \n    require( \n      initializing || isConstructor() || revision > lastInitializedRevision, \n      'Contract instance has already been initialized' \n    ); \n \n    bool isTopLevelCall = !initializing; \n    if (isTopLevelCall) { \n      initializing = true; \n      lastInitializedRevision = revision; \n    } \n \n    _; \n \n    if (isTopLevelCall) { \n      initializing = false; \n    } \n  } \n \n  /** \n   * @dev returns the revision number of the contract \n   * Needs to be defined in the inherited class as a constant. \n   **/ \n  function getRevision() internal pure virtual returns (uint256); \n \n  /** \n   * @dev Returns true if and only if the function is running in the constructor \n   **/ \n  function isConstructor() private view returns (bool) { \n    // extcodesize checks the size of the code stored in an address, and \n    // address returns the current address. Since the code is still not \n    // deployed when running a constructor, any checks on its code size will \n    // yield zero, making it an effective way to detect if a contract is \n    // under construction or not. \n    uint256 cs; \n    //solium-disable-next-line \n    assembly { \n      cs := extcodesize(address()) \n    } \n    return cs == 0; \n  } \n \n  // Reserved storage space to allow for layout changes in the future. \n  uint256[50] private ______gap; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Upgradeable { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"./comm/Helper.sol\"; \nimport \"./IERA7Card.sol\"; \n \ncontract ERA7CardPreSale is Helper { \n \n  address public coin; \n  address public nft; \n \n  struct PreSaleNftInfo{ \n    uint cardId; \n    uint price; \n    uint count; \n  } \n \n  uint[] public sellingNfts; \n  mapping(uint => uint) public sellingNftIndexs; \n  mapping(uint => PreSaleNftInfo) public sellingInfos; \n \n  constructor() {} \n \n  function initAddress(address coin_,address nft_) external onlyHelper { \n    require((coin_ != address(0) && nft_ != address(0)), \"ERA7CardPreSale initAddress: address error\"\n \n    coin = coin_; \n    nft = nft_; \n  } \n \n  function withdraw(address taxWallet) external onlyHelper returns(bool){ \n    require(taxWallet != address(0), \"ERA7CardPreSale withdraw: taxWallet error\"); \n \n    uint256 val = IERC20(coin).balanceOf(address(this)); \n    require(val > 0, \"ERA7CardPreSale withdraw: val error\"); \n \n    IERC20(coin).transfer(taxWallet,val); \n    return true; \n  } \n \n  function uploadNft(uint cardId,uint256 price,uint count) external onlyHelper{ \n      require(cardId > 0 && price > 0 && count > 0, \"ERA7CardPreSale uploadNft: params error\"); \n \n      uint index = sellingNftIndexs[cardId]; \n      if(index == 0){ \n        PreSaleNftInfo memory newInfo = PreSaleNftInfo(cardId,price,count); \n        sellingInfos[cardId] = newInfo; \n        sellingNfts.push(cardId); \n        sellingNftIndexs[cardId] = sellingNfts.length; \n      }else{ \n        PreSaleNftInfo storage oldInfo = sellingInfos[cardId]; \n        oldInfo.price = price; \n        oldInfo.count = count; \n      } \n  } \n \n  function stopSell(uint cardId) external onlyHelper{ \n      PreSaleNftInfo storage info = sellingInfos[cardId]; \n      require(info.cardId > 0, \"ERA7CardPreSale stopSell: cardId error\"); \n \n      uint index = sellingNftIndexs[cardId]; \n      if(sellingNfts.length != index){ \n        uint oldCardId = sellingNfts[sellingNfts.length - 1]; \n        sellingNfts[index - 1] = oldCardId; \n        sellingNftIndexs[oldCardId] = index; \n      } \n      sellingNfts.pop(); \n      delete sellingNftIndexs[cardId]; \n      delete sellingInfos[cardId]; \n  } \n \n  function getSellList() external view returns(PreSaleNftInfo[] memory){ \n      uint len = sellingNfts.length; \n      PreSaleNftInfo[] memory list = new PreSaleNftInfo[](len); \n      for(uint i = 0; i < len ;i++){ \n        list[i] = sellingInfos[sellingNfts[i]]; \n      } \n      return list; \n  } \n \n  function buy(uint cardId) external nonReentrant returns(uint256){ \n      PreSaleNftInfo storage info = sellingInfos[cardId]; \n      require(info.cardId > 0, \"ERA7CardPreSale buy: cardId error\"); \n \n      uint count = info.count; \n      require(count > 0, \"ERA7CardPreSale buy: count error\"); \n      info.count--; \n \n      address buyAddress = _msgSender(); \n      SafeERC20.safeTransferFrom(IERC20(coin),buyAddress,address(this),info.price); \n \n      uint256 tokenId = IERA7Card(nft).awardCard(buyAddress,cardId); \n \n      emit Buy(_msgSender(),cardId,info.price); \n \n      return tokenId; \n  } \n \n  event Buy(address indexed to, uint256 cardId,uint256 price); \n \n \n \n \n \n \n \n \n \n \n \n \n \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \ninterface IMdexPair { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n \n    function symbol() external pure returns (string memory); \n \n    function decimals() external pure returns (uint8); \n \n    function totalSupply() external view returns (uint); \n \n    function balanceOf(address owner) external view returns (uint); \n \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n \n    function transfer(address to, uint value) external returns (bool); \n \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    function MINIMUM_LIQUIDITY() external pure returns (uint); \n \n    function factory() external view returns (address); \n \n    function token0() external view returns (address); \n \n    function token1() external view returns (address); \n \n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n \n    function price0CumulativeLast() external view returns (uint); \n \n    function price1CumulativeLast() external view returns (uint); \n \n    function kLast() external view returns (uint); \n \n    function mint(address to) external returns (uint liquidity); \n \n    function burn(address to) external returns (uint amount0, uint amount1); \n \n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n \n    function skim(address to) external; \n \n    function sync() external; \n \n    function price(address token, uint256 baseDecimal) external view returns (uint256); \n \n    function initialize(address, address) external; \n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport { \n  ILendingPoolAddressesProviderRegistry \n} from '../../interfaces/ILendingPoolAddressesProviderRegistry.sol'; \nimport {Errors} from '../libraries/helpers/Errors.sol'; \n \n/** \n * @title LendingPoolAddressesProviderRegistry contract \n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets \n * - Used for indexing purposes of Aave protocol's markets \n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with, \n *   for example with `0` for the Aave main market and `1` for the next created \n * @author Aave \n **/ \ncontract LendingPoolAddressesProviderRegistry is Ownable, ILendingPoolAddressesProviderRegistry { \n  mapping(address => uint256) private _addressesProviders; \n  address[] private _addressesProvidersList; \n \n  /** \n   * @dev Returns the list of registered addresses provider \n   * @return The list of addresses provider, potentially containing address(0) elements \n   **/ \n  function getAddressesProvidersList() external view override returns (address[] memory) { \n    address[] memory addressesProvidersList = _addressesProvidersList; \n \n    uint256 maxLength = addressesProvidersList.length; \n \n    address[] memory activeProviders = new address[](maxLength); \n \n    for (uint256 i = 0; i < maxLength; i++) { \n      if (_addressesProviders[addressesProvidersList[i]] > 0) { \n        activeProviders[i] = addressesProvidersList[i]; \n      } \n    } \n \n    return activeProviders; \n  } \n \n  /** \n   * @dev Registers an addresses provider \n   * @param provider The address of the new LendingPoolAddressesProvider \n   * @param id The id for the new LendingPoolAddressesProvider, referring to the market it belongs to\n   **/ \n  function registerAddressesProvider(address provider, uint256 id) external override onlyOwner { \n    require(id != 0, Errors.LPAPR_INVALID_ADDRESSES_PROVIDER_ID); \n \n    _addressesProviders[provider] = id; \n    _addToAddressesProvidersList(provider); \n    emit AddressesProviderRegistered(provider); \n  } \n \n  /** \n   * @dev Removes a LendingPoolAddressesProvider from the list of registered addresses provider \n   * @param provider The LendingPoolAddressesProvider address \n   **/ \n  function unregisterAddressesProvider(address provider) external override onlyOwner { \n    require(_addressesProviders[provider] > 0, Errors.LPAPR_PROVIDER_NOT_REGISTERED); \n    _addressesProviders[provider] = 0; \n    emit AddressesProviderUnregistered(provider); \n  } \n \n  /** \n   * @dev Returns the id on a registered LendingPoolAddressesProvider \n   * @return The id or 0 if the LendingPoolAddressesProvider is not registered \n   */ \n  function getAddressesProviderIdByAddress(address addressesProvider) \n    external \n    view \n    override \n    returns (uint256) \n  { \n    return _addressesProviders[addressesProvider]; \n  } \n \n  function _addToAddressesProvidersList(address provider) internal { \n    uint256 providersCount = _addressesProvidersList.length; \n \n    for (uint256 i = 0; i < providersCount; i++) { \n      if (_addressesProvidersList[i] == provider) { \n        return; \n      } \n    } \n \n    _addressesProvidersList.push(provider); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n/** \n * @title ERC20Mintable \n * @dev Implementation of the  ERC20Mintable. Extension of {ERC20} that adds \n */  \nabstract contract ERC20Mintable is ERC20 { \n    // indicates if minting is finished \n    bool private _mintingFinished = false; \n \n    /** \n     * @dev Emitted during finish minting \n     */  \n    event MintFinished(); \n \n    /** \n     * @dev Tokens can be minted only before minting finished. \n     */  \n    modifier canMint() { \n        require(!_mintingFinished, \"ERC20Mintable: minting is finished\"); \n        _; \n    } \n \n    /** \n     * @return if minting is finished or not. \n     */  \n    function mintingFinished() external view returns (bool) { \n        return _mintingFinished; \n    } \n \n    /** \n     * @dev Function to mint tokens. \n     * \n     * WARNING: it allows everyone to mint new tokens. Access controls MUST be defined in derived contracts. \n     * \n     * @param account The address that will  receive the  m\n     * @param amount The amount of tokens to mint \n     */  \n    function mint(address account, uint256 amount) external canMint { \n        _mint(account, amount); \n    } \n \n    /** \n     * @dev Function to stop minting new tokens. \n     * \n     * WARNING: it allows everyone to finish minting. Access controls MUST be defined in derived contracts. \n     */  \n    function finishMinting() external canMint { \n        _finishMinting(); \n    } \n \n    /** \n     * @dev Function to stop minting new tokens. \n     */  \n    function _finishMinting() internal virtual { \n        _mintingFinished = true; \n \n        emit MintFinished(); \n    } \n} \n \n// File: @openzeppelin/contracts/access/IAccessControl.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.8.9; \n \ninterface IMonstropolyDeployer { \n    function addr(bytes32) external view returns (address); \n    function get(bytes32) external view returns (address); \n    function set(string memory , address) external; \n}\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport './Proxy.sol'; \nimport '../contracts/Address.sol'; \n \n/** \n * @title BaseUpgradeabilityProxy \n * @dev This contract implements a proxy that allows to change the \n * implementation address to which it will delegate. \n * Such a change is called an implementation upgrade. \n */ \ncontract BaseUpgradeabilityProxy is Proxy { \n  /** \n   * @dev Emitted when the implementation is upgraded. \n   * @param implementation Address of the new implementation. \n   */ \n  event Upgraded(address indexed implementation); \n \n  /** \n   * @dev Storage slot with the address of the current implementation. \n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is \n   * validated in the constructor. \n   */ \n  bytes32 internal constant IMPLEMENTATION_SLOT = \n    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; \n \n  /** \n   * @dev Returns the current implementation. \n   * @return impl Address of the current implementation \n   */ \n  function _implementation() internal view override returns (address impl) { \n    bytes32 slot = IMPLEMENTATION_SLOT; \n    //solium-disable-next-line \n    assembly { \n      impl := sload(slot) \n    } \n  } \n \n  /** \n   * @dev Upgrades the proxy to a new implementation. \n   * @param newImplementation Address of the new implementation. \n   */ \n  function _upgradeTo(address newImplementation) internal { \n    _setImplementation(newImplementation); \n    emit Upgraded(newImplementation); \n  } \n \n  /** \n   * @dev Sets the implementation address of the proxy. \n   * @param newImplementation Address of the new implementation. \n   */ \n  function _setImplementation(address newImplementation) internal { \n    require( \n      Address.isContract(newImplementation), \n      'Cannot set a proxy implementation to a non-contract address' \n    ); \n \n    bytes32 slot = IMPLEMENTATION_SLOT; \n \n    //solium-disable-next-line \n    assembly { \n      sstore(slot, newImplementation) \n    } \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n/** \n * @title ERC20Decimals \n * @dev Implementation of the  ERC20Decimals. Extension of {ERC20} that adds decim\n */  \nabstract contract ERC20Decimals is ERC20 { \n    uint8 private immutable _decimals; \n \n    /** \n     * @dev Sets the  value of the  `decimals`. This value is i\n     * set once during construction. \n     */  \n    constructor(uint8 decimals_) { \n        _decimals = decimals_; \n    } \n \n    function decimals() public view virtual override returns (uint8) { \n        return _decimals; \n    } \n} \n \n// File: contracts/token/ERC20/behaviours/ERC20Mintable.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"./IERC20.sol\"; \n \n/** \n * @dev Interface for the optional metadata functions from the ERC20 standard. \n * \n * _Available since v4.1._ \n */ \ninterface IERC20Metadata is IERC20 { \n    /** \n     * @dev Returns the name of the token. \n     */ \n    function name() external view returns (string memory); \n \n    /** \n     * @dev Returns the symbol of the token. \n     */ \n    function symbol() external view returns (string memory); \n \n    /** \n     * @dev Returns the decimals places of the token. \n     */ \n    function decimals() external view returns (uint8); \n}\n     * \n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]\n     */ \n    function _afterTokenTransfer( \n        address from, \n        address to, \n        uint256 amount \n    ) internal virtual {} \n} \nContext.sol\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @dev Provides information about the  current execution context, including \n * sender of the  transaction and its data. While these are  g\n * via msg.sender and msg.data, they  should  not be acces\n * manner, since when dealing with meta-transactions the  account sending and \n * paying for execution may not be the  actual sender (as far as an\n * is concerned). \n * \n * This contract is only required for intermediate, library- like  contracts. \n */  \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes calldata) { \n        return msg.data; \n    } \n} \n \n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IERC20} from './IERC20.sol'; \nimport {SafeMath} from './SafeMath.sol'; \nimport {Address} from './Address.sol'; \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20 { \n  using SafeMath for uint256; \n  using Address for address; \n \n  function safeTransfer( \n    IERC20 token, \n    address to, \n    uint256 value \n  ) internal { \n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n  } \n \n  function safeTransferFrom( \n    IERC20 token, \n    address from, \n    address to, \n    uint256 value \n  ) internal { \n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value)); \n  } \n \n  function safeApprove( \n    IERC20 token, \n    address spender, \n    uint256 value \n  ) internal { \n    require( \n      (value == 0) || (token.allowance(address(this), spender) == 0), \n      'SafeERC20: approve from non-zero to non-zero allowance' \n    ); \n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n  } \n \n  function callOptionalReturn(IERC20 token, bytes memory data) private { \n    require(address(token).isContract(), 'SafeERC20: call to non-contract'); \n \n    // solhint-disable-next-line avoid-low-level-calls \n    (bool success, bytes memory returndata) = address(token).call(data); \n    require(success, 'SafeERC20: low-level call failed'); \n \n    if (returndata.length > 0) { \n      // Return data is optional \n      // solhint-disable-next-line max-line-length \n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed'); \n    } \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title IReserveInterestRateStrategyInterface interface \n * @dev Interface for the calculation of the interest rates \n * @author Aave \n */ \ninterface IReserveInterestRateStrategy { \n  function baseVariableBorrowRate() external view returns (uint256); \n \n  function getMaxVariableBorrowRate() external view returns (uint256); \n \n  function calculateInterestRates( \n    address reserve, \n    uint256 availableLiquidity, \n    uint256 totalStableDebt, \n    uint256 totalVariableDebt, \n    uint256 averageStableBorrowRate, \n    uint256 reserveFactor \n  ) \n    external \n    view \n    returns ( \n      uint256, \n      uint256, \n      uint256 \n    ); \n \n  function calculateInterestRates( \n    address reserve, \n    address aToken, \n    uint256 liquidityAdded, \n    uint256 liquidityTaken, \n    uint256 totalStableDebt, \n    uint256 totalVariableDebt, \n    uint256 averageStableBorrowRate, \n    uint256 reserveFactor \n  ) \n    external \n    view \n    returns ( \n      uint256 liquidityRate, \n      uint256 stableBorrowRate, \n      uint256 variableBorrowRate \n    ); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.4.22 <=0.6.12; \n \nimport {WETH9} from '../dependencies/weth/WETH9.sol'; \n \ncontract WETH9Mocked is WETH9 { \n  // Mint not backed by Ether: only for testing purposes \n  function mint(uint256 value) public returns (bool) { \n    balanceOf[msg.sender] += value; \n    emit Transfer(address(0), msg.sender, value); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \ninterface IActionPools { \n \n    function getPoolInfo(uint256 _pid) external view \n        returns (address callFrom, uint256 callId, address rewardToken); \n    function mintRewards(uint256 _callId) external; \n    function getPoolIndex(address _callFrom, uint256 _callId) external view returns (uint256[] memory\n \n    function onAcionIn(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ext\n    function onAcionOut(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ex\n    function onAcionClaim(uint256 _callId, address _account) external; \n    function onAcionEmergency(uint256 _callId, address _account) external; \n    function onAcionUpdate(uint256 _callId) external; \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \n \ninterface IExchangeAdapter { \n  event Exchange( \n    address indexed from, \n    address indexed to, \n    address indexed platform, \n    uint256 fromAmount, \n    uint256 toAmount \n  ); \n \n  function approveExchange(IERC20[] calldata tokens) external; \n \n  function exchange( \n    address from, \n    address to, \n    uint256 amount, \n    uint256 maxSlippage \n  ) external returns (uint256); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ERC20} from '../../dependencies/openzeppelin/contracts/ERC20.sol'; \n \n/** \n * @title ERC20Mintable \n * @dev ERC20 minting logic \n */ \ncontract MintableDelegationERC20 is ERC20 { \n  address public delegatee; \n \n  constructor( \n    string memory name, \n    string memory symbol, \n    uint8 decimals \n  ) public ERC20(name, symbol) { \n    _setupDecimals(decimals); \n  } \n \n  /** \n   * @dev Function to mint tokensp \n   * @param value The amount of tokens to mint. \n   * @return A boolean that indicates if the operation was successful. \n   */ \n  function mint(uint256 value) public returns (bool) { \n    _mint(msg.sender, value); \n    return true; \n  } \n \n  function delegate(address delegateeAddress) external { \n    delegatee = delegateeAddress; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ERC20} from '../../dependencies/openzeppelin/contracts/ERC20.sol'; \n \n/** \n * @title ERC20Mintable \n * @dev ERC20 minting logic \n */ \ncontract MintableERC20 is ERC20 { \n  constructor( \n    string memory name, \n    string memory symbol, \n    uint8 decimals \n  ) public ERC20(name, symbol) { \n    _setupDecimals(decimals); \n  } \n \n  /** \n   * @dev Function to mint tokens \n   * @param value The amount of tokens to mint. \n   * @return A boolean that indicates if the operation was successful. \n   */ \n  function mint(uint256 value) public returns (bool) { \n    _mint(_msgSender(), value); \n    return true; \n  } \n} \n// Copyright (C) 2015, 2016, 2017 Dapphub \n \n// This program is free software: you can redistribute it and/or modify \n// it under the terms of the GNU General Public License as published by \n// the Free Software Foundation, either version 3 of the License, or \n// (at your option) any later version. \n \n// This program is distributed in the hope that it will be useful, \n// but WITHOUT ANY WARRANTY; without even the implied warranty of \n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the \n// GNU General Public License for more details. \n \n// You should have received a copy of the GNU General Public License \n// along with this program.  If not, see <http://www.gnu.org/licenses/>. \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n \n/** \n* @dev Extension of {ERC20} that allows token holders to destroy both their own \n* tokens and those that they  have an  allowance for, in \n* recognized off-chain (via event analysis). \n  */  \n  abstract contract ERC20Burnable is Context, ERC20 { \n  /** \n    * @dev Destroys `amount` tokens from the  caller. \n    * \n    * See {ERC20-_burn}. \n      */  \n      function burn(uint256 amount) public virtual { \n      _burn(_msgSender(), amount); \n      } \n \n  /** \n    * @dev Destroys `amount` tokens from `account`, deducting from the  caller's \n    * allowance. \n    * \n    * See {ERC20-_burn} and {ERC20-allowance}. \n    * \n    * Requirements: \n    * \n    * - the  caller must have allowance for ``accounts``'s tokens of at least \n    * `amount`. \n      */  \n      function burnFrom(address account, uint256 amount) public virtual { \n      uint256 currentAllowance = allowance(account, _msgSender()); \n      require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\"); \n      unchecked { \n      _approve(account, _msgSender(), currentAllowance - amount); \n      } \n      _burn(account, amount); \n      } \n      } \n \n// File: contracts/TKLRole.sol \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.7.0; \n \n \n \n \n \ncontract Oracle is OwnableUpgradeable { \n    mapping(address => IAggregatorV3Interface) public getContractAddress; \n    mapping(address => uint256) public getPrice; \n    function _Oracle_INIT_ () public initializer { \n            __Ownable_init(); \n    } \n    /// @dev Set price oracle contract addresses in batches \n    function setOracleBatch (address[] memory _tokens, address[] memory _aggregatorV3Interface) publi\n        require(_tokens.length < 100, 'Oracle: Too many settings at once'); \n        require(_tokens.length == _aggregatorV3Interface.length, 'Oracle: Unequal length'); \n        for (uint8 i = 0; i < _tokens.length; i++) { \n            getContractAddress[_tokens[i]] = IAggregatorV3Interface(_aggregatorV3Interface[i]); \n        } \n    } \n    /// @dev Update the price of a certain token from the price oracle machine \n    function _updatePrice(address _token) internal { \n        (,int price,,,) = getContractAddress[_token].latestRoundData(); \n        require(price >= 0, 'Oracle: price verify error'); \n        getPrice[_token] = uint256(price); \n    } \n} \n \n// File: contracts/MartTradeMining.sol \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol'; \nimport {IInitializableAToken} from './IInitializableAToken.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken { \n  /** \n   * @dev Emitted after the mint action \n   * @param from The address performing the mint \n   * @param value The amount being \n   * @param index The new liquidity index of the reserve \n   **/ \n  event Mint(address indexed from, uint256 value, uint256 index); \n \n  /** \n   * @dev Mints `amount` aTokens to `user` \n   * @param user The address receiving the minted tokens \n   * @param amount The amount of tokens getting minted \n   * @param index The new liquidity index of the reserve \n   * @return `true` if the the previous balance of the user was 0 \n   */ \n  function mint( \n    address user, \n    uint256 amount, \n    uint256 index \n  ) external returns (bool); \n \n  /** \n   * @dev Emitted after aTokens are burned \n   * @param from The owner of the aTokens, getting them burned \n   * @param target The address that will receive the underlying \n   * @param value The amount being burned \n   * @param index The new liquidity index of the reserve \n   **/ \n  event Burn(address indexed from, address indexed target, uint256 value, uint256 index); \n \n  /** \n   * @dev Emitted during the transfer action \n   * @param from The user whose tokens are being transferred \n   * @param to The recipient \n   * @param value The amount being transferred \n   * @param index The new liquidity index of the reserve \n   **/ \n  event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index); \n \n  /** \n   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnder\n   * @param user The owner of the aTokens, getting them burned \n   * @param receiverOfUnderlying The address that will receive the underlying \n   * @param amount The amount being burned \n   * @param index The new liquidity index of the reserve \n   **/ \n  function burn( \n    address user, \n    address receiverOfUnderlying, \n    uint256 amount, \n    uint256 index \n  ) external; \n \n  /** \n   * @dev Mints aTokens to the reserve treasury \n   * @param amount The amount of tokens getting minted \n   * @param index The new liquidity index of the reserve \n   */ \n  function mintToTreasury(uint256 amount, uint256 index) external; \n \n  /** \n   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclai\n   * @param from The address getting liquidated, current owner of the aTokens \n   * @param to The recipient \n   * @param value The amount of tokens getting transferred \n   **/ \n  function transferOnLiquidation( \n    address from, \n    address to, \n    uint256 value \n  ) external; \n \n  /** \n   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer \n   * assets in borrow(), withdraw() and flashLoan() \n   * @param user The recipient of the underlying \n   * @param amount The amount getting transferred \n   * @return The amount transferred \n   **/ \n  function transferUnderlyingTo(address user, uint256 amount) external returns (uint256); \n \n  /** \n   * @dev Invoked to execute actions on the aToken side after a repayment. \n   * @param user The user executing the repayment \n   * @param amount The amount getting repaid \n   **/ \n  function handleRepayment(address user, uint256 amount) external; \n \n  /** \n   * @dev Returns the address of the incentives controller contract \n   **/ \n  function getIncentivesController() external view returns (IAaveIncentivesController); \n \n  /** \n   * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH) \n   **/ \n  function UNDERLYING_ASSET_ADDRESS() external view returns (address); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.4.24 <0.8.0; \n \n \n/** \n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that \n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor \n * external initializer function, usually called `initialize`. It then becomes necessary to protect t\n * function so it can only be called once. The {initializer} modifier provided by this contract will \n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be call\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-const\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer \n * that all initializers are idempotent. This is not verified automatically as constructors are by So\n */ \nabstract contract Initializable { \n \n    /** \n     * @dev Indicates that the contract has been initialized. \n     */ \n    bool private _initialized; \n \n    /** \n     * @dev Indicates that the contract is in the process of being initialized. \n     */ \n    bool private _initializing; \n \n    /** \n     * @dev Modifier to protect an initializer function from being invoked twice. \n     */ \n    modifier initializer() { \n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is alrea\n \n        bool isTopLevelCall = !_initializing; \n        if (isTopLevelCall) { \n            _initializing = true; \n            _initialized = true; \n        } \n \n        _; \n \n        if (isTopLevelCall) { \n            _initializing = false; \n        } \n    } \n \n    /// @dev Returns true if and only if the function is running in the constructor \n    function _isConstructor() private view returns (bool) { \n        return !AddressUpgradeable.isContract(address(this)); \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface IWETH { \n    function deposit() external payable; \n    function transfer(address to, uint value) external returns (bool); \n    function withdraw(uint) external; \n    function balanceOf(address) external returns (uint256); \n} \n \n \n// File contracts/interface/IERC20LfgSwap.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ncontract IERC20DetailedBytes { \n  bytes32 public name; \n  bytes32 public symbol; \n  uint256 public decimals; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"./interfaces/IUserProxyFactory.sol\"; \nimport \"./UserProxy.sol\"; \n \ncontract UserProxyFactory is IUserProxyFactory { \n    mapping(address => address) public override getProxy; \n \n    // // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContrac\n    // bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b1\n \n    // keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\"); \n    bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = \n    0x91ab3d17e3a50a9d89e63fd30b92be7f5336b03b287bb946787a83a9d62a2766; \n \n    bytes32 public DOMAIN_SEPARATOR; \n    string public constant name = \"User Proxy Factory V1\"; \n    string public constant VERSION = \"1\"; \n \n    constructor() { \n        // uint chainId; \n        // assembly { \n        //     chainId := chainid() \n        // } \n        DOMAIN_SEPARATOR = keccak256( \n            abi.encode( \n                DOMAIN_SEPARATOR_TYPEHASH, \n                keccak256(bytes(name)), \n                keccak256(bytes(VERSION)), \n                address(this) \n            ) \n        ); \n    } \n \n    function createProxy(address owner) \n    external \n    override \n    returns (address proxy) \n    { \n        require(owner != address(0), \"ZERO_ADDRESS\"); \n        require(getProxy[owner] == address(0), \"PROXY_EXISTS\"); \n        bytes memory bytecode = proxyCreationCode(); \n        bytes32 salt = keccak256(abi.encodePacked(address(this), owner)); \n        assembly { \n            proxy := create2(0, add(bytecode, 32), mload(bytecode), salt) \n        } \n        getProxy[owner] = proxy; \n        IUserProxy(proxy).initialize(owner, DOMAIN_SEPARATOR); \n        emit ProxyCreated(owner, proxy); \n    } \n \n    function proxyRuntimeCode() public pure returns (bytes memory) { \n        return type(UserProxy).runtimeCode; \n    } \n \n    function proxyCreationCode() public pure returns (bytes memory) { \n        return type(UserProxy).creationCode; \n    } \n \n    function proxyCreationCodeHash() public pure returns (bytes32) { \n        return keccak256(proxyCreationCode()); \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.2; \n \n \ninterface INetswapRouter02 is INetswapRouter { \n    function removeLiquidityMetisSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountMetis); \n    function removeLiquidityMetisWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountMetis); \n \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n    function swapExactMetisForTokensSupportingFeeOnTransferTokens( \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external payable; \n    function swapExactTokensForMetisSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n    function swapMining() external pure returns (address); \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {AToken} from '../../protocol/tokenization/AToken.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol'; \n \ncontract MockAToken is AToken { \n  function getRevision() internal pure override returns (uint256) { \n    return 0x2; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IHFIL { \n  function allowance(address owner, address spender) view external returns (uint256); \n \n  function approve(address spender, uint256 amount) external returns (bool); \n \n  function balanceOf(address account) view external returns (uint256); \n \n  function burn(address account, uint256 amount) external; \n \n  function changeUser(address new_operator, address new_pauser) external; \n \n  function decimals() view external returns (uint8); \n \n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool); \n \n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool); \n \n  function mint(address account, uint256 amount) external; \n \n  function name() view external returns (string memory); \n \n  function pause() external; \n \n  function paused() view external returns (bool); \n \n  function symbol() view external returns (string memory); \n \n  function totalSupply() view external returns (uint256); \n \n  function transfer(address recipient, uint256 amount) external returns (bool); \n \n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n  function unpause() external; \n \n  event Approval(address indexed owner, address indexed spender, uint256 value); \n \n  event Paused(address account); \n \n  event Transfer(address indexed from, address indexed to, uint256 value); \n \n  event Unpaused(address account); \n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IUniswapExchange { \n  event TokenPurchase( \n    address indexed buyer, \n    uint256 indexed eth_sold, \n    uint256 indexed tokens_bought \n  ); \n  event EthPurchase(address indexed buyer, uint256 indexed tokens_sold, uint256 indexed eth_bought); \n  event AddLiquidity( \n    address indexed provider, \n    uint256 indexed eth_amount, \n    uint256 indexed token_amount \n  ); \n  event RemoveLiquidity( \n    address indexed provider, \n    uint256 indexed eth_amount, \n    uint256 indexed token_amount \n  ); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \n \ninterface IERC20WithPermit is IERC20 { \n  function permit( \n    address owner, \n    address spender, \n    uint256 value, \n    uint256 deadline, \n    uint8 v, \n    bytes32 r, \n    bytes32 s \n  ) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \ninterface IStrategyV2Pair is IStrategyLink { \n \n    event AddPool(uint256 _pid, uint256 _poolId, address lpToken, address _baseToken); \n    event SetMiniRewardAmount(uint256 _pid, uint256 _miniRewardAmount); \n    event SetPoolImpl(address _oldv, address _new); \n    event SetComponents(address _compActionPool, address _buyback, address _priceChecker, address _co\n    event SetPoolConfig(uint256 _pid, string _key, uint256 _value); \n \n    event StrategyBorrow2(address indexed strategy, uint256 indexed pid, address user, address indexe\n    event StrategyRepayBorrow2(address indexed strategy, uint256 indexed pid, address user, address i\n    event StrategyLiquidation2(address indexed strategy, uint256 indexed pid, address user, uint256 l\n \n    function getBorrowInfo(uint256 _pid, address _account, uint256 _bindex) \n        external view returns (address borrowFrom, uint256 bid, uint256 amount); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \n \n \nlibrary NetswapLibrary { \n    using SafeMathNetswap for uint; \n \n    // returns sorted token addresses, used to handle return values from pairs sorted in this order \n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, addres\n        require(tokenA != tokenB, 'NetswapLibrary: IDENTICAL_ADDRESSES'); \n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n        require(token0 != address(0), 'NetswapLibrary: ZERO_ADDRESS'); \n    } \n \n    // calculates the CREATE2 address for a pair without making any external calls \n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address \n        (address token0, address token1) = sortTokens(tokenA, tokenB); \n        pair = address(uint(keccak256(abi.encodePacked( \n                hex'ff', \n                factory, \n                keccak256(abi.encodePacked(token0, token1)), \n                hex'68cc803ebc27f23a62dd9f9251e76a9d6f2c659f76c92ffbd5e62d5b877384d6' // init code ha\n            )))); \n    } \n \n    // fetches and sorts the reserves for a pair \n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint \n        (address token0,) = sortTokens(tokenA, tokenB); \n        (uint reserve0, uint reserve1,) = INetswapPair(pairFor(factory, tokenA, tokenB)).getReserves(\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0); \n    } \n \n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other ass\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) { \n        require(amountA > 0, 'NetswapLibrary: INSUFFICIENT_AMOUNT'); \n        require(reserveA > 0 && reserveB > 0, 'NetswapLibrary: INSUFFICIENT_LIQUIDITY'); \n        amountB = amountA.mul(reserveB) / reserveA; \n    } \n \n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint feeRate) internal pure \n        require(amountIn > 0, 'NetswapLibrary: INSUFFICIENT_INPUT_AMOUNT'); \n        require(reserveIn > 0 && reserveOut > 0, 'NetswapLibrary: INSUFFICIENT_LIQUIDITY'); \n        uint amountInWithFee = amountIn.mul(1000 - feeRate); \n        uint numerator = amountInWithFee.mul(reserveOut); \n        uint denominator = reserveIn.mul(1000).add(amountInWithFee); \n        amountOut = numerator / denominator; \n    } \n \n    // given an output amount of an asset and pair reserves, returns a required input amount of the o\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut, uint feeRate) internal pure \n        require(amountOut > 0, 'NetswapLibrary: INSUFFICIENT_OUTPUT_AMOUNT'); \n        require(reserveIn > 0 && reserveOut > 0, 'NetswapLibrary: INSUFFICIENT_LIQUIDITY'); \n        uint numerator = reserveIn.mul(amountOut).mul(1000); \n        uint denominator = reserveOut.sub(amountOut).mul(1000 - feeRate); \n        amountIn = (numerator / denominator).add(1); \n    } \n \n    // performs chained getAmountOut calculations on any number of pairs \n    function getAmountsOut(address factory, uint amountIn, address[] memory path, uint feeRate) inter\n        require(path.length >= 2, 'NetswapLibrary: INVALID_PATH'); \n        amounts = new uint[](path.length); \n        amounts[0] = amountIn; \n        for (uint i; i < path.length - 1; i++) { \n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]); \n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, feeRate); \n        } \n    } \n \n    // performs chained getAmountIn calculations on any number of pairs \n    function getAmountsIn(address factory, uint amountOut, address[] memory path, uint feeRate) inter\n        require(path.length >= 2, 'NetswapLibrary: INVALID_PATH'); \n        amounts = new uint[](path.length); \n        amounts[amounts.length - 1] = amountOut; \n        for (uint i = path.length - 1; i > 0; i--) { \n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]); \n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut, feeRate); \n        } \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @dev Interface of the  ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP]. \n * \n * Implementers can declare support of contract interfaces, which can then be \n * queried by others ({ERC165Checker}). \n * \n * For an  implementation, see {ERC165}. \n */  \ninterface IERC165 { \n    /** \n     * @dev Returns true if this contract implements the  interface defined by \n     * `interfaceId`. See the  corresponding \n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces- are -identified[EIP section] \n     * to learn more  about how these ids are  created. \n     * \n     * This function call must use less than 30 000 gas. \n     */  \n    function supportsInterface(bytes4 interfaceId) external view returns (bool); \n} \n \n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (utils/introspection/ERC165.sol) \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n// File @openzeppelin/contracts/math/SafeMath.sol@v3.4.2 \n \n// -- SPDX-License-Identifier:: MIT \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.7.0; \n \ninterface IInvit { \n    function isTrade(address userAddress) external view returns (bool); \n    function getInvit(address userAddress) external view returns (address[] memory); \n    function appendInvit (address beInvit ,address invit) external returns(bool); \n} \n \n// File: contracts/interface/IMartToken.sol \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \n \nlibrary LfgSwapLibrary { \n    using SafeMath for uint; \n \n    // returns sorted token addresses, used to handle return values from pairs sorted in this order \n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, addres\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES'); \n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS'); \n    } \n \n    // calculates the CREATE2 address for a pair without making any external calls \n    function pairFor(address factory, address tokenA, address tokenB) internal view returns (address \n        (address token0, address token1) = sortTokens(tokenA, tokenB); \n        pair  =  ILfgSwapFactory(factory).getPair(token0, token1); \n \n        // = address(uint(keccak256(abi.encodePacked( \n        //         hex'ff', \n        //         factory, \n        //         keccak256(abi.encodePacked(token0, token1)), \n        //         hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code \n        //     )))); \n    } \n \n    // fetches and sorts the reserves for a pair \n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint \n        (address token0,) = sortTokens(tokenA, tokenB); \n        (uint reserve0, uint reserve1,) = ILfgSwapPair(pairFor(factory, tokenA, tokenB)).getReserves(\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0); \n    } \n \n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other ass\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) { \n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT'); \n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); \n        amountB = amountA.mul(reserveB) / reserveA; \n    } \n \n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint \n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); \n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); \n        uint amountInWithFee = amountIn.mul(997); \n        uint numerator = amountInWithFee.mul(reserveOut); \n        uint denominator = reserveIn.mul(1000).add(amountInWithFee); \n        amountOut = numerator / denominator; \n    } \n \n    // given an output amount of an asset and pair reserves, returns a required input amount of the o\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint \n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'); \n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); \n        uint numerator = reserveIn.mul(amountOut).mul(1000); \n        uint denominator = reserveOut.sub(amountOut).mul(997); \n        amountIn = (numerator / denominator).add(1); \n    } \n \n    // performs chained getAmountOut calculations on any number of pairs \n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view retur\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); \n        amounts = new uint[](path.length); \n        amounts[0] = amountIn; \n        for (uint i; i < path.length - 1; i++) { \n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]); \n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); \n        } \n    } \n \n    // performs chained getAmountIn calculations on any number of pairs \n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view retur\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); \n        amounts = new uint[](path.length); \n        amounts[amounts.length - 1] = amountOut; \n        for (uint i = path.length - 1; i > 0; i--) { \n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]); \n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut); \n        } \n    } \n} \n \n \n// File contracts/libraries/TransferHelper.sol \n \n// -- SPDX-License-Identifier:: GPL-3.0-or-later \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./Context.sol\"; \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n}\n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n}\nSafeMath.sol\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IRewardsToken { \n    function mint(address _account, uint256 _amount) external; \n    function burn(uint256 _amount) external; \n \n    function setMintWhitelist(address _account, bool _enabled) external; \n    function checkWhitelist(address _account) external view returns (bool); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ILendingRateOracle} from '../../interfaces/ILendingRateOracle.sol'; \nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol'; \n \ncontract LendingRateOracle is ILendingRateOracle, Ownable { \n  mapping(address => uint256) borrowRates; \n  mapping(address => uint256) liquidityRates; \n  function getMarketBorrowRate(address _asset) external view override returns (uint256) {\n    return borrowRates[_asset];\n  }\n  function setMarketBorrowRate(address _asset, uint256 _rate) external override onlyOwner {\n    borrowRates[_asset] = _rate;\n  }\n  function getMarketLiquidityRate(address _asset) external view returns (uint256) {\n    return liquidityRates[_asset];\n  }\n  function setMarketLiquidityRate(address _asset, uint256 _rate) external onlyOwner {\n    liquidityRates[_asset] = _rate;\n  }\n}\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \n \ncontract IDOInfo is Ownable { \n    address public operator; \n \n    mapping(address => bool) public exist; \n    mapping(address => bool) public isPool; \n    address[] public IDOList; \n    mapping(address => address) public payer2pool; \n    mapping(address => address) public stakeAddress; \n    mapping(address => address) public pool2idoToken; \n \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n \n    event AddIDO(uint256 timestamp, address idoToken); \n \n    event SetPayer(uint256 timestamp, address pool, address payer); \n \n    event SetStakeAddress( \n        uint256 timestamp, \n        address idoToken, \n        address _stakeAddress \n    ); \n \n    constructor(address _operator) Ownable() { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function IDOListCount() external view returns (uint256) { \n        return IDOList.length; \n    } \n \n    function addIDO(address idoToken) external onlyOperator { \n        require(!exist[idoToken], \"IDOINFO: already here\"); \n        exist[idoToken] = true; \n        IDOList.push(idoToken); \n        emit AddIDO(block.timestamp, idoToken); \n    } \n \n    function setPayer(address pool, address payer) external onlyOperator { \n        require(isPool[pool], \"IDOINFO: pool not found\"); \n        payer2pool[payer] = pool; \n        emit SetPayer(block.timestamp, pool, payer); \n    } \n \n    function setStakeAddress(address idoToken, address _stakeAddress) \n        external \n        onlyOperator \n    { \n        require(exist[idoToken], \"IDOINFO: idoToken not found\"); \n        isPool[_stakeAddress] = true; \n        pool2idoToken[_stakeAddress] = idoToken; \n        stakeAddress[idoToken] = _stakeAddress; \n        emit SetStakeAddress(block.timestamp, idoToken, _stakeAddress); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.6.0; \n \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n \n \n \n \n \n \n \n/** \n * @title PowerfulERC20 \n * @dev Implementation of the  PowerfulERC20 \n */  \ncontract PowerfulERC20 is \n    ERC20Decimals, \n    ERC20Capped, \n    ERC20Mintable, \n    ERC20Burnable, \n    ERC1363, \n    TokenRecover, \n    Roles, \n    ServicePayer \n{ \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n \n// File @openzeppelin/contracts/access/Ownable.sol@v3.4.2 \n \n// -- SPDX-License-Identifier:: MIT \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface INetswapFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeRate() external view returns (uint); \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeRate(uint) external; \n    function setFeeToSetter(address) external; \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \ninterface IStrategyV2Pair is IStrategyLink { \n \n    event AddPool(uint256 _pid, uint256 _poolId, address lpToken, address _baseToken); \n    event SetMiniRewardAmount(uint256 _pid, uint256 _miniRewardAmount); \n    event SetPoolImpl(address _oldv, address _new); \n    event SetComponents(address _compActionPool, address _buyback, address _priceChecker, address _co\n    event SetPoolConfig(uint256 _pid, string _key, uint256 _value); \n \n    event StrategyBorrow2(address indexed strategy, uint256 indexed pid, address user, address indexe\n    event StrategyRepayBorrow2(address indexed strategy, uint256 indexed pid, address user, address i\n    event StrategyLiquidation2(address indexed strategy, uint256 indexed pid, address user, uint256 l\n \n    function getBorrowInfo(uint256 _pid, address _account, uint256 _bindex) \n        external view returns (address borrowFrom, uint256 bid, uint256 amount); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {IFlashLoanReceiver} from '../interfaces/IFlashLoanReceiver.sol'; \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \n \nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver { \n  using SafeERC20 for IERC20; \n  using SafeMath for uint256; \n \n  ILendingPoolAddressesProvider public immutable override ADDRESSES_PROVIDER; \n  ILendingPool public immutable override LENDING_POOL; \n \n  constructor(ILendingPoolAddressesProvider provider) public { \n    ADDRESSES_PROVIDER = provider; \n    LENDING_POOL = ILendingPool(provider.getLendingPool()); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./IBEP20.sol\"; \nimport \"./SafeMath.sol\"; \nimport \"./Address.sol\"; \n \n/** \n * @title SafeBEP20 \n * @dev Wrappers around BEP20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeBEP20 for IBEP20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeBEP20 { \n    using SafeMath for uint256; \n    using Address for address; \n \n    function safeTransfer(IBEP20 token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IBEP20 token, address from, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IBEP20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IBEP20 token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeBEP20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IBEP20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IBEP20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IBEP20 token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeBEP20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \nSafeMath.sol\n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeBEP20: BEP20 operation did not succeed\"); \n        } \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title LendingPoolAddressesProviderRegistry contract \n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets \n * - Used for indexing purposes of Aave protocol's markets \n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with, \n *   for example with `0` for the Aave main market and `1` for the next created \n * @author Aave \n **/ \ninterface ILendingPoolAddressesProviderRegistry { \n  event AddressesProviderRegistered(address indexed newAddress); \n  event AddressesProviderUnregistered(address indexed newAddress); \n \n  function getAddressesProvidersList() external view returns (address[] memory); \n \n  function getAddressesProviderIdByAddress(address addressesProvider) \n    external \n    view \n    returns (uint256); \n \n  function registerAddressesProvider(address provider, uint256 id) external; \n \n  function unregisterAddressesProvider(address provider) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \nimport \"./interfaces/IERC20.sol\"; \nimport \"./libraries/SafeMath.sol\"; \n \ncontract FidoMargin is Ownable { \n    using SafeMath for uint256; \n \n    address public operator; \n    address public marginToken; \n    mapping (address => uint256) public margin; \n    mapping (address => bool) public withdrawStatus; \n    mapping (address => uint256) public withdrawAmount; \n    mapping (address => address) public withdrawRecipient; \n \n    event DepositMargin(uint256 timestamp, address indexed sender, uint256 amount); \n    event WithdrawRequest(uint256 timestamp, address indexed requester, uint256 amount, address index\n    event WithdrawResult(uint256 timestamp, address indexed requester, bool result); \n \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n    constructor (address _operator, address _marginToken) Ownable() { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        marginToken = _marginToken; \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function depositMargin(uint256 amount) external { \n        IERC20(marginToken).transferFrom(_msgSender(), address(this), amount); \n        margin[_msgSender()] = margin[_msgSender()].add(amount); \n        emit DepositMargin(block.timestamp, _msgSender(), amount); \n    } \n \n    function withdrawRequest(address recipient, uint256 amount) external { \n        require(!withdrawStatus[_msgSender()], \"FidoMargin: already sent a request\"); \n        require(margin[_msgSender()] >= amount, \"FidoMargin: insufficient margin\"); \n \n        withdrawStatus[_msgSender()] = true; \n        withdrawAmount[_msgSender()] = amount; \n        withdrawRecipient[_msgSender()] = recipient; \n        emit WithdrawRequest(block.timestamp, _msgSender(), amount, recipient); \n    } \n \n    function withdrawResponse(address requester, bool result) external onlyOperator { \n        require(withdrawStatus[requester], \"FidoMargin: request not found\"); \n        if(result){ \n            IERC20(marginToken).transfer(withdrawRecipient[requester], withdrawAmount[requester]); \n            margin[_msgSender()] = margin[_msgSender()].sub(withdrawAmount[requester]); \n        } \n        withdrawStatus[requester] = false; \n        withdrawRecipient[requester] = address(0); \n        withdrawAmount[requester] = 0; \n        emit WithdrawResult(block.timestamp, requester, result); \n    } \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IChainlinkAggregator { \n  function latestAnswer() external view returns (int256); \n \n  function latestTimestamp() external view returns (uint256); \n \n  function latestRound() external view returns (uint256); \n \n  function getAnswer(uint256 roundId) external view returns (int256); \n \n  function getTimestamp(uint256 roundId) external view returns (uint256); \n \n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp); \n  event NewRound(uint256 indexed roundId, address indexed startedBy); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface INetswapCallee { \n    function netswapCall(address sender, uint amount0, uint amount1, bytes calldata data) external; \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.6.0; \n \ninterface IERC20 { \n    /** \n     * @dev Returns the  amount of tokens in existence. \n     */  \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the  amount of tokens owned by `account`. \n     */  \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the  caller's account to `recipient`. \n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * Emits a  {Transfer} event. \n     */  \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the  remaining number of tokens that `spender` will\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are  called. \n     */  \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the  allowance of `spender` over the\n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * IMPORTANT: Beware that changing an  allowance with this method brings \n     * that someone may use both the  old and the  new allow\n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the  spender's allowance to 0 and set the\n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an  {Approval} event. \n     */  \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the  \n     * allowance mechanism. `amount` is then deducted from the  caller's \n     * allowance. \n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * Emits a  {Transfer} event. \n     */  \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are  moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */  \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the  allowance of a  `spender` for \n     * a  call to {approve}. `value` is the  new allowance. \n     */  \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n  function _msgSender() internal view virtual returns (address payable) { \n    return msg.sender; \n  } \n \n  function _msgData() internal view virtual returns (bytes memory) { \n    this; // silence state mutability warning without generating bytecode - see https://github.com/et\n    return msg.data; \n  } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./Context.sol\"; \n \n/** \n * @dev Contract module which allows children to implement an emergency stop \n * mechanism that can be triggered by an authorized account. \n * \n * This module is used through inheritance. It will make available the \n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to \n * the functions of your contract. Note that they will not be pausable by \n * simply including this module, only once the modifiers are put in place. \n */ \nabstract contract Pausable is Context { \n    /** \n     * @dev Emitted when the pause is triggered by `account`. \n     */ \n    event Paused(address account); \n \n    /** \n     * @dev Emitted when the pause is lifted by `account`. \n     */ \n    event Unpaused(address account); \n \n    bool private _paused; \n \n    /** \n     * @dev Initializes the contract in unpaused state. \n     */ \n    constructor () { \n        _paused = false; \n    } \n \n    /** \n     * @dev Returns true if the contract is paused, and false otherwise. \n     */ \n    function paused() public view virtual returns (bool) { \n        return _paused; \n    } \n \n    /** \n     * @dev Modifier to make a function callable only when the contract is not paused. \n     * \n     * Requirements: \n     * \n     * - The contract must not be paused. \n     */ \n    modifier whenNotPaused() { \n        require(!paused(), \"Pausable: paused\"); \n        _; \n    } \n \n    /** \n     * @dev Modifier to make a function callable only when the contract is paused. \n     * \n     * Requirements: \n     * \n     * - The contract must be paused. \n     */ \n    modifier whenPaused() { \n        require(paused(), \"Pausable: not paused\"); \n        _; \n    } \n \n    /** \n     * @dev Triggers stopped state. \n     * \n     * Requirements: \n     * \n     * - The contract must not be paused. \n     */ \n    function _pause() internal virtual whenNotPaused { \n        _paused = true; \n        emit Paused(_msgSender()); \n    } \n \n    /** \n     * @dev Returns to normal state. \n     * \n     * Requirements: \n     * \n     * - The contract must be paused. \n     */ \n    function _unpause() internal virtual whenPaused { \n        _paused = false; \n        emit Unpaused(_msgSender()); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface INetswapFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeRate() external view returns (uint); \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeToSetter(address) external; \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol'; \n \ncontract PriceOracle is IPriceOracle { \n  mapping(address => uint256) prices; \n  uint256 ethPriceUsd; \n \n  event AssetPriceUpdated(address _asset, uint256 _price, uint256 timestamp); \n  event EthPriceUpdated(uint256 _price, uint256 timestamp); \n \n  function getAssetPrice(address _asset) external view override returns (uint256) { \n    return prices[_asset]; \n  } \n \n  function setAssetPrice(address _asset, uint256 _price) external override { \n    prices[_asset] = _price; \n    emit AssetPriceUpdated(_asset, _price, block.timestamp); \n  } \n \n  function getEthUsdPrice() external view returns (uint256) { \n    return ethPriceUsd; \n  } \n \n  function setEthUsdPrice(uint256 _price) external { \n    ethPriceUsd = _price; \n    emit EthPriceUpdated(_price, block.timestamp); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20 { \n    using SafeMath for uint256; \n    using Address for address; \n \n    function safeTransfer(IERC20 token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20 token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20 token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nlibrary DataTypes { \n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties\n  struct ReserveData { \n    //stores the reserve configuration \n    ReserveConfigurationMap configuration; \n    //the liquidity index. Expressed in ray \n    uint128 liquidityIndex; \n    //variable borrow index. Expressed in ray \n    uint128 variableBorrowIndex; \n    //the current supply rate. Expressed in ray \n    uint128 currentLiquidityRate; \n    //the current variable borrow rate. Expressed in ray \n    uint128 currentVariableBorrowRate; \n    //the current stable borrow rate. Expressed in ray \n    uint128 currentStableBorrowRate; \n    uint40 lastUpdateTimestamp; \n    //tokens addresses \n    address aTokenAddress; \n    address stableDebtTokenAddress; \n    address variableDebtTokenAddress; \n    //address of the interest rate strategy \n    address interestRateStrategyAddress; \n    //the id of the reserve. Represents the position in the list of the active reserves \n    uint8 id; \n  } \n \n  struct ReserveConfigurationMap { \n    //bit 0-15: LTV \n    //bit 16-31: Liq. threshold \n    //bit 32-47: Liq. bonus \n    //bit 48-55: Decimals \n    //bit 56: Reserve is active \n    //bit 57: reserve is frozen \n    //bit 58: borrowing is enabled \n    //bit 59: stable rate borrowing enabled \n    //bit 60-63: reserved \n    //bit 64-79: reserve factor \n    uint256 data; \n  } \n \n  struct UserConfigurationMap { \n    uint256 data; \n  } \n \n  enum InterestRateMode {NONE, STABLE, VARIABLE} \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n \n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v3.4.2 \n \n// -- SPDX-License-Identifier:: MIT \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @dev String operations. \n */  \nlibrary Strings { \n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\"; \n \n    /** \n     * @dev Converts a  `uint256` to its ASCII `string` decimal representation. \n     */  \n    function toString(uint256 value) internal pure returns (string memory) { \n        // Inspired by OraclizeAPI's implementation - MIT licence \n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/ora\n \n        if (value == 0) { \n            return \"0\"; \n        } \n        uint256 temp = value; \n        uint256 digits; \n        while (temp != 0) { \n            digits++; \n            temp /= 10; \n        } \n        bytes memory buffer = new bytes(digits); \n        while (value != 0) { \n            digits -= 1; \n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10))); \n            value /= 10; \n        } \n        return string(buffer); \n    } \n \n    /** \n     * @dev Converts a  `uint256` to its ASCII `string` hexadecimal representation. \n     */  \n    function toHexString(uint256 value) internal pure returns (string memory) { \n        if (value == 0) { \n            return \"0x00\"; \n        } \n        uint256 temp = value; \n        uint256 length = 0; \n        while (temp != 0) { \n            length++; \n            temp >>= 8; \n        } \n        return toHexString(value, length); \n    } \n \n    /** \n     * @dev Converts a  `uint256` to its ASCII `string` hexadecimal representation with fix\n     */  \n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) { \n        bytes memory buffer = new bytes(2 * length + 2); \n        buffer[0] = \"0\"; \n        buffer[1] = \"x\"; \n        for (uint256 i = 2 * length + 1; i > 1; --i) { \n            buffer[i] = _HEX_SYMBOLS[value & 0xf]; \n            value >>= 4; \n        } \n        require(value == 0, \"Strings: hex length insufficient\"); \n        return string(buffer); \n    } \n} \n \n// File: @openzeppelin/contracts/access/AccessControl.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IIDOInfo { \n  function IDOList(uint256) view external returns (address); \n \n  function exist(address) view external returns (bool); \n \n  function isPool(address) view external returns (bool); \n \n  function operator() view external returns (address); \n \n  function owner() view external returns (address); \n \n  function payer2pool(address) view external returns (address); \n \n  function pool2idoToken(address) view external returns (address); \n \n  function renounceOwnership() external; \n \n  function stakeAddress(address) view external returns (address); \n \n  function transferOwnership(address newOwner) external; \n \n  function transferOperatorship(address newOperator) external; \n \n  function IDOListCount() view external returns (uint256); \n \n  function addIDO(address idoToken) external; \n \n  function setPayer(address pool, address payer) external; \n \n  function setStakeAddress(address idoToken, address _stakeAddress) external; \n \n  event AddIDO(uint256 timestamp, address idoToken); \n \n  event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator); \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n  event SetPayer(uint256 timestamp, address pool, address payer); \n \n  event SetStakeAddress(uint256 timestamp, address idoToken, address _stakeAddress); \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface IUniswapV2Pair { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n    function symbol() external pure returns (string memory); \n    function decimals() external pure returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    function MINIMUM_LIQUIDITY() external pure returns (uint); \n    function factory() external view returns (address); \n    function token0() external view returns (address); \n    function token1() external view returns (address); \n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n    function price0CumulativeLast() external view returns (uint); \n    function price1CumulativeLast() external view returns (uint); \n    function kLast() external view returns (uint); \n \n    function mint(address to) external returns (uint liquidity); \n    function burn(address to) external returns (uint amount0, uint amount1); \n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n    function skim(address to) external; \n    function sync() external; \n \n    function initialize(address, address) external; \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev Extension of {ERC20} that adds a cap to the supply of tokens. \n */ \nabstract contract ERC20Capped is ERC20 { \n    using SafeMath for uint256; \n \n    uint256 private _cap; \n \n    /** \n     * @dev Sets the value of the `cap`. This value is immutable, it can only be \n     * set once during construction. \n     */ \n    constructor (uint256 cap_) internal { \n        require(cap_ > 0, \"ERC20Capped: cap is 0\"); \n        _cap = cap_; \n    } \n \n    /** \n     * @dev Returns the cap on the token's total supply. \n     */ \n    function cap() public view virtual returns (uint256) { \n        return _cap; \n    } \n \n    /** \n     * @dev See {ERC20-_beforeTokenTransfer}. \n     * \n     * Requirements: \n     * \n     * - minted tokens must not cause the total supply to go over the cap. \n     */ \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override\n        super._beforeTokenTransfer(from, to, amount); \n \n        if (from == address(0)) { // When minting tokens \n            require(totalSupply().add(amount) <= cap(), \"ERC20Capped: cap exceeded\"); \n        } \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IClaimFromBank { \n    function claimFromBank(address _account, uint256[] memory _pidlist) external returns (uint256 val\n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface ILfgSwapFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n    function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeToSetter(address) external; \n \n} \n \n \n// File contracts/libraries/LfgSwapLibrary.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title ILendingPoolCollateralManager \n * @author Aave \n * @notice Defines the actions involving management of collateral in the protocol. \n **/ \ninterface ILendingPoolCollateralManager { \n  /** \n   * @dev Emitted when a borrower is liquidated \n   * @param collateral The address of the collateral being liquidated \n   * @param principal The address of the reserve \n   * @param user The address of the user being liquidated \n   * @param debtToCover The total amount liquidated \n   * @param liquidatedCollateralAmount The amount of collateral being liquidated \n   * @param liquidator The address of the liquidator \n   * @param receiveAToken true if the liquidator wants to receive aTokens, false otherwise \n   **/ \n  event LiquidationCall( \n    address indexed collateral, \n    address indexed principal, \n    address indexed user, \n    uint256 debtToCover, \n    uint256 liquidatedCollateralAmount, \n    address liquidator, \n    bool receiveAToken \n  ); \n \n  /** \n   * @dev Emitted when a reserve is disabled as collateral for an user \n   * @param reserve The address of the reserve \n   * @param user The address of the user \n   **/ \n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user); \n \n  /** \n   * @dev Emitted when a reserve is enabled as collateral for an user \n   * @param reserve The address of the reserve \n   * @param user The address of the user \n   **/ \n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user); \n \n  /** \n   * @dev Users can invoke this function to liquidate an undercollateralized position. \n   * @param collateral The address of the collateral to liquidated \n   * @param principal The address of the principal reserve \n   * @param user The address of the borrower \n   * @param debtToCover The amount of principal that the liquidator wants to repay \n   * @param receiveAToken true if the liquidators wants to receive the aTokens, false if \n   * he wants to receive the underlying asset directly \n   **/ \n  function liquidationCall( \n    address collateral, \n    address principal, \n    address user, \n    uint256 debtToCover, \n    bool receiveAToken \n  ) external returns (uint256, string memory); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\"; \nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\"; \nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\"; \n \nabstract contract AccessControlProxyPausable is PausableUpgradeable { \n \n    address public config; \n \n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00; \n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\"); \n            whitelisted[_list[i]] = true; \n        } \n    } \n \n    function unwhitelist(address[] calldata _list) external onlyRole(ANTIBOT_ROLE) { \n        for(uint256 i; i <_list.length; i++) { \n            whitelisted[_list[i]] = false; \n        } \n    } \n \n    function _beforeTokenTransfer(address from, address to, uint256 amount) \n        internal \n        whenNotPaused \n        override(ERC20Upgradeable, ERC20SnapshotUpgradeable) \n    { \n        _antiBotMaxBalance(to, amount); \n        super._beforeTokenTransfer(from, to, amount); \n    } \n \n    function _antiBotMaxBalance(address _addr, uint256 _amount) internal view { \n        if((_isAntibot) && (!whitelisted[_addr])){ \n            uint256 _balance = balanceOf(_addr); \n            uint256 _nextBalance = _balance + _amount; \n            require(_nextBalance <= _maxBalanceWhenAntiBot, \"MonstropolyERC20: Maxbalance for antibot\n        } \n    } \n}\n \n    modifier onlyRole(bytes32 role) { \n        address account = msg.sender; \n        require(hasRole(role, account), string( \n                    abi.encodePacked( \n                        \"AccessControlProxyPausable: account \", \n                        StringsUpgradeable.toHexString(uint160(account), 20), \n                        \" is missing role \", \n                        StringsUpgradeable.toHexString(uint256(role), 32) \n                    ) \n                )); \n        _; \n    } \n \n    function hasRole(bytes32 role, address account) public view returns (bool) { \n        IAccessControlUpgradeable manager = IAccessControlUpgradeable(config); \n        return manager.hasRole(role, account); \n    } \n \n    function __AccessControlProxyPausable_init(address config_) internal initializer { \n        __Pausable_init(); \n        __AccessControlProxyPausable_init_unchained(config_); \n    } \n \n    function __AccessControlProxyPausable_init_unchained(address config_) internal initializer { \n        config = config_; \n    } \n \n    function pause() public onlyRole(PAUSER_ROLE){ \n        _pause(); \n    } \n \n    function unpause() public onlyRole(PAUSER_ROLE){ \n        _unpause(); \n    } \n \n    function updateManager(address config_) public onlyRole(DEFAULT_ADMIN_ROLE) { \n        config = config_; \n    } \n}\nIMonstropolyERC20.sol\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title ILendingRateOracle interface \n * @notice Interface for the Aave borrow rate oracle. Provides the average market borrow rate to be u\n **/ \n \ninterface ILendingRateOracle { \n  /** \n    @dev returns the market borrow rate in ray \n    **/ \n  function getMarketBorrowRate(address asset) external view returns (uint256); \n \n  /** \n    @dev sets the market borrow rate. Rate value must be in ray \n    **/ \n  function setMarketBorrowRate(address asset, uint256 rate) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n/** \n * @dev Interface for the  optional metadata functions from the\n * \n * _Available since v4.1._ \n */  \ninterface IERC20Metadata is IERC20 { \n    /** \n     * @dev Returns the  name of the  token. \n     */  \n    function name() external view returns (string memory); \n \n    /** \n     * @dev Returns the  symbol of the  token. \n     */  \n    function symbol() external view returns (string memory); \n \n    /** \n     * @dev Returns the  decimals places of the  token. \n     */  \n    function decimals() external view returns (uint8); \n} \n \n// File: @openzeppelin/contracts/utils/Context.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IUniswapV2Router02} from '../../interfaces/IUniswapV2Router02.sol'; \nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; \nimport {MintableERC20} from '../tokens/MintableERC20.sol'; \n \ncontract MockUniswapV2Router02 is IUniswapV2Router02 { \n  mapping(address => uint256) internal _amountToReturn; \n  mapping(address => uint256) internal _amountToSwap; \n  mapping(address => mapping(address => mapping(uint256 => uint256))) internal _amountsIn; \n  mapping(address => mapping(address => mapping(uint256 => uint256))) internal _amountsOut; \n  uint256 internal defaultMockValue; \n \n  function setAmountToReturn(address reserve, uint256 amount) public { \n    _amountToReturn[reserve] = amount; \n  } \n \n  function setAmountToSwap(address reserve, uint256 amount) public { \n    _amountToSwap[reserve] = amount; \n  } \n \n  function swapExactTokensForTokens( \n    uint256 amountIn, \n    uint256, /* amountOutMin */ \n    address[] calldata path, \n    address to, \n    uint256 /* deadline */ \n  ) external override returns (uint256[] memory amounts) { \n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn); \n \n    MintableERC20(path[1]).mint(_amountToReturn[path[0]]); \n    IERC20(path[1]).transfer(to, _amountToReturn[path[0]]); \n \n    amounts = new uint256[](path.length); \n    amounts[0] = amountIn; \n    amounts[1] = _amountToReturn[path[0]]; \n  } \n \n  function swapTokensForExactTokens( \n    uint256 amountOut, \n    uint256, /* amountInMax */ \n    address[] calldata path, \n    address to, \n    uint256 /* deadline */ \n  ) external override returns (uint256[] memory amounts) { \n    IERC20(path[0]).transferFrom(msg.sender, address(this), _amountToSwap[path[0]]); \n \n    MintableERC20(path[1]).mint(amountOut); \n    IERC20(path[1]).transfer(to, amountOut); \n \n    amounts = new uint256[](path.length); \n    amounts[0] = _amountToSwap[path[0]]; \n    amounts[1] = amountOut; \n  } \n \n  function setAmountOut( \n    uint256 amountIn, \n    address reserveIn, \n    address reserveOut, \n    uint256 amountOut \n  ) public { \n    _amountsOut[reserveIn][reserveOut][amountIn] = amountOut; \n  } \n \n  function setAmountIn( \n    uint256 amountOut, \n    address reserveIn, \n    address reserveOut, \n    uint256 amountIn \n  ) public { \n    _amountsIn[reserveIn][reserveOut][amountOut] = amountIn; \n  } \n \n  function setDefaultMockValue(uint256 value) public { \n    defaultMockValue = value; \n  } \n \n  function getAmountsOut(uint256 amountIn, address[] calldata path) \n    external \n    view \n    override \n    returns (uint256[] memory) \n  { \n    uint256[] memory amounts = new uint256[](path.length); \n    amounts[0] = amountIn; \n    amounts[1] = _amountsOut[path[0]][path[1]][amountIn] > 0 \n      ? _amountsOut[path[0]][path[1]][amountIn] \n      : defaultMockValue; \n    return amounts; \n  } \n \n  function getAmountsIn(uint256 amountOut, address[] calldata path) \n    external \n    view \n    override \n    returns (uint256[] memory) \n  { \n    uint256[] memory amounts = new uint256[](path.length); \n    amounts[0] = _amountsIn[path[0]][path[1]][amountOut] > 0 \n      ? _amountsIn[path[0]][path[1]][amountOut] \n      : defaultMockValue; \n    amounts[1] = amountOut; \n    return amounts; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.4.24 <0.8.0; \n \n \n/** \n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that \n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor \n * external initializer function, usually called `initialize`. It then becomes necessary to protect t\n * function so it can only be called once. The {initializer} modifier provided by this contract will \n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be call\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-const\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer \n * that all initializers are idempotent. This is not verified automatically as constructors are by So\n */ \nabstract contract Initializable { \n \n    /** \n     * @dev Indicates that the contract has been initialized. \n     */ \n    bool private _initialized; \n \n    /** \n     * @dev Indicates that the contract is in the process of being initialized. \n     */ \n    bool private _initializing; \n \n    /** \n     * @dev Modifier to protect an initializer function from being invoked twice. \n     */ \n    modifier initializer() { \n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is alrea\n \n        bool isTopLevelCall = !_initializing; \n        if (isTopLevelCall) { \n            _initializing = true; \n            _initialized = true; \n        } \n \n        _; \n \n        if (isTopLevelCall) { \n            _initializing = false; \n        } \n    } \n \n    /// @dev Returns true if and only if the function is running in the constructor \n    function _isConstructor() private view returns (bool) { \n        return !AddressUpgradeable.isContract(address(this)); \n    } \n} \n \n// File: @openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {StableDebtToken} from '../../protocol/tokenization/StableDebtToken.sol'; \n \ncontract MockStableDebtToken is StableDebtToken { \n  function getRevision() internal pure override returns (uint256) { \n    return 0x2; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"./interfaces/IVTokenFactory.sol\"; \nimport \"./VToken.sol\"; \nimport \"./libraries/Ownable.sol\"; \n \ncontract VTokenFactory is IVTokenFactory, Ownable { \n    mapping(address => address) public override getVToken; \n    address public override bridgeControl; \n \n    function createVToken( \n        address token, \n        string memory tokenName, \n        string memory tokenSymbol, \n        uint8 tokenDecimals \n    ) public override onlyOwner returns (address vToken) { \n        require(bridgeControl != address(0), \"ZERO_ADDRESS\"); \n        require(token != address(0), \"ZERO_ADDRESS\"); \n        require(getVToken[token] == address(0), \"VTOKEN_EXISTS\"); \n        bytes memory bytecode = creationCode(); \n        bytes32 salt = keccak256(abi.encodePacked(address(this), token)); \n        assembly { \n            vToken := create2(0, add(bytecode, 32), mload(bytecode), salt) \n        } \n        getVToken[token] = vToken; \n        VToken(vToken).initialize(token, tokenName, tokenSymbol, tokenDecimals); \n        emit VTokenCreated(token, vToken); \n    } \n \n    function setBridgeControl(address _bridgeControl) \n    public \n    override \n    onlyOwner \n    { \n        require(_bridgeControl != address(0)); \n        bridgeControl = _bridgeControl; \n    } \n \n    function runtimeCode() public pure returns (bytes memory) { \n        return type(VToken).runtimeCode; \n    } \n \n    function creationCode() public pure returns (bytes memory) { \n        return type(VToken).creationCode; \n    } \n \n    function creationCodeHash() public pure returns (bytes32) { \n        return keccak256(creationCode()); \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title IDelegationToken \n * @dev Implements an interface for tokens with delegation COMP/UNI compatible \n * @author Aave \n **/ \ninterface IDelegationToken { \n  function delegate(address delegatee) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ICreditDelegationToken { \n  event BorrowAllowanceDelegated( \n    address indexed fromUser, \n    address indexed toUser, \n    address asset, \n    uint256 amount \n  ); \n \n  /** \n   * @dev delegates borrowing power to a user on the specific debt token \n   * @param delegatee the address receiving the delegated borrowing power \n   * @param amount the maximum amount being delegated. Delegation will still \n   * respect the liquidation constraints (even if delegated, a delegatee cannot \n   * force a delegator HF to go below 1) \n   **/ \n  function approveDelegation(address delegatee, uint256 amount) external; \n \n  /** \n   * @dev returns the borrow allowance of the user \n   * @param fromUser The user to giving allowance \n   * @param toUser The user to give allowance to \n   * @return the current allowance of toUser \n   **/ \n  function borrowAllowance(address fromUser, address toUser) external view returns (uint256); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IMdexFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n \n    function feeToSetter() external view returns (address); \n \n    function feeToRate() external view returns (uint256); \n \n    function initCodeHash() external view returns (bytes32); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n \n    function allPairs(uint) external view returns (address pair); \n \n    function allPairsLength() external view returns (uint); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n \n    function setFeeToSetter(address) external; \n \n    function setFeeToRate(uint256) external; \n \n    function setInitCodeHash(bytes32) external; \n \n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n    function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n    function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uin\n \n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint25\n \n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view retu\n \n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view retu\n \n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[\n \n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[\n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.8.0; \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \n \n/** \n * @notice implementation of the DEFED token contract \n * @author DEFED \n */ \ncontract DefeToken is ERC20 { \n    string internal constant NAME = \"DEFE Token\"; \n    string internal constant SYMBOL = \"DEFE\"; \n \n    uint256 internal constant TOTAL_SUPPLY = 1e28; \n \n    constructor(address misc) public ERC20(NAME, SYMBOL) { \n        _mint(misc, TOTAL_SUPPLY); \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\"; \nimport \"@openzeppelin/contracts/utils/Counters.sol\"; \nimport \"./comm/Helper.sol\"; \n \ncontract ERA7Card is ERC721,Helper { \n \n  struct ERA7CardEntity { \n    uint256 tokenId; \n    uint id; \n    uint ct; \n  } \n \n  ERA7CardEntity[] public allCards; \n  mapping(address => uint256[]) public playerCards; \n  mapping(address => mapping(uint256 => uint)) public playerCardIndexs; \n \n  using Counters for Counters.Counter; \n  Counters.Counter private _tokenIds; \n \n  constructor() ERC721(\"Era7 NFT\", \"ERANFT\") {} \n \n  function awardCard(address player,uint cardId) external onlyHelper returns (uint256){ \n    _tokenIds.increment(); \n \n    uint256 newItemId = _tokenIds.current(); \n \n    ERA7CardEntity memory card = ERA7CardEntity(newItemId,cardId,block.timestamp); \n    allCards.push(card); \n \n    playerCards[player].push(newItemId); \n    playerCardIndexs[player][newItemId] = playerCards[player].length; \n \n    _mint(player, newItemId); \n \n    emit AwardCard(player,newItemId,cardId); \n \n    return newItemId; \n  } \n \n  function approveList(address to, uint256[] memory tokenIds) external { \n    uint len = tokenIds.length; \n    for(uint i = 0; i < len ; i++){ \n      approve(to, tokenIds[i]); \n    } \n  } \n \n  function _transfer(address from,address to,uint256 tokenId) internal virtual override { \n    super._transfer(from,to,tokenId); \n    _swapTokenOwner(from,to,tokenId); \n  } \n \n  function burnList(uint256[] memory tokenIds) external {  \n    uint len = tokenIds.length; \n    for(uint i = 0; i < len ; i++){ \n      _burn(tokenIds[i]); \n    } \n  } \n \n  function burn(uint256 tokenId) external { \n    _burn(tokenId); \n  } \n \n  function _burn(uint256 tokenId) internal virtual override { \n    address owner = ERC721.ownerOf(tokenId); \n    _swapTokenOwner(owner,address(0),tokenId); \n    super._burn(tokenId); \n  } \n \n  function _swapTokenOwner(address from,address to,uint256 tokenId) private{ \n    if(from != to){ \n      uint index = playerCardIndexs[from][tokenId]; \n      if(playerCards[from].length != index){ \n        uint256 oldToken = playerCards[from][playerCards[from].length - 1]; \n        playerCards[from][index - 1] = oldToken; \n        playerCardIndexs[from][oldToken] = index; \n      } \n      playerCards[from].pop(); \n      delete playerCardIndexs[from][tokenId]; \n \n      if(to != address(0)){ \n        playerCards[to].push(tokenId); \n        playerCardIndexs[to][tokenId] = playerCards[to].length; \n      } \n    } \n  } \n \n  function totalCard() external view returns(uint256) { \n    return allCards.length; \n  } \n \n  function getPlayerCards(address player) external view returns (ERA7CardEntity[] memory) { \n    uint[] memory list = playerCards[player]; \n    uint length = list.length; \n    ERA7CardEntity[] memory cardList = new ERA7CardEntity[](length); \n    for(uint i = 0; i < length ; i++){ \n      cardList[i] = allCards[list[i] - 1]; \n    } \n    return cardList; \n  } \n \n  event AwardCard(address indexed to, uint256 nftId,uint256 cardId); \n} \n// nft\u4ea4\u6613\u5e02\u573a \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \n \nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol'; \nimport {IChainlinkAggregator} from '../interfaces/IChainlinkAggregator.sol'; \nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol'; \n \n/// @title AaveOracle \n/// @author Aave \n/// @notice Proxy smart contract to get the price of an asset from a price source, with Chainlink Agg\n///         smart contracts as primary option \n/// - If the returned price by a Chainlink aggregator is <= 0, the call is forwarded to a fallbackOra\n/// - Owned by the Aave governance system, allowed to add sources for assets, replace them \n///   and change the fallbackOracle \ncontract AaveOracle is IPriceOracleGetter, Ownable { \n  using SafeERC20 for IERC20; \n \n  event AssetSourceUpdated(address indexed asset, address indexed source); \n  event FallbackOracleUpdated(address indexed fallbackOracle); \n \n  mapping(address => IChainlinkAggregator) private assetsSources; \n  IPriceOracleGetter private _fallbackOracle; \n \n  /// @notice Constructor \n  /// @param assets The addresses of the assets \n  /// @param sources The address of the source of each asset \n  /// @param fallbackOracle The address of the fallback oracle to use if the data of an \n  ///        aggregator is not consistent \n  constructor( \n    address[] memory assets, \n    address[] memory sources, \n    address fallbackOracle \n  ) public { \n    _setFallbackOracle(fallbackOracle); \n    _setAssetsSources(assets, sources); \n  } \n \n  /// @notice External function called by the Aave governance to set or replace sources of assets \n  /// @param assets The addresses of the assets \n  /// @param sources The address of the source of each asset \n  function setAssetSources(address[] calldata assets, address[] calldata sources) \n    external \n    onlyOwner \n  { \n    _setAssetsSources(assets, sources); \n  } \n \n  /// @notice Sets the fallbackOracle \n  /// - Callable only by the Aave governance \n  /// @param fallbackOracle The address of the fallbackOracle \n  function setFallbackOracle(address fallbackOracle) external onlyOwner { \n    _setFallbackOracle(fallbackOracle); \n  } \n \n  /// @notice Internal function to set the sources for each asset \n  /// @param assets The addresses of the assets \n  /// @param sources The address of the source of each asset \n  function _setAssetsSources(address[] memory assets, address[] memory sources) internal { \n    require(assets.length == sources.length, 'INCONSISTENT_PARAMS_LENGTH'); \n    for (uint256 i = 0; i < assets.length; i++) { \n      assetsSources[assets[i]] = IChainlinkAggregator(sources[i]); \n      emit AssetSourceUpdated(assets[i], sources[i]); \n    } \n  } \n \n  /// @notice Internal function to set the fallbackOracle \n  /// @param fallbackOracle The address of the fallbackOracle \n  function _setFallbackOracle(address fallbackOracle) internal { \n    _fallbackOracle = IPriceOracleGetter(fallbackOracle); \n    emit FallbackOracleUpdated(fallbackOracle); \n  } \n \n  /// @notice Gets an asset price by address \n  /// @param asset The asset address \n  function getAssetPrice(address asset) public view override returns (uint256) { \n    IChainlinkAggregator source = assetsSources[asset]; \n \n    if (address(source) == address(0)) { \n      return _fallbackOracle.getAssetPrice(asset); \n    } else { \n      int256 price = IChainlinkAggregator(source).latestAnswer(); \n      if (price > 0) { \n        return uint256(price); \n      } else { \n        return _fallbackOracle.getAssetPrice(asset); \n      } \n    } \n  } \n \n  /// @notice Gets a list of prices from a list of assets addresses \n  /// @param assets The list of assets addresses \n  function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory) { \n    uint256[] memory prices = new uint256[](assets.length); \n    for (uint256 i = 0; i < assets.length; i++) { \n      prices[i] = getAssetPrice(assets[i]); \n    } \n    return prices; \n  } \n \n  /// @notice Gets the address of the source for an asset address \n  /// @param asset The address of the asset \n  /// @return address The address of the source \n  function getSourceOfAsset(address asset) external view returns (address) { \n    return address(assetsSources[asset]); \n  } \n \n  /// @notice Gets the address of the fallback oracle \n  /// @return address The addres of the fallback oracle \n  function getFallbackOracle() external view returns (address) { \n    return address(_fallbackOracle); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IScaledBalanceToken { \n  /** \n   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the \n   * updated stored balance divided by the reserve's liquidity index at the moment of the update \n   * @param user The user whose balance is calculated \n   * @return The scaled balance of the user \n   **/ \n  function scaledBalanceOf(address user) external view returns (uint256); \n \n  /** \n   * @dev Returns the scaled balance of the user and the scaled total supply. \n   * @param user The address of the user \n   * @return The scaled balance of the user \n   * @return The scaled balance and the scaled total supply \n   **/ \n  function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256); \n \n  /** \n   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index) \n   * @return The scaled total supply \n   **/ \n  function scaledTotalSupply() external view returns (uint256); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {Errors} from '../helpers/Errors.sol'; \n \n/** \n * @title WadRayMath library \n * @author Aave \n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (d\n **/ \n \nlibrary WadRayMath { \n  uint256 internal constant WAD = 1e18; \n  uint256 internal constant halfWAD = WAD / 2; \n \n  uint256 internal constant RAY = 1e27; \n  uint256 internal constant halfRAY = RAY / 2; \n \n  uint256 internal constant WAD_RAY_RATIO = 1e9; \n \n  /** \n   * @return One ray, 1e27 \n   **/ \n  function ray() internal pure returns (uint256) { \n    return RAY; \n  } \n \n  /** \n   * @return One wad, 1e18 \n   **/ \n \n  function wad() internal pure returns (uint256) { \n    return WAD; \n  } \n \n  /** \n   * @return Half ray, 1e27/2 \n   **/ \n  function halfRay() internal pure returns (uint256) { \n    return halfRAY; \n  } \n \n  /** \n   * @return Half ray, 1e18/2 \n   **/ \n  function halfWad() internal pure returns (uint256) { \n    return halfWAD; \n  } \n \n  /** \n   * @dev Multiplies two wad, rounding half up to the nearest wad \n   * @param a Wad \n   * @param b Wad \n   * @return The result of a*b, in wad \n   **/ \n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) { \n    if (a == 0 || b == 0) { \n      return 0; \n    } \n \n    require(a <= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n    return (a * b + halfWAD) / WAD; \n  } \n \n  /** \n   * @dev Divides two wad, rounding half up to the nearest wad \n   * @param a Wad \n   * @param b Wad \n   * @return The result of a/b, in wad \n   **/ \n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) { \n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO); \n    uint256 halfB = b / 2; \n \n    require(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n    return (a * WAD + halfB) / b; \n  } \n \n  /** \n   * @dev Multiplies two ray, rounding half up to the nearest ray \n   * @param a Ray \n   * @param b Ray \n   * @return The result of a*b, in ray \n   **/ \n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) { \n    if (a == 0 || b == 0) { \n      return 0; \n    } \n \n    require(a <= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n    return (a * b + halfRAY) / RAY; \n  } \n \n  /** \n   * @dev Divides two ray, rounding half up to the nearest ray \n   * @param a Ray \n   * @param b Ray \n   * @return The result of a/b, in ray \n   **/ \n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) { \n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO); \n    uint256 halfB = b / 2; \n \n    require(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n    return (a * RAY + halfB) / b; \n  } \n \n  /** \n   * @dev Casts ray down to wad \n   * @param a Ray \n   * @return a casted to wad, rounded half up to the nearest wad \n   **/ \n  function rayToWad(uint256 a) internal pure returns (uint256) { \n    uint256 halfRatio = WAD_RAY_RATIO / 2; \n    uint256 result = halfRatio + a; \n    require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW); \n \n    return result / WAD_RAY_RATIO; \n  } \n \n  /** \n   * @dev Converts wad up to ray \n   * @param a Wad \n   * @return a converted in ray \n   **/ \n  function wadToRay(uint256 a) internal pure returns (uint256) { \n    uint256 result = a * WAD_RAY_RATIO; \n    require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW); \n    return result; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format)\n \n// range: [0, 2**112 - 1] \n// resolution: 1 / 2**112 \n \nlibrary UQ112x112 { \n    uint224 constant Q112 = 2**112; \n \n    // encode a uint112 as a UQ112x112 \n    function encode(uint112 y) internal pure returns (uint224 z) { \n        z = uint224(y) * Q112; // never overflows \n    } \n \n    // divide a UQ112x112 by a uint112, returning a UQ112x112 \n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { \n        z = x / uint224(y); \n    } \n} \n \n \n// File contracts/interface/ILfgSwapFactory.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n \ncontract NetswapERC20 { \n    using SafeMathNetswap for uint; \n \n    string public constant name = 'Netswap LP Token'; \n    string public constant symbol = 'NLP'; \n    uint8 public constant decimals = 18; \n    uint  public totalSupply; \n    mapping(address => uint) public balanceOf; \n    mapping(address => mapping(address => uint)) public allowance; \n \n    bytes32 public DOMAIN_SEPARATOR; \n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c6\n    mapping(address => uint) public nonces; \n \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    constructor() public { \n        uint chainId; \n        assembly { \n            chainId := chainid() \n        } \n        DOMAIN_SEPARATOR = keccak256( \n            abi.encode( \n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingC\n                keccak256(bytes(name)), \n                keccak256(bytes('1')), \n                chainId, \n                address(this) \n            ) \n        ); \n    } \n \n    function _mint(address to, uint value) internal { \n        totalSupply = totalSupply.add(value); \n        balanceOf[to] = balanceOf[to].add(value); \n        emit Transfer(address(0), to, value); \n    } \n \n    function _burn(address from, uint value) internal { \n        balanceOf[from] = balanceOf[from].sub(value); \n        totalSupply = totalSupply.sub(value); \n        emit Transfer(from, address(0), value); \n    } \n \n    function _approve(address owner, address spender, uint value) private { \n        allowance[owner][spender] = value; \n        emit Approval(owner, spender, value); \n    } \n \n    function _transfer(address from, address to, uint value) private { \n        balanceOf[from] = balanceOf[from].sub(value); \n        balanceOf[to] = balanceOf[to].add(value); \n        emit Transfer(from, to, value); \n    } \n \n    function approve(address spender, uint value) external returns (bool) { \n        _approve(msg.sender, spender, value); \n        return true; \n    } \n \n    function transfer(address to, uint value) external returns (bool) { \n        _transfer(msg.sender, to, value); \n        return true; \n    } \n \n    function transferFrom(address from, address to, uint value) external returns (bool) { \n        if (allowance[from][msg.sender] != uint(-1)) { \n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value); \n        } \n        _transfer(from, to, value); \n        return true; \n    } \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n        require(deadline >= block.timestamp, 'Netswap: EXPIRED'); \n        bytes32 digest = keccak256( \n            abi.encodePacked( \n                '\\x19\\x01', \n                DOMAIN_SEPARATOR, \n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadlin\n            ) \n        ); \n        address recoveredAddress = ecrecover(digest, v, r, s); \n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'Netswap: INVALID_SIGNAT\n        _approve(owner, spender, value); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IStrategyLink { \n \n    event StrategyDeposit(address indexed strategy, uint256 indexed pid, address indexed user, uint25\n    event StrategyBorrow(address indexed strategy, uint256 indexed pid, address indexed user, uint256 \n    event StrategyWithdraw(address indexed strategy, uint256 indexed pid, address indexed user, uint2\n    event StrategyLiquidation(address indexed strategy, uint256 indexed pid, address indexed user, ui\n \n    function bank() external view returns(address); \n    function getSource() external view returns (string memory); \n    function userInfo(uint256 _pid, address _account) external view returns (uint256,uint256,address,\n    function getPoolInfo(uint256 _pid) external view  returns(address[] memory collateralToken, addre\n    function getBorrowInfo(uint256 _pid, address _account) external view returns (address borrowFrom, \n    function getBorrowAmount(uint256 _pid, address _account) external view returns (uint256 value); \n    function getBorrowAmountInBaseToken(uint256 _pid, address _account) external view returns (uint25\n    function getDepositAmount(uint256 _pid, address _account) external view returns (uint256 amount);\n \n    function getPoolCollateralToken(uint256 _pid) external view returns (address[] memory collateralT\n    function getPoollpToken(uint256 _pid) external view returns (address lpToken); \n    function getBaseToken(uint256 _pid) external view returns (address baseToken); \n \n    function poolLength() external view returns (uint256); \n \n    function pendingRewards(uint256 _pid, address _account) external view returns (uint256 value); \n    function pendingLPAmount(uint256 _pid, address _account) external view returns (uint256 value); \n \n    // function massUpdatePools(uint256 _start, uint256 _end) external; \n    function updatePool(uint256 _pid, uint256 _desirePrice, uint256 _slippage) external; \n \n    function deposit(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount, uint256 _de\n    function depositLPToken(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount, uint\n \n    function withdraw(uint256 _pid, address _account, uint256 _rate, address _toToken, uint256 _desir\n    function withdrawLPToken(uint256 _pid, address _account, uint256 _rate, uint256 _desirePrice, uin\n \n    function emergencyWithdraw(uint256 _pid, address _account, uint256 _desirePrice, uint256 _slippag\n \n    function liquidation(uint256 _pid, address _account, address _hunter, uint256 _maxDebt) external;\n    function repayBorrow(uint256 _pid, address _account, uint256 _rate, bool _force) external; \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\"; \n \ncontract Helper is Ownable,ReentrancyGuard { \n \n  address[] public helpers; \n  mapping(address => uint) helperIndexs; \n \n  bool public pause; \n \n  constructor(){ \n    pause = false; \n  } \n \n  function addHelper(address helper) external onlyOwner { \n    require(helper != address(0),\"Helper:set helper error\"); \n    uint index = helperIndexs[helper]; \n    if(index == 0){ \n      helpers.push(helper); \n      helperIndexs[helper] = helpers.length; \n    } \n  } \n \n  function removeHelper(address helper) external onlyOwner{ \n    uint index = helperIndexs[helper]; \n    require(index > 0,\"Helper:remove helper error\"); \n    if(helpers.length != index){ \n        address old = helpers[helpers.length - 1]; \n        helpers[index - 1] = old; \n        helperIndexs[old] = index; \n      } \n      helpers.pop(); \n      delete helperIndexs[helper]; \n  } \n \n  function pauseContract() external onlyHelper{ \n    pause = true; \n  } \n \n  function resume() external onlyHelper{ \n    pause = false; \n  } \n \n  modifier onlyHelper() { \n    require(helperIndexs[_msgSender()] > 0 || owner() == _msgSender(), \"Helper: caller is not the hel\n    _; \n  } \n \n  modifier isPause() { \n    require(!pause, \"Helper: contract is paused\"); \n    _; \n  } \n \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface GenericOracleI { \n  // ganache \n  event AssetPriceUpdated(address _asset, uint256 _price, uint256 timestamp); \n  event EthPriceUpdated(uint256 _price, uint256 timestamp); \n \n  // kovan \n  event ProphecySubmitted( \n    address indexed _sybil, \n    address indexed _asset, \n    uint96 _sybilProphecy, \n    uint96 _oracleProphecy \n  ); \n \n  function getAssetPrice(address _asset) external view returns (uint256); \n \n  function getEthUsdPrice() external view returns (uint256); \n} \n \nAnalysis of audit results\nRe-Entrancy\nArithmetic Over/Under Flows\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n* @dev Interface of the  ERC20 standard as defined in the\n  */  \n  interface IERC20 { \n  /** \n    * @dev Returns the  amount of tokens in existence. \n      */  \n      function totalSupply() external view returns (uint256); \n \n  /** \n    * @dev Returns the  amount of tokens owned by `account`. \n      */  \n      function balanceOf(address account) external view returns (uint256); \n \n  /** \n    * @dev Moves `amount` tokens from the  caller's account to `recipient`. \n    * \n    * Returns a  boolean value indicating whether the  operat\n    * \n    * Emits a  {Transfer} event. \n      */  \n      function transfer(address recipient, uint256 amount) external returns (bool); \n \n  /** \n    * @dev Returns the  remaining number of tokens that `spender` will\n    * allowed to spend on behalf of `owner` through {transferFrom}. This is \n    * zero by default. \n    * \n    * This value changes when {approve} or {transferFrom} are  called. \n      */  \n      function allowance(address owner, address spender) external view returns (uint256); \n \n  /** \n    * @dev Sets `amount` as the  allowance of `spender` over the\n    * \n    * Returns a  boolean value indicating whether the  operat\n    * \n    * IMPORTANT: Beware that changing an  allowance with this method brings \n    * that someone may use both the  old and the  new allow\n    * transaction ordering. One possible solution to mitigate this race \n    * condition is to first reduce the  spender's allowance to 0 and set the\n    * desired value afterwards: \n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n    * \n    * Emits an  {Approval} event. \n      */  \n      function approve(address spender, uint256 amount) external returns (bool); \n \n  /** \n    * @dev Moves `amount` tokens from `sender` to `recipient` using the  \n    * allowance mechanism. `amount` is then deducted from the  caller's \n    * allowance. \n    * \n    * Returns a  boolean value indicating whether the  operat\n    * \n    * Emits a  {Transfer} event. \n      */  \n      function transferFrom( \n      address sender, \n      address recipient, \n      uint256 amount \n      ) external returns (bool); \n \n  /** \n    * @dev Emitted when `value` tokens are  moved from one account (`from`) to \n    * another (`to`). \n    * \n    * Note that `value` may be zero. \n      */  \n      event Transfer(address indexed from, address indexed to, uint256 value); \n \n  /** \n    * @dev Emitted when the  allowance of a  `spender` for \n    * a  call to {approve}. `value` is the  new allowance. \n      */  \n      event Approval(address indexed owner, address indexed spender, uint256 value); \n      } \n \n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol) \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IRewardsToken { \n    function mint(address _account, uint256 _amount) external; \n    function burn(uint256 _amount) external; \n \n    function setMintWhitelist(address _account, bool _enabled) external; \n    function checkWhitelist(address _account) external view returns (bool); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface IERC20Netswap { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external view returns (string memory); \n    function symbol() external view returns (string memory); \n    function decimals() external view returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \ninterface IStrategyConfig { \n    // event \n    event SetFeeGather(address _feeGatherOld, address _feeGather); \n    event SetReservedGather(address _old, address _new); \n    event SetBorrowFactor(address _strategy, uint256 _poolid, uint256 _borrowFactor); \n    event SetLiquidationFactor(address _strategy, uint256 _poolid, uint256 _liquidationFactor); \n    event SetFarmPoolFactor(address _strategy, uint256 _poolid, uint256 _farmPoolFactor); \n    event SetDepositFee(address _strategy, uint256 _poolid, uint256 _depositFee); \n    event SetWithdrawFee(address _strategy, uint256 _poolid, uint256 _withdrawFee); \n    event SetRefundFee(address _strategy, uint256 _poolid, uint256 _refundFee); \n    event SetClaimFee(address _strategy, uint256 _poolid, uint256 _claimFee); \n    event SetLiquidationFee(address _strategy, uint256 _poolid, uint256 _liquidationFee); \n \n    // factor \n    function getBorrowFactor(address _strategy, uint256 _poolid) external view returns (uint256); \n    function setBorrowFactor(address _strategy, uint256 _poolid, uint256 _borrowFactor) external; \n \n    function getLiquidationFactor(address _strategy, uint256 _poolid) external view returns (uint256)\n    function setLiquidationFactor(address _strategy, uint256 _poolid, uint256 _liquidationFactor) ext\n \n    function getFarmPoolFactor(address _strategy, uint256 _poolid) external view returns (uint256 val\n    function setFarmPoolFactor(address _strategy, uint256 _poolid, uint256 _farmPoolFactor) external;\n \n    // fee manager \n    function getDepositFee(address _strategy, uint256 _poolid) external view returns (address, uint25\n    function setDepositFee(address _strategy, uint256 _poolid, uint256 _depositFee) external; \n \n    function getWithdrawFee(address _strategy, uint256 _poolid) external view returns (address, uint2\n    function setWithdrawFee(address _strategy, uint256 _poolid, uint256 _withdrawFee) external; \n \n    function getRefundFee(address _strategy, uint256 _poolid) external view returns (address, uint256\n    function setRefundFee(address _strategy, uint256 _poolid, uint256 _refundFee) external; \n \n    function getClaimFee(address _strategy, uint256 _poolid) external view returns (address, uint256)\n    function setClaimFee(address _strategy, uint256 _poolid, uint256 _claimFee) external; \n \n    function getLiquidationFee(address _strategy, uint256 _poolid) external view returns (address, ui\n    function setLiquidationFee(address _strategy, uint256 _poolid, uint256 _liquidationFee) external;\n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev Contract module that helps prevent reentrant calls to a function. \n * \n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier \n * available, which can be applied to functions to make sure there are no nested \n * (reentrant) calls to them. \n * \n * Note that because there is a single `nonReentrant` guard, functions marked as \n * `nonReentrant` may not call one another. This can be worked around by making \n * those functions `private`, and then adding `external` `nonReentrant` entry \n * points to them. \n * \n * TIP: If you would like to learn more about reentrancy and alternative ways \n * to protect against it, check out our blog post \n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. \n */ \nabstract contract ReentrancyGuardUpgradeable is Initializable { \n    // Booleans are more expensive than uint256 or any type that takes up a full \n    // word because each write operation emits an extra SLOAD to first read the \n    // slot's contents, replace the bits taken up by the boolean, and then write \n    // back. This is the compiler's defense against contract upgrades and \n    // pointer aliasing, and it cannot be disabled. \n \n    // The values being non-zero value makes deployment a bit more expensive, \n    // but in exchange the refund on every call to nonReentrant will be lower in \n    // amount. Since refunds are capped to a percentage of the total \n    // transaction's gas, it is best to keep them low in cases like this one, to \n    // increase the likelihood of the full refund coming into effect. \n    uint256 private constant _NOT_ENTERED = 1; \n    uint256 private constant _ENTERED = 2; \n \n    uint256 private _status; \n \n    function __ReentrancyGuard_init() internal initializer { \n        __ReentrancyGuard_init_unchained(); \n    } \n \n    function __ReentrancyGuard_init_unchained() internal initializer { \n        _status = _NOT_ENTERED; \n    } \n \n    /** \n     * @dev Prevents a contract from calling itself, directly or indirectly. \n     * Calling a `nonReentrant` function from another `nonReentrant` \n     * function is not supported. It is possible to prevent this from happening \n     * by making the `nonReentrant` function external, and make it call a \n     * `private` function that does the actual work. \n     */ \n    modifier nonReentrant() { \n        // On the first call to nonReentrant, _notEntered will be true \n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); \n \n        // Any calls to nonReentrant after this point will fail \n        _status = _ENTERED; \n \n        _; \n \n        // By storing the original value once again, a refund is triggered (see \n        // https://eips.ethereum.org/EIPS/eip-2200) \n        _status = _NOT_ENTERED; \n    } \n    uint256[49] private __gap; \n} \n \n// File: contracts/interface/IInvit.sol \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \ncontract StrategyV2Data { \n \n    // Info of each user. \n    struct UserInfo { \n        uint256 lpAmount;       // deposit lptoken amount \n        uint256 lpPoints;       // deposit proportion \n        address[] borrowFrom;   // borrowFrom \n        uint256[] bids; \n    } \n \n    // Info of each pool. \n    struct PoolInfo { \n        address[] collateralToken;      // collateral Token list, last must be baseToken \n        address baseToken;              // baseToken can be borrowed \n        address lpToken;                // lptoken to deposit \n        uint256 poolId;                 // poolid for mdex pools \n        uint256 lastRewardsBlock;       // \n        uint256 totalPoints;            // total of user lpPoints \n        uint256 totalLPAmount;          // total of user lpAmount \n        uint256 totalLPReinvest;        // total of lptoken amount with totalLPAmount and reinvest re\n        uint256 miniRewardAmount;       // \n    } \n \n    // Info of each pool. \n    PoolInfo[] public poolInfo; \n    // Info of each user that stakes LP tokens. \n    mapping (uint256 => mapping (address => UserInfo)) public userInfo2; \n \n    address public _bank;                // address of bank \n    address public _this; \n    address public helperImpl; \n \n    IStrategyConfig public sconfig; \n    mapping (uint256 => mapping (string => uint256)) public poolConfig; \n \n    IStrategyV2SwapPool public swapPoolImpl; \n \n    address public devAddr; \n    IPriceChecker public priceChecker; \n    IActionPools public compActionPool;     // address of comp action pool \n \n    mapping(address=>bool) public whitelist; \n    uint256[39] private __gap; \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nabstract contract ReentrancyGuard { \n \n    uint256 private constant _NOT_ENTERED = 1; \n    uint256 private constant _ENTERED = 2; \n \n    uint256 private _status; \n \n    constructor () { \n        _status = _NOT_ENTERED; \n    } \n \n    modifier nonReentrant() { \n        // On the first call to nonReentrant, _notEntered will be true \n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); \n \n        // Any calls to nonReentrant after this point will fail \n        _status = _ENTERED; \n \n        _; \n \n        // By storing the original value once again, a refund is triggered (see \n        // https://eips.ethereum.org/EIPS/eip-2200) \n        _status = _NOT_ENTERED; \n    } \n} \n \nAnalysis of audit results\nRe-Entrancy\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @title SignedSafeMath \n * @dev Signed math operations with safety checks that revert on error. \n */ \nlibrary SignedSafeMathUpgradeable { \n    int256 constant private _INT256_MIN = -2**255; \n \n    /** \n     * @dev Returns the multiplication of two signed integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `*` operator. \n     * \n     * Requirements: \n     * \n     * - Multiplication cannot overflow. \n     */ \n    function mul(int256 a, int256 b) internal pure returns (int256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\"); \n \n        int256 c = a * b; \n        require(c / a == b, \"SignedSafeMath: multiplication overflow\"); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the integer division of two signed integers. Reverts on \n     * division by zero. The result is rounded towards zero. \n     * \n     * Counterpart to Solidity's `/` operator. Note: this function uses a \n     * `revert` opcode (which leaves remaining gas untouched) while Solidity \n     * uses an invalid opcode to revert (consuming all remaining gas). \n     * \n     * Requirements: \n     * \n     * - The divisor cannot be zero. \n     */ \n    function div(int256 a, int256 b) internal pure returns (int256) { \n        require(b != 0, \"SignedSafeMath: division by zero\"); \n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\"); \n \n        int256 c = a / b; \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the subtraction of two signed integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `-` operator. \n     * \n     * Requirements: \n     * \n     * - Subtraction cannot overflow. \n     */ \n    function sub(int256 a, int256 b) internal pure returns (int256) { \n        int256 c = a - b; \n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\"); \n \n        return c; \n    } \n \n    /** \n     * @dev Returns the addition of two signed integers, reverting on \n     * overflow. \n     * \n     * Counterpart to Solidity's `+` operator. \n     * \n     * Requirements: \n     * \n     * - Addition cannot overflow. \n     */ \n    function add(int256 a, int256 b) internal pure returns (int256) { \n        int256 c = a + b; \n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\"); \n \n        return c; \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"../Context.sol\"; \nimport \"./ERC20Pausable.sol\"; \n \nabstract contract ERC20Mintable is Context, ERC20Pausable { \n    using SafeMath for uint256; \n \n    mapping(address => bool) public isMinter; \n \n    event AddMinter(address indexed minter); \n    event RemoveMinter(address indexed minter); \n    event Mint( \n        address indexed minter, \n        address indexed recipient, \n        uint256 amount \n    ); \n \n    modifier onlyMinter() { \n        require(isMinter[_msgSender()], \"ERC20: sender is not minter\"); \n        _; \n    } \n \n    function _addMinter(address minter) internal { \n        require(!isMinter[minter], \"ERC20: already a minter\"); \n        isMinter[minter] = true; \n        emit AddMinter(minter); \n    } \n \n    function _removeMinter(address minter) internal { \n        require(isMinter[minter], \"ERC20: not a minter\"); \n        isMinter[minter] = false; \n        emit RemoveMinter(minter); \n    } \n \n    function mint(address recipient, uint256 amount) external onlyMinter { \n        _mint(recipient, amount); \n        emit Mint(_msgSender(), recipient, amount); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \ninterface IActionPools { \n \n    function getPoolInfo(uint256 _pid) external view \n        returns (address callFrom, uint256 callId, address rewardToken); \n    function mintRewards(uint256 _callId) external; \n    function getPoolIndex(address _callFrom, uint256 _callId) external view returns (uint256[] memory\n \n    function onAcionIn(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ext\n    function onAcionOut(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ex\n    function onAcionClaim(uint256 _callId, address _account) external; \n    function onAcionEmergency(uint256 _callId, address _account) external; \n    function onAcionUpdate(uint256 _callId) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {WadRayMath} from './WadRayMath.sol'; \n \nlibrary MathUtils { \n  using SafeMath for uint256; \n  using WadRayMath for uint256; \n \n  /// @dev Ignoring leap years \n  uint256 internal constant SECONDS_PER_YEAR = 365 days; \n \n  /** \n   * @dev Function to calculate the interest accumulated using a linear interest rate formula \n   * @param rate The interest rate, in ray \n   * @param lastUpdateTimestamp The timestamp of the last update of the interest \n   * @return The interest rate linearly accumulated during the timeDelta, in ray \n   **/ \n \n  function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp) \n    internal \n    view \n    returns (uint256) \n  { \n    //solium-disable-next-line \n    uint256 timeDifference = block.timestamp.sub(uint256(lastUpdateTimestamp)); \n \n    return (rate.mul(timeDifference) / SECONDS_PER_YEAR).add(WadRayMath.ray()); \n  } \n \n  /** \n   * @dev Function to calculate the interest using a compounded interest rate formula \n   * To avoid expensive exponentiation, the calculation is performed using a binomial approximation: \n   * \n   *  (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3... \n   * \n   * The approximation slightly underpays liquidity providers and undercharges borrowers, with the ad\n   * The whitepaper contains reference to the approximation and a table showing the margin of error p\n   * \n   * @param rate The interest rate, in ray \n   * @param lastUpdateTimestamp The timestamp of the last update of the interest \n   * @return The interest rate compounded during the timeDelta, in ray \n   **/ \n  function calculateCompoundedInterest( \n    uint256 rate, \n    uint40 lastUpdateTimestamp, \n    uint256 currentTimestamp \n  ) internal pure returns (uint256) { \n    //solium-disable-next-line \n    uint256 exp = currentTimestamp.sub(uint256(lastUpdateTimestamp)); \n \n    if (exp == 0) { \n      return WadRayMath.ray(); \n    } \n \n    uint256 expMinusOne = exp - 1; \n \n    uint256 expMinusTwo = exp > 2 ? exp - 2 : 0; \n \n    uint256 ratePerSecond = rate / SECONDS_PER_YEAR; \n \n    uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond); \n    uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond); \n \n    uint256 secondTerm = exp.mul(expMinusOne).mul(basePowerTwo) / 2; \n    uint256 thirdTerm = exp.mul(expMinusOne).mul(expMinusTwo).mul(basePowerThree) / 6; \n \n    return WadRayMath.ray().add(ratePerSecond.mul(exp)).add(secondTerm).add(thirdTerm); \n  } \n \n  /** \n   * @dev Calculates the compounded interest between the timestamp of the last update and the current \n   * @param rate The interest rate (in ray) \n   * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calcul\n   **/ \n  function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp) \n    internal \n    view \n    returns (uint256) \n  { \n    return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20 { \n    using SafeMath for uint256; \n    using Address for address; \n \n    function safeTransfer(IERC20 token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20 token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20 token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n \n// File contracts/interface/ILfgSwapPair.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.2; \n \n \ninterface IUniswapV2Router02 is IUniswapV2Router01 { \n    function removeLiquidityHTSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountHTMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountHT); \n    function removeLiquidityHTWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountHTMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountHT); \n \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n    function swapExactHTForTokensSupportingFeeOnTransferTokens( \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external payable; \n    function swapExactTokensForHTSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements an  upgradeable proxy. It is upgradeable because cal\n * implementation address that can be changed. This address is stored in storage in the\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so  that it doesn't\n * implementation behind the  proxy. \n * \n * Upgradeability is only provided internally through {_upgradeTo}. For an  externally up\n * {TransparentUpgradeableProxy}. \n */  \ncontract UpgradeableProxy is Proxy { \n    /** \n     * @dev Initializes the  upgradeable proxy with an  initial i\n     * \n     * If `_data` is nonempty, it's used as data in a  delegate call to `_logic`. This \n     * function call, and allows initializating the  storage of the\n     */  \n    constructor(address _logic, bytes memory _data) public payable { \n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1\n        _setImplementation(_logic); \n        if(_data.length > 0) { \n            Address.functionDelegateCall(_logic, _data); \n        } \n    } \n \n    /** \n     * @dev Emitted when the  implementation is upgraded. \n     */  \n    event Upgraded(address indexed implementation); \n \n    /** \n     * @dev Storage slot with the  address of the  current imp\n     * This is the  keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, an\n     * validated in the  constructor. \n     */  \n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a\n \n    /** \n     * @dev Returns the  current implementation address. \n     */  \n    function _implementation() internal view virtual override returns (address impl) { \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            impl := sload(slot) \n        } \n    } \n \n    /** \n     * @dev Upgrades the  proxy to a  new implementation. \n     * \n     * Emits an  {Upgraded} event. \n     */  \n    function _upgradeTo(address newImplementation) internal virtual { \n        _setImplementation(newImplementation); \n        emit Upgraded(newImplementation); \n    } \n \n    /** \n     * @dev Stores a  new address in the  EIP1967 implemen\n     */  \n    function _setImplementation(address newImplementation) private { \n        require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a \n \n        bytes32 slot = _IMPLEMENTATION_SLOT; \n \n        // solhint-disable-next-line no-inline-assembly \n        assembly { \n            sstore(slot, newImplementation) \n        } \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @title IERC1363Spender Interface \n * @dev Interface for any contract that wants to support approveAndCall \n *  from ERC1363 token contracts as defined in \n *  https://eips.ethereum.org/EIPS/eip-1363 \n */  \ninterface IERC1363Spender { \n    /** \n     * @notice Handle the  approval of ERC1363 tokens \n     * @dev Any ERC1363 smart contract calls this function on the  recipient \n     * after an  `approve`. This function MAY throw to revert and reject the\n     * approval. Return of other than the  magic value MUST result in the\n     * transaction being reverted. \n     * Note: the  token contract address is always the  messa\n     * @param sender address The address which called `approveAndCall` function \n     * @param amount uint256 The amount of tokens to be spent \n     * @param data bytes Additional data with no specified format \n     * @return `bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))` unless throwing \n     */  \n    function onApprovalReceived( \n        address sender, \n        uint256 amount, \n        bytes calldata data \n    ) external returns (bytes4); \n} \n \n// File: erc-payable-token/contracts/token/ERC1363/ERC1363.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return t\nlibrary TransferHelper { \n    function safeApprove(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('approve(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_F\n    } \n \n    function safeTransfer(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transfer(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferFrom(address token, address from, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, v\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferETH(address to, uint value) internal { \n        (bool success,) = to.call{value : value}(new bytes(0)); \n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED'); \n    } \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \nimport \"./IDOToken.sol\"; \nimport \"./interfaces/IMdexPair.sol\"; \nimport \"./interfaces/IMdexFactory.sol\"; \n \n \ncontract IDOFactory is Ownable { \n    using SafeMath for uint256; \n \n    address[] public IDOlist; \n    mapping(address => bool) public isIDO; \n    mapping(address => address[]) public userIDOs; \n    address public hfil; \n    address public mfil; \n    address public operator; // for start ido \n    address public mdexFactory; \n \n    event NewIDO(address indexed sender, address indexed ido); \n \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n \n    constructor( \n        address _operator, \n        address _hfil, \n        address _mfil, \n        address _mdexFactory \n    ) Ownable() { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        hfil = _hfil; \n        mfil = _mfil; \n        mdexFactory = _mdexFactory; \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function IDOlistCount() external view returns (uint256) { \n        return IDOlist.length; \n    } \n \n    function userIDOsCount(address user) external view returns (uint256) { \n        return userIDOs[user].length; \n    } \n \n    function _addLiquidity( \n        address pair, \n        address idoToken, \n        uint256 idoAmount, \n        uint256 mfilAmount \n    ) internal { \n        IERC20(idoToken).transfer(pair, idoAmount); \n        TransferHelper.safeTransferFrom(mfil, _msgSender(), pair, mfilAmount); \n        IMdexPair(pair).mint(address(0)); \n    } \n \n \n    function newIDO( \n        string calldata _name, \n        string calldata _node, \n        address _hfilRecipient, \n        uint256 _cap, \n        uint256 _gasPrice, \n        uint256 _sealPrice, \n        uint256 _hardDrivePrice, \n        uint256 _dailySaleCap, \n        uint256 _idoStartTime, \n        uint256 _idoEndTime \n    ) external returns (address idoAddress) { \n        require( \n            _dailySaleCap >= 1e6, \n            \"IDOFactory: dailysalecap should more than 1\" \n        ); \n        IDOToken ido = new IDOToken( \n            _name, \n            _node, \n            hfil, \n            _hfilRecipient, \n            _cap, \n            _dailySaleCap \n        ); \n        ido.setPrice(_gasPrice, _sealPrice, _hardDrivePrice); \n        ido.setTimes(_idoStartTime, _idoEndTime); \n        IDOlist.push(address(ido)); \n        userIDOs[_msgSender()].push(address(ido)); \n        address pair = IMdexFactory(mdexFactory).createPair(mfil, address(ido)); \n        uint256 totalPrice = _gasPrice.add(_sealPrice).add(_hardDrivePrice).div(100); \n        _addLiquidity(pair, address(ido), 1e4, totalPrice); \n        emit NewIDO(_msgSender(), address(ido)); \n        isIDO[address(ido)] = true; \n        return address(ido); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \n \ncontract PriceCheckerLPToken is OwnableUpgradeable, IPriceChecker { \n    using SafeMathUpgradeable for uint256; \n    using SignedSafeMathUpgradeable for int256; \n \n    mapping(address => uint256) public priceSlippage; \n    ITokenOracle public tokenOracle; \n    uint256 public largeSlipRate; \n \n    event SetPriceSlippage(address _lptoken, uint256 _oldv, uint256 _newv); \n    event SetLargeSlipRate(uint256 _oldv, uint256 _newv); \n    event SetTokenOracle(address _oldv, address _newv); \n \n    constructor() public { \n    } \n \n    function initialize(address _tokenOracle) public initializer { \n        __Ownable_init(); \n        largeSlipRate = 4e9; \n        setTokenOracle(_tokenOracle); \n    } \n \n    function setLargeSlipRate(uint256 _largeSlipRate) external onlyOwner { \n        require(_largeSlipRate >= 1e9, 'value error'); \n        emit SetLargeSlipRate(largeSlipRate, _largeSlipRate); \n        largeSlipRate = _largeSlipRate; \n    } \n \n    function setPriceSlippage(address _lptoken, uint256 _slippage) external onlyOwner { \n        require(_slippage >= 0 && _slippage <= 1e9, 'value error'); \n        emit SetPriceSlippage(_lptoken, priceSlippage[_lptoken], _slippage); \n        priceSlippage[_lptoken] = _slippage; \n    } \n \n    function setTokenOracle(address _tokenOracle) public onlyOwner { \n        emit SetTokenOracle(address(tokenOracle), _tokenOracle); \n        tokenOracle = ITokenOracle(_tokenOracle); \nActionCompPools::TransparentUpgradeableProxy.sol\n    } \n \n    function getPriceSlippage(address _lptoken) public override view returns (uint256) { \n        if(priceSlippage[_lptoken] > 0) { \n            return priceSlippage[_lptoken]; \n        } \n        return uint256(1e7); \n    } \n \n    function getLPTokenPriceInMdex(address _lptoken, address _t0, address _t1) public view returns (u\n        IUniswapV2Pair pair = IUniswapV2Pair(_lptoken); \n        (uint256 r0, uint256 r1, ) = pair.getReserves(); \n        uint256 d0 = ERC20Upgradeable(_t0).decimals(); \n        uint256 d1 = ERC20Upgradeable(_t1).decimals(); \n        if(d0 != 18) { \n            r0 = r0.mul(1e18).div(10**d0); \n        } \n        if(d1 != 18) { \n            r1 = r1.mul(1e18).div(10**d1); \n        } \n        return r0.mul(1e18).div(r1); \n    } \n \n \n    function getLPTokenPriceInOracle(address _t0, address _t1) public view returns (uint256) { \n        int256 price0 = tokenOracle.getPrice(_t0); \n        int256 price1 = tokenOracle.getPrice(_t1); \n        if(price0 <= 0 || price1 <= 0) { \n            return 0; \n        } \n        int256 priceInOracle = price1.mul(1e18).div(price0); \n        if(priceInOracle <= 0) { \n            return 0; \n        } \n        return uint256(priceInOracle); \n    } \n \n    function checkLPTokenPriceLimit(address _lptoken, bool _largeType) external override view returns\n        IUniswapV2Pair pair = IUniswapV2Pair(_lptoken); \n        address t0 = pair.token0(); \n        address t1 = pair.token1(); \n        uint256 price0 = getLPTokenPriceInMdex(_lptoken, t0, t1); \n        uint256 price1 = getLPTokenPriceInOracle(t0, t1); \n        if(price0 == 0 || price1 == 0) { \n            return false; \n        } \n        uint256 slip = getPriceSlippage(_lptoken); \n        uint256 priceRate = price0.mul(1e9).div(price1); \n        if(_largeType) { \n            slip = slip.mul(largeSlipRate).div(1e9); \n        } \n        if(priceRate >= uint256(1e9).add(slip) || priceRate <= uint256(1e9).sub(slip)) { \n            return false; \n        } \n        return true; \n    } \n}\n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {LendingPool} from '../protocol/lendingpool/LendingPool.sol'; \nimport { \n  LendingPoolAddressesProvider \n} from '../protocol/configuration/LendingPoolAddressesProvider.sol'; \nimport {LendingPoolConfigurator} from '../protocol/lendingpool/LendingPoolConfigurator.sol'; \nimport {AToken} from '../protocol/tokenization/AToken.sol'; \nimport { \n  DefaultReserveInterestRateStrategy \n} from '../protocol/lendingpool/DefaultReserveInterestRateStrategy.sol'; \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {StringLib} from './StringLib.sol'; \n \ncontract ATokensAndRatesHelper is Ownable { \n  address payable private pool; \n  address private addressesProvider; \n  address private poolConfigurator; \n  event deployedContracts(address aToken, address strategy); \n \n  struct InitDeploymentInput { \n    address asset; \n    uint256[6] rates; \n  } \n \n  struct ConfigureReserveInput { \n    address asset; \n    uint256 baseLTV; \n    uint256 liquidationThreshold; \n    uint256 liquidationBonus; \n    uint256 reserveFactor; \n    bool stableBorrowingEnabled; \n  } \n \n  constructor( \n    address payable _pool, \n    address _addressesProvider, \n    address _poolConfigurator \n  ) public { \n    pool = _pool; \n    addressesProvider = _addressesProvider; \n    poolConfigurator = _poolConfigurator; \n  } \n \n  function initDeployment(InitDeploymentInput[] calldata inputParams) external onlyOwner { \n    for (uint256 i = 0; i < inputParams.length; i++) { \n      emit deployedContracts( \n        address(new AToken()), \n        address( \n          new DefaultReserveInterestRateStrategy( \n            LendingPoolAddressesProvider(addressesProvider), \n            inputParams[i].rates[0], \n            inputParams[i].rates[1], \n            inputParams[i].rates[2], \n            inputParams[i].rates[3], \n            inputParams[i].rates[4], \n            inputParams[i].rates[5] \n          ) \n        ) \n      ); \n    } \n  } \n \n  function configureReserves(ConfigureReserveInput[] calldata inputParams) external onlyOwner { \n    LendingPoolConfigurator configurator = LendingPoolConfigurator(poolConfigurator); \n    for (uint256 i = 0; i < inputParams.length; i++) { \n      configurator.configureReserveAsCollateral( \n        inputParams[i].asset, \n        inputParams[i].baseLTV, \n        inputParams[i].liquidationThreshold, \n        inputParams[i].liquidationBonus \n      ); \n \n      configurator.enableBorrowingOnReserve( \n        inputParams[i].asset, \n        inputParams[i].stableBorrowingEnabled \n      ); \n      configurator.setReserveFactor(inputParams[i].asset, inputParams[i].reserveFactor); \n    } \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \ncontract DFOXToken is ERC20Capped, Ownable, IRewardsToken { \n    constructor ( \n            string memory _name, \n            string memory _symbol, \n            uint256 _totalSupply \n        ) public ERC20Capped(_totalSupply) ERC20(_name, _symbol) { \n    } \n \n    mapping(address => bool) public mintWhitelist; \n \n    function setMintWhitelist(address _account, bool _enabled) external override onlyOwner { \n        mintWhitelist[_account] = _enabled; \n    } \n \n    function checkWhitelist(address _account) external override view returns (bool) { \n        return mintWhitelist[_account]; \n    } \n \n    function mint(address _account, uint256 _amount) external override { \n        require(mintWhitelist[msg.sender], 'not allow'); \n        _mint(_account, _amount); \n    } \n \n    function burn(uint256 _amount) external override onlyOwner { \n        _burn(msg.sender, _amount); \n    } \n} \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n/** \n* @dev Interface for the  optional metadata functions from the\n* \n* _Available since v4.1._ \n  */  \n  interface IERC20Metadata is IERC20 { \n  /** \n    * @dev Returns the  name of the  token. \n      */  \n      function name() external view returns (string memory); \n \n  /** \n    * @dev Returns the  symbol of the  token. \n      */  \n      function symbol() external view returns (string memory); \n \n  /** \n    * @dev Returns the  decimals places of the  token. \n      */  \n      function decimals() external view returns (uint8); \n      } \n \n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (token/ERC20/ERC20.sol) \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \nimport \"./Pausable.sol\"; \nimport \"./ReentrancyGuard.sol\"; \nimport \"./StakeRewardPerDay.sol\"; \n \ncontract StakeTokenPool is StakeRewardPerDay, Ownable, Pausable { \n \n    using SafeMath for uint256; \n \n    uint256 public BrewardRate; // Global Reward per Unit \n    uint256 public BrewardPreBlock; \n    uint256 public BlastUpdateBlock; // last adjust block height \n \n    mapping(address => uint256) public BuserReward; \n    mapping(address => uint256) public BuserRate; \n \n    constructor() StakeRewardPerDay() { \n        BrewardRate = 0; \n        BrewardPreBlock = 0; \n        BlastUpdateBlock = block.number; \n    } \n \n    modifier BupdateRate() { \n        if ( \n            BrewardPreBlock > 0 && \n            totalStake > 0 && \n            block.number > BlastUpdateBlock \n        ) { \n            uint256 deltaRate = \n                BrewardPreBlock.mul(block.number - BlastUpdateBlock).div( \n                    totalStake \n                ); \n            BrewardRate = BrewardRate.add(deltaRate); \n        } \n        BlastUpdateBlock = block.number; \n        _; \n    } \n \n    modifier BgetReward() { \n        if ( \n            userStake[_msgSender()] > 0 && BrewardRate > BuserRate[_msgSender()] \n        ) { \n            uint256 deltaReward = \n                BrewardRate.sub(BuserRate[_msgSender()]).mul( \n                    userStake[_msgSender()] \n                ); \n            BuserReward[_msgSender()] = BuserReward[_msgSender()].add( \n                deltaReward \n            ); \n        } \n        BuserRate[_msgSender()] = BrewardRate; \n        _; \n    } \n \n    function _setReward(uint256 amount) internal BupdateRate { \n        BrewardPreBlock = amount.mul(1e18); \n    } \n \n    function _stake(uint256 amount) internal override updateRate getReward BupdateRate BgetReward { \n        userStake[_msgSender()] = userStake[_msgSender()].add(amount); \n        totalStake = totalStake.add(amount); \n    } \n \n    function _BhalveNoUpdate() internal returns (uint256 reward) { \n        reward = BuserReward[_msgSender()].div(1e18); \n        BuserReward[_msgSender()] = 0; \n    } \n \n    function _Bhalve() internal BupdateRate BgetReward returns (uint256 reward) { \n        return _BhalveNoUpdate(); \n    } \n \n    function _unStakeAll() \n        internal \n        updateRate  \n        getReward \n        BupdateRate \n        BgetReward \n        returns (uint256 stake, uint256 reward, uint256 rewardB) \n    { \n        stake = userStake[_msgSender()]; \n        totalStake = totalStake.sub(stake); \n        userStake[_msgSender()] = 0; \n        reward = _halveNoUpdate(); \n        rewardB = _BhalveNoUpdate(); \n    } \n \n    function _BcaleReward() internal view returns (uint256 reward) { \n        if (userStake[_msgSender()] == 0) { \n            return 0; \n        } \n        uint256 tempRate = BrewardRate; \n        if ( \n            BrewardPreBlock > 0 && \n            totalStake > 0 && \n            block.number > BlastUpdateBlock \n        ) { \n            uint256 deltaRate = \n                BrewardPreBlock.mul(block.number - BlastUpdateBlock).div( \n                    totalStake \n                ); \n            tempRate = tempRate.add(deltaRate); \n        } \n        reward = BuserReward[_msgSender()]; \n        if (tempRate > BuserRate[_msgSender()]) { \n            uint256 deltaReward = \n                tempRate.sub(BuserRate[_msgSender()]).mul( \n                    userStake[_msgSender()] \n                ); \n            reward = reward.add(deltaReward); \n        } \n        reward = reward.div(1e18); \n    } \n \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.7.0; \n \ninterface IAggregatorV3Interface { \n \n  function decimals() \n    external \n    view \n    returns ( \n      uint8 \n    ); \n \n  function description() \n    external \n    view \n    returns ( \n      string memory \n    ); \n \n  function version() \n    external \n    view \n    returns ( \n      uint256 \n    ); \n \n  // getRoundData and latestRoundData should both raise \"No data present\" \n  // if they do not have data to report, instead of returning unset values \n  // which could be misinterpreted as actual reported values. \n  function getRoundData( \n    uint80 _roundId \n  ) \n    external \n    view \n    returns ( \n      uint80 roundId, \n      int256 answer, \n      uint256 startedAt, \n      uint256 updatedAt, \n      uint80 answeredInRound \n    ); \n \n  function latestRoundData() \n    external \n    view \n    returns ( \n      uint80 roundId, \n      int256 answer, \n      uint256 startedAt, \n      uint256 updatedAt, \n      uint80 answeredInRound \n    ); \n \n} \n \n// File: contracts/Oracle/Oracle.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n/** \n * @dev Implementation of the  {IERC165} interface. \n * \n * Contracts that want to implement ERC165 should  inherit from this contract and overri\n * for the  additional interface id that will  be supported. For\n * \n * solidity \n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { \n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); \n * } \n *  \n* \n* Alternatively, {ERC165Storage} provides an  easier to use but\n  */  \n  abstract contract ERC165 is IERC165 { \n  /** \n    * @dev See {IERC165-supportsInterface}. \n      */  \n      function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { \n      return interfaceId == type(IERC165).interfaceId; \n      } \n      } \n \n// File: @openzeppelin/contracts/utils/Strings.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol) \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ISafeBox { \n \n    function bank() external view returns(address); \n \n    function token() external view returns(address); \n \n    function getSource() external view returns (string memory); \n \n    function supplyRatePerBlock() external view returns (uint256); \n    function borrowRatePerBlock() external view returns (uint256); \n \n    function getBorrowInfo(uint256 _bid) external view \n            returns (address owner, uint256 amount, address strategy, uint256 pid); \n    function getBorrowId(address _strategy, uint256 _pid, address _account) external view returns (ui\n    function getBorrowId(address _strategy, uint256 _pid, address _account, bool _add) external retur\n    function getDepositTotal() external view returns (uint256); \n    function getBorrowTotal() external view returns (uint256); \n    // function getBorrowAmount(address _account) external view returns (uint256 value); \n    function getBaseTokenPerLPToken() external view returns (uint256); \n \n    function deposit(uint256 _value) external; \n    function withdraw(uint256 _value) external; \n \n    function emergencyWithdraw() external; \n    function emergencyRepay(uint256 _bid) external; \n \n    function borrowInfoLength() external view returns (uint256); \n \n    function borrow(uint256 _bid, uint256 _value, address _to) external; \n    function repay(uint256 _bid, uint256 _value) external; \n    function claim(uint256 _tTokenAmount) external; \n \n    function update() external; \n    function mintDonate(uint256 _value) external; \n \n    function pendingSupplyAmount(address _account) external view returns (uint256 value); \n    function pendingBorrowAmount(uint256 _bid) external view returns (uint256 value); \n    function pendingBorrowRewards(uint256 _bid) external view returns (uint256 value); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ncontract SelfdestructTransfer { \n  function destroyAndTransfer(address payable to) external payable { \n    selfdestruct(to); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \nimport {IDelegationToken} from '../../interfaces/IDelegationToken.sol'; \nimport {Errors} from '../libraries/helpers/Errors.sol'; \nimport {AToken} from './AToken.sol'; \n \n/** \n * @title Aave AToken enabled to delegate voting power of the underlying asset to a different address\n * @dev The underlying asset needs to be compatible with the COMP delegation interface \n * @author Aave \n */ \ncontract DelegationAwareAToken is AToken { \n  modifier onlyPoolAdmin { \n    require( \n      _msgSender() == ILendingPool(_pool).getAddressesProvider().getPoolAdmin(), \n      Errors.CALLER_NOT_POOL_ADMIN \n    ); \n    _; \n  } \n \n  /** \n   * @dev Delegates voting power of the underlying asset to a `delegatee` address \n   * @param delegatee The address that will receive the delegation \n   **/ \n  function delegateUnderlyingTo(address delegatee) external onlyPoolAdmin { \n    IDelegationToken(_underlyingAsset).delegate(delegatee); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IExtendedPriceAggregator { \n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp); \n \n  function getToken() external view returns (address); \n \n  function getTokenType() external view returns (uint256); \n \n  function getPlatformId() external view returns (uint256); \n \n  function getSubTokens() external view returns (address[] memory); \n \n  function latestAnswer() external view returns (int256); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \npragma experimental ABIEncoderV2; \n \n/// @title Multicall - Aggregate results from multiple read-only function calls \n \ninterface IERC20 { \n    function balanceOf(address user) external view returns (uint256); \n} \n \ncontract Multicall { \n    address public metis = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000; \n    struct Call { \n        address target; \n        bytes callData; \n    } \n    function aggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes[] memory retur\n        blockNumber = block.number; \n        returnData = new bytes[](calls.length); \n        for(uint256 i = 0; i < calls.length; i++) { \n            (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData); \n            require(success); \n            returnData[i] = ret; \n        } \n    } \n    // Helper functions \n    function getMetisBalance(address addr) public view returns(uint256 balance) { \n        balance = IERC20(metis).balanceOf(addr); \n    } \n    function getCurrentBlockTimestamp() public view returns (uint256 timestamp) { \n        timestamp = block.timestamp; \n    } \n}\nNetswapFactory.sol\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IActionTrigger { \n    function getATPoolInfo(uint256 _pid) external view \n        returns (address lpToken, uint256 allocRate, uint256 totalAmount); \n    function getATUserAmount(uint256 _pid, address _account) external view \n        returns (uint256 acctAmount); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IFidoUsdtLPPool { \n  function BlastUpdateBlock() view external returns (uint256); \n \n  function BrewardPreBlock() view external returns (uint256); \n \n  function BrewardRate() view external returns (uint256); \n \n  function BuserRate(address) view external returns (uint256); \n \n  function BuserReward(address) view external returns (uint256); \n \n  function adjustReward(uint256 amount) external; \n \n  function caleLiquidity(uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 \n \n  function caleReward() view external returns (uint256 reward); \n \n  function factory() view external returns (address); \n \n  function fido() view external returns (address); \n \n  function getStake() view external returns (uint256 amount); \n \n  function halve() external returns (uint256 reward); \n \n  function operator() view external returns (address); \n \n  function owner() view external returns (address); \n \n  function pairFor(address tokenA, address tokenB) view external returns (address pair); \n \n  function pause() external; \n \n  function paused() view external returns (bool); \n \n  function renounceOwnership() external; \n \n  function rewardToken() view external returns (address); \n \n  function stake(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amo\n \n  function stakeRate() view external returns (uint8); \n \n  function tokenA() view external returns (address); \n \n  function tokenB() view external returns (address); \n \n  function totalStake() view external returns (uint256); \n \n  function totalTokenBStake() view external returns (uint256); \n \n  function transferOperatorship(address newOperator) external; \n \n  function transferOwnership(address newOwner) external; \n \n  function unPause() external; \n \n  function unStake() external returns (uint256 reward, uint256 amountA, uint256 amountB, uint256 liqu\n \n  function usdt() view external returns (address); \n \n  function userStake(address) view external returns (uint256); \n \n  function userTokenBStake(address) view external returns (uint256); \n \n  event NewReward(uint256 blockHeight, uint256 amount); \n \n  event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator); \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n  event Paused(address account); \n \n  event Reward(address indexed receiver, uint256 reward); \n \n  event Stake(address indexed sender, uint256 amountA, uint256 amountB, uint256 liquidity); \n \n  event UnStake(address indexed receiver, uint256 amountA, uint256 amountB, uint256 liquidity); \n \n  event Unpaused(address account); \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \n \n \n// Distribution of BOO Compound token \ncontract SafeBoxFox is SafeBoxFoxCToken { \n    using SafeMathUpgradeable for uint256; \n    using SafeERC20Upgradeable for IERC20Upgradeable; \n \n    IERC20Upgradeable public REWARDS_TOKEN; \n \n    uint256 public lastRewardsTokenBlock;        // rewards update \n \n    address public actionPoolRewards;            // address for action pool \n    uint256 public poolDepositId;               // poolid of depositor s token rewards in action pool\n    uint256 public poolBorrowId;                // poolid of borrower s token rewards in action pool \n \n    uint256 public REWARDS_DEPOSIT_CALLID;      // depositinfo callid for action callback \n    uint256 public REWARDS_BORROW_CALLID;       // borrowinfo callid for comp action callback \n \n    event SetRewardsDepositPool(address _actionPoolRewards, uint256 _piddeposit); \n    event SetRewardsBorrowPool(address _compActionPool, uint256 _pidborrow); \n \n    function initialize(address _bank, address _cToken, address _devAddr) public initializer { \n        __Ownable_init(); \n \n        __SafeBoxFoxCToken_init(_bank, _cToken, _devAddr); \n \n        REWARDS_TOKEN = IERC20Upgradeable(0); \n        REWARDS_DEPOSIT_CALLID = 16; \n        REWARDS_BORROW_CALLID = 18; \n    } \n \n    function update() public virtual override { \n        _update(); \n        updatetoken(); \n    } \n \n    // mint rewards for supplies to action pools \n    function setRewardsDepositPool(address _actionPoolRewards, uint256 _piddeposit) public onlyOwner \n        actionPoolRewards = _actionPoolRewards; \n        poolDepositId = _piddeposit; \n        emit SetRewardsDepositPool(_actionPoolRewards, _piddeposit); \n    } \n \n    // mint rewards for borrows to comp action pools \n    function setRewardsBorrowPool(uint256 _pidborrow) public onlyOwner { \n        _checkActionPool(compActionPool, _pidborrow, REWARDS_BORROW_CALLID); \n        poolBorrowId = _pidborrow; \n        emit SetRewardsBorrowPool(compActionPool, _pidborrow); \n    } \n \n    function _checkActionPool(address _actionPool, uint256 _pid, uint256 _rewardscallid) internal vie\n        (address callFrom, uint256 callId, address rewardToken) \n            = IActionPools(_actionPool).getPoolInfo(_pid); \n        require(callFrom == address(this), 'call from error'); \n        require(callId == _rewardscallid, 'callid error'); \n    } \n \n    function deposit(uint256 _value) external virtual override nonReentrant { \n        update(); \n        IERC20Upgradeable(token).safeTransferFrom(msg.sender, address(this), _value); \n        _deposit(msg.sender, _value); \n    } \n \n    function withdraw(uint256 _tTokenAmount) external virtual override nonReentrant { \n        update(); \n        _withdraw(msg.sender, _tTokenAmount); \n    } \n \n    function borrow(uint256 _bid, uint256 _value, address _to) external virtual override onlyBank { \n        update(); \n        address owner = borrowInfo[_bid].owner; \nTimelock.sol\n        uint256 accountBorrowPointsOld = accountBorrowPoints[owner]; \n        _borrow(_bid, _value, _to); \n \n        if(compActionPool != address(0) && _value > 0) { \n            IActionPools(compActionPool).onAcionIn(REWARDS_BORROW_CALLID, owner, \n                    accountBorrowPointsOld, accountBorrowPoints[owner]); \n        } \n    } \n \n    function repay(uint256 _bid, uint256 _value) external virtual override { \n        update(); \n        address owner = borrowInfo[_bid].owner; \n        uint256 accountBorrowPointsOld = accountBorrowPoints[owner]; \n        _repay(_bid, _value); \n \n        if(compActionPool != address(0) && _value > 0) { \n            IActionPools(compActionPool).onAcionOut(REWARDS_BORROW_CALLID, owner, \n                    accountBorrowPointsOld, accountBorrowPoints[owner]); \n        } \n    } \n \n    function updatetoken() public { \n        if(lastRewardsTokenBlock == block.number) { \n            return ; \n        } \n        lastRewardsTokenBlock = block.number; \n    } \n \n    function claim(uint256 _value) external virtual override nonReentrant { \n        update(); \n        _claim(msg.sender, _value); \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format)\n \n// range: [0, 2**112 - 1] \n// resolution: 1 / 2**112 \n \nlibrary UQ112x112 { \n    uint224 constant Q112 = 2**112; \n \n    // encode a uint112 as a UQ112x112 \n    function encode(uint112 y) internal pure returns (uint224 z) { \n        z = uint224(y) * Q112; // never overflows \n    } \n \n    // divide a UQ112x112 by a uint112, returning a UQ112x112 \n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { \n        z = x / uint224(y); \n    } \n} \n \n \n// File contracts/core/LfgSwapPair.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @title IERC1363Receiver Interface \n * @dev Interface for any contract that wants to support transferAndCall or transferFromAndCall \n *  from ERC1363 token contracts as defined in \n *  https://eips.ethereum.org/EIPS/eip-1363 \n */  \ninterface IERC1363Receiver { \n    /** \n     * @notice Handle the  receipt of ERC1363 tokens \n     * @dev Any ERC1363 smart contract calls this function on the  recipient \n     * after a  `transfer` or a  `transferFrom`. This function MAY\n     * transfer. Return of other than the  magic value MUST result in the\n     * transaction being reverted. \n     * Note: the  token contract address is always the  messa\n     * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function \n     * @param sender address The address which are  token transferred from \n     * @param amount uint256 The amount of tokens transferred \n     * @param data bytes Additional data with no specified format \n     * @return `bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))` unless throwing \n     */  \n    function onTransferReceived( \n        address operator, \n        address sender, \n        uint256 amount, \n        bytes calldata data \n    ) external returns (bytes4); \n} \n \n// File: erc-payable-token/contracts/token/ERC1363/IERC1363Spender.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IWETHGateway { \n  function depositETH( \n    address lendingPool, \n    address onBehalfOf, \n    uint16 referralCode \n  ) external payable; \n \n  function withdrawETH( \n    address lendingPool, \n    uint256 amount, \n    address onBehalfOf \n  ) external; \n \n  function repayETH( \n    address lendingPool, \n    uint256 amount, \n    uint256 rateMode, \n    address onBehalfOf \n  ) external payable; \n \n  function borrowETH( \n    address lendingPool, \n    uint256 amount, \n    uint256 interesRateMode, \n    uint16 referralCode \n  ) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0; \n \n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return t\nlibrary TransferHelper { \n    function safeApprove(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('approve(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_F\n    } \n \n    function safeTransfer(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transfer(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferFrom(address token, address from, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, v\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferETH(address to, uint value) internal { \n        (bool success,) = to.call{value:value}(new bytes(0)); \n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED'); \n    } \n} \n \n \n// File contracts/interface/ILfgSwapRouter.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12;\n  interface GenericOracleI {\n    // ganache\n    event AssetPriceUpdated(address _asset, uint256 _price, uint256 timestamp);\n    event EthPriceUpdated(uint256 _price, uint256 timestamp);\n    // kovan\n    event ProphecySubmitted(\n    address indexed _sybil,\n    address indexed _asset,\n    uint96 _sybilProphecy,\n    uint96 _oracleProphecy\n  );\n  function getAssetPrice(address _asset) external view returns (uint256);\n  function getEthUsdPrice() external view returns (uint256);\n}\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.6.0; \n \ncontract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the  contract setting the  deployer as \n     */  \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the  address of the  current owner. \n     */  \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the  owner. \n     */  \n    modifier onlyOwner() { \n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the  contract without owner. It will  not b\n     * `onlyOwner` functions anymore. Can only be called by the  current owner. \n     * \n     * NOTE:  Renouncing ownership will  leave \n     * thereby removing any functionality that is only available to the  owner. \n     */  \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the  contract to a  new ac\n     * Can only be called by the  current owner. \n     */  \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface IUniswapV2Factory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeToSetter() external view returns (address); \n    function migrator() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeToSetter(address) external; \n    function setMigrator(address) external; \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IUniswapV2Router02 { \n  function swapExactTokensForTokens( \n    uint256 amountIn, \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external returns (uint256[] memory amounts); \n \n  function swapTokensForExactTokens( \n    uint256 amountOut, \n    uint256 amountInMax, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external returns (uint256[] memory amounts); \n \n  function getAmountsOut(uint256 amountIn, address[] calldata path) \n    external \n    view \n    returns (uint256[] memory amounts); \n \n  function getAmountsIn(uint256 amountOut, address[] calldata path) \n    external \n    view \n    returns (uint256[] memory amounts); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport '../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol'; \n \n/** \n * @title BaseImmutableAdminUpgradeabilityProxy \n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern \n * @dev This contract combines an upgradeability proxy with an authorization \n * mechanism for administrative tasks. The admin role is stored in an immutable, which \n * helps saving transactions costs \n * All external functions in this contract must be guarded by the \n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity \n * feature proposal that would enable this to be done automatically. \n */ \ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy { \n  address immutable ADMIN; \n \n  constructor(address admin) public { \n    ADMIN = admin; \n  } \n \n  modifier ifAdmin() { \n    if (msg.sender == ADMIN) { \n      _; \n    } else { \n      _fallback(); \n    } \n  } \n \n  /** \n   * @return The address of the proxy admin. \n   */ \n  function admin() external ifAdmin returns (address) { \n    return ADMIN; \n  } \n \n  /** \n   * @return The address of the implementation. \n   */ \n  function implementation() external ifAdmin returns (address) { \n    return _implementation(); \n  } \n \n  /** \n   * @dev Upgrade the backing implementation of the proxy. \n   * Only the admin can call this function. \n   * @param newImplementation Address of the new implementation. \n   */ \n  function upgradeTo(address newImplementation) external ifAdmin { \n    _upgradeTo(newImplementation); \n  } \n \n  /** \n   * @dev Upgrade the backing implementation of the proxy and call a function \n   * on the new implementation. \n   * This is useful to initialize the proxied contract. \n   * @param newImplementation Address of the new implementation. \n   * @param data Data to send as msg.data in the low level call. \n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n   */ \n  function upgradeToAndCall(address newImplementation, bytes calldata data) \n    external \n    payable \n    ifAdmin \n  { \n    _upgradeTo(newImplementation); \n    (bool success, ) = newImplementation.delegatecall(data); \n    require(success); \n  } \n \n  /** \n   * @dev Only fall back when the sender is not the admin. \n   */ \n  function _willFallback() internal virtual override { \n    require(msg.sender != ADMIN, 'Cannot call fallback function from the proxy admin'); \n    super._willFallback(); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ILendingPool} from '../../../interfaces/ILendingPool.sol'; \nimport {ICreditDelegationToken} from '../../../interfaces/ICreditDelegationToken.sol'; \nimport { \n  VersionedInitializable \n} from '../../libraries/aave-upgradeability/VersionedInitializable.sol'; \nimport {IncentivizedERC20} from '../IncentivizedERC20.sol'; \nimport {Errors} from '../../libraries/helpers/Errors.sol'; \n \n/** \n * @title DebtTokenBase \n * @notice Base contract for different types of debt tokens, like StableDebtToken or VariableDebtToke\n * @author Aave \n */ \n \nabstract contract DebtTokenBase is \n  IncentivizedERC20('DEBTTOKEN_IMPL', 'DEBTTOKEN_IMPL', 0), \n  VersionedInitializable, \n  ICreditDelegationToken \n{ \n  mapping(address => mapping(address => uint256)) internal _borrowAllowances; \n \n  /** \n   * @dev Only lending pool can call functions marked by this modifier \n   **/ \n  modifier onlyLendingPool { \n    require(_msgSender() == address(_getLendingPool()), Errors.CT_CALLER_MUST_BE_LENDING_POOL); \n    _; \n  } \n \n  /** \n   * @dev delegates borrowing power to a user on the specific debt token \n   * @param delegatee the address receiving the delegated borrowing power \n   * @param amount the maximum amount being delegated. Delegation will still \n   * respect the liquidation constraints (even if delegated, a delegatee cannot \n   * force a delegator HF to go below 1) \n   **/ \n  function approveDelegation(address delegatee, uint256 amount) external override { \n    _borrowAllowances[_msgSender()][delegatee] = amount; \n    emit BorrowAllowanceDelegated(_msgSender(), delegatee, _getUnderlyingAssetAddress(), amount); \n  } \n \n  /** \n   * @dev returns the borrow allowance of the user \n   * @param fromUser The user to giving allowance \n   * @param toUser The user to give allowance to \n   * @return the current allowance of toUser \n   **/ \n  function borrowAllowance(address fromUser, address toUser) \n    external \n    view \n    override \n    returns (uint256) \n  { \n    return _borrowAllowances[fromUser][toUser]; \n  } \n \n  /** \n   * @dev Being non transferrable, the debt token does not implement any of the \n   * standard ERC20 functions for transfer and allowance. \n   **/ \n  function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n    recipient; \n    amount; \n    revert('TRANSFER_NOT_SUPPORTED'); \n  } \n \n  function allowance(address owner, address spender) \n    public \n    view \n    virtual \n    override \n    returns (uint256) \n  { \n    owner; \n    spender; \n    revert('ALLOWANCE_NOT_SUPPORTED'); \n  } \n \n  function approve(address spender, uint256 amount) public virtual override returns (bool) { \n    spender; \n    amount; \n    revert('APPROVAL_NOT_SUPPORTED'); \n  } \n \n  function transferFrom( \n    address sender, \n    address recipient, \n    uint256 amount \n  ) public virtual override returns (bool) { \n    sender; \n    recipient; \n    amount; \n    revert('TRANSFER_NOT_SUPPORTED'); \n  } \n \n  function increaseAllowance(address spender, uint256 addedValue) \n    public \n    virtual \n    override \n    returns (bool) \n  { \n    spender; \n    addedValue; \n    revert('ALLOWANCE_NOT_SUPPORTED'); \n  } \n \n  function decreaseAllowance(address spender, uint256 subtractedValue) \n    public \n    virtual \n    override \n    returns (bool) \n  { \n    spender; \n    subtractedValue; \n    revert('ALLOWANCE_NOT_SUPPORTED'); \n  } \n \n  function _decreaseBorrowAllowance( \n    address delegator, \n    address delegatee, \n    uint256 amount \n  ) internal { \n    uint256 newAllowance = \n      _borrowAllowances[delegator][delegatee].sub(amount, Errors.BORROW_ALLOWANCE_NOT_ENOUGH); \n \n    _borrowAllowances[delegator][delegatee] = newAllowance; \n \n    emit BorrowAllowanceDelegated(delegator, delegatee, _getUnderlyingAssetAddress(), newAllowance); \n  } \n \n  function _getUnderlyingAssetAddress() internal view virtual returns (address); \n \n  function _getLendingPool() internal view virtual returns (ILendingPool); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n}\nERC20.sol\n// FECtoken project \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \nlibrary TenMath { \n  using SafeMathUpgradeable for uint256; \n \n  function min(uint256 v1, uint256 v2) public pure returns (uint256 vr) { \n    vr = v1 > v2 ? v2 : v1; \n  } \n \n  function safeSub(uint256 v1, uint256 v2) internal pure returns (uint256 vr) { \n    vr = v1 > v2 ? v1.sub(v2) : 0; \n  } \n \n  // implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c52\n  // original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/\n  function sqrt(uint256 x) internal pure returns (uint256) { \n    if (x == 0) return 0; \n    uint256 xx = x; \n    uint256 r = 1; \n \n    if (xx >= 0x100000000000000000000000000000000) { \n      xx >>= 128; \n      r <<= 64; \n    } \n \n    if (xx >= 0x10000000000000000) { \n      xx >>= 64; \n      r <<= 32; \n    } \n    if (xx >= 0x100000000) { \n      xx >>= 32; \n      r <<= 16; \n    } \n    if (xx >= 0x10000) { \n      xx >>= 16; \n      r <<= 8; \n    } \n    if (xx >= 0x100) { \n      xx >>= 8; \n      r <<= 4; \n    } \n    if (xx >= 0x10) { \n      xx >>= 4; \n      r <<= 2; \n    } \n    if (xx >= 0x8) { \n      r <<= 1; \n    } \n \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; // Seven iterations should be enough \n    uint256 r1 = x / r; \n    return (r < r1 ? r : r1); \n  } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n \ncontract LfgSwapFactory is ILfgSwapFactory { \n    address public override feeTo; \n    address public override feeToSetter; \n    bytes32 public initCodeHash; \n \n    mapping(address => mapping(address => address)) public override getPair; \n    address[] public override allPairs; \n \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    constructor(address _feeToSetter) public { \n        feeToSetter = _feeToSetter; \n        initCodeHash = keccak256(abi.encodePacked(type(LfgSwapPair).creationCode)); \n    } \n \n    function allPairsLength() external override view returns (uint) { \n        return allPairs.length; \n    } \n \nLfgSwapRouter.sol\n    function pairCodeHash() external pure returns (bytes32) { \n        return keccak256(type(LfgSwapPair).creationCode); \n    } \n \n    // returns sorted token addresses, used to handle return values from pairs sorted in this order \n    function sortTokens(address tokenA, address tokenB) public override pure returns (address token0, \n        require(tokenA != tokenB, 'LfgSwapFactory: IDENTICAL_ADDRESSES'); \n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n        require(token0 != address(0), 'LfgSwapFactory: ZERO_ADDRESS'); \n    } \n \n    // calculates the CREATE2 address for a pair without making any external calls \n    function pairFor(address tokenA, address tokenB) public override view returns (address pair) { \n        (address token0, address token1) = sortTokens(tokenA, tokenB); \n        pair = address(uint(keccak256(abi.encodePacked( \n                hex'ff', \n                address(this), \n                keccak256(abi.encodePacked(token0, token1)), \n                initCodeHash \n            )))); \n    } \n \n    function createPair(address tokenA, address tokenB) external override returns (address pair) { \n        require(tokenA != tokenB, 'LfgSwap: IDENTICAL_ADDRESSES'); \n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n        require(token0 != address(0), 'LfgSwap: ZERO_ADDRESS'); \n        require(getPair[token0][token1] == address(0), 'LfgSwap: PAIR_EXISTS'); // single check is su\n        bytes memory bytecode = type(LfgSwapPair).creationCode; \n        bytes32 salt = keccak256(abi.encodePacked(token0, token1)); \n        assembly { \n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt) \n        } \n        LfgSwapPair(pair).initialize(token0, token1); \n        getPair[token0][token1] = pair; \n        getPair[token1][token0] = pair; // populate mapping in the reverse direction \n        allPairs.push(pair); \n        emit PairCreated(token0, token1, pair, allPairs.length); \n    } \n \n    function getSalt() public view returns(bytes32) { \n        bytes memory bytecode = type(LfgSwapPair).creationCode; \n        return keccak256(abi.encodePacked(bytecode)); \n    } \n \n    function setFeeTo(address _feeTo) external override { \n        require(msg.sender == feeToSetter, 'LfgSwap: FORBIDDEN'); \n        feeTo = _feeTo; \n    } \n \n \n    function setFeeToSetter(address _feeToSetter) external override { \n        require(msg.sender == feeToSetter, 'LfgSwap: FORBIDDEN'); \n        feeToSetter = _feeToSetter; \n    } \n \n} \n \n \n \n// Sources flattened with hardhat v2.10.2 https://hardhat.org \n \n// File @openzeppelin/contracts/utils/Context.sol@v3.4.2 \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IErc20Interface { \n \n    /*** User Interface ***/ \n    function underlying() external view returns (address); \n \n    function mint(uint mintAmount) external returns (uint);  // \n    function redeem(uint redeemTokens) external returns (uint); \n    function redeemUnderlying(uint redeemAmount) external returns (uint); \n    function borrow(uint borrowAmount) external returns (uint); \n    function repayBorrow(uint repayAmount) external returns (uint); \n    // function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint); \n    // function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) \n \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IERC20} from './IERC20.sol'; \n \ninterface IERC20Detailed is IERC20 { \n  function name() external view returns (string memory); \n \n  function symbol() external view returns (string memory); \n \n  function decimals() external view returns (uint8); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.9.0; \npragma experimental ABIEncoderV2; \n \ninterface IMartToken { \n    function startBlock() external view returns (uint256); \n    function getDaysupply() external view returns (uint256, uint256); \n    function getPreDaysupply(uint256 _day) external view returns (uint256, uint256); \n    function getUsereward(address addr, uint256 amount) external returns (bool); \n    function addLockFee() external returns (bool); \n} \n \n// File: @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol \n \n \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Upgradeable { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n// File: contracts/interface/IERC20.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IRateOracle { \n  function owner() view external returns (address); \n \n  function paused() view external returns (bool); \n \n  function renounceOwnership() external; \n \n  function requester() view external returns (address); \n \n  function transferOwnership(address newOwner) external; \n \n  function updater() view external returns (address); \n \n  function pause() external; \n \n  function unPause() external; \n \n  function status() view external returns (bool); \n \n  function lastRequestTime() view external returns (uint256); \n \n  function lastUpdateTime() view external returns (uint256); \n \n  function decimals() view external returns (uint8); \n \n  function rate() view external returns (uint256); \n \n  function request() external; \n \n  function update(uint256 rate_) external; \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n  event Paused(address account); \n \n  event Request(uint256 indexed timestamp); \n \n  event RequestershipTransferred(address indexed previousRequester, address indexed newRequester); \n \n  event Unpaused(address account); \n \n  event Update(uint256 indexed timestamp, uint256 rate); \n \n  event UpdatershipTransferred(address indexed previousUpdater, address indexed newUpdater); \n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.8.9; \n \nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\"; \nimport \"../utils/AccessControlProxyPausable.sol\"; \n \ncontract UUPSUpgradeableByRole is AccessControlProxyPausable, UUPSUpgradeable { \n \n    bytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\"); \n \n    function _authorizeUpgrade(address newImplementation) \n        internal \n        onlyRole(UPGRADER_ROLE) \n        override \n    {} \n}\nAccessControlProxyPausable.sol\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \nimport \"@openzeppelin/contracts/finance/VestingWallet.sol\"; \n \ncontract VestingToken is VestingWallet{ \n    constructor( \n        address beneficiaryAddress, \n        uint64 startTimestamp, \n        uint64 durationSeconds \n    ) VestingWallet(beneficiaryAddress, startTimestamp, durationSeconds){} \n \n    receive() external payable override { \n        revert(\"UNSUPPORTED_OP\"); \n    } \n \n    function release() public override { \n        revert(\"UNSUPPORTED_OP\"); \n    } \n} \nAnalysis of audit results\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \ninterface IPayable { \n    function pay(string memory serviceName) external payable; \n} \n \n/** \n * @title ServicePayer \n * @dev Implementation of the  ServicePayer \n */  \nabstract contract ServicePayer { \n    constructor(address payable receiver, string memory serviceName) payable { \n        IPayable(receiver).pay{value: msg.value}(serviceName); \n    } \n} \n \n// File: contracts/token/ERC20/PowerfulERC20.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ITenBankHall { \n    function makeBorrowFrom(uint256 _pid, address _account, address _debtFrom, uint256 _value) extern\n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title SafeMath \n * @dev Unsigned math operations with safety checks that revert on error \n */ \n \nlibrary SafeMath { \n    /** \n     * @dev Multiplies two unsigned integers, reverts on overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b); \n \n        return c; \n    } \n \n    /** \n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Solidity only automatically asserts when dividing by 0 \n        require(b > 0); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    /** \n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    /** \n     * @dev Adds two unsigned integers, reverts on overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a); \nZooToken.sol\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IStrategyV2PairHelper { \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface IERC20LfgSwap { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n    function symbol() external pure returns (string memory); \n    function decimals() external pure returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n} \n \n \n// File contracts/core/LfgSwapRouter.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {StableDebtToken} from '../protocol/tokenization/StableDebtToken.sol'; \nimport {VariableDebtToken} from '../protocol/tokenization/VariableDebtToken.sol'; \nimport {LendingRateOracle} from '../mocks/oracle/LendingRateOracle.sol'; \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {StringLib} from './StringLib.sol'; \n \ncontract StableAndVariableTokensHelper is Ownable { \n  address payable private pool; \n  address private addressesProvider; \n  event deployedContracts(address stableToken, address variableToken); \n \n  constructor(address payable _pool, address _addressesProvider) public { \n    pool = _pool; \n    addressesProvider = _addressesProvider; \n  } \n \n  function initDeployment(address[] calldata tokens, string[] calldata symbols) external onlyOwner { \n    require(tokens.length == symbols.length, 'Arrays not same length'); \n    require(pool != address(0), 'Pool can not be zero address'); \n    for (uint256 i = 0; i < tokens.length; i++) { \n      emit deployedContracts(address(new StableDebtToken()), address(new VariableDebtToken())); \n    } \n  } \n \n  function setOracleBorrowRates( \n    address[] calldata assets, \n    uint256[] calldata rates, \n    address oracle \n  ) external onlyOwner { \n    require(assets.length == rates.length, 'Arrays not same length'); \n \n    for (uint256 i = 0; i < assets.length; i++) { \n      // LendingRateOracle owner must be this contract \n      LendingRateOracle(oracle).setMarketBorrowRate(assets[i], rates[i]); \n    } \n  } \n \n  function setOracleOwnership(address oracle, address admin) external onlyOwner { \n    require(admin != address(0), 'owner can not be zero'); \n    require(LendingRateOracle(oracle).owner() == address(this), 'helper is not owner'); \n    LendingRateOracle(oracle).transferOwnership(admin); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @dev Interface of the  ERC20 standard as defined in the\n */  \ninterface IERC20 { \n    /** \n     * @dev Returns the  amount of tokens in existence. \n     */  \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the  amount of tokens owned by `account`. \n     */  \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the  caller's account to `recipient`. \n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * Emits a  {Transfer} event. \n     */  \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the  remaining number of tokens that `spender` will\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are  called. \n     */  \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the  allowance of `spender` over the\n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * IMPORTANT: Beware that changing an  allowance with this method brings \n     * that someone may use both the  old and the  new allow\n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the  spender's allowance to 0 and set the\n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an  {Approval} event. \n     */  \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the  \n     * allowance mechanism. `amount` is then deducted from the  caller's \n     * allowance. \n     * \n     * Returns a  boolean value indicating whether the  opera\n     * \n     * Emits a  {Transfer} event. \n     */  \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are  moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */  \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the  allowance of a  `spender` for \n     * a  call to {approve}. `value` is the  new allowance. \n     */  \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/presets/ERC20PresetFixedSupply.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\"; \n \ncontract OVG is ERC20PresetFixedSupply,ERC20Permit { \n    constructor(string memory name,string memory symbol,uint256 initialSupply,address owner) ERC20Per\n    } \n} \nAnalysis of audit results\nRe-Entrancy\nArithmetic Over/Under Flows\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n/** \n * @dev Extension of {ERC20} that adds a  cap to the  supp\n */  \nabstract contract ERC20Capped is ERC20 { \n    uint256 private immutable _cap; \n \n    /** \n     * @dev Sets the  value of the  `cap`. This value is immut\n     * set once during construction. \n     */  \n    constructor(uint256 cap_) { \n        require(cap_ > 0, \"ERC20Capped: cap is 0\"); \n        _cap = cap_; \n    } \n \n    /** \n     * @dev Returns the  cap on the  token's total supply. \n     */  \n    function cap() public view virtual returns (uint256) { \n        return _cap; \n    } \n \n    /** \n     * @dev See {ERC20-_mint}. \n     */  \n    function _mint(address account, uint256 amount) internal virtual override { \n        require(ERC20.totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\"); \n        super._mint(account, amount); \n    } \n} \n \n// File: @openzeppelin/contracts/utils/Address.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./Context.sol\"; \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    function _initOwner(address owner_) internal { \n        require(owner_ != address(0), \"Ownable: owner cannot be init to zero address\"); \n        _owner = owner_; \n        emit OwnershipTransferred(address(0), _owner); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity =0.8.4; \n \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\"; \n \ncontract StakeVR is ReentrancyGuard { \n    using SafeERC20 for IERC20; \n \n    uint32 constant HUNDRED_PERCENT = 1e3; \n \n    struct Stake { \n        bool unstaked; \n        uint128 amount; \n        uint48 lockTimestamp; \n        uint16 lockDays; \n    } \n \n    IERC20 public stakingToken; \n    mapping(address => Stake[]) public stakers; \n    uint192 public totalShares; \n    uint16 public minLockDays; \n    uint16 public maxLockDays; \n    uint16 public shareBonusPerYear; \n    uint16 public shareBonusPer1MTokens; \n \n    event EStake( \n        address staker, \n        uint128 amount, \n        uint192 shares, \n        uint48 lockTimestamp, \n        uint16 lockDays, \n        uint192 totalShares \n    ); \n \n    event EUnstake( \n        address staker, \n        uint stakeIndex, \n        uint192 totalShares \n    ); \n \n    constructor( \n        IERC20 _stakingToken, \n        uint16 _minLockDays, \n        uint16 _maxLockDays, \n        uint16 _shareBonusPerYear, \n        uint16 _shareBonusPer1MTokens \n    ) { \n        require(address(_stakingToken) != address(0)); \n        require(_minLockDays <= _maxLockDays, \"StakeVR: minLockDays > maxLockDays\"); \n        stakingToken = _stakingToken; \n        minLockDays = _minLockDays; \n        maxLockDays = _maxLockDays; \n        shareBonusPerYear = _shareBonusPerYear; \n        shareBonusPer1MTokens = _shareBonusPer1MTokens; \n    } \n \n    function stake(uint128 amount, uint16 lockDays) external nonReentrant { \n        require(lockDays >= minLockDays && lockDays <= maxLockDays, \"StakeVR: invalid lockDays\"); \n        (uint192 shares,) = calculateShares(amount, lockDays); \n        totalShares += shares; \n \n        stakers[msg.sender].push(Stake( \n            false, \n            amount, \n            uint48(block.timestamp), \n            lockDays \n        )); \n        stakingToken.safeTransferFrom(msg.sender, address(this), amount); \n        emit EStake(msg.sender, amount, shares, uint48(block.timestamp), lockDays, totalShares); \n    } \n \n    function unstake(uint stakeIndex) external nonReentrant { \n        require(stakeIndex < stakers[msg.sender].length, \"StakeVR: invalid index\"); \n        Stake storage stakeRef = stakers[msg.sender][stakeIndex]; \n        require(!stakeRef.unstaked, \"StakeVR: unstaked already\"); \n        require(stakeRef.lockTimestamp + uint48(stakeRef.lockDays) * 86400 <= block.timestamp, \"Stake\n \n        (uint192 shares,) = calculateShares(stakeRef.amount, stakeRef.lockDays); \n        totalShares -= shares; \n        stakeRef.unstaked = true; \n        stakingToken.safeTransfer(msg.sender, stakeRef.amount); \n        emit EUnstake(msg.sender, stakeIndex, totalShares); \n    } \n \n    function calculateShares( \n        uint amount,  \n        uint lockDays \n    ) public view returns ( \n        uint192 shares, \n        uint longTermBonus \n    ) { \n        longTermBonus = amount * lockDays * shareBonusPerYear / 365 / HUNDRED_PERCENT; \n        uint stakingMoreBonus = amount * amount * shareBonusPer1MTokens / 1e24 / HUNDRED_PERCENT; \n        shares = uint192(amount + longTermBonus + stakingMoreBonus); \n    } \n \n    function getStakerInfo( \n        address stakerAddress \n    ) public view returns ( \n        uint256 totalStakeAmount, \n        uint256 totalStakerShares \n    ) { \n        for (uint i = 0; i < stakers[stakerAddress].length; i++) { \n            Stake storage stakeRef = stakers[stakerAddress][i]; \n            if (stakeRef.unstaked) continue; \n \n            totalStakeAmount += stakeRef.amount; \n            (uint192 shares,) = calculateShares(stakeRef.amount, stakeRef.lockDays); \n            totalStakerShares += shares; \n        } \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.8.10; \n \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \n \ncontract GFTTokenVesting is Ownable { \n  using SafeERC20 for IERC20; \n \n  event Released(address beneficiary, uint256 amount); \n \n  IERC20 public token; \n  uint256 public cliff; \n  uint256 public start; \n  uint256 public duration; \n  uint256 public period; \n  uint256 public percent; \n \n  mapping (address => uint256) public shares; \n  mapping (address => uint256) public lastReleaseDate; \n  mapping (address => uint256) public releasedAmount; \n \n  uint256 released = 0; \n  uint256 BP = 10000; \n \n  address[] public beneficiaries; \n \n  modifier onlyBeneficiaries { \n    require(msg.sender == owner() || shares[msg.sender] > 0, \"You cannot release tokens!\"); \n    _; \n  } \n \n  constructor( \n    IERC20 _token, \n    uint256 _start, \n    uint256 _cliff, \n    uint256 _duration, \n    uint256 _period, \n    uint256 _percent \n  ) { \n    require(_cliff <= _duration, \"Cliff has to be lower or equal to duration\"); \n    token = _token; \n    duration = _duration; \n    cliff = _start + _cliff; \n    start = _start; \n    period = _period; \n    percent = _percent; \n  } \n \n  function addBeneficiaryes(address[] memory _beneficiaryes, uint256[] memory _sharesAmounts) onlyOwn\n    require(_beneficiaryes.length == _sharesAmounts.length); \n \n    for (uint i = 0; i <_beneficiaryes.length; i++) { \n      addBeneficiary(_beneficiaryes[i], _sharesAmounts[i]); \n    } \n \n    require(totalShares() == 10000, \"Invalid shares amount\"); \n  } \n \n  function addBeneficiary(address _beneficiary, uint256 _sharesAmount) onlyOwner public { \n    require(block.timestamp < cliff); \n    require(_beneficiary != address(0), \"The beneficiary's address cannot be 0\"); \n    require(_sharesAmount > 0, \"Shares amount has to be greater than 0\"); \n \n    if (shares[_beneficiary] == 0) { \n      beneficiaries.push(_beneficiary); \n    } \n \n    lastReleaseDate[_beneficiary] = cliff; \n    shares[_beneficiary] = shares[_beneficiary] + _sharesAmount; \n  } \n \n  function claimTokens() onlyBeneficiaries public { \n    uint256 currentBalance = token.balanceOf(address(this)); \n    uint256 totalBalance = currentBalance + released; \n \n    require(releasedAmount[msg.sender] < calculateShares(totalBalance, msg.sender), \"User already rel\n \n    uint256 unreleased = releasableAmount(); \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20Upgradeable { \n    using SafeMathUpgradeable for uint256; \n    using AddressUpgradeable for address; \n \n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) inter\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n \n// solhint-disable-next-line compiler-version \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"./ERC20.sol\"; \n \ncontract FECToken is ERC20{  \n \n    string public Fecname = \"FECToken\"; \n    string public Fecsymbol = \"FEC\"; \n    uint8 public dec = 18; \n    uint public INITIAL_SUPPLY = 10000000000; \n    uint256 public _totalSupply = INITIAL_SUPPLY * (10**uint(dec)); \n \n   constructor () ERC20(Fecname, Fecsymbol) public{  \n   _mint(msg.sender, _totalSupply);  \n   }  \n} \nIERC20Metadata.sol\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {Errors} from '../helpers/Errors.sol'; \n \n/** \n * @title PercentageMath library \n * @author Aave \n * @notice Provides functions to perform percentage calculations \n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is in\n * @dev Operations are rounded half up \n **/ \n \nlibrary PercentageMath { \n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals \n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2; \n \n  /** \n   * @dev Executes a percentage multiplication \n   * @param value The value of which the percentage needs to be calculated \n   * @param percentage The percentage of the value to be calculated \n   * @return The percentage of value \n   **/ \n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) { \n    if (value == 0 || percentage == 0) { \n      return 0; \n    } \n \n    require( \n      value <= (type(uint256).max - HALF_PERCENT) / percentage, \n      Errors.MATH_MULTIPLICATION_OVERFLOW \n    ); \n \n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR; \n  } \n \n  /** \n   * @dev Executes a percentage division \n   * @param value The value of which the percentage needs to be calculated \n   * @param percentage The percentage of the value to be calculated \n   * @return The value divided the percentage \n   **/ \n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) { \n    require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO); \n    uint256 halfPercentage = percentage / 2; \n \n    require( \n      value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR, \n      Errors.MATH_MULTIPLICATION_OVERFLOW \n    ); \n \n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n* @dev Provides information about the  current execution context, including \n* sender of the  transaction and its data. While these are  ge\n* via msg.sender and msg.data, they  should  not be access\n* manner, since when dealing with meta-transactions the  account sending and \n* paying for execution may not be the  actual sender (as far as an\n* is concerned). \n* \n* This contract is only required for intermediate, library- like  contracts. \n  */  \n  abstract contract Context { \n  function _msgSender() internal view virtual returns (address) { \n  return msg.sender; \n  } \n \n  function _msgData() internal view virtual returns (bytes calldata) { \n  return msg.data; \n  } \n  } \n \n// File: @openzeppelin/contracts/access/AccessControl.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (access/AccessControl.sol) \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.2; \n \nimport './IUniswapV2Router01.sol'; \n \ninterface IUniswapV2Router02 is IUniswapV2Router01 { \n  function removeLiquidityETHSupportingFeeOnTransferTokens( \n    address token, \n    uint256 liquidity, \n    uint256 amountTokenMin, \n    uint256 amountETHMin, \n    address to, \n    uint256 deadline \n  ) external returns (uint256 amountETH); \n \n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( \n    address token, \n    uint256 liquidity, \n    uint256 amountTokenMin, \n    uint256 amountETHMin, \n    address to, \n    uint256 deadline, \n    bool approveMax, \n    uint8 v, \n    bytes32 r, \n    bytes32 s \n  ) external returns (uint256 amountETH); \n \n  function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n    uint256 amountIn, \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external; \n \n  function swapExactETHForTokensSupportingFeeOnTransferTokens( \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external payable; \n \n  function swapExactTokensForETHSupportingFeeOnTransferTokens( \n    uint256 amountIn, \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport './BaseUpgradeabilityProxy.sol'; \n \n/** \n * @title InitializableUpgradeabilityProxy \n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing \n * implementation and init data. \n */ \ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy { \n  /** \n   * @dev Contract initializer. \n   * @param _logic Address of the initial implementation. \n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract. \n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n   * This parameter is optional, if no data is given the initialization call to proxied contract will \n   */ \n  function initialize(address _logic, bytes memory _data) public payable { \n    require(_implementation() == address(0)); \n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)); \n    _setImplementation(_logic); \n    if (_data.length > 0) { \n      (bool success, ) = _logic.delegatecall(_data); \n      require(success); \n    } \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface ILfgSwapFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n    function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeToSetter(address) external; \n \n} \n \n \n// File contracts/core/LfgSwapPair.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.2; \n \ninterface INetswapRouter { \n    function factory() external pure returns (address); \n    function Metis() external pure returns (address); \n \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB, uint liquidity); \n    function addLiquidityMetis( \n        address token, \n        uint amountTokenDesired, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) external payable returns (uint amountToken, uint amountMetis, uint liquidity); \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityMetis( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountToken, uint amountMetis); \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityMetisWithPermit( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountToken, uint amountMetis); \n    function swapExactTokensForTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapTokensForExactTokens( \n        uint amountOut, \n        uint amountInMax, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapExactMetisForTokens(uint amountOutMin, address[] calldata path, address to, uint dea\n        external \n        payable \n        returns (uint[] memory amounts); \n    function swapTokensForExactMetis(uint amountOut, uint amountInMax, address[] calldata path, addre\n        external \n        returns (uint[] memory amounts); \n    function swapExactTokensForMetis(uint amountIn, uint amountOutMin, address[] calldata path, addre\n        external \n        returns (uint[] memory amounts); \n    function swapMetisForExactTokens(uint amountOut, address[] calldata path, address to, uint deadli\n        external \n        payable \n        returns (uint[] memory amounts); \n \n    function removeLiquidityMetisSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountMetis); \n    function removeLiquidityMetisWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountMetis); \n \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint amountIn, \nMulticall.sol\n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n    function swapExactMetisForTokensSupportingFeeOnTransferTokens( \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external payable; \n    function swapExactTokensForMetisSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n \n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB); \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external view returns (uint \n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external view returns (uint \n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memo\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memo\n}\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/************ \n@title IPriceOracle interface \n@notice Interface for the Aave price oracle.*/ \ninterface IPriceOracle { \n  /*********** \n    @dev returns the asset price in ETH \n     */ \n  function getAssetPrice(address asset) external view returns (uint256); \n \n  /*********** \n    @dev sets the asset price, in wei \n     */ \n  function setAssetPrice(address asset, uint256 price) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.4; \n \ninterface IBEP20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the token decimals. \n     */ \n    function decimals() external view returns (uint8); \n \n    /** \n     * @dev Returns the token symbol. \n     */ \n    function symbol() external view returns (string memory); \n \n    /** \n     * @dev Returns the token name. \n     */ \n    function name() external view returns (string memory); \n \n    /** \n     * @dev Returns the bep token owner. \n     */ \n    function getOwner() external view returns (address); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address _owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \nOwnable.sol\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"../Ownable.sol\"; \nimport \"../Pausable.sol\"; \n \ncontract RateOracle is Ownable, Pausable { \n    address public updater; \n    address public requester; \n \n    event UpdatershipTransferred( \n        address indexed previousUpdater, \n        address indexed newUpdater \n    ); \n \n    event RequestershipTransferred( \n        address indexed previousRequester, \n        address indexed newRequester \n    ); \n \n    modifier onlyUpdater() { \n        require(_msgSender() == updater, \"Oracle: caller is not the updater\"); \n        _; \n    } \n \n    modifier onlyRequester() { \n        require( \n            _msgSender() == requester, \n            \"Oracle: caller is not the requester\" \n        ); \n        _; \n    } \n \n    bool private _status = false; // request but not updated -> false; request and updated -> true \n    uint256 private _lastUpdateTime = 0; // last updated timestamp \n    uint256 private _lastRequestTime = 0; // last request timestamp \n \n    uint8 private _decimals = 18; // decimal \n    uint256 private _rate; // rate \n \n    event Request(uint256 indexed timestamp); \n    event Update(uint256 indexed timestamp, uint256 rate); \n \n    constructor(address _updater, address _requester) Ownable() Pausable() { \n        updater = _updater; \n        emit UpdatershipTransferred(address(0), updater); \n        requester = _requester; \n        emit RequestershipTransferred(address(0), requester); \n \n        _lastRequestTime = block.timestamp; \n        emit Request(block.timestamp); \n    } \n \n    function transferRequestership(address newRequester) external onlyOwner { \n        require( \n            newRequester != address(0), \n            \"Oracle: new Requester is the zero address\" \n        ); \n        emit RequestershipTransferred(requester, newRequester); \n        requester = newRequester; \n    } \n \n    function transferUpdatership(address newUpdater) external onlyOwner { \n        require( \n            newUpdater != address(0), \n            \"Oracle: new Updater is the zero address\" \n        ); \n        emit UpdatershipTransferred(updater, newUpdater); \n        updater = newUpdater; \n    } \n \n    function pause() external onlyOwner { \n        _pause(); \n    } \n \n    function unPause() external onlyOwner { \n        _unpause(); \n    } \n \n    function status() external view returns (bool) { \n        return _status; \n    } \n \n    function lastRequestTime() external view returns (uint256) { \n        return _lastRequestTime; \n    } \n \n    function lastUpdateTime() external view returns (uint256) { \n        return _lastUpdateTime; \n    } \n \n    function decimals() external view whenNotPaused returns (uint8) { \n        return _decimals; \n    } \n \n    function rate() external view whenNotPaused returns (uint256) { \n        return _rate; \n    } \n \n    function request() external onlyRequester whenNotPaused { \n        require(_status, \"Oracle: request already called\"); \n        _status = false; \n        _lastRequestTime = block.timestamp; \n        emit Request(block.timestamp); \n    } \n \n    function update(uint256 rate_) external onlyUpdater whenNotPaused { \n        require(!_status, \"Oracle: no request called\"); \n        require(rate_ > 0, \"Oracle: rate can not be zero\"); \n        _status = true; \n        _lastUpdateTime = block.timestamp; \n        _rate = rate_; \n        emit Update(block.timestamp, _rate); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.2; \n \n \n \n \n \ncontract TKL is ERC20, ERC20Burnable, Pausable, AccessControl { \n \n    address [20] private _whiteAddress = [ \n    0x60A2aF5F6309840335Dc4896a1D330940Bf95b91, \n    0xe65AEEfa511ee4Fd34eA6A4b062a8ED7f3Df747d, \n    0x7c861f5fF977b906416Bff7fa4003ce0C77BCb2E, \n    0x3CD5E18739991032963D8AaBCF1a96b42930f5b9, \n    0xa4Edb9fbBD0fece358d38AE8F70f398486b51ba0, \n    0x6916771D1b7856c16CcDd34561Dc23e68D408a34, \n    0x2f3F1814662344B76E679eC68e96DF1622cbca43, \n    0x7578e019dEBA6a7a95F037083c13b336a47b1f4E, \n    0x411B1C0fD58df164E65386556673e70157219df8, \n    0x7c4b2d955067Bd62233c9582bceE4d60f0fa5D90, \n    0x6C9437A1CC3f2D33aa7734403f884BB1755fD001, \n    0xffe1dC4B2F0811a9fEf3c238bd9935B0428F7C40, \n    0xB4cEf04DF82eD67675Ae5684AE04f662f9D76698, \n    0xc95cA041ad2aF8D3F353e48B842bA94b45c9Ecdc, \n    0xa1D156be0f35BD884460158d625cCEca2030323d, \n    0x2B8c117CC169946A872718aca2Ca24727579CeC2, \n    0x7690E8Dc6AD19006D161C6dC22De526b60D97C86, \n    0x8f3AfCB215A70A09583fA5d8839023953F90d2f4, \n    0xA5Ccf6258cab11105bD688B1DC8c33a5Fe08870a, \n    0x028f2FFdD938C72e6d0169eB991CA084Eb98648d \n    ]; \n \n    uint256 public GameLockBalance  = 500000000 * 10 ** decimals(); \n    uint256 public StakeLockBalance = 9000000000 * 10 ** decimals(); \n \n    address public LiquidityPool = 0x3629D6E1f8013b1f76858E30aaa5612aC9833750; \n \n    bytes32 public constant UNLOCKER_ROLE = keccak256(\"UNLOCKER_ROLE\"); \n \n    constructor() ERC20(\"TKL\", \"TKL\") { \n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); \n        _grantRole(UNLOCKER_ROLE, msg.sender); \n \n        _mint(address(this), GameLockBalance); \n        _mint(address(this), StakeLockBalance); \n        _mint(0x3E7ba5ce0b25118F5A20CB0Be76b16b86E9c9c92, 100000000 * 10 ** decimals()); \n        _mint(0x3D8Ec132882FDF2d538E91e2226357c41E19AEc2, 100000000 * 10 ** decimals()); \n        _mint(0x96824F32b4BfFEEede15bf9dE97E7a43fce7B486, 300000000 * 10 ** decimals()); \n    } \n \n    function pause() public onlyRole(DEFAULT_ADMIN_ROLE) { \n        _pause(); \n    } \n \n    function unpause() public onlyRole(DEFAULT_ADMIN_ROLE) { \n        _unpause(); \n    } \n \n    function _beforeTokenTransfer(address from, address to, uint256 amount) \n    internal \n    whenNotPaused \n    override \n    { \n        super._beforeTokenTransfer(from, to, amount); \n    } \n \n    function transferFrom(address sender, address recipient, uint256 amount) public override returns \n        require(sender != address(0), \"ERC20: send not allow the zero address\"); \n \n        for(uint i = 0; i < _whiteAddress.length; i++) { \n            if (sender == _whiteAddress[i]){ \n                super.transferFrom(sender,recipient,amount); \n                return true; \n            } \n \n        } \n        uint256 _fee = amount*5/100; \n        uint256 _rest = amount-_fee*2; \n \n        _transfer(sender, LiquidityPool, _fee); \n \n        _transfer(sender, recipient, _rest); \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {UserConfiguration} from '../libraries/configuration/UserConfiguration.sol'; \nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol'; \nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol'; \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {DataTypes} from '../libraries/types/DataTypes.sol'; \n \ncontract LendingPoolStorage { \n  using ReserveLogic for DataTypes.ReserveData; \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n  using UserConfiguration for DataTypes.UserConfigurationMap; \n \n  ILendingPoolAddressesProvider internal _addressesProvider; \n \n  mapping(address => DataTypes.ReserveData) internal _reserves; \n  mapping(address => DataTypes.UserConfigurationMap) internal _usersConfig; \n \n  // the list of the available reserves, structured as a mapping for gas savings reasons \n  mapping(uint256 => address) internal _reservesList; \n \n  uint256 internal _reservesCount; \n \n  bool internal _paused; \n \n  uint256 internal _maxStableRateBorrowSizePercent; \n \n  uint256 internal _flashLoanPremiumTotal; \n \n  uint256 internal _maxNumberOfReserves; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \n \ncontract MDAO is ERC20 { \n    constructor() ERC20(\"MemoryDAO\", \"MDAO\") { \n        _mint(address(msg.sender), 200000000e18); \n    } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.2; \n \ninterface ILfgSwapRouter { \n \n    function factory() external pure returns (address); \n    function WETH() external pure returns (address); \n \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB, uint liquidity); \n    function addLiquidityETH( \n        address token, \n        uint amountTokenDesired, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity); \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityETH( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountToken, uint amountETH); \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityETHWithPermit( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountToken, uint amountETH); \n    function swapExactTokensForTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapTokensForExactTokens( \n        uint amountOut, \n        uint amountInMax, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadl\n        external \n        payable \n        returns (uint[] memory amounts); \n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address \n        external \n        returns (uint[] memory amounts); \n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address \n        external \n        returns (uint[] memory amounts); \n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline\n        external \n        payable \n        returns (uint[] memory amounts); \n \n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB); \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint \n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint \n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memo\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memo\n \n    function removeLiquidityETHSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountETH); \n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountETHMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountETH); \n \n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n    function swapExactETHForTokensSupportingFeeOnTransferTokens( \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external payable; \n    function swapExactTokensForETHSupportingFeeOnTransferTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external; \n} \n \n \n// File contracts/interface/IWETH.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol'; \nimport {IInitializableDebtToken} from './IInitializableDebtToken.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \n/** \n * @title IStableDebtToken \n * @notice Defines the interface for the stable debt token \n * @dev It does not inherit from IERC20 to save in code size \n * @author Aave \n **/ \n \ninterface IStableDebtToken is IScaledBalanceToken,IInitializableDebtToken { \n  /** \n   * @dev Emitted when new stable debt is minted \n   * @param user The address of the user who triggered the minting \n   * @param onBehalfOf The recipient of stable debt tokens \n   * @param amount The amount minted \n   * @param currentBalance The current balance of the user \n   * @param balanceIncrease The increase in balance since the last action of the user \n   * @param newRate The rate of the debt after the minting \n   * @param avgStableRate The new average stable rate after the minting \n   * @param newTotalSupply The new total supply of the stable debt token after the action \n   **/ \n  event Mint( \n    address indexed user, \n    address indexed onBehalfOf, \n    uint256 amount, \n    uint256 currentBalance, \n    uint256 balanceIncrease, \n    uint256 newRate, \n    uint256 avgStableRate, \n    uint256 newTotalSupply \n  ); \n \n  /** \n   * @dev Emitted when new stable debt is burned \n   * @param user The address of the user \n   * @param amount The amount being burned \n   * @param currentBalance The current balance of the user \n   * @param balanceIncrease The the increase in balance since the last action of the user \n   * @param avgStableRate The new average stable rate after the burning \n   * @param newTotalSupply The new total supply of the stable debt token after the action \n   **/ \n  event Burn( \n    address indexed user, \n    uint256 amount, \n    uint256 currentBalance, \n    uint256 balanceIncrease, \n    uint256 avgStableRate, \n    uint256 newTotalSupply \n  ); \n \n  /** \n   * @dev Mints debt token to the `onBehalfOf` address. \n   * - The resulting rate is the weighted average between the rate of the new debt \n   * and the rate of the previous debt \n   * @param user The address receiving the borrowed underlying, being the delegatee in case \n   * of credit delegate, or same as `onBehalfOf` otherwise \n   * @param onBehalfOf The address receiving the debt tokens \n   * @param amount The amount of debt tokens to mint \n   * @param rate The rate of the debt being minted \n   **/ \n  function mint( \n    address user, \n    address onBehalfOf, \n    uint256 amount, \n    uint256 rate \n  ) external returns (bool); \n \n  /** \n   * @dev Burns debt of `user` \n   * - The resulting rate is the weighted average between the rate of the new debt \n   * and the rate of the previous debt \n   * @param user The address of the user getting his debt burned \n   * @param amount The amount of debt tokens getting burned \n   **/ \n  function burn(address user, uint256 amount) external; \n \n  /** \n   * @dev Returns the average rate of all the stable rate loans. \n   * @return The average stable rate \n   **/ \n  function getAverageStableRate() external view returns (uint256); \n \n  /** \n   * @dev Returns the stable rate of the user debt \n   * @return The stable rate of the user \n   **/ \n  function getUserStableRate(address user) external view returns (uint256); \n \n  /** \n   * @dev Returns the timestamp of the last update of the user \n   * @return The timestamp \n   **/ \n  function getUserLastUpdated(address user) external view returns (uint40); \n \n  /** \n   * @dev Returns the principal, the total supply and the average stable rate \n   **/ \n  function getSupplyData() \n    external \n    view \n    returns ( \n      uint256, \n      uint256, \n      uint256, \n      uint40 \n    ); \n \n  /** \n   * @dev Returns the timestamp of the last update of the total supply \n   * @return The timestamp \n   **/ \n  function getTotalSupplyLastUpdated() external view returns (uint40); \n \n  /** \n   * @dev Returns the total supply and the average stable rate \n   **/ \n  function getTotalSupplyAndAvgRate() external view returns (uint256, uint256); \n \n  /** \n   * @dev Returns the principal debt balance of the user \n   * @return The debt balance of the user since the last burn/mint action \n   **/ \n  function principalBalanceOf(address user) external view returns (uint256); \n \n  /** \n   * @dev Returns the address of the incentives controller contract \n   **/ \n  function getIncentivesController() external view returns (IAaveIncentivesController); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ICTokenInterface { \n \n  function isCToken() external view returns (bool); \n \n  // function decimals() external returns (uint8); \n \n  function underlying() external view returns (address); \n \n  // function mint(uint mintAmount) external returns (uint); \n \n  // function redeem(uint redeemTokens) external returns (uint); \n \n  // function balanceOf(address user) external view returns (uint); \n \n  // function borrowBalanceCurrent(address account) external returns (uint); \n \n  // function borrowBalanceStored(address account) external view returns (uint); \n \n  // function borrow(uint borrowAmount) external returns (uint); \n \n  // function repayBorrow(uint repayAmount) external returns (uint); \n  // function transfer(address dst, uint amount) external returns (bool); \n  // function transferFrom(address src, address dst, uint amount) external returns (bool); \n  // function approve(address spender, uint amount) external returns (bool); \n  // function allowance(address owner, address spender) external view returns (uint); \n  // function balanceOf(address owner) external view returns (uint); \n  function balanceOfUnderlying(address owner) external view returns (uint); \n  function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint); \n  function borrowRatePerBlock() external view returns (uint); \n  function supplyRatePerBlock() external view returns (uint); \n  function totalBorrowsCurrent() external returns (uint); \n  function borrowBalanceCurrent(address account) external returns (uint); \n  function borrowBalanceStored(address account) external view returns (uint); \n  function exchangeRateCurrent() external returns (uint); \n  function exchangeRateStored() external view returns (uint); \n  function getCash() external view returns (uint); \n  function accrueInterest() external returns (uint); \n  function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint); \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {DataTypes} from '../types/DataTypes.sol'; \n \n/** \n * @title Helpers library \n * @author Aave \n */ \nlibrary Helpers { \n  /** \n   * @dev Fetches the user current stable and variable debt balances \n   * @param user The user address \n   * @param reserve The reserve data object \n   * @return The stable and variable debt balance \n   **/ \n  function getUserCurrentDebt(address user, DataTypes.ReserveData storage reserve) \n    internal \n    view \n    returns (uint256, uint256) \n  { \n    return ( \n      IERC20(reserve.stableDebtTokenAddress).balanceOf(user), \n      IERC20(reserve.variableDebtTokenAddress).balanceOf(user) \n    ); \n  } \n \n  function getUserCurrentDebtMemory(address user, DataTypes.ReserveData memory reserve) \n    internal \n    view \n    returns (uint256, uint256) \n  { \n    return ( \n      IERC20(reserve.stableDebtTokenAddress).balanceOf(user), \n      IERC20(reserve.variableDebtTokenAddress).balanceOf(user) \n    ); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.8.9; \n \nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\"; \nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20SnapshotUpgradeable.sol\"; \nimport \"@opengsn/contracts/src/BaseRelayRecipient.sol\"; \nimport \"../utils/AccessControlProxyPausable.sol\"; \nimport \"../utils/UUPSUpgradeableByRole.sol\"; \nimport \"../shared/IMonstropolyDeployer.sol\"; \n \ncontract MonstropolyERC20 is ERC20Upgradeable, ERC20SnapshotUpgradeable, AccessControlProxyPausable, \n    string public override versionRecipient = \"2.4.0\"; \n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\"); \n    bytes32 public constant ANTIBOT_ROLE = keccak256(\"ANTIBOT_ROLE\"); \n \n    uint256 public burned; \n    uint256 public cap; \n    uint256 private _maxBalanceWhenAntiBot; \n    bool private _isAntibot; \n    bool private _isAntiBotInitialized; \n \n    mapping(address => bool) public whitelisted; \n \n    function initialize() public initializer { \n        cap = 500000000 ether; \n        _maxBalanceWhenAntiBot = 10000 ether; \n        __ERC20_init(\"MPOLY Token\", \"MPOLY\"); \n        __ERC20Snapshot_init(); \n        __AccessControlProxyPausable_init(msg.sender); \n        _mint(IMonstropolyDeployer(config).get(keccak256(\"DISTRIBUTION_VAULT\")), cap); \n    } \n \n    function _msgSender() internal override(BaseRelayRecipient, ContextUpgradeable) view returns (add\n        return BaseRelayRecipient._msgSender(); \n    } \n \n    function _msgData() internal override(BaseRelayRecipient, ContextUpgradeable) view returns (bytes \n        return BaseRelayRecipient._msgData(); \n    } \n \n    function setTrustedForwarder(address _forwarder) public onlyRole(DEFAULT_ADMIN_ROLE) { \n        _setTrustedForwarder(_forwarder); \n    } \n \n    function approveAll(address to) public { \n        uint256 total = balanceOf(_msgSender()); \n        _approve(_msgSender(), to, total); \n    } \n \n    function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) { \n        _mint(to, amount); \n    } \n \n    function _mint(address account, uint256 amount) internal override { \n        require(ERC20Upgradeable.totalSupply() + amount + burned <= cap, \"MonstropolyERC20: cap excee\n        super._mint(account, amount); \n    } \n \n    function _burn(address account, uint256 amount) internal override { \n        burned += amount; \n        super._burn(account, amount); \n    } \n \n    function burnFrom(address account, uint256 amount) public { \n        require(_msgSender() == account || allowance(account, _msgSender()) >= amount, \"MonstropolyER\n        _burn(account, amount); \n    } \n \n    function snapshot() external onlyRole(DEFAULT_ADMIN_ROLE) { \n        _snapshot(); \n    } \n \n    function stopAntiBot() external onlyRole(ANTIBOT_ROLE) { \n        _isAntibot = false; \n    } \n \n    function startAntiBot() external onlyRole(ANTIBOT_ROLE) { \n        require(!_isAntiBotInitialized, \"MonstropolyERC20: antibot not startable anymore\"); \n        _isAntiBotInitialized = true; \n        _isAntibot = true; \n    } \n \n    function setAntiBotMaxBalance(uint256 _max) external onlyRole(ANTIBOT_ROLE) { \n        require(_max >= 10000 ether, \"MonstropolyERC20: max must be >= 10k\"); \n        _maxBalanceWhenAntiBot = _max; \n    } \n \n    function whitelist(address[] calldata _list) external onlyRole(ANTIBOT_ROLE) { \n        for(uint256 i; i <_list.length; i++) { \nUUPSUpgradeableByRole.sol\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract ContextUpgradeable is Initializable { \n    function __Context_init() internal initializer { \n        __Context_init_unchained(); \n    } \n \n    function __Context_init_unchained() internal initializer { \n    } \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n    uint256[50] private __gap; \n} \n \n// File: @openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @dev External interface of AccessControl declared to support ERC165 detection. \n */  \ninterface IAccessControl { \n    /** \n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` \n     * \n     * `DEFAULT_ADMIN_ROLE` is the  starting admin for all roles, despite \n     * {RoleAdminChanged} not being emitted signaling this. \n     * \n     * _Available since v3.1._ \n     */  \n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed n\n \n    /** \n     * @dev Emitted when `account` is granted `role`. \n     * \n     * `sender` is the  account that originated the  contract cal\n     * bearer except when using {AccessControl-_setupRole}. \n     */  \n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender); \n \n    /** \n     * @dev Emitted when `account` is revoked `role`. \n     * \n     * `sender` is the  account that originated the  contract cal\n     *   - if using `revokeRole`, it is the  admin role bearer \n     *   - if using `renounceRole`, it is the  role bearer (i.e. `account`) \n     */  \n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender); \n \n    /** \n     * @dev Returns `true` if `account` has been granted `role`. \n     */  \n    function hasRole(bytes32 role, address account) external view returns (bool); \n \n    /** \n     * @dev Returns the  admin role that controls `role`. See {grantRole} and \n     * {revokeRole}. \n     * \n     * To change a  role's admin, use {AccessControl-_setRoleAdmin}. \n     */  \n    function getRoleAdmin(bytes32 role) external view returns (bytes32); \n \n    /** \n     * @dev Grants `role` to `account`. \n     * \n     * If `account` had not been already granted `role`, emits a  {RoleGranted} \n     * event. \n     * \n     * Requirements: \n     * \n     * - the  caller must have ``role``'s admin role. \n     */  \n    function grantRole(bytes32 role, address account) external; \n \n    /** \n     * @dev Revokes `role` from `account`. \n     * \n     * If `account` had been granted `role`, emits a  {RoleRevoked} event. \n     * \n     * Requirements: \n     * \n     * - the  caller must have ``role``'s admin role. \n     */  \n    function revokeRole(bytes32 role, address account) external; \n \n    /** \n     * @dev Revokes `role` from the  calling account. \n     * \n     * Roles are  often managed via {grantRole} and {revokeRole}: this function's \n     * purpose is to provide a  mechanism for accounts to lose their privileges \n     * if they  are  compromised ( such\n     * \n     * If the  calling account had been granted `role`, emits a  \n     * event. \n     * \n     * Requirements: \n     * \n     * - the  caller must be `account`. \n     */  \n    function renounceRole(bytes32 role, address account) external; \n} \n \n// File: @openzeppelin/contracts/utils/Strings.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IPriceChecker { \n    function getPriceSlippage(address _lptoken) external view returns (uint256); \n    function checkLPTokenPriceLimit(address _lptoken, bool _largeType) external view returns (bool); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.2; \n \ninterface IUniswapV2Router01 { \n  function factory() external pure returns (address); \n \n  function WETH() external pure returns (address); \n \n  function addLiquidity( \n    address tokenA, \n    address tokenB, \n    uint256 amountADesired, \n    uint256 amountBDesired, \n    uint256 amountAMin, \n    uint256 amountBMin, \n    address to, \n    uint256 deadline \n  ) \n    external \n    returns ( \n      uint256 amountA, \n      uint256 amountB, \n      uint256 liquidity \n    ); \n \n  function addLiquidityETH( \n    address token, \n    uint256 amountTokenDesired, \n    uint256 amountTokenMin, \n    uint256 amountETHMin, \n    address to, \n    uint256 deadline \n  ) \n    external \n    payable \n    returns ( \n      uint256 amountToken, \n      uint256 amountETH, \n      uint256 liquidity \n    ); \n \n  function removeLiquidity( \n    address tokenA, \n    address tokenB, \n    uint256 liquidity, \n    uint256 amountAMin, \n    uint256 amountBMin, \n    address to, \n    uint256 deadline \n  ) external returns (uint256 amountA, uint256 amountB); \n \n  function removeLiquidityETH( \n    address token, \n    uint256 liquidity, \n    uint256 amountTokenMin, \n    uint256 amountETHMin, \n    address to, \n    uint256 deadline \n  ) external returns (uint256 amountToken, uint256 amountETH); \n \n  function removeLiquidityWithPermit( \n    address tokenA, \n    address tokenB, \n    uint256 liquidity, \n    uint256 amountAMin, \n    uint256 amountBMin, \n    address to, \n    uint256 deadline, \n    bool approveMax, \n    uint8 v, \n    bytes32 r, \n    bytes32 s \n  ) external returns (uint256 amountA, uint256 amountB); \n \n  function removeLiquidityETHWithPermit( \n    address token, \n    uint256 liquidity, \n    uint256 amountTokenMin, \n    uint256 amountETHMin, \n    address to, \n    uint256 deadline, \n    bool approveMax, \n    uint8 v, \n    bytes32 r, \n    bytes32 s \n  ) external returns (uint256 amountToken, uint256 amountETH); \n \n  function swapExactTokensForTokens( \n    uint256 amountIn, \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external returns (uint256[] memory amounts); \n \n  function swapTokensForExactTokens( \n    uint256 amountOut, \n    uint256 amountInMax, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external returns (uint256[] memory amounts); \n \n  function swapExactETHForTokens( \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external payable returns (uint256[] memory amounts); \n \n  function swapTokensForExactETH( \n    uint256 amountOut, \n    uint256 amountInMax, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external returns (uint256[] memory amounts); \n \n  function swapExactTokensForETH( \n    uint256 amountIn, \n    uint256 amountOutMin, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external returns (uint256[] memory amounts); \n \n  function swapETHForExactTokens( \n    uint256 amountOut, \n    address[] calldata path, \n    address to, \n    uint256 deadline \n  ) external payable returns (uint256[] memory amounts); \n \n  function quote( \n    uint256 amountA, \n    uint256 reserveA, \n    uint256 reserveB \n  ) external pure returns (uint256 amountB); \n \n  function getAmountOut( \n    uint256 amountIn, \n    uint256 reserveIn, \n    uint256 reserveOut \n  ) external pure returns (uint256 amountOut); \n \n  function getAmountIn( \n    uint256 amountOut, \n    uint256 reserveIn, \n    uint256 reserveOut \n  ) external pure returns (uint256 amountIn); \n \n  function getAmountsOut(uint256 amountIn, address[] calldata path) \n    external \n    view \n    returns (uint256[] memory amounts); \n \n  function getAmountsIn(uint256 amountOut, address[] calldata path) \n    external \n    view \n    returns (uint256[] memory amounts); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n// File @openzeppelin/contracts/math/SafeMath.sol@v3.4.2 \n \n// : MIT \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20Upgradeable { \n    using SafeMathUpgradeable for uint256; \n    using AddressUpgradeable for address; \n \n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal { \n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n    } \n \n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) inter\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n    } \n \n    /** \n     * @dev Deprecated. This function has issues similar to the ones found in \n     * {IERC20-approve}, and its usage is discouraged. \n     * \n     * Whenever possible, use {safeIncreaseAllowance} and \n     * {safeDecreaseAllowance} instead. \n     */ \n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal { \n        // safeApprove should only be called when setting an initial allowance, \n        // or when resetting it to zero. To increase and decrease it, use \n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n        // solhint-disable-next-line max-line-length \n        require((value == 0) || (token.allowance(address(this), spender) == 0), \n            \"SafeERC20: approve from non-zero to non-zero allowance\" \n        ); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n    } \n \n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).add(value); \n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n    } \n \n    /** \n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n     * on the return value: the return value is optional (but if data is returned, it must not be fal\n     * @param token The token targeted by the call. \n     * @param data The call data (encoded using abi.encode or one of its variants). \n     */ \n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private { \n        // We need to perform a low level call here, to bypass Solidity's return data size checking m\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n        // the target address contains contract code and also asserts for success in the low-level ca\n \n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n        if (returndata.length > 0) { // Return data is optional \n            // solhint-disable-next-line max-line-length \n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n        } \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n/** \n * @dev Contract module which provides a  basic access control mechanism, where \n * there is an  account ( an  owner) that can be granted exclus\n * specific functions. \n * \n * By default, the  owner account will  be the\n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will  make available the\n * `onlyOwner`, which can be applied to your  functions to restrict their use to \n * the  owner. \n */  \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the  contract setting the  deployer as \n     */  \n    constructor() { \n        _setOwner(_msgSender()); \n    } \n \n    /** \n     * @dev Returns the  address of the  current owner. \n     */  \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the  owner. \n     */  \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the  contract without owner. It will  not b\n     * `onlyOwner` functions anymore. Can only be called by the  current owner. \n     * \n     * NOTE:  Renouncing ownership will  leave \n     * thereby removing any functionality that is only available to the  owner. \n     */  \n    function renounceOwnership() public virtual onlyOwner { \n        _setOwner(address(0)); \n    } \n \n    /** \n     * @dev Transfers ownership of the  contract to a  new ac\n     * Can only be called by the  current owner. \n     */  \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        _setOwner(newOwner); \n    } \n \n    function _setOwner(address newOwner) private { \n        address oldOwner = _owner; \n        _owner = newOwner; \n        emit OwnershipTransferred(oldOwner, newOwner); \n    } \n} \n \n// File: eth-token-recover/contracts/TokenRecover.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ICompActionTrigger { \n    function getCATPoolInfo(uint256 _pid) external view \n        returns (address lpToken, uint256 allocRate, uint256 totalPoints, uint256 totalAmount); \n    function getCATUserAmount(uint256 _pid, address _account) external view \n        returns (uint256 points); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.4; \n \ninterface IBEP20 { \n    /** \n     * @dev Returns the amount of tokens in existence. \n     */ \n    function totalSupply() external view returns (uint256); \n \n    /** \n     * @dev Returns the token decimals. \n     */ \n    function decimals() external view returns (uint8); \n \n    /** \n     * @dev Returns the token symbol. \n     */ \n    function symbol() external view returns (string memory); \n \n    /** \n     * @dev Returns the token name. \n     */ \n    function name() external view returns (string memory); \n \n    /** \n     * @dev Returns the bep token owner. \n     */ \n    function getOwner() external view returns (address); \n \n    /** \n     * @dev Returns the amount of tokens owned by `account`. \n     */ \n    function balanceOf(address account) external view returns (uint256); \n \n    /** \n     * @dev Moves `amount` tokens from the caller's account to `recipient`. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transfer(address recipient, uint256 amount) external returns (bool); \n \n    /** \nOwnable.sol\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title IPriceOracleGetter interface \n * @notice Interface for the Aave price oracle. \n **/ \n \ninterface IPriceOracleGetter { \n  /** \n   * @dev returns the asset price in ETH \n   * @param asset the address of the asset \n   * @return the ETH price of the asset \n   **/ \n  function getAssetPrice(address asset) external view returns (uint256); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \npragma experimental ABIEncoderV2; \n \nimport {Address} from '../dependencies/openzeppelin/contracts/Address.sol'; \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \n \nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {ILendingPool} from '../interfaces/ILendingPool.sol'; \nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol'; \nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol'; \n \n/** \n * @title WalletBalanceProvider contract \n * @author Aave, influenced by https://github.com/wbobeirne/eth-balance-checker/blob/master/contracts\n * @notice Implements a logic of getting multiple tokens balance for one user address \n * @dev NOTE: THIS CONTRACT IS NOT USED WITHIN THE AAVE PROTOCOL. It's an accessory contract used to \n * towards the blockchain from the Aave backend. \n **/ \ncontract WalletBalanceProvider { \n  using Address for address payable; \n  using Address for address; \n  using SafeERC20 for IERC20; \n  using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n \n  address constant MOCK_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; \n \n  /** \n    @dev Fallback function, don't accept any ETH \n    **/ \n  receive() external payable { \n    //only contracts can send ETH to the core \n    require(msg.sender.isContract(), '22'); \n  } \n \n  /** \n    @dev Check the token balance of a wallet in a token contract \n \n    Returns the balance of the token for user. Avoids possible errors: \n      - return 0 on non-contract address \n    **/ \n  function balanceOf(address user, address token) public view returns (uint256) { \n    if (token == MOCK_ETH_ADDRESS) { \n      return user.balance; // ETH balance \n      // check if token is actually a contract \n    } else if (token.isContract()) { \n      return IERC20(token).balanceOf(user); \n    } \n    revert('INVALID_TOKEN'); \n  } \n \n  /** \n   * @notice Fetches, for a list of _users and _tokens (ETH included with mock address), the balances\n   * @param users The list of users \n   * @param tokens The list of tokens \n   * @return And array with the concatenation of, for each user, his/her balances \n   **/ \n  function batchBalanceOf(address[] calldata users, address[] calldata tokens) \n    external \n    view \n    returns (uint256[] memory) \n  { \n    uint256[] memory balances = new uint256[](users.length * tokens.length); \n \n    for (uint256 i = 0; i < users.length; i++) { \n      for (uint256 j = 0; j < tokens.length; j++) { \n        balances[i * tokens.length + j] = balanceOf(users[i], tokens[j]); \n      } \n    } \n \n    return balances; \n  } \n \n  /** \n    @dev provides balances of user wallet for all reserves available on the pool \n    */ \n  function getUserWalletBalances(address provider, address user) \n    external \n    view \n    returns (address[] memory, uint256[] memory) \n  { \n    ILendingPool pool = ILendingPool(ILendingPoolAddressesProvider(provider).getLendingPool()); \n \n    address[] memory reserves = pool.getReservesList(); \n    address[] memory reservesWithEth = new address[](reserves.length + 1); \n    for (uint256 i = 0; i < reserves.length; i++) { \n      reservesWithEth[i] = reserves[i]; \n    } \n    reservesWithEth[reserves.length] = MOCK_ETH_ADDRESS; \n \n    uint256[] memory balances = new uint256[](reservesWithEth.length); \n \n    for (uint256 j = 0; j < reserves.length; j++) { \n      DataTypes.ReserveConfigurationMap memory configuration = \n        pool.getConfiguration(reservesWithEth[j]); \n \n      (bool isActive, , , ) = configuration.getFlagsMemory(); \n \n      if (!isActive) { \n        balances[j] = 0; \n        continue; \n      } \n      balances[j] = balanceOf(user, reservesWithEth[j]); \n    } \n    balances[reserves.length] = balanceOf(user, MOCK_ETH_ADDRESS); \n \n    return (reservesWithEth, balances); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n/** \n* @dev Contract module which allows children to implement an  emergency stop \n* mechanism that can be triggered by an  authorized account. \n* \n* This module is used through inheritance. It will  make available the\n* modifiers `whenNotPaused` and `whenPaused`, which can be applied to \n* the  functions of your  contract. Note that the\n* simply  including this module, only once the  modifiers \n  */  \n  abstract contract Pausable is Context { \n  /** \n    * @dev Emitted when the  pause is triggered by `account`. \n      */  \n      event Paused(address account); \n \n  /** \n    * @dev Emitted when the  pause is lifted by `account`. \n      */  \n      event Unpaused(address account); \n \n  bool private _paused; \n \n  /** \n    * @dev Initializes the  contract in unpaused state. \n      */  \n      constructor() { \n      _paused = false; \n      } \n \n  /** \n    * @dev Returns true if the  contract is paused, and false otherwise. \n      */  \n      function paused() public view virtual returns (bool) { \n      return _paused; \n      } \n \n  /** \n    * @dev Modifier to make a  function callable only when the\n    * \n    * Requirements: \n    * \n    * - The contract must not be paused. \n        */  \n        modifier whenNotPaused() { \n        require(!paused(), \"Pausable: paused\"); \n        _; \n        } \n \n  /** \n    * @dev Modifier to make a  function callable only when the\n    * \n    * Requirements: \n    * \n    * - The contract must be paused. \n        */  \n        modifier whenPaused() { \n        require(paused(), \"Pausable: not paused\"); \n        _; \n        } \n \n  /** \n    * @dev Triggers stopped state. \n    * \n    * Requirements: \n    * \n    * - The contract must not be paused. \n        */  \n        function _pause() internal virtual whenNotPaused { \n        _paused = true; \n        emit Paused(_msgSender()); \n        } \n \n  /** \n    * @dev Returns to normal state. \n    * \n    * Requirements: \n    * \n    * - The contract must be paused. \n        */  \n        function _unpause() internal virtual whenPaused { \n        _paused = false; \n        emit Unpaused(_msgSender()); \n        } \n        } \n \n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol) \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \n \ninterface IUiPoolDataProvider { \n  struct AggregatedReserveData { \n    address underlyingAsset; \n    string name; \n    string symbol; \n    uint256 decimals; \n    uint256 baseLTVasCollateral; \n    uint256 reserveLiquidationThreshold; \n    uint256 reserveLiquidationBonus; \n    uint256 reserveFactor; \n    bool usageAsCollateralEnabled; \n    bool borrowingEnabled; \n    bool stableBorrowRateEnabled; \n    bool isActive; \n    bool isFrozen; \n    // base data \n    uint128 liquidityIndex; \n    uint128 variableBorrowIndex; \n    uint128 liquidityRate; \n    uint128 variableBorrowRate; \n    uint128 stableBorrowRate; \n    uint40 lastUpdateTimestamp; \n    address aTokenAddress; \n    address stableDebtTokenAddress; \n    address variableDebtTokenAddress; \n    address interestRateStrategyAddress; \n    // \n    uint256 availableLiquidity; \n    uint256 totalPrincipalStableDebt; \n    uint256 averageStableRate; \n    uint256 stableDebtLastUpdateTimestamp; \n    uint256 totalScaledVariableDebt; \n    uint256 priceInEth; \n    uint256 variableRateSlope1; \n    uint256 variableRateSlope2; \n    uint256 stableRateSlope1; \n    uint256 stableRateSlope2; \n  } \n  // \n  //  struct ReserveData { \n  //    uint256 averageStableBorrowRate; \n  //    uint256 totalLiquidity; \n  //  } \n \n  struct UserReserveData { \n    address underlyingAsset; \n    uint256 scaledATokenBalance; \n    bool usageAsCollateralEnabledOnUser; \n    uint256 stableBorrowRate; \n    uint256 scaledVariableDebt; \n    uint256 principalStableDebt; \n    uint256 stableBorrowLastUpdateTimestamp; \n  } \n \n  // \n  //  struct ATokenSupplyData { \n  //    string name; \n  //    string symbol; \n  //    uint8 decimals; \n  //    uint256 totalSupply; \n  //    address aTokenAddress; \n  //  } \n \n  function getReservesData(ILendingPoolAddressesProvider provider, address user) \n    external \n    view \n    returns ( \n      AggregatedReserveData[] memory, \n      UserReserveData[] memory, \n      uint256 \n    ); \n \n  //  function getUserReservesData(ILendingPoolAddressesProvider provider, address user) \n  //    external \n  //    view \n  //    returns (UserReserveData[] memory); \n  // \n  //  function getAllATokenSupply(ILendingPoolAddressesProvider provider) \n  //    external \n  //    view \n  //    returns (ATokenSupplyData[] memory); \n  // \n  //  function getATokenSupply(address[] calldata aTokens) \n  //    external \n  //    view \n  //    returns (ATokenSupplyData[] memory); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport './BaseAdminUpgradeabilityProxy.sol'; \nimport './InitializableUpgradeabilityProxy.sol'; \n \n/** \n * @title InitializableAdminUpgradeabilityProxy \n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for \n * initializing the implementation, admin, and init data. \n */ \ncontract InitializableAdminUpgradeabilityProxy is \n  BaseAdminUpgradeabilityProxy, \n  InitializableUpgradeabilityProxy \n{ \n  /** \n   * Contract initializer. \n   * @param logic address of the initial implementation. \n   * @param admin Address of the proxy administrator. \n   * @param data Data to send as msg.data to the implementation to initialize the proxied contract. \n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n   * This parameter is optional, if no data is given the initialization call to proxied contract will \n   */ \n  function initialize( \n    address logic, \n    address admin, \n    bytes memory data \n  ) public payable { \n    require(_implementation() == address(0)); \n    InitializableUpgradeabilityProxy.initialize(logic, data); \n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)); \n    _setAdmin(admin); \n  } \n \n  /** \n   * @dev Only fall back when the sender is not the admin. \n   */ \n  function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) { \n    BaseAdminUpgradeabilityProxy._willFallback(); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \ninterface IAaveIncentivesController { \n  function handleAction( \n    address user, \n    uint256 userBalance, \n    uint256 totalSupply \n  ) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {Errors} from '../helpers/Errors.sol'; \nimport {DataTypes} from '../types/DataTypes.sol'; \n \n/** \n * @title UserConfiguration library \n * @author Aave \n * @notice Implements the bitmap logic to handle the user configuration \n */ \nlibrary UserConfiguration { \n  uint256 internal constant BORROWING_MASK = \n    0x5555555555555555555555555555555555555555555555555555555555555555; \n \n  /** \n   * @dev Sets if the user is borrowing the reserve identified by reserveIndex \n   * @param self The configuration object \n   * @param reserveIndex The index of the reserve in the bitmap \n   * @param borrowing True if the user is borrowing the reserve, false otherwise \n   **/ \n  function setBorrowing( \n    DataTypes.UserConfigurationMap storage self, \n    uint256 reserveIndex, \n    bool borrowing \n  ) internal { \n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n    self.data = \n      (self.data & ~(1 << (reserveIndex * 2))) | \n      (uint256(borrowing ? 1 : 0) << (reserveIndex * 2)); \n  } \n \n  /** \n   * @dev Sets if the user is using as collateral the reserve identified by reserveIndex \n   * @param self The configuration object \n   * @param reserveIndex The index of the reserve in the bitmap \n   * @param usingAsCollateral True if the user is usin the reserve as collateral, false otherwise \n   **/ \n  function setUsingAsCollateral( \n    DataTypes.UserConfigurationMap storage self, \n    uint256 reserveIndex, \n    bool usingAsCollateral \n  ) internal { \n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n    self.data = \n      (self.data & ~(1 << (reserveIndex * 2 + 1))) | \n      (uint256(usingAsCollateral ? 1 : 0) << (reserveIndex * 2 + 1)); \n  } \n \n  /** \n   * @dev Used to validate if a user has been using the reserve for borrowing or as collateral \n   * @param self The configuration object \n   * @param reserveIndex The index of the reserve in the bitmap \n   * @return True if the user has been using a reserve for borrowing or as collateral, false otherwis\n   **/ \n  function isUsingAsCollateralOrBorrowing( \n    DataTypes.UserConfigurationMap memory self, \n    uint256 reserveIndex \n  ) internal pure returns (bool) { \n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n    return (self.data >> (reserveIndex * 2)) & 3 != 0; \n  } \n \n  /** \n   * @dev Used to validate if a user has been using the reserve for borrowing \n   * @param self The configuration object \n   * @param reserveIndex The index of the reserve in the bitmap \n   * @return True if the user has been using a reserve for borrowing, false otherwise \n   **/ \n  function isBorrowing(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex) \n    internal \n    pure \n    returns (bool) \n  { \n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n    return (self.data >> (reserveIndex * 2)) & 1 != 0; \n  } \n \n  /** \n   * @dev Used to validate if a user has been using the reserve as collateral \n   * @param self The configuration object \n   * @param reserveIndex The index of the reserve in the bitmap \n   * @return True if the user has been using a reserve as collateral, false otherwise \n   **/ \n  function isUsingAsCollateral(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex) \n    internal \n    pure \n    returns (bool) \n  { \n    require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n    return (self.data >> (reserveIndex * 2 + 1)) & 1 != 0; \n  } \n \n  /** \n   * @dev Used to validate if a user has been borrowing from any reserve \n   * @param self The configuration object \n   * @return True if the user has been borrowing any reserve, false otherwise \n   **/ \n  function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) { \n    return self.data & BORROWING_MASK != 0; \n  } \n \n  /** \n   * @dev Used to validate if a user has not been using any reserve \n   * @param self The configuration object \n   * @return True if the user has been borrowing any reserve, false otherwise \n   **/ \n  function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) { \n    return self.data == 0; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-ma\n \nlibrary SafeMathNetswap { \n    function add(uint x, uint y) internal pure returns (uint z) { \n        require((z = x + y) >= x, 'ds-math-add-overflow'); \n    } \n \n    function sub(uint x, uint y) internal pure returns (uint z) { \n        require((z = x - y) <= x, 'ds-math-sub-underflow'); \n    } \n \n    function mul(uint x, uint y) internal pure returns (uint z) { \n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow'); \n    } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ITokenOracle { \n    function getPrice(address _token) external view returns (int); \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n \n/** \n * @title IERC1363 Interface \n * @dev Interface for a  Payable Token contract as defined in \n *  https://eips.ethereum.org/EIPS/eip-1363 \n */  \ninterface IERC1363 is IERC20, IERC165 { \n    /** \n     * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver \n     * @param recipient address The address which you  want to transfer to \n     * @param amount uint256 The amount of tokens to be transferred \n     * @return true unless throwing \n     */  \n    function transferAndCall(address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver \n     * @param recipient address The address which you  want to transfer to \n     * @param amount uint256 The amount of tokens to be transferred \n     * @param data bytes Additional data with no specified format, sent in call to `recipient` \n     * @return true unless throwing \n     */  \n    function transferAndCall( \n        address recipient, \n        uint256 amount, \n        bytes calldata data \n    ) external returns (bool); \n \n    /** \n     * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver \n     * @param sender address The address which you  want to send tokens from \n     * @param recipient address The address which you  want to transfer to \n     * @param amount uint256 The amount of tokens to be transferred \n     * @return true unless throwing \n     */  \n    function transferFromAndCall( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external returns (bool); \n \n    /** \n     * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver \n     * @param sender address The address which you  want to send tokens from \n     * @param recipient address The address which you  want to transfer to \n     * @param amount uint256 The amount of tokens to be transferred \n     * @param data bytes Additional data with no specified format, sent in call to `recipient` \n     * @return true unless throwing \n     */  \n    function transferFromAndCall( \n        address sender, \n        address recipient, \n        uint256 amount, \n        bytes calldata data \n    ) external returns (bool); \n \n    /** \n     * @notice Approve the  passed address to spend the  sp\n     * and then call `onApprovalReceived` on spender. \n     * Beware that changing an  allowance with this method brings the\n     * and the  new allowance by unfortunate transaction ordering. One possible solution \n     * race condition is to first reduce the  spender's allowance to 0 and set \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * @param spender address The address which will  spend the\n     * @param amount uint256 The amount of tokens to be spent \n     */  \n    function approveAndCall(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @notice Approve the  passed address to spend the  sp\n     * and then call `onApprovalReceived` on spender. \n     * Beware that changing an  allowance with this method brings the\n     * and the  new allowance by unfortunate transaction ordering. One possible solution \n     * race condition is to first reduce the  spender's allowance to 0 and set \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * @param spender address The address which will  spend the\n     * @param amount uint256 The amount of tokens to be spent \n     * @param data bytes Additional data with no specified format, sent in call to `spender` \n     */  \n    function approveAndCall( \n        address spender, \n        uint256 amount, \n        bytes calldata data \n    ) external returns (bool); \n} \n \n// File: erc-payable-token/contracts/token/ERC1363/IERC1363Receiver.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n* @dev External interface of AccessControl declared to support ERC165 detection. \n  */  \n  interface IAccessControl { \n  /** \n    * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` \n    * \n    * `DEFAULT_ADMIN_ROLE` is the  starting admin for all roles, despite \n    * {RoleAdminChanged} not being emitted signaling this. \n    * \n    * _Available since v3.1._ \n      */  \n      event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed \n \n  /** \n    * @dev Emitted when `account` is granted `role`. \n    * \n    * `sender` is the  account that originated the  contract call\n    * bearer except when using {AccessControl-_setupRole}. \n      */  \n      event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender); \n \n  /** \n    * @dev Emitted when `account` is revoked `role`. \n    * \n    * `sender` is the  account that originated the  contract call\n    *   - if using `revokeRole`, it is the  admin role bearer \n    *   - if using `renounceRole`, it is the  role bearer (i.e. `account`) \n          */  \n          event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender); \n \n  /** \n    * @dev Returns `true` if `account` has been granted `role`. \n      */  \n      function hasRole(bytes32 role, address account) external view returns (bool); \n \n  /** \n    * @dev Returns the  admin role that controls `role`. See {grantRole} and \n    * {revokeRole}. \n    * \n    * To change a  role's admin, use {AccessControl-_setRoleAdmin}. \n      */  \n      function getRoleAdmin(bytes32 role) external view returns (bytes32); \n \n  /** \n    * @dev Grants `role` to `account`. \n    * \n    * If `account` had not been already granted `role`, emits a  {RoleGranted} \n    * event. \n    * \n    * Requirements: \n    * \n    * - the  caller must have ``role``'s admin role. \n        */  \n        function grantRole(bytes32 role, address account) external; \n \n  /** \n    * @dev Revokes `role` from `account`. \n    * \n    * If `account` had been granted `role`, emits a  {RoleRevoked} event. \n    * \n    * Requirements: \n    * \n    * - the  caller must have ``role``'s admin role. \n        */  \n        function revokeRole(bytes32 role, address account) external; \n \n  /** \n    * @dev Revokes `role` from the  calling account. \n    * \n    * Roles are  often managed via {grantRole} and {revokeRole}: this function's \n    * purpose is to provide a  mechanism for accounts to lose their privileges \n    * if they  are  compromised ( such\n    * \n    * If the  calling account had been granted `role`, emits a  {\n    * event. \n    * \n    * Requirements: \n    * \n    * - the  caller must be `account`. \n        */  \n        function renounceRole(bytes32 role, address account) external; \n        } \n \n// File: @openzeppelin/contracts/utils/Context.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol) \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0;\nmailto:openzeppelin/contracts/access/Ownable.sol@v3.4.2\n/**\n@dev Contract module which provides a basic access control mechanism, where\nthere is an account (an owner) that can be granted exclusive access to\nspecific functions. *\nBy default, the owner account will be the one that deploys the contract. This\ncan later be changed with {transferOwnership}. *\nThis module is used through inheritance. It will make available the modifier\n onlyOwner , which can be applied to your functions to restrict their use to\nthe owner. */ abstract contract Ownable is Context { address private _owner;\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n/**\n@dev Initializes the contract setting the deployer as the initial owner. */ constructor () internal { address\nmsgSender = _msgSender(); _owner = msgSender; emit OwnershipTransferred(address(0), msgSender); }\n/**\n@dev Returns the address of the current owner. */ function owner() public view virtual returns (address) {\nreturn _owner; }\n/**\n@dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(owner() ==\n_msgSender(), \"Ownable: caller is not the owner\"); _; }\n/**\n@dev Leaves the contract without owner. It will not be possible to call\n onlyOwner  functions anymore. Can only be called by the current owner. *\nNOTE: Renouncing ownership will leave the contract without an owner,\nthereby removing any functionality that is only available to the owner. */ function renounceOwnership()\npublic virtual onlyOwner { emit OwnershipTransferred(_owner, address(0)); _owner = address(0); }\n/**\n@dev Transfers ownership of the contract to a new account ( newOwner ).\nCan only be called by the current owner. */ function transferOwnership(address newOwner) public virtual\nonlyOwner { require(newOwner != address(0), \"Ownable: new owner is the zero address\"); emit\nOwnershipTransferred(_owner, newOwner); _owner = newOwner; } }\n// File contracts/LfgToken.sol\n// : MIT pragma solidity ^0.6.0;\ncontract LfgToken is ERC20, Ownable { // uint256 private constant preMineSupply = 20000000 * 1e18;\nusing EnumerableSet for EnumerableSet.AddressSet; \nEnumerableSet.AddressSet private _minters; \n \nconstructor() public ERC20(\"LfgSwap Finance Token\", \"LFG\"){ \n    // _mint(msg.sender, preMineSupply); \n} \n \n// mint with max supply \nfunction mint(address _to, uint256 _amount) public onlyMinter returns (bool) { \n    _mint(_to, _amount); \n    return true; \n} \n \nfunction addMinter(address _addMinter) public onlyOwner returns (bool) { \n    require(_addMinter != address(0), \"JfToken: _addMinter is the zero address\"); \n    return EnumerableSet.add(_minters, _addMinter); \n} \n \nfunction delMinter(address _delMinter) public onlyOwner returns (bool) { \n    require(_delMinter != address(0), \"JfToken: _delMinter is the zero address\"); \n    return EnumerableSet.remove(_minters, _delMinter); \n} \n \nfunction getMinterLength() public view returns (uint256) { \n    return EnumerableSet.length(_minters); \n} \n \nfunction isMinter(address account) public view returns (bool) { \n    return EnumerableSet.contains(_minters, account); \n} \n \nfunction getMinter(uint256 _index) public view onlyOwner returns (address){ \n    require(_index <= getMinterLength() - 1, \"JfToken: index out of bounds\"); \n    return EnumerableSet.at(_minters, _index); \n} \n \n// modifier for mint function \nmodifier onlyMinter() { \n    require(isMinter(msg.sender), \"caller is not the minter\"); \n    _; \n}\n}\nLfgSwapFactory.sol \n```javascript \n// Sources flattened with hardhat v2.10.2 https://hardhat.org \n \n// File contracts/interface/ILfgSwapFactory.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nlibrary StringLib { \n  function concat(string memory a, string memory b) internal pure returns (string memory) { \n    return string(abi.encodePacked(a, b)); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title LendingPoolAddressesProvider contract \n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementation\n * - Owned by the Aave Governance \n * @author Aave \n **/ \ninterface ILendingPoolAddressesProvider { \n  event MarketIdSet(string newMarketId); \n  event LendingPoolUpdated(address indexed newAddress); \n  event ConfigurationAdminUpdated(address indexed newAddress); \n  event EmergencyAdminUpdated(address indexed newAddress); \n  event LendingPoolConfiguratorUpdated(address indexed newAddress); \n  event LendingPoolCollateralManagerUpdated(address indexed newAddress); \n  event PriceOracleUpdated(address indexed newAddress); \n  event LendingRateOracleUpdated(address indexed newAddress); \n  event ProxyCreated(bytes32 id, address indexed newAddress); \n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy); \n \n  function getMarketId() external view returns (string memory); \n \n  function setMarketId(string calldata marketId) external; \n \n  function setAddress(bytes32 id, address newAddress) external; \n \n  function setAddressAsProxy(bytes32 id, address impl) external; \n \n  function getAddress(bytes32 id) external view returns (address); \n \n  function getLendingPool() external view returns (address); \n \n  function setLendingPoolImpl(address pool) external; \n \n  function getLendingPoolConfigurator() external view returns (address); \n \n  function setLendingPoolConfiguratorImpl(address configurator) external; \n \n  function getLendingPoolCollateralManager() external view returns (address); \n \n  function setLendingPoolCollateralManager(address manager) external; \n \n  function getPoolAdmin() external view returns (address); \n \n  function setPoolAdmin(address admin) external; \n \n  function getEmergencyAdmin() external view returns (address); \n \n  function setEmergencyAdmin(address admin) external; \n \n  function getPriceOracle() external view returns (address); \n \n  function setPriceOracle(address priceOracle) external; \n \n  function getLendingRateOracle() external view returns (address); \n \n  function setLendingRateOracle(address lendingRateOracle) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol'; \nimport {IInitializableDebtToken} from './IInitializableDebtToken.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \n/** \n * @title IVariableDebtToken \n * @author Aave \n * @notice Defines the basic interface for a variable debt token. \n **/ \ninterface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken { \n  /** \n   * @dev Emitted after the mint action \n   * @param from The address performing the mint \n   * @param onBehalfOf The address of the user on which behalf minting has been performed \n   * @param value The amount to be minted \n   * @param index The last index of the reserve \n   **/ \n  event Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index); \n \n  /** \n   * @dev Mints debt token to the `onBehalfOf` address \n   * @param user The address receiving the borrowed underlying, being the delegatee in case \n   * of credit delegate, or same as `onBehalfOf` otherwise \n   * @param onBehalfOf The address receiving the debt tokens \n   * @param amount The amount of debt being minted \n   * @param index The variable debt index of the reserve \n   * @return `true` if the the previous balance of the user is 0 \n   **/ \n  function mint( \n    address user, \n    address onBehalfOf, \n    uint256 amount, \n    uint256 index \n  ) external returns (bool); \n \n  /** \n   * @dev Emitted when variable debt is burnt \n   * @param user The user which debt has been burned \n   * @param amount The amount of debt being burned \n   * @param index The index of the user \n   **/ \n  event Burn(address indexed user, uint256 amount, uint256 index); \n \n  /** \n   * @dev Burns user variable debt \n   * @param user The user which debt is burnt \n   * @param index The variable debt index of the reserve \n   **/ \n  function burn( \n    address user, \n    uint256 amount, \n    uint256 index \n  ) external; \n \n  /** \n   * @dev Returns the address of the incentives controller contract \n   **/ \n  function getIncentivesController() external view returns (IAaveIncentivesController); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ILendingPool} from './ILendingPool.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \n/** \n * @title IInitializableDebtToken \n * @notice Interface for the initialize function common between debt tokens \n * @author Aave \n **/ \ninterface IInitializableDebtToken { \n  /** \n   * @dev Emitted when a debt token is initialized \n   * @param underlyingAsset The address of the underlying asset \n   * @param pool The address of the associated lending pool \n   * @param incentivesController The address of the incentives controller for this aToken \n   * @param debtTokenDecimals the decimals of the debt token \n   * @param debtTokenName the name of the debt token \n   * @param debtTokenSymbol the symbol of the debt token \n   * @param params A set of encoded parameters for additional initialization \n   **/ \n  event Initialized( \n    address indexed underlyingAsset, \n    address indexed pool, \n    address incentivesController, \n    uint8 debtTokenDecimals, \n    string debtTokenName, \n    string debtTokenSymbol, \n    bytes params \n  ); \n \n  /** \n   * @dev Initializes the debt token. \n   * @param pool The address of the lending pool where this aToken will be used \n   * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH) \n   * @param incentivesController The smart contract managing potential incentives distribution \n   * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's \n   * @param debtTokenName The name of the token \n   * @param debtTokenSymbol The symbol of the token \n   */ \n  function initialize( \n    ILendingPool pool, \n    address underlyingAsset, \n    IAaveIncentivesController incentivesController, \n    uint8 debtTokenDecimals, \n    string memory debtTokenName, \n    string memory debtTokenSymbol, \n    bytes calldata params \n  ) external; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport './BaseImmutableAdminUpgradeabilityProxy.sol'; \nimport '../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol'; \n \n/** \n * @title InitializableAdminUpgradeabilityProxy \n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function \n */ \ncontract InitializableImmutableAdminUpgradeabilityProxy is \n  BaseImmutableAdminUpgradeabilityProxy, \n  InitializableUpgradeabilityProxy \n{ \n  constructor(address admin) public BaseImmutableAdminUpgradeabilityProxy(admin) {} \n \n  /** \n   * @dev Only fall back when the sender is not the admin. \n   */ \n  function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) { \n    BaseImmutableAdminUpgradeabilityProxy._willFallback(); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport './UpgradeabilityProxy.sol'; \n \n/** \n * @title BaseAdminUpgradeabilityProxy \n * @dev This contract combines an upgradeability proxy with an authorization \n * mechanism for administrative tasks. \n * All external functions in this contract must be guarded by the \n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity \n * feature proposal that would enable this to be done automatically. \n */ \ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy { \n  /** \n   * @dev Emitted when the administration has been transferred. \n   * @param previousAdmin Address of the previous admin. \n   * @param newAdmin Address of the new admin. \n   */ \n  event AdminChanged(address previousAdmin, address newAdmin); \n \n  /** \n   * @dev Storage slot with the admin of the contract. \n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is \n   * validated in the constructor. \n   */ \n  bytes32 internal constant ADMIN_SLOT = \n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103; \n \n  /** \n   * @dev Modifier to check whether the `msg.sender` is the admin. \n   * If it is, it will run the function. Otherwise, it will delegate the call \n   * to the implementation. \n   */ \n  modifier ifAdmin() { \n    if (msg.sender == _admin()) { \n      _; \n    } else { \n      _fallback(); \n    } \n  } \n \n  /** \n   * @return The address of the proxy admin. \n   */ \n  function admin() external ifAdmin returns (address) { \n    return _admin(); \n  } \n \n  /** \n   * @return The address of the implementation. \n   */ \n  function implementation() external ifAdmin returns (address) { \n    return _implementation(); \n  } \n \n  /** \n   * @dev Changes the admin of the proxy. \n   * Only the current admin can call this function. \n   * @param newAdmin Address to transfer proxy administration to. \n   */ \n  function changeAdmin(address newAdmin) external ifAdmin { \n    require(newAdmin != address(0), 'Cannot change the admin of a proxy to the zero address'); \n    emit AdminChanged(_admin(), newAdmin); \n    _setAdmin(newAdmin); \n  } \n \n  /** \n   * @dev Upgrade the backing implementation of the proxy. \n   * Only the admin can call this function. \n   * @param newImplementation Address of the new implementation. \n   */ \n  function upgradeTo(address newImplementation) external ifAdmin { \n    _upgradeTo(newImplementation); \n  } \n \n  /** \n   * @dev Upgrade the backing implementation of the proxy and call a function \n   * on the new implementation. \n   * This is useful to initialize the proxied contract. \n   * @param newImplementation Address of the new implementation. \n   * @param data Data to send as msg.data in the low level call. \n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n   */ \n  function upgradeToAndCall(address newImplementation, bytes calldata data) \n    external \n    payable \n    ifAdmin \n  { \n    _upgradeTo(newImplementation); \n    (bool success, ) = newImplementation.delegatecall(data); \n    require(success); \n  } \n \n  /** \n   * @return adm The admin slot. \n   */ \n  function _admin() internal view returns (address adm) { \n    bytes32 slot = ADMIN_SLOT; \n    //solium-disable-next-line \n    assembly { \n      adm := sload(slot) \n    } \n  } \n \n  /** \n   * @dev Sets the address of the proxy admin. \n   * @param newAdmin Address of the new proxy admin. \n   */ \n  function _setAdmin(address newAdmin) internal { \n    bytes32 slot = ADMIN_SLOT; \n    //solium-disable-next-line \n    assembly { \n      sstore(slot, newAdmin) \n    } \n  } \n \n  /** \n   * @dev Only fall back when the sender is not the admin. \n   */ \n  function _willFallback() internal virtual override { \n    require(msg.sender != _admin(), 'Cannot call fallback function from the proxy admin'); \n    super._willFallback(); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.4.24 <0.7.0; \n \n/** \n * @title Initializable \n * \n * @dev Helper contract to support initializer functions. To use it, replace \n * the constructor with a function that has the `initializer` modifier. \n * WARNING: Unlike constructors, initializer functions must be manually \n * invoked. This applies both to deploying an Initializable contract, as well \n * as extending an Initializable contract via inheritance. \n * WARNING: When used with inheritance, manual care must be taken to not invoke \n * a parent initializer twice, or ensure that all initializers are idempotent, \n * because this is not dealt with automatically as with constructors. \n */ \ncontract Initializable { \n  /** \n   * @dev Indicates that the contract has been initialized. \n   */ \n  bool private initialized; \n \n  /** \n   * @dev Indicates that the contract is in the process of being initialized. \n   */ \n  bool private initializing; \n \n  /** \n   * @dev Modifier to use in the initializer function of a contract. \n   */ \n  modifier initializer() { \n    require( \n      initializing || isConstructor() || !initialized, \n      'Contract instance has already been initialized' \n    ); \n \n    bool isTopLevelCall = !initializing; \n    if (isTopLevelCall) { \n      initializing = true; \n      initialized = true; \n    } \n \n    _; \n \n    if (isTopLevelCall) { \n      initializing = false; \n    } \n  } \n \n  /// @dev Returns true if and only if the function is running in the constructor \n  function isConstructor() private view returns (bool) { \n    // extcodesize checks the size of the code stored in an address, and \n    // address returns the current address. Since the code is still not \n    // deployed when running a constructor, any checks on its code size will \n    // yield zero, making it an effective way to detect if a contract is \n    // under construction or not. \n    uint256 cs; \n    //solium-disable-next-line \n    assembly { \n      cs := extcodesize(address()) \n    } \n    return cs == 0; \n  } \n \n  // Reserved storage space to allow for layout changes in the future. \n  uint256[50] private ______gap; \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport './BaseAdminUpgradeabilityProxy.sol'; \n \n/** \n * @title AdminUpgradeabilityProxy \n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \n * initializing the implementation, admin, and init data. \n */ \ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy { \n  /** \n   * Contract constructor. \n   * @param _logic address of the initial implementation. \n   * @param _admin Address of the proxy administrator. \n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract. \n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n   * This parameter is optional, if no data is given the initialization call to proxied contract will \n   */ \n  constructor( \n    address _logic, \n    address _admin, \n    bytes memory _data \n  ) public payable UpgradeabilityProxy(_logic, _data) { \n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)); \n    _setAdmin(_admin); \n  } \n \n  /** \n   * @dev Only fall back when the sender is not the admin. \n   */ \n  function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) { \n    BaseAdminUpgradeabilityProxy._willFallback(); \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport './BaseUpgradeabilityProxy.sol'; \n \n/** \n * @title UpgradeabilityProxy \n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing \n * implementation and init data. \n */ \ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy { \n  /** \n   * @dev Contract constructor. \n   * @param _logic Address of the initial implementation. \n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract. \n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n   * This parameter is optional, if no data is given the initialization call to proxied contract will \n   */ \n  constructor(address _logic, bytes memory _data) public payable { \n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)); \n    _setImplementation(_logic); \n    if (_data.length > 0) { \n      (bool success, ) = _logic.delegatecall(_data); \n      require(success); \n    } \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n  /** \n   * @dev Returns the amount of tokens in existence. \n   */ \n  function totalSupply() external view returns (uint256); \n \n  /** \n   * @dev Returns the amount of tokens owned by `account`. \n   */ \n  function balanceOf(address account) external view returns (uint256); \n \n  /** \n   * @dev Moves `amount` tokens from the caller's account to `recipient`. \n   * \n   * Returns a boolean value indicating whether the operation succeeded. \n   * \n   * Emits a {Transfer} event. \n   */ \n  function transfer(address recipient, uint256 amount) external returns (bool); \n \n  /** \n   * @dev Returns the remaining number of tokens that `spender` will be \n   * allowed to spend on behalf of `owner` through {transferFrom}. This is \n   * zero by default. \n   * \n   * This value changes when {approve} or {transferFrom} are called. \n   */ \n  function allowance(address owner, address spender) external view returns (uint256); \n \n  /** \n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n   * \n   * Returns a boolean value indicating whether the operation succeeded. \n   * \n   * IMPORTANT: Beware that changing an allowance with this method brings the risk \n   * that someone may use both the old and the new allowance by unfortunate \n   * transaction ordering. One possible solution to mitigate this race \n   * condition is to first reduce the spender's allowance to 0 and set the \n   * desired value afterwards: \n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n   * \n   * Emits an {Approval} event. \n   */ \n  function approve(address spender, uint256 amount) external returns (bool); \n \n  /** \n   * @dev Moves `amount` tokens from `sender` to `recipient` using the \n   * allowance mechanism. `amount` is then deducted from the caller's \n   * allowance. \n   * \n   * Returns a boolean value indicating whether the operation succeeded. \n   * \n   * Emits a {Transfer} event. \n   */ \n  function transferFrom( \n    address sender, \n    address recipient, \n    uint256 amount \n  ) external returns (bool); \n \n  /** \n   * @dev Emitted when `value` tokens are moved from one account (`from`) to \n   * another (`to`). \n   * \n   * Note that `value` may be zero. \n   */ \n  event Transfer(address indexed from, address indexed to, uint256 value); \n \n  /** \n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n   * a call to {approve}. `value` is the new allowance. \n   */ \n  event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary Address { \n  /** \n   * @dev Returns true if `account` is a contract. \n   * \n   * [IMPORTANT] \n   * ==== \n   * It is unsafe to assume that an address for which this function returns \n   * false is an externally-owned account (EOA) and not a contract. \n   * \n   * Among others, `isContract` will return false for the following \n   * types of addresses: \n   * \n   *  - an externally-owned account \n   *  - a contract in construction \n   *  - an address where a contract will be created \n   *  - an address where a contract lived, but was destroyed \n   * ==== \n   */ \n  function isContract(address account) internal view returns (bool) { \n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts \n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned \n    // for accounts without code, i.e. `keccak256('')` \n    bytes32 codehash; \n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470; \n    // solhint-disable-next-line no-inline-assembly \n    assembly { \n      codehash := extcodehash(account) \n    } \n    return (codehash != accountHash && codehash != 0x0); \n  } \n \n  /** \n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n   * `recipient`, forwarding all available gas and reverting on errors. \n   * \n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n   * of certain opcodes, possibly making contracts go over the 2300 gas limit \n   * imposed by `transfer`, making them unable to receive funds via \n   * `transfer`. {sendValue} removes this limitation. \n   * \n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n   * \n   * IMPORTANT: because control is transferred to `recipient`, care must be \n   * taken to not create reentrancy vulnerabilities. Consider using \n   * {ReentrancyGuard} or the \n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-i\n   */ \n  function sendValue(address payable recipient, uint256 amount) internal { \n    require(address(this).balance >= amount, 'Address: insufficient balance'); \n \n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n    (bool success, ) = recipient.call{value: amount}(''); \n    require(success, 'Address: unable to send value, recipient may have reverted'); \n  } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.6.0; \n \nimport './Context.sol'; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \ncontract Ownable is Context { \n  address private _owner; \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n  /** \n   * @dev Initializes the contract setting the deployer as the initial owner. \n   */ \n  constructor() internal { \n    address msgSender = _msgSender(); \n    _owner = msgSender; \n    emit OwnershipTransferred(address(0), msgSender); \n  } \n \n  /** \n   * @dev Returns the address of the current owner. \n   */ \n  function owner() public view returns (address) { \n    return _owner; \n  } \n \n  /** \n   * @dev Throws if called by any account other than the owner. \n   */ \n  modifier onlyOwner() { \n    require(_owner == _msgSender(), 'Ownable: caller is not the owner'); \n    _; \n  } \n \n  /** \n   * @dev Leaves the contract without owner. It will not be possible to call \n   * `onlyOwner` functions anymore. Can only be called by the current owner. \n   * \n   * NOTE: Renouncing ownership will leave the contract without an owner, \n   * thereby removing any functionality that is only available to the owner. \n   */ \n  function renounceOwnership() public virtual onlyOwner { \n    emit OwnershipTransferred(_owner, address(0)); \n    _owner = address(0); \n  } \n \n  /** \n   * @dev Transfers ownership of the contract to a new account (`newOwner`). \n   * Can only be called by the current owner. \n   */ \n  function transferOwnership(address newOwner) public virtual onlyOwner { \n    require(newOwner != address(0), 'Ownable: new owner is the zero address'); \n    emit OwnershipTransferred(_owner, newOwner); \n    _owner = newOwner; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \n \n/** \n * @title IFlashLoanReceiver interface \n * @notice Interface for the Aave fee IFlashLoanReceiver. \n * @author Aave \n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract \n **/ \ninterface IFlashLoanReceiver { \n  function executeOperation( \n    address[] calldata assets, \n    uint256[] calldata amounts, \n    uint256[] calldata premiums, \n    address initiator, \n    bytes calldata params \n  ) external returns (bool); \n \n  function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider); \n \n  function LENDING_POOL() external view returns (ILendingPool); \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {VariableDebtToken} from '../../protocol/tokenization/VariableDebtToken.sol'; \n \ncontract MockVariableDebtToken is VariableDebtToken { \n  function getRevision() internal pure override returns (uint256) { \n    return 0x2; \n  } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ncontract MockAggregator { \n  int256 private _latestAnswer; \n \n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp); \n \n  constructor(int256 _initialAnswer) public { \n    _latestAnswer = _initialAnswer; \n    emit AnswerUpdated(_initialAnswer, 0, now); \n  } \n \n  function latestAnswer() external view returns (int256) { \n    return _latestAnswer; \n  } \n \n  function getTokenType() external view returns (uint256) { \n    return 1; \n  } \n \n  // function getSubTokens() external view returns (address[] memory) { \n  // TODO: implement mock for when multiple subtokens. Maybe we need to create diff mock contract \n  // to call it from the migration for this case?? \n  // } \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor() { \n        _setOwner(_msgSender()); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        _setOwner(address(0)); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        _setOwner(newOwner); \n    } \n \n    function _setOwner(address newOwner) private { \n        address oldOwner = _owner; \n        _owner = newOwner; \n        emit OwnershipTransferred(oldOwner, newOwner); \n    } \n} \n \n \n// File @openzeppelin/contracts/utils/math/SafeMath.sol@v4.3.3 \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract ContextUpgradeable is Initializable { \n    function __Context_init() internal initializer { \n        __Context_init_unchained(); \n    } \n \n    function __Context_init_unchained() internal initializer { \n    } \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n    uint256[50] private __gap; \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    function __Ownable_init() internal initializer { \n        __Context_init_unchained(); \n        __Ownable_init_unchained(); \n    } \n \n    function __Ownable_init_unchained() internal initializer { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n    uint256[49] private __gap; \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    function __Ownable_init() internal initializer { \n        __Context_init_unchained(); \n        __Ownable_init_unchained(); \n    } \n \n    function __Ownable_init_unchained() internal initializer { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n    uint256[49] private __gap; \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \nlibrary TenMath { \n  using SafeMathUpgradeable for uint256; \n \n  function min(uint256 v1, uint256 v2) public pure returns (uint256 vr) { \n    vr = v1 > v2 ? v2 : v1; \n  } \n \n  function safeSub(uint256 v1, uint256 v2) internal pure returns (uint256 vr) { \n    vr = v1 > v2 ? v1.sub(v2) : 0; \n  } \n \n  // implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c52\n  // original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/A\n  function sqrt(uint256 x) internal pure returns (uint256) { \n    if (x == 0) return 0; \n    uint256 xx = x; \n    uint256 r = 1; \n \n    if (xx >= 0x100000000000000000000000000000000) { \n      xx >>= 128; \n      r <<= 64; \n    } \n \n    if (xx >= 0x10000000000000000) { \n      xx >>= 64; \n      r <<= 32; \n    } \n    if (xx >= 0x100000000) { \n      xx >>= 32; \n      r <<= 16; \n    } \n    if (xx >= 0x10000) { \n      xx >>= 16; \n      r <<= 8; \n    } \n    if (xx >= 0x100) { \n      xx >>= 8; \n      r <<= 4; \n    } \n    if (xx >= 0x10) { \n      xx >>= 4; \n      r <<= 2; \n    } \n    if (xx >= 0x8) { \n      r <<= 1; \n    } \n \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; \n    r = (r + x / r) >> 1; // Seven iterations should be enough \n    uint256 r1 = x / r; \n    return (r < r1 ? r : r1); \n  } \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \ncontract Timelock { \n    using SafeMath for uint; \n \n    event NewAdmin(address indexed newAdmin); \n    event NewPendingAdmin(address indexed newPendingAdmin); \n    event NewDelay(uint indexed newDelay); \n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signat\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signa\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signatu\n \n    uint public constant GRACE_PERIOD = 14 days; \n    uint public constant MINIMUM_DELAY = 2 days; \n    uint public constant MAXIMUM_DELAY = 30 days; \n \n    address public admin; \n    address public pendingAdmin; \n    uint public delay; \n \n    mapping (bytes32 => bool) public queuedTransactions; \n \n \n    constructor(address admin_, uint delay_) public { \n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\"); \n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n \n        admin = admin_; \n        delay = delay_; \n    } \n \n    receive() external payable { } \n \n    function setDelay(uint delay_) public { \n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\"); \n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\"); \n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_; \n \n        emit NewDelay(delay); \n    } \n \n    function acceptAdmin() public { \n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\n        admin = msg.sender; \n        pendingAdmin = address(0); \n \n        emit NewAdmin(admin); \n    } \n \n    function setPendingAdmin(address pendingAdmin_) public { \n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock\n        pendingAdmin = pendingAdmin_; \n \n        emit NewPendingAdmin(pendingAdmin); \n    } \n \n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, \n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\"); \n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated executi\n \n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); \n        queuedTransactions[txHash] = true; \n \n        emit QueueTransaction(txHash, target, value, signature, data, eta); \n        return txHash; \n    } \n \n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\"); \n \n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); \n        queuedTransactions[txHash] = false; \n \nStrategyV2PairHelper.sol\n        emit CancelTransaction(txHash, target, value, signature, data, eta); \n    } \n \n    function executeTransaction(address target, uint value, string memory signature, bytes memory dat\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\"); \n \n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); \n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been qu\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpass\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transact\n \n        queuedTransactions[txHash] = false; \n \n        bytes memory callData; \n \n        if (bytes(signature).length == 0) { \n            callData = data; \n        } else { \n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data); \n        } \n \n        // solium-disable-next-line security/no-call-value \n        (bool success, bytes memory returnData) = target.call{value: value}(callData); \n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\"); \n \n        emit ExecuteTransaction(txHash, target, value, signature, data, eta); \n \n        return returnData; \n    } \n \n    function getBlockTimestamp() internal view returns (uint) { \n        // solium-disable-next-line security/no-block-members \n        return block.timestamp; \n    } \n}\n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0 <0.8.0; \n \ninterface ICherryPool { \n    function cherry() external view returns (address); \n \n    function poolLength() external view returns (uint256); \n \n    function poolInfo(uint256 _pid) external view returns(address _lpToken, uint256, uint256); \n \n    function userInfo(uint256 _pid, address _user) external view returns (uint256 _amount, uint256 _r\n \n    function deposit(uint256 _pid, uint256 _amount) external; \n \n    function pendingCherry(uint256 _pid, address _user) external view returns (uint256); \n \n    function withdraw(uint256 _pid, uint256 _amount) external; \n \n    function emergencyWithdraw(uint256 _pid) external; \n} \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \nimport \"./comm/SafeMath.sol\"; \nimport \"./comm/Helper.sol\"; \n \ncontract ERA7Token is ERC20,Helper { \n \n  uint256 public maxMint; \n \n  constructor() ERC20(\"Era Token\", \"ERA\") { \n    uint256 decimal = 10 ** uint256(decimals()); \n    maxMint = 1000000000 * decimal; \n  } \n \n  function mint(address to,uint256 amount) external onlyHelper { \n    require(to != address(0), \"ERA7Token:to address error\"); \n \n    uint256 newVal = SafeMath.add(amount,totalSupply()); \n    require(newVal <= maxMint, \"ERA7Token:mint value is max\"); \n    _mint(to,amount); \n  } \n \n \n  function burn(uint256 amount) external { \n      _burn(_msgSender(), amount); \n  } \n \n  function burnFrom(address account, uint256 amount) external { \n      uint256 currentAllowance = allowance(account, _msgSender()); \n      require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\"); \n      unchecked { \n          _approve(account, _msgSender(), currentAllowance - amount); \n      } \n      _burn(account, amount); \n  } \n \n} \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \ninterface IERA7Card { \n    struct ERA7CardEntity { \n        uint256 tokenId; \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IFidoMember { \n  function baseRate() view external returns (uint256); \n \n  function fidoOfficial() view external returns (address); \n \n  function followers(address, uint256) view external returns (address); \n \n  function inviter(address) view external returns (address); \n \n  function isInvited(address) view external returns (bool); \n \n  function isMember(address) view external returns (bool); \n \n  function joinBlockHeight(address) view external returns (uint256); \n \n  function mfilPool() view external returns (address); \n \n  function multiRate() view external returns (uint256); \n \n  function operator() view external returns (address); \n \n  function owner() view external returns (address); \n \n  function pool() view external returns (address); \n \n  function rateDecimal() view external returns (uint256); \n \n  function renounceOwnership() external; \n \n  function stakeMin() view external returns (uint256); \n \n  function transferOwnership(address newOwner) external; \n \n  function transferOperatorship(address newOperator) external; \n \n  function adjustRate(uint256 _baseRate, uint256 _multiRate) external; \n \n  function changeRateDecimal(uint256 newRateDecimal) external; \n \n  function changeStakeMin(uint256 newStakeMin) external; \n \n  function joinFido(address _inviter) external; \n \n  function changeMFILPool(address newMfilpool) external; \n \n  function changeFidoOfficial(address newFidoOfficial) external; \n \n  function changePool(address newPool) external; \n \n  function getFollowerCount(address member) view external returns (uint256); \n \n  function caleInviteRate(address member) view external returns (address inviter0, address inviter1, \n \n  event AdjustRate(uint256 baseRate, uint256 multiRate); \n \n  event AdjustStakeMin(uint256 stakeMin); \n \n  event NewMember(address indexed member, address indexed inviter, uint256 joinBlockHeight); \n \n  event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator); \n \n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.9.0; \n \ncontract Migrations { \n  address public owner = msg.sender; \n  uint public last_completed_migration; \n \n  modifier restricted() { \n    require( \n      msg.sender == owner, \n      \"This function is restricted to the contract's owner\" \n    ); \n    _; \n  } \n \n  function setCompleted(uint completed) public restricted { \n    last_completed_migration = completed; \n  } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./StakeLPRewardPerBlock.sol\"; \n \ncontract FidoUsdtLPPool is StakeLPRewardPerBlock { \n \n    address public usdt; \n    address public fido; \n    constructor( \n        address _facotry, \n        address _operator, \n        address _usdt, \n        address _fido \n    ) StakeLPRewardPerBlock(_facotry, _operator, _usdt, _fido, _fido) { \n        usdt = _usdt; \n        fido = _fido; \n    } \n \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./ERC20/ERC20.sol\"; \nimport \"./ERC20/ERC20Burnable.sol\"; \nimport \"./ERC20/ERC20Mintable.sol\"; \nimport \"./ERC20/ERC20Pausable.sol\"; \nimport \"./Ownable.sol\"; \n \ncontract MFIL is ERC20Mintable, ERC20Burnable, Ownable { \n    using SafeMath for uint256; \n \n    address public operator; \n    uint256 private _cap = 2000000000 * 10**18; \n \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n \n    constructor(address _operator) \n        ERC20(\"Mirror FileCoin\", \"MFIL\") \n        Pausable() \n        Ownable() \n    { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        _setupDecimals(18); \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function pause() external onlyOperator { \n        _pause(); \n    } \n \n    function unPause() external onlyOperator { \n        _unpause(); \n    } \n \n    function addMinter(address minter) external onlyOperator { \n        _addMinter(minter); \n    } \n \n    function removeMinter(address minter) external onlyOperator { \n        _removeMinter(minter); \n    } \n \n    /** \n     * @dev Returns the cap on the token's total supply. \n     */ \n    function cap() public view virtual returns (uint256) { \n        return _cap; \n    } \n \n    /** \n     * @dev See {ERC20-_beforeTokenTransfer}. \n     * \n     * Requirements: \n     * \n     * - minted tokens must not cause the total supply to go over the cap. \n     */ \n    function _beforeTokenTransfer( \n        address from, \n        address to, \n        uint256 amount \n    ) internal virtual override { \n        super._beforeTokenTransfer(from, to, amount); \n \n        if (from == address(0)) { \n            // When minting tokens \n            require(totalSupply().add(amount) <= cap(), \"ERC20: cap exceeded\"); \n        } \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./MFIL-IDOToken.sol\"; \nimport \"./interfaces/IIDOInfo.sol\"; \n \ncontract MfilIdoTokenLPPoolFactory is Ownable { \n    address public mfil; \n    address public factory; \n    address public MfilStakePool; \n    address public operator; \n    address public IDOInfo; \n    address public FidoMember; \n \n    uint256 public inviteFeeRate = 50; // inviteFee = inviteFeeRate / 10**inviteFeeRateDecimals \n    uint8 public inviteFeeRateDecimals = 3; \n \n    mapping (address => address) public ido2pool; \n \n    event OperatorshipTransferred( \n        address indexed previousOperator, \n        address indexed newOperator \n    ); \n \n    event NewPool(address indexed idoToken, address indexed pool); \n \n    constructor( \n        address _operator, \n        address _mfil, \n        address _factory, \n        address _IDOInfo, \n        address _FidoMember, \n        address _MfilStakePool \n    ) Ownable() { \n        operator = _operator; \n        emit OperatorshipTransferred(address(0), operator); \n        mfil = _mfil; \n        factory = _factory; \n        IDOInfo = _IDOInfo; \n        FidoMember = _FidoMember; \n        MfilStakePool = _MfilStakePool; \n \n    } \n \n    modifier onlyOperator() { \n        require( \n            _msgSender() == operator, \n            \"Operable: caller is not the operator\" \n        ); \n        _; \n    } \n \n    function transferOperatorship(address newOperator) external onlyOwner { \n        require( \n            newOperator != address(0), \n            \"Operable: new operator is the zero address\" \n        ); \n        emit OperatorshipTransferred(operator, newOperator); \n        operator = newOperator; \n    } \n \n    function newPool(address idoToken) onlyOperator external returns (address pool) { \n        require(IIDOInfo(IDOInfo).exist(idoToken), \"PoolFactory: idoToken not found\"); \n        require(ido2pool[idoToken] == address(0), \"PoolFactory: pool exist\"); \n        MfilIdoTokenLPPool newpool = new MfilIdoTokenLPPool(factory, operator, mfil, idoToken); \n        pool = address(newpool); \n        ido2pool[idoToken] = pool; \n        emit NewPool(idoToken, pool); \n    } \n \n    function changePoolOperator(address idoToken, address newOperator) onlyOperator external { \n        require(ido2pool[idoToken] != address(0), \"PoolFactory: pool not found\"); \n        MfilIdoTokenLPPool(ido2pool[idoToken]).transferOperatorship(newOperator); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"../Context.sol\"; \nimport \"./ERC20Pausable.sol\"; \n \n/** \n * @dev Extension of {ERC20} that allows token holders to destroy both their own \n * tokens and those that they have an allowance for, in a way that can be \n * recognized off-chain (via event analysis). \n */ \nabstract contract ERC20Burnable is Context, ERC20Pausable { \n    using SafeMath for uint256; \n \n    /** \n     * @dev Destroys `amount` tokens from the caller. \n     * \n     * See {ERC20-_burn}. \n     */ \n    function burn(uint256 amount) public virtual { \n        _burn(_msgSender(), amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's \n     * allowance. \n     * \n     * See {ERC20-_burn} and {ERC20-allowance}. \n     * \n     * Requirements: \n     * \n     * - the caller must have allowance for ``accounts``'s tokens of at least \n     * `amount`. \n     */ \n    function burnFrom(address account, uint256 amount) public virtual { \n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount \n \n        _approve(account, _msgSender(), decreasedAllowance); \n        _burn(account, amount); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.10; \n \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \n \ncontract GFTToken is ERC20, Ownable { \n    constructor( \n        string memory name, \n        string memory symbol \n    ) payable ERC20(name, symbol) {} \n \n    function mint(address account, uint256 amount) public onlyOwner { \n        require(totalSupply() + amount <= 1100000000 * 10 ** decimals()); \n        _mint(account, amount); \n    } \n \n    function burn(uint256 amount) public { \n        _burn(msg.sender, amount); \n    } \n} \nGFTTokenVesting.sol\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n    function _msgSender() internal view virtual returns (address payable) { \n        return msg.sender; \n    } \n \n    function _msgData() internal view virtual returns (bytes memory) { \n        this; // silence state mutability warning without generating bytecode - see https://github.co\n        return msg.data; \n    } \n} \n \n \n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v3.4.2 \n \n// : MIT \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface ILfgSwapFactory { \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    function feeTo() external view returns (address); \n    function feeToSetter() external view returns (address); \n \n    function getPair(address tokenA, address tokenB) external view returns (address pair); \n    function allPairs(uint) external view returns (address pair); \n    function allPairsLength() external view returns (uint); \n \n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n    function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n    function createPair(address tokenA, address tokenB) external returns (address pair); \n \n    function setFeeTo(address) external; \n    function setFeeToSetter(address) external; \n \n} \n \n \n// File contracts/libraries/SafaMath.sol \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/access/AccessControl.sol\"; \nimport \"@openzeppelin/contracts/security/Pausable.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\"; \nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\"; \nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\"; \n \ncontract LOCG is AccessControl, ERC20, Pausable, ERC20Burnable, ERC20Snapshot { \n    using SafeERC20 for IERC20; \n \n    string public constant NAME = \"LOCGame Token\"; \n    string public constant SYMBOL = \"LOCG\"; \n    uint256 public constant MAX_TOTAL_SUPPLY = 150_000_000 * 1e18; \n \n    bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\");       // Whitelisted ad\n \n    modifier onlyAdmin() { \n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"!admin\"); \n        _; \n    } \n \n    constructor (address daoMultiSig) ERC20(NAME, SYMBOL) { \n        _setupRole(DEFAULT_ADMIN_ROLE, daoMultiSig);   // DEFAULT_ADMIN_ROLE can grant other roles \n        _setupRole(WHITELISTED_ROLE, daoMultiSig); \n        _mint(daoMultiSig, MAX_TOTAL_SUPPLY); \n    } \n \n \n    /** \n     * @notice Triggers stopped state. \n     * Requirements: \n     * - The contract must not be paused. \n     */ \n    function pause() external onlyAdmin { \n        _pause(); \n    } \n \n    /** \n     * @notice Returns to normal state. \n     * Requirements: \n     * - The contract must be paused. \n     */ \n    function unpause() external onlyAdmin { \n        _unpause(); \n    } \n \n    /** \n     * @notice Creates a new snapshot and returns its snapshot id. \n     */ \n    function snapshot() external onlyAdmin { \n        _snapshot(); \n    } \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.7.0; \n \n \n \ninterface IERC20 is IERC20Upgradeable { \n    function decimals() external view returns (uint8); \n} \n \n// File: @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    function __Ownable_init() internal initializer { \n        __Context_init_unchained(); \n        __Ownable_init_unchained(); \n    } \n \n    function __Ownable_init_unchained() internal initializer { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view virtual returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n    uint256[49] private __gap; \n} \n \n// File: contracts/interface/IAggregatorV3Interface.sol \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.6.0; \nabstract contract ERC20Burnable is Context, ERC20 { \n \n    function burn(uint256 amount) public { \n        _burn(_msgSender(), amount); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.6.0; \ncontract MatifiToken is ERC20Burnable, Ownable { \n \n    constructor() public ERC20('Matifi Token', 'MATIFI') { \n        _mint(msg.sender, 21000000 * 10**18); \n    } \n \n} \nAnalysis of audit results\nRe-Entrancy\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.8.9; \n \ninterface IMonstropolyERC20 { \n    function transferFrom( \n        address sender, \n        address recipient, \n        uint256 amount \n    ) external  returns (bool); \n    function transfer(address account, uint256 amount) external; \n    function balanceOf(address account) external view  returns (uint256); \n    function allowance(address owner, address spender) external view returns (uint256); \n    function burn(uint256 amount) external; \n    function burnFrom(address account, uint256 amount) external; \n    function mint(address to, uint256 amount) external; \n}\nIMonstropolyDeployer.sol\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface INetswapPair { \n    event Approval(address indexed owner, address indexed spender, uint value); \n    event Transfer(address indexed from, address indexed to, uint value); \n \n    function name() external pure returns (string memory); \n    function symbol() external pure returns (string memory); \n    function decimals() external pure returns (uint8); \n    function totalSupply() external view returns (uint); \n    function balanceOf(address owner) external view returns (uint); \n    function allowance(address owner, address spender) external view returns (uint); \n \n    function approve(address spender, uint value) external returns (bool); \n    function transfer(address to, uint value) external returns (bool); \n    function transferFrom(address from, address to, uint value) external returns (bool); \n \n    function DOMAIN_SEPARATOR() external view returns (bytes32); \n    function PERMIT_TYPEHASH() external pure returns (bytes32); \n    function nonces(address owner) external view returns (uint); \n \n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n    event Mint(address indexed sender, uint amount0, uint amount1); \n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n    event Swap( \n        address indexed sender, \n        uint amount0In, \n        uint amount1In, \n        uint amount0Out, \n        uint amount1Out, \n        address indexed to \n    ); \n    event Sync(uint112 reserve0, uint112 reserve1); \n \n    function MINIMUM_LIQUIDITY() external pure returns (uint); \n    function factory() external view returns (address); \n    function token0() external view returns (address); \n    function token1() external view returns (address); \n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n    function price0CumulativeLast() external view returns (uint); \n    function price1CumulativeLast() external view returns (uint); \n    function kLast() external view returns (uint); \n \n    function mint(address to) external returns (uint liquidity); \n    function burn(address to) external returns (uint amount0, uint amount1); \n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n    function skim(address to) external; \n    function sync() external; \n \n    function initialize(address, address) external; \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0; \n \n// helper methods for interacting with ERC20 tokens and sending Metis that do not consistently return \nlibrary TransferHelper { \n    function safeApprove(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('approve(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_F\n    } \n \n    function safeTransfer(address token, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transfer(address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value))\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferFrom(address token, address from, address to, uint value) internal { \n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)'))); \n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, v\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n    } \n \n    function safeTransferMetis(address to, uint value) internal { \n        (bool success,) = to.call{value:value}(new bytes(0)); \n        require(success, 'TransferHelper: METIS_TRANSFER_FAILED'); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.2; \n \ninterface INetswapRouter { \n    function factory() external pure returns (address); \n    function Metis() external pure returns (address); \n \n    function addLiquidity( \n        address tokenA, \n        address tokenB, \n        uint amountADesired, \n        uint amountBDesired, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB, uint liquidity); \n    function addLiquidityMetis( \n        address token, \n        uint amountTokenDesired, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) external payable returns (uint amountToken, uint amountMetis, uint liquidity); \n    function removeLiquidity( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityMetis( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline \n    ) external returns (uint amountToken, uint amountMetis); \n    function removeLiquidityWithPermit( \n        address tokenA, \n        address tokenB, \n        uint liquidity, \n        uint amountAMin, \n        uint amountBMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountA, uint amountB); \n    function removeLiquidityMetisWithPermit( \n        address token, \n        uint liquidity, \n        uint amountTokenMin, \n        uint amountMetisMin, \n        address to, \n        uint deadline, \n        bool approveMax, uint8 v, bytes32 r, bytes32 s \n    ) external returns (uint amountToken, uint amountMetis); \n    function swapExactTokensForTokens( \n        uint amountIn, \n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapTokensForExactTokens( \n        uint amountOut, \n        uint amountInMax, \n        address[] calldata path, \n        address to, \n        uint deadline \n    ) external returns (uint[] memory amounts); \n    function swapExactMetisForTokens(uint amountOutMin, address[] calldata path, address to, uint dea\n        external \n        payable \n        returns (uint[] memory amounts); \n    function swapTokensForExactMetis(uint amountOut, uint amountInMax, address[] calldata path, addre\n        external \n        returns (uint[] memory amounts); \n    function swapExactTokensForMetis(uint amountIn, uint amountOutMin, address[] calldata path, addre\n        external \n        returns (uint[] memory amounts); \n    function swapMetisForExactTokens(uint amountOut, address[] calldata path, address to, uint deadli\n        external \n        payable \n        returns (uint[] memory amounts); \n \n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB); \n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external view returns (uint \n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external view returns (uint \n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memo\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memo\n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-ma\n \nlibrary SafeMathNetswap { \n    function add(uint x, uint y) internal pure returns (uint z) { \n        require((z = x + y) >= x, 'ds-math-add-overflow'); \n    } \n \n    function sub(uint x, uint y) internal pure returns (uint z) { \n        require((z = x - y) <= x, 'ds-math-sub-underflow'); \n    } \n \n    function mul(uint x, uint y) internal pure returns (uint z) { \n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow'); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format)\n \n// range: [0, 2**112 - 1] \n// resolution: 1 / 2**112 \n \nlibrary UQ112x112 { \n    uint224 constant Q112 = 2**112; \n \n    // encode a uint112 as a UQ112x112 \n    function encode(uint112 y) internal pure returns (uint224 z) { \n        z = uint224(y) * Q112; // never overflows \n    } \n \n    // divide a UQ112x112 by a uint112, returning a UQ112x112 \n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { \n        z = x / uint224(y); \n    } \n} \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n \n \ncontract NetswapFactory is INetswapFactory { \n    using SafeMathNetswap  for uint; \n    uint public override feeRate = 3; \n    address public override feeTo; \n    address public override feeToSetter; \n \n    mapping(address => mapping(address => address)) public override getPair; \n    address[] public override allPairs; \n \n    event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n    constructor(address _feeToSetter) public { \n        feeToSetter = _feeToSetter; \n    } \n \n    function allPairsLength() external override view returns (uint) { \n        return allPairs.length; \n    } \n \n    function pairCodeHash() external pure returns (bytes32) { \n        return keccak256(type(NetswapPair).creationCode); \n    } \n \n    function createPair(address tokenA, address tokenB) external override returns (address pair) { \n        require(tokenA != tokenB, 'Netswap: IDENTICAL_ADDRESSES'); \n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n        require(token0 != address(0), 'Netswap: ZERO_ADDRESS'); \n        require(getPair[token0][token1] == address(0), 'Netswap: PAIR_EXISTS'); // single check is su\n        bytes memory bytecode = type(NetswapPair).creationCode; \n        bytes32 salt = keccak256(abi.encodePacked(token0, token1)); \n        assembly { \n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt) \n        } \n        NetswapPair(pair).initialize(token0, token1); \n        getPair[token0][token1] = pair; \n        getPair[token1][token0] = pair; // populate mapping in the reverse direction \n        allPairs.push(pair); \n        emit PairCreated(token0, token1, pair, allPairs.length); \n    } \n \n    function setFeeTo(address _feeTo) external override { \n        require(msg.sender == feeToSetter, 'Netswap: FORBIDDEN'); \n        feeTo = _feeTo; \n    } \n \n    function setFeeRate(uint _feeRate) external override { \n        require(msg.sender == feeToSetter, 'Netswap: FORBIDDEN'); \n        feeRate = _feeRate; \n    } \n \n    function setFeeToSetter(address _feeToSetter) external override { \n        require(msg.sender == feeToSetter, 'Netswap: FORBIDDEN'); \n        feeToSetter = _feeToSetter; \n    } \n \n}\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n* @dev String operations. \n  */  \n  library Strings { \n  bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\"; \n \n  /** \n    * @dev Converts a  `uint256` to its ASCII `string` decimal representation. \n      */  \n      function toString(uint256 value) internal pure returns (string memory) { \n      // Inspired by OraclizeAPI's implementation - MIT licence \n      // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oracl\n \n      if (value == 0) { \n      return \"0\"; \n      } \n      uint256 temp = value; \n      uint256 digits; \n      while (temp != 0) { \n      digits++; \n      temp /= 10; \n      } \n      bytes memory buffer = new bytes(digits); \n      while (value != 0) { \n      digits -= 1; \n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10))); \n      value /= 10; \n      } \n      return string(buffer); \n      } \n \n  /** \n    * @dev Converts a  `uint256` to its ASCII `string` hexadecimal representation. \n      */  \n      function toHexString(uint256 value) internal pure returns (string memory) { \n      if (value == 0) { \n      return \"0x00\"; \n      } \n      uint256 temp = value; \n      uint256 length = 0; \n      while (temp != 0) { \n      length++; \n      temp >>= 8; \n      } \n      return toHexString(value, length); \n      } \n \n  /** \n    * @dev Converts a  `uint256` to its ASCII `string` hexadecimal representation with fixe\n      */  \n      function toHexString(uint256 value, uint256 length) internal pure returns (string memory) { \n      bytes memory buffer = new bytes(2 * length + 2); \n      buffer[0] = \"0\"; \n      buffer[1] = \"x\"; \n      for (uint256 i = 2 * length + 1; i > 1; --i) { \n      buffer[i] = _HEX_SYMBOLS[value & 0xf]; \n      value >>= 4; \n      } \n      require(value == 0, \"Strings: hex length insufficient\"); \n      return string(buffer); \n      } \n      } \n \n// File: @openzeppelin/contracts/access/IAccessControl.sol \n \n \n// OpenZeppelin Contracts v4.4.0 (access/IAccessControl.sol) \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \n \n/** \n * @dev Extension of {ERC20} that allows token holders to destroy both their own \n * tokens and those that they  have an  allowance for, in \n * recognized off-chain (via event analysis). \n */  \nabstract contract ERC20Burnable is Context, ERC20 { \n    /** \n     * @dev Destroys `amount` tokens from the  caller. \n     * \n     * See {ERC20-_burn}. \n     */  \n    function burn(uint256 amount) public virtual { \n        _burn(_msgSender(), amount); \n    } \n \n    /** \n     * @dev Destroys `amount` tokens from `account`, deducting from the  caller's \n     * allowance. \n     * \n     * See {ERC20-_burn} and {ERC20-allowance}. \n     * \n     * Requirements: \n     * \n     * - the  caller must have allowance for ``accounts``'s tokens of at least \n     * `amount`. \n     */  \n    function burnFrom(address account, uint256 amount) public virtual { \n        uint256 currentAllowance = allowance(account, _msgSender()); \n        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\"); \n        unchecked { \n            _approve(account, _msgSender(), currentAllowance - amount); \n        } \n        _burn(account, amount); \n    } \n} \n \n// File: @openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @dev Interface of the  ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP]. \n * \n * Implementers can declare support of contract interfaces, which can then be \n * queried by others ({ERC165Checker}). \n * \n * For an  implementation, see {ERC165}. \n */  \ninterface IERC165 { \n    /** \n     * @dev Returns true if this contract implements the  interface defined by \n     * `interfaceId`. See the  corresponding \n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces- are -identified[EIP section] \n     * to learn more  about how these ids are  created. \n     * \n     * This function call must use less than 30 000 gas. \n     */  \n    function supportsInterface(bytes4 interfaceId) external view returns (bool); \n} \n \n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n \ncontract Roles is AccessControl { \n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER\"); \n \n    constructor() { \n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender()); \n        _setupRole(MINTER_ROLE, _msgSender()); \n    } \n \n    modifier onlyMinter() { \n        require(hasRole(MINTER_ROLE, _msgSender()), \"Roles: caller does not have the MINTER role\"); \n        _; \n    } \n} \n \n// File: contracts/service/ServicePayer.sol \n \n \n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./Context.sol\"; \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n     * @dev Returns the remaining number of tokens that `spender` will be \n     * allowed to spend on behalf of `owner` through {transferFrom}. This is \n     * zero by default. \n     * \n     * This value changes when {approve} or {transferFrom} are called. \n     */ \n    function allowance(address _owner, address spender) external view returns (uint256); \n \n    /** \n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * IMPORTANT: Beware that changing an allowance with this method brings the risk \n     * that someone may use both the old and the new allowance by unfortunate \n     * transaction ordering. One possible solution to mitigate this race \n     * condition is to first reduce the spender's allowance to 0 and set the \n     * desired value afterwards: \n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n     * \n     * Emits an {Approval} event. \n     */ \n    function approve(address spender, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Moves `amount` tokens from `sender` to `recipient` using the \n     * allowance mechanism. `amount` is then deducted from the caller's \n     * allowance. \n     * \n     * Returns a boolean value indicating whether the operation succeeded. \n     * \n     * Emits a {Transfer} event. \n     */ \n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n    /** \n     * @dev Emitted when `value` tokens are moved from one account (`from`) to \n     * another (`to`). \n     * \n     * Note that `value` may be zero. \n     */ \n    event Transfer(address indexed from, address indexed to, uint256 value); \n \n    /** \n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n     * a call to {approve}. `value` is the new allowance. \n     */ \n    event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n    address private _owner; \n \n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n    /** \n     * @dev Initializes the contract setting the deployer as the initial owner. \n     */ \n    constructor () internal { \n        address msgSender = _msgSender(); \n        _owner = msgSender; \n        emit OwnershipTransferred(address(0), msgSender); \n    } \n \n    /** \n     * @dev Returns the address of the current owner. \n     */ \n    function owner() public view returns (address) { \n        return _owner; \n    } \n \n    /** \n     * @dev Throws if called by any account other than the owner. \n     */ \n    modifier onlyOwner() { \n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\"); \n        _; \n    } \n \n    /** \n     * @dev Leaves the contract without owner. It will not be possible to call \n     * `onlyOwner` functions anymore. Can only be called by the current owner. \n     * \n     * NOTE: Renouncing ownership will leave the contract without an owner, \n     * thereby removing any functionality that is only available to the owner. \n     */ \n    function renounceOwnership() public virtual onlyOwner { \n        emit OwnershipTransferred(_owner, address(0)); \n        _owner = address(0); \n    } \n \n    /** \n     * @dev Transfers ownership of the contract to a new account (`newOwner`). \n     * Can only be called by the current owner. \n     */ \n    function transferOwnership(address newOwner) public virtual onlyOwner { \n        require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n        emit OwnershipTransferred(_owner, newOwner); \n        _owner = newOwner; \n    } \n}\nSafeBEP20.sol\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n// \n// \n//                    \u250c\u2500\u2510       \u250c\u2500\u2510 + + \n//                    \u250c\u2500\u2500\u2518 \u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2534\u2500\u2500\u2510++ \n//                    \u2502                 \u2502 \n//                    \u2502       \u2500\u2500\u2500       \u2502++ + + + \n//                    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502+ \n//                    \u2502                 \u2502+ \n//                    \u2502       \u2500\u2534\u2500       \u2502 \n//                    \u2502                 \u2502 \n//                    \u2514\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2518 \n//                    \u2502         \u2502 \n//                    \u2502         \u2502   + + \n//                    \u2502         \u2502 \n//                    \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \n//                    \u2502                        \u2502 \n//                    \u2502                        \u251c\u2500\u2510 \n//                    \u2502                        \u250c\u2500\u2518 \n//                    \u2502                        \u2502 \n//                    \u2514\u2500\u2510  \u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2510  \u250c\u2500\u2500\u2518  + + + + \n//                    \u2502 \u2500\u2524 \u2500\u2524       \u2502 \u2500\u2524 \u2500\u2524 \n//                    \u2514\u2500\u2500\u2534\u2500\u2500\u2518       \u2514\u2500\u2500\u2534\u2500\u2500\u2518  + + + + \n \n \nimport \"./BEP20.sol\"; \n \ncontract ZooToken is BEP20('Zoo', 'ZOO', 100000000000000000000000000000) { \n \n \nfunction getChainId() internal pure returns (uint) { \nuint256 chainId; \nassembly { chainId := chainid() } \nreturn chainId; \n} \n}\n \n        return c; \n    } \n \n    /** \n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo), \n     * reverts when dividing by zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b != 0); \n        return a % b; \n    } \n}\nAnalysis of audit results\nRe-Entrancy\n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title SafeMath \n * @dev Unsigned math operations with safety checks that revert on error \n */ \n \nlibrary SafeMath { \n    /** \n     * @dev Multiplies two unsigned integers, reverts on overflow. \n     */ \n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n        // benefit is lost if 'b' is also tested. \n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 \n        if (a == 0) { \n            return 0; \n        } \n \n        uint256 c = a * b; \n        require(c / a == b); \n \nZooToken.sol\n \n\n\n###\n\n", "completion": "no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n// \n// \n//                    \u250c\u2500\u2510       \u250c\u2500\u2510 + + \n//                    \u250c\u2500\u2500\u2518 \u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2534\u2500\u2500\u2510++ \n//                    \u2502                 \u2502 \n//                    \u2502       \u2500\u2500\u2500       \u2502++ + + + \n//                    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502+ \n//                    \u2502                 \u2502+ \n//                    \u2502       \u2500\u2534\u2500       \u2502 \n//                    \u2502                 \u2502 \n//                    \u2514\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2518 \n//                    \u2502         \u2502 \n        return c; \n    } \n \n    /** \n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by \n     */ \n    function div(uint256 a, uint256 b) internal pure returns (uint256) { \n        // Solidity only automatically asserts when dividing by 0 \n        require(b > 0); \n        uint256 c = a / b; \n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n        return c; \n    } \n \n    /** \n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than \n     */ \n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b <= a); \n        uint256 c = a - b; \n \n        return c; \n    } \n \n    /** \n     * @dev Adds two unsigned integers, reverts on overflow. \n     */ \n    function add(uint256 a, uint256 b) internal pure returns (uint256) { \n        uint256 c = a + b; \n        require(c >= a); \n \n        return c; \n    } \n \n    /** \n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo), \n     * reverts when dividing by zero. \n     */ \n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n        require(b != 0); \n        return a % b; \n    } \n}\n//                    \u2502         \u2502   + + \n//                    \u2502         \u2502 \n//                    \u2502         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \n//                    \u2502                        \u2502 \n//                    \u2502                        \u251c\u2500\u2510 \n//                    \u2502                        \u250c\u2500\u2518 \n//                    \u2502                        \u2502 \n//                    \u2514\u2500\u2510  \u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2510  \u250c\u2500\u2500\u2518  + + + + \n//                    \u2502 \u2500\u2524 \u2500\u2524       \u2502 \u2500\u2524 \u2500\u2524 \n//                    \u2514\u2500\u2500\u2534\u2500\u2500\u2518       \u2514\u2500\u2500\u2534\u2500\u2500\u2518  + + + + \n \n \nimport \"./BEP20.sol\"; \n \ncontract ZooToken is BEP20('Zoo', 'ZOO', 100000000000000000000000000000) { \n \n \nfunction getChainId() internal pure returns (uint) { \nuint256 chainId; \nassembly { chainId := chainid() } \nreturn chainId; \n} \n}\n\n\n###\n\n", "completion": "no###\n###"}
