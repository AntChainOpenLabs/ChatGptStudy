{
    "0": [
        "yes,Price oracle manipulation.The vulnerability is in addLiquidity function.AMM price oracle manipulation.The WorldFootball contract provides a function, addLiquidity, that allows transferring BNB to the contract. It also has a function, swapTokensForBNB, that allows token->BNB swaps given an amount of token to transfer. However, there is no lock-up period for the tokens sent to the contract via addLiquidity, and as such it is possible to use flash loans to pump the token before calling addLiquidity, leading to a permanent 1:1 BNB-token pair in the contract. Using 1:1 pairs is a way to manipulate the Binance DEX\u2019s price tracing mechanism, which makes it possible to manipulate the WorldFootball contract\u2019s assets for the malicious contract owner\u2019s benefits.",
        "yes,ID-related violations.The vulnerability is in swapTokensForBNB and addLiquidity functions.Shared resource (e.g., token) without proper locks.Malicious owners could stealthily increase _tTotal and/or _tOwned arbitrarily by calling the above functions.The _tTotal and _tOwned are publicly accessible uint256 variables that represent the total token amounts in the vault. They are increased each time a token is transferred into the vault. Malicious owners could stealthily increase _tTotal and/or _tOwned arbitrarily by calling the swapTokensForBNB() and addLiquidity() functions.",
        "yes,ID-related violations.The vulnerability is in function _tokenTransfer.ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.The following functions can be called by arbitrary users to transfer tokens:_tokenTransfer() in WorldFootball.sol L59-L76SwapAndLiquify() in WorldFootball.sol L198-L256But since the public functions _tokenTransfer() and SwapAndLiquify() call the internally-called _tokenTransferInternal() and SwapAndLiquifyInternal() first, the functions must be called before their internal counterparts to have any effect. If this ordering is not respected, the transfer will revert.",
        "yes,ID-related violations.The vulnerability is in owner() function.ID can be arbitrarily set by users or lack of ID validation.We have a concern regarding the owner() function. The current implementation allows owners to set the owner address. In the current implementation, anyone can become the owner of the contract by calling the owner() function.",
        "yes,ID-related violations.The vulnerability is in if(recipient == Wallet_Burn).ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.The function _tokenTransfer() is called from WorldFootball.liquifyTokens() , which can be invoked by anyone who wants to liquify tokens. ___tokenTransfer() transfers tokens between the supply and the wallet. If the amount of tokens to be transferred is larger than 10, the transfer is executed multiple times with a step of 1. A user has noticed that one of these multiple executions of ___tokenTransfer() transfers all the user\u2019s token balance to the contract, i.e. the user\u2019s tokens are locked in the contract. This is because WorldFootball.renounceOwnership() doesn\u2019t revert the first transfer. The user\u2019s token balance is set to 0 and a call"
    ],
    "1": [
        "yes,ID-related violations.The vulnerability is in functions (runPhasedDistribution, increaseAllocations, distribute) .Shared resource (e.g., token) without proper locks.TransmuterD8: !governance, Although the design separates authority (governance), users (administrators) have full authority, there is still a problem with the implementation. Currently, transmuterD8 contract implementation does not require the admin for running the operations, allowing an attacker to repeatedly call runPhasedDistribution() to steal the all the pending allocations in the queue.",
        "yes,ID-related violations.The vulnerability is in distribute() function.ID can be arbitrarily set by users or lack of ID validation.Users\u2019 tokens can be stolen by malicious actor,The tokens deposited by users to the TransmuterD8 contract cannot be recovered if the malicious actor successfully performs a sybil attack against the user. As a result, the user may permanently lose the deposited tokens if unable to access the contract before the attack.",
        "yes,ID-related violations.The vulnerability is in  if(block.number.sub(lastDepositBlock) > TRANSMUTATION_PERIOD){_toDistribute = buffer;} in userInfo function.Shared resource (e.g., token) without proper locks.TransmuterD8: Vulnerability in userInfo function,WaToken = the tokens deposited by users in the contract, where each user is represented by an address. because the (_toDistribute, _deltaBlocks, _buffer) = userInfo(i) will be calculated based on the _buffer at the current block, if the current block is larger than the expected _deltaBlocks, it will lead to errors. In the worst case, it will cause all the deposited tokens of the users to be mistakenly distributed.",
        "yes,ID-related violations.The vulnerability is in distribute function. ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Function distribute() lacks discretion and can therefore be called and overwritten by anyone, leading to Vault funds being transferred to the input address,If anyone can call distribute() with an input address that they have the keys to, the funds in the WaToken bucket will be transferred to the input address. The integrity of the bucket contents would be completely broken, leaving the project without any protection against further fund transfer.",
        "yes,Erroneous state updates.The vulnerability is in function distribute(address origin, uint256 amount) public onlyWhitelisted() runPhasedDistribution() {  IERC20Burnable(Token).safeTransferFrom(origin, address(this), amount);  buffer = buffer.add(amount); }.AmnSU17SafeTransfer.sol#20.The accounting rules are broken here. After burning WAT from origin, the user balance is supposed to decrease but it's still the same before and after executing this function."
    ],
    "2": [
        "yes,ID-related violations.The vulnerability is in function stake(uint numStakes) external nzUint(numStakes) nonReentrant updateExec noFish override {    uint amount = numStakes * STAN_STAKE;   _stakerToStakedAmount[msg.sender] += amount;   IERC777 AUTO = _AUTO;    uint balBefore = AUTO.balanceOf(address(this));   AUTO.operatorSend(msg.sender, address(this), amount, \"\", _stakingIndicator);   require(AUTO.balanceOf(address(this)) - balBefore == amount, \"SM: transfer bal check failed\");    for (uint i; i < numStakes; i++) { _stakes.push(msg.sender);   }    _totalStaked += amount;   emit Staked(",
        "yes,Reentrancy.The vulnerability is in function stake(uint numStakes) external nzUint(numStakes) nonReentrant updateExec noFish override {   uint amount = numStakes * STAN_STAKE;   _stakerToStakedAmount[msg.sender] += amount;   IERC777 AUTO = _AUTO;    uint balBefore = AUTO.balanceOf(address(this));   AUTO.operatorSend(msg.sender, address(this), amount, \"\", _stakingIndicator);   require(AUTO.balanceOf(address(this)) - balBefore == amount, \"SM: transfer bal check failed\");    for (uint i; i < numStakes; i++) { _stakes.push(msg.sender);   }    _totalStaked += amount;   emit Staked(",
        "yes,ID-related violations.The vulnerability is in function stake(uint numStakes) external nzUint(numStakes) nonReentrant updateExec noFish override { uint amount = numStakes * STAN_STAKE; _stakerToStakedAmount[msg.sender] += amount; IERC777 AUTO = _AUTO; uint balBefore = AUTO.balanceOf(address(this)); AUTO.operatorSend(msg.sender, address(this), amount, \"\", _stakingIndicator); require(AUTO.balanceOf(address(this)) - balBefore == amount, \"SM: transfer bal check failed\"); for (uint i; i < numStakes; i++) { _stakes.push(msg.sender); } _totalStaked += amount; emit Staked(msg.sender, amount); }.Other accounting errors. An arbitrary amount of token is transferred to",
        "yes,ID-related violations.The vulnerability is in   // Shitty state machine    //$VAR1 = 0; 7e3eb3c3270a82ecc267f2a1fcac253a679f24ad556366d0e690c8210ebb0e.Shitty state machine.The function stake() in DSToken.sol has three roles: register staker, execute staker and final balance computation. When register staker, there\u2019s no execute staker, all stakers are registered by this function. When execute staker, there\u2019s already one staker registered with ioSender == msg.sender , and all following stakers register with ioSender != msg.sender. When final account balance computation, there\u2019s a list of staker registered one by one, and there\u2019s staker chances to override the final balance computation result: 1",
        "yes,ID-related violations.The vulnerability is in    if (_stakes.length == 0) {  return true; }   if (_stakes.length == 0) { return true; } in stake function, any number of users can be locked out.Users are deleted instead of unbonding,Precedence given to unbond over withdraw,Allows unbounded locks,Hog hunting,Locking user before funds removed,Blocking account before unbonding,Cannot withdraw when smeared,Immutable contract,Taking ownership,Reoptimize for tagged liveness,The current implementation of the unstake() function does not check if the unbonding amount is greater than its number of stakes, allowing an attacker to lock up tokens from legitimate users as some amounts can be as little as 1 UCT."
    ],
    "3": [
        "yes,Price oracle manipulation.The vulnerability is in   uint256 tokens_to_Burn = contractTokenBalance * Percent_Burn / 100; in _transfer function.AMM price oracle manipulation.As the SwapAndLiquify function can be called upon swapping tokens to 2.0, we notice that the tokens_to_Burn is computed using the current contractTokenBalance which defines a portion of the swapped tokens to be burnt. However, the current contract TokenU has no support for burning, causing the computation to yield an unexpected value and causing unexpected results in the following processes. We believe the support for burning should be added to the base contract. In the absence of a function BURN() in TokenU, we believe such burning can be emulated by a simple token transfer out of the contract but with a burn fee, to mimic a similar effect.",
        "yes,ID-related violations.The vulnerability is in  if(recipient == Wallet_Burn)_tTotal = _tTotal-tAmount;.ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.UniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens() swaps tokens for BNB, however, this function is also used by the _transfer function of UniswapV2.sol which swaps tokens for UniswapV2_V2_TOKENs. This function, however, does not check whether the user is swapping to the correct tokens, potentially leading to a large number of tokens being sent to the wrong user.",
        "yes,Price oracle manipulation.The vulnerability is in sendToWallet function.AMM price oracle manipulation.The function _transfer funds between a wearer and a wallet. The current implementation doesn't require a flash loan session which leaves the protocols vulnerable to price manipulation by buyers and sellers. If a buyer places a buy order with a ridiculously high price or a seller places a sell with a ridiculously low price, the protocol would be forced to transfer funds at a very unfavorable rate.",
        "yes,ID-related violations.The vulnerability is in function owner() public view virtual returns (address) {   return _owner; }.ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.UniswapV2BNT.sol#owner()",
        "yes,Price oracle manipulation.The vulnerability is in swapAndLiquify function.AMM price oracle manipulation.The function swapAndLiquify() is using uint256 tokenAmount as input parameter which could be used to manipulate the price of the Token values by whatever method like market making and to perform funneling attack (hack / hyperlooping)."
    ],
    "4": [
        "yes,Price oracle manipulation.The vulnerability is in price =(reserve1 *10**decimalsIn) / reserve0.AMM price oracle manipulation.The price calculated by the formula is a non-integer value (i.e., a fractional number). Since the price is supposed to be an integer value due to the fact that it is being used in the calculation of the final price, there might be some manipulation by the various parties involved in the transaction through a series of techniques, such as flashloan, which can cause direct loss to the token'S funds in the HAT contract.",
        "yes,Price oracle manipulation.The vulnerability is in (reserve1 *10**decimalsIn) / reserve0.AMM price oracle manipulation.the price is computed via (reserve1 *10**decimalsIn) / reserve0.The division operation is vulnerable to the integer division truncation error. The division operation with improper boolean logic condition will lead to up to 100%+ the original amount of the token A or B to degrade the performance of the entire Swaptoken contract.One possible way to mitigate this issue is to use the SNR token as a kind of \"bonding\" token of the volatility swap contract. ",
        "yes,Price oracle manipulation.The vulnerability is in price =(reserve1 *10**decimalsIn) / reserve0;.AMM price oracle manipulation.The calculated price is numerically compared to a precise value instead of being represented as a fraction or with decimals. The comparison is vulnerable to sign-Magnitude exact comparison error. As a result, if the price of the token1 in the pair is more than 99.99 times the price of token0, the division result will be 0, causing the comparison to fail.",
        "yes,Price oracle manipulation.The vulnerability is in price =(reserve1 *10**decimalsIn) / reserve0.AMM price oracle manipulation.The price is computed using reserve balances which can be manipulated by exchanges. Arbitrary ratio can be used to steal tokens or manipulate the prices.",
        "yes,Price oracle manipulation.The vulnerability is in price =(reserve1 *10**decimalsIn) / reserve0;.AMM price oracle manipulation.The price is computed using the balance of the aggregator determined by the BLOOM ticket. However, it is possible to manipulate the balance by transferring tokens to the aggregator and thus influencing the price. Each token has its own price oracle (ValuePerToken()), which is derived from the internal balance of the aggregator. By injecting tokens into the pool (there are a number of ways to do this, e.g. wrap-around oracle swap), the balance of the aggregator pool can be manipulated, which results in arbitrary manipulation of the price. Due to the way the price is calculated (using the ratio of the reserves), a change in the price results in a proportional change in the _amount of token0 relative to token1."
    ]
}