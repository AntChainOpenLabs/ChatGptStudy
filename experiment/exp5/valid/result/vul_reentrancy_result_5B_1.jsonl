{
    "0": [
        "yes,Reentrancy.The vulnerability is in permit function.The function permits a user to transfer up to its bonus balance - linked to the number of nonces - of an arbitrary second asset. A user can call the function repeatedly with various v values to take ownership of the entire bonus balance. The owner can then set v=\"1\" to revert back ownership of the first asset, and use the second asset to drain all balances back to itself.",
        "yes,Reentrancy.The vulnerability is in approve() function of BathToken.sol.The approve() function of BathToken.sol is vulnerable to reentrancy attacks.",
        "yes,Reentrancy.The vulnerability is in BathToken.sol#initialize.In initialize function, any user can perform the following actions:1. Deposit some bonus tokens2. Call BathToken.initialize()3. Blackmail the contract, by threatening to redistribute the deposited bonus tokens to all users",
        "yes,Reentrancy.The vulnerability is in permit function.The function permits an owner to permit another owner.If the owner permits to himself, he can call the function again to drain all the funds of the bathHouse.",
        "yes,Reentrancy.The vulnerability is in permit() function.The function permits an owner to spend tokens approved for a specific spender. However, it also increases the nonces[owner] counter, which can be used as a way to increase the bandwidth allowance of the token. The user would be able to make more calls to the permit() function than they are supposed to, and possibly steal the tokens they were supposed to permit."
    ],
    "1": [
        "yes,Price oracle manipulation.The vulnerability is in executeOperation function.AMM price oracle manipulation.AMM price oracle manipulation.In the MIMO AutoRebalance contract, there is a price-dependent operation that can be taken by lenders, to autonomously trigger a rebalancing operation. The operation consists of a single call to the MIMOProxy.execute() function, forwards all the necessary data to MIMOProxy for the actual calls to the Mimosa APIs (i.e., the Vault and the Swap). A malicious actor can thus trigger a rebalance operation by simply lending at the same time a small number of assets to the contract, at a price that makes profitable for him. In particular, the attack can be made without the use of any bug or any permission that investors would not allow to the normal operation. We will see later the actual parameters and values that should be opted-in by contract\u2019s developers.",
        "yes,Reentrancy.The vulnerability is in executeOperation function in MIMOAutoRebalance.Customers can initiate the risky Reentrancy attack with the help of high gas amount operations, as it uses WadRayMath.wadDiv for calculating mintAmount and rebalanceAmount, anyWadDiv operation can lead to the exploit, as it calls toexecuteOperation which transfers ERC20 and mints WAD.Here is the function code of MIMOAutoRebalance.executeOperation :Automated Vaults (MimoAutobook) are currently live on the mainnet. Attackers can abuse this reentrancy vulnerability To execute arbitrary operations on any Automated Vault. By doing that, users funds on these Vaults are at significant risk.",
        "yes,Reentrancy.The vulnerability is in executeOperation function of MIMOAutoRebalance contract.Deserialization Can Be Used to Take Back Control in Approved Operations,Perform Actions Unrelated to Approved Operation,Or Violate Other Public Constraints.The  _takeFlashLoan(flData, abi.encode(vaultOwner, autoFee, rbData, swapData)); in executeOperation function of MIMOAutoRebalance.sol involves deserializing a WadRayCodec.AutomatedVault.FlashLoanData array further comprising of a toVaultCollateral WAD token address with a toVaultMcr MCR token address, whereby both token addresses are provided by a mimoProxy via a swapData.toCollateral address in a swapData.abi field. However, any mimoProxy could provide a maliciously crafted swapData to control the toVaultCollateral and",
        "yes,Reentrancy.The vulnerability is in executeOperation function in MIMOAutoRebalance contract.The function rebalance() in MIMOAutoRebalance.sol delays the repayment of flash loan collateral until the vault is successfully rebalanced, a design choice which enables exploitation of the reentrancy flaw by creating a Vault wrapper contract and overloading the executeOperation() function.",
        "yes,Price oracle manipulation.The vulnerability is in executeOperation function.AMM price oracle manipulation.AMM price oracle manipulation.In MIMOAutoRebalance.java, there is a price oracle manipulation vulnerability. The _getVaultStats() to get the vault stats includes the stored collateral in the vault\u2019s collateral balance (line 279). It is a WadRay attack, as anyone can manipulate the vault balance by sending collaterals to the vault. The algorithm in MIMOAutoRebalance.java (line 327) assumes the vault balance is constant throughout the rebalance process, leading to possible net loss for lenders if the manipulator front-runs with a large amount of collaterals.Sending a large enough amount of collaterals to the vault before the rebalance is started, the algorithm compares the old vault collateral balance to the new vault collateral balance to update the exchange rate. The attacker can manipulate the initial vault"
    ],
    "2": [
        "yes,Reentrancy.The vulnerability is in Market.sol#withdrawOnBehalf.functions withdraw and withdrawOnBehalf both call withdrawInternal. There is a possibility for an attacker to reenter withdrawInternal and manipulate nonces or withdraw amount.",
        "yes,Reentrancy.The vulnerability is in Market.sol#withdrawOnBehalf.The withdrawOnBehalf function in the Market contract allows reentrancy. If the withdrawOnBehalf function is invoked while the borrowed debt is still less than the liquidation point, the user can withdraw more than their share of the debt, resulting in theft of lender funds.",
        "yes,ID fraud.The vulnerability is in function withdrawOnBehalf.ID can be arbitrarily set by users or lack of ID validation.The function withdrawOnBehalf is vulnerable to ID fraud. Users can set the from address to their own address and the receiver address to their callback address which is an inconvenience for the project.",
        "yes,Reentrancy.The vulnerability is in withdrawOnBehalf function in Market contract.Unchecked call to ecrecover() in withdrawOnBehalf() can be exploited to drain lender's deposits,In the withdrawOnBehalf function, calling withdrawInternal() makes the fallback contract's deposit() call permanent to allow re-entrancy.",
        "yes,Reentrancy.The vulnerability is in withdrawOnBehalf function in Market.sol.The function withdrawOnBehalf allows reentrancy allowing attackers to withdrawal more than their deposit."
    ],
    "3": [
        "yes,Reentrancy.The vulnerability is in withdrawETHForKnot function in LiquidStakingManager.sol.Returned value (e.g., token or ETH) may be stolen by the sender of the message due to reentrancy.",
        "yes,ID-related violations.The vulnerability is in withdrawETHForKnot function .ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Unable to withdraw ETH for approved knot,Unable to withdraw ETH for approved knotIf a knot has been approved, it can be claimed for ETH by calling withdrawETHForKnot(recipient, BLSpublicKeyOfKnot). Subsequent calls to this function will have no effect. In case the knot\u2019s approval lapses, it becomes necessary to wait for the approvers to vote on the knot\u2019s approval again, after which the approved knot can once again be claimed.",
        "yes,Reentrancy.The vulnerability is in withdrawETHForKnot.In the PSA-initiated withdrawETHForKnot function, there is a reentrancy vulnerability. The current implementation (the line numbers have been removed from the code), calls   IOwnableSmartWallet(associatedSmartWallet).rawExecute(  _recipient,   \"\"   ,   4 ether   ) to refund 4 ether from the associated smart wallet. This call allows the recipient to reenter the LiquidStakingManager contract and possibly withdraw stake for knot that it has claimed previously, making possible to perform the reentrancy attack by repeatedly calling the same knot's claim() function until the enough stake has been claimed and then possibly withdrawal the entire untested claimSteps amount.",
        "yes,Reentrancy.The vulnerability is in withdrawETHForKnot function in LiquidStakingManager.sol.A malicious node runner may repeat the withdrawETHForKnot function to cause the final balance of the associated smart wallet (i.e. the DAO) to become less than the amount of ETH in the staking pool, which allows the node runner to drain the DAO's balance. Once the DAO's balance hits zero, its curator can be reentered. Since there is no per-DAO deposit limit, the node runner now has the ability to drain any DAO's balance at will. This breaks the assumption that code deployed to the mainnet does not have the ability to drain any DAO's balance.",
        "yes,Reentrancy.The vulnerability is in   function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {   require(_recipient != address(0), \"Zero address\");   require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, \"BLS public key has already withdrawn or not a part of LSD network\");    address associatedSmartWallet = smartWalletOfKnot[_blsPublicKeyOfKnot];   require(smartWalletOfNodeRunner[msg.sender] == associatedSmartWallet, \"Not the node runner for the smart wallet \");   require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) == false, \"Node runner is banned from LSD network\");    require(associatedSmartWallet.balance >= 4 ether, \"Insufficient balance\");   require("
    ],
    "4": [
        "yes,Reentrancy.The vulnerability is in claim and Bond contract's refund functions.The claim and Bond.claimDebt functions of the BondNFT contract allow maliciously crafted bonds to be reentered and the funds they had set aside to be refunded. These funds are held by the contract in its bondPaid array and can be accessed by the revert() function. The refund vulnerability can be abused by creating a revocable bond and calling the claim() function, passing a caller as the _claimer address. This allows for caller to later call BondNFT.claim(_id) and revert() to retrieve the bond set aside funds.",
        "yes,ID-related violations.The vulnerability is in claim, claimDebt and successors functions.ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.The Bond class inherits from ERC721 and implements the standard ERC721 functionality along with some additional functionality required to facilitate the functionality desired by the project. In particular, the Bond.claim() and Bond.claimDebt() functions allow any address to reclaim bonds that have been issued to them by calling the bond.transferTo(claimer, amount) function with the value claim or claimDebt as the first parameter. This value can be any integer but they are usually easy to identify as the first parameter to these functions is the bond\u2019s ID. Claiming a bond requires the claiming address to be approved to claim for it by calling requireClaim(bond.id) on the token representing the",
        "yes,Reentrancy.The vulnerability is in   function claim(    uint _id,    address _claimer   ) public onlyManager() returns(uint amount, address tigAsset) {    Bond memory bond = idToBond(_id);    require(_claimer == bond.owner, \"!owner\");    amount = bond.pending;    tigAsset = bond.asset;    unchecked {  if (bond.expired) {   uint _pendingDelta = (bond.shares * accRewardsPerShare[bond.asset][epoch[bond.asset]] / 1e18 - bondPaid[_id][bond.asset]) - (bond.shares * accRewardsPerShare[bond.asset][bond.expireEpoch-1] / 1e",
        "yes,Reentrancy.The vulnerability is in BondNFT() functions in BondNFT.sol Ie, if an attacker calls to claim() or claimDebt() or _burn() or any other functions that modify the state of the contract, the attacker may be able to withdraw the entire deposit of any investor.",
        "yes,Reentrancy.The vulnerability is in ClaimDebt function of BondNFT contract.Unchecked reentrancy is a type of vulnerability where a contract does not explicitly check that a function call is associated with the correct caller. The result is that it's possible for a malicious caller to call the function with a specific caller (e.g. their own account) and pass a caller that allows the function to be reentered. The malicious caller can then manipulate the state in such a way that benefits from the current program flow.In BondNFT.claimDebt the function receives an user's debts to the tiggerAsset. The _user's userDebt[...] is incremented by the bonds[...] owed to the tiggerAsset. Sadly, checking whether the user's debt should be minted isn't done. Therefore, a malicious user can repeatedly call BondNFT.claimDebt() with a different address as _user each time, re"
    ]
}