{
    "0": [
        "yes,ID-related violations.The vulnerability is in addForMember function.ID can be arbitrarily set by users or lack of ID validation. ID can also be a token address, the token\u2019s balance, a user\u2019s token balance, or virtually any other piece of information. Unscoped fees can be stolen, Account balance can be depleted, Synths can be minted without proper consent, Revenue can be stolen. In Pool.sol#addForMember, if baseAmount is 0 or tokenAmount is 0, the addForMember function will issue the baseAmount and tokenAmount amount of base or synth tokens to the member account. If a user with just enough balance calls this function with just a tokenAmount, the function will issue all the balance amount of base and synth tokens to the member account. To recover the balance, vigilante justice can be enforced by _forceAccruedBalances() and _voidAll() calls to revert the transaction and reclaim the balance back",
        "yes,Reentrancy.The vulnerability is in swapTo() function of Pool.sol.The _balances mapping is updated after the swap is performed reentrantly resulting in the same token being swapped multiple times. This is then exploited by swapping a specific token repeatedly to gain more of the pool token than originally intended.",
        "yes,ID-related violations.The vulnerability is in swapTo function.Shared resource (e.g., token) without proper locks.TokenSwap must be matched with corresponding token pairs, otherwise brokeFinality(), which is designed to finalize a token swap by making it irrevocable, would be called from a matched token pair and result in an error signal to the application.\\",
        "yes,ID-related violations.The vulnerability is in addForMember function.ID can be arbitrarily set by users or lack of ID validation. ID can also be a smart contract address or an account number.The function addForMember() can be called by anybody that wishes to join the pool,the function will calculate the amount of base or token tokens to be added to the pool as a percentage of the total pool size, and then proceed to mint the tokens to the user according to the percentage. However, the current implementation assumes that only one user is added to the pool at a time. If a user wishes to be the second person added to the pool, they would be added to the pool with 100% of the pool size unlike the first user who would be at 50% of the pool size. With a third user added to the pool, they would be added to the pool with 150% of the pool size, etc. This issue results in a base or token pool that is",
        "yes,Price oracle manipulation.The vulnerability is in swapTo and burnSynth.a user can set low base or token amount and set large liquidity output or solvent chain to swap the token to liquidy or to drain the pool reserves."
    ],
    "1": [
        "yes,Reentrancy.The vulnerability is in   if (index > 0 &&  assets[index - 1].currencyId == liquidityToken.currencyId && assets[index - 1].maturity == liquidityToken.maturity && assets[index - 1].assetType == Constants.FCASH_ASSET_TYPE  ) { assets[index - 1].notional = assets[index - 1].notional.add(fCashClaim); return (assetCashClaim, 0);.Other accounting errors. Assets total notional (calculated at each index and stored as array element) is updated by adding fCashClaim only when index>=2. Before that, totalNotional should be equal to fCashClaim.",
        "yes,Reentrancy.The vulnerability is in getLiquidityTokenValue() function in AssetHandler.sol.The function invokes getRiskAdjustedPresentValue() or getPresentValue() which may lead to reentrancy attack",
        "yes,Reentrancy.The vulnerability is in return (assetCashClaim, pv);   in getLiquidityTokenValue function.An attacker can obtain a significant amount of funds from the pool by conducting a reentrancy attack. As the function does not check whether the current oracle rate is the same as the market.oracleRate (line 173 in / Contracts/AssetHandler/src/handlers/LiquidityHandler.h), it is possible to reenter the function with an attacker's desired market.oracleRate, allowing the attacker to obtain a significant amount of funds from the pool.",
        "yes,Price oracle manipulation.The vulnerability is in getLiquidityTokenValue function.The price used to calculate the liquidity token value is malleable due to the use of DateTime.getMarketIndex.e.g., assume market has a liquidity token with a notional of 1, the index is 50, and the block time is 2 days. If an attacker wants to attack the contract, he obviously attacks at 2 days ago. But after 1 day, the notional for the liquidity token is suddenly 1 000 000 and the index becomes 100 000. If the hacker continues with the attack, it will receive a higher cash claim than before. In consequence, the cash claim of the liquidity token will be mis-set, ",
        "yes,Price oracle manipulation.The vulnerability is in   if (riskAdjusted) { int256 pv =  getRiskAdjustedPresentValue(   cashGroup,   fCashClaim,   liquidityToken.maturity,   blockTime,   market.oracleRate  ); return (assetCashClaim, pv);   } else { int256 pv =  getPresentValue(fCashClaim, liquidityToken.maturity, blockTime, market.oracleRate);   return (assetCashClaim, pv);   }.AMM price oracle manipulation.Price oracle manipulation allows the core valuation formula to be manipulated and will result in incorrect valuation. This pretty much breaks the functionality of the pool contract."
    ],
    "2": [
        "yes,Price oracle manipulation.The vulnerability is in mintSynth and burnSynth.AMM price oracle manipulation.The cumulativePrices function returns the price in a non-indexed format to make it easier to check the prices. However, the mintSynth and burnSynth functions do lookups on these cumulative prices. The values are returned as uint256, but these functions expect it to be in an indexed format that allows to check if the price has reached a certain amount. As a result, it is possible to set a price that when looked up for a given amount, it shows a higher amount, than it actually is.",
        "yes,Price oracle manipulation.The vulnerability is in mintSynth and burnSynth.AMM price oracle manipulation.In both mintSynth and burnSynth, the user's deposits are swapped for synths. This can be abused by creating a lot of native or synths and swapping for more native than is currently in the pool",
        "yes,Price oracle manipulation.The vulnerability is in mintSynth and burnSynth.AMM price oracle manipulation.There is a price oracle manipulation in mintSynth and burnSynth.The VaderPoolV2.mintSynth function is vulnerable to a price oracle manipulation.The nativeDeposit of foreignAsset is transferred to this contract. Then the reserveNative and reserveForeign of foreignAsset are retrieved by this contract. Finally this contract mints a certain amount of synths(equal to the value of the nativeDeposit).However, there is a risk that an attacker transfers a nativeAsset to this contract first and manipulates the price of the nativeAsset to be a very high value. Then the attacker transfers a foreignAsset an amount of this contract. This way the foreignAsset will be minted at a large amount of synths. Afterwards the attacker manipulates the price of the foreignAsset back to the original value. In this way, the foreignAsset would",
        "yes,Price oracle manipulation.The vulnerability is in mintSynth and burnSynth functions.Sandwich attack.In the VaderPoolV2.mintSynth and VaderPoolV2.burnSynth functions, there is a danger of being flash-crashed by a sandwich attack. The attack would work like this: Someone would send a native deposit of size N, followed by N unit of foreignAsset to the pool. The pool would then compute the swap amount, update reserves, mint the synth, and then transfer to the user the synthAmount nativeAsset. Then this user would create a giant bid for this synthAsset, which can artificially increase its price. He'll then send N native back to the pool. The pool computes the resulting swap value and transfer back the original amount of foreignAsset units to the user. Back to the user a the pool a gigantic synthetic foreignAsset investment, which can be sold to realize a profit.",
        "yes,Price oracle manipulation.The vulnerability is in mintSynth and burnSynth.AMM price oracle manipulation.Because these functions directly update the pool.balance[foreignAsset] from the reserves, any token that can be minted can be used to manipulate the pool\u2019s reserves. To attack the pool, an attacker just needs to acquire some share of the synths pool, then send a large number of synths to manipulate the reserves of one of the assets in the pool. Note that due to the stateless design of VaderPool this manipulation affects all the linked pools."
    ],
    "3": [
        "yes,Reentrancy.The vulnerability is in monolithic guarantee-free contract VaderRouterV2.sol.Specifically, the function addLiquidity() allows to transfer funds to the pool, bypassing the approval step. The function can be called again with an updated deadline and larger amounts, potentially draining the user-provided wallet.",
        "yes,Reentrancy.The vulnerability is in vader.addLiquidity function.Repeated calls to the Vader.addLiquidity function can be reentered due to the presence of the internal ensure() contract clause. Although this clause is meant to guard against external actors (i.e., the contract caller is expected to enter this function once and only once), it is nevertheless possible for an external caller to repeatedly call this function if it can affect the state of the contract in a way that breaks the guard clause. The LucasEmperor.addRevenue function, which calls Vader.addLiquidity, could be called repeatedly if the profit-sharing pool of a given token reserves too much of said token, causing the pool to run out of said token. Because the Vader.addLiquidity function retrieves reserves for the token and calls reserve.mint to add the liquidity, the attack causes the given token to be added to the pool multiple times. This allows any external user",
        "yes,Reentrancy.The vulnerability is in index.sol#L23-L27.Due to the nature of the implementation (swapping tokens prior to minting liquidity), reentrancy occurs when the beneficiary of the liquidity pool call is the same as the address of the beneficiary of the token swap. The VaderV2.addLiquidity() method calls transferFrom() to transfer the tokens to the pool before swapping the tokens, causing a reentrancy attack vector.",
        "yes,ID-related violations.The vulnerability is in _swap function.ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.VaderRouterV2.sol#L128-L131:L128-IF path.length == 2,need to check only the [0]",
        "yes,ID-related violations.The vulnerability is in function addLiquidity.ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.The current implementation of VaderRouterV2.sol:addLiquidity() requires both tokenA and tokenB to be Supported assets and validated via _pool.supported(tokenB). However there is no constraint on what _pool is and hence it can be (mis) used to perform salad back-door like attack."
    ],
    "4": [
        "yes,Reentrancy.The vulnerability is in removeQuote function in Pair contract.The removeQuote function in Pair can be abused to drain lpToken completely by reentering it once with a high value of fractionalTokenAmount which is close to 0 and then running a tiny fractionalTokenAmount through it. It will allow the attacker to seize control of the entire LP ecosystem. It would still be possible to mitigate this by forcing people to pass signature over NFTs when calling the removeQuote to ensure that noone is pulling tricks.",
        "yes,Reentrancy.The vulnerability is in Pair contract.The lpToken.mint(msg.sender, lpTokenAmount); and ERC20(baseToken).safeTransferFrom(msg.sender, address(this), baseTokenAmount); triggers in add() function. When the pair is minted, the first contract call in the add() function that implements the functionality of the pair wraps (or swaps) the fractional token amounts for the reserve amounts of base token, and this amount of base token is then transferred in the second contract call to the Vault for safe storage. However, because of the nature of the ERC-20 interface this transfer causes the baseTokenAmount of base token to be locked up in the Vault eternally, as the code in the second contract call expects the ERC-20 compliant output to function in the same as a transfer() function would in other contracts, locking up the matching amount of the tokens on the other side",
        "yes,Price oracle manipulation.The vulnerability is in removeQuote function.AMM price oracle manipulation.The Pair contract defines the lpToken supply as the baseline for the fractional token reserves calculation: // ... uint256 baseTokenOutputAmount = (baseTokenReserves() * lpTokenAmount) / lpTokenSupply; uint256 fractionalTokenOutputAmount = (fractionalTokenReserves() * lpTokenAmount) / lpTokenSupply;   // ... function removeQuote(uint256 lpTokenAmount) public view returns (uint256, uint256) {  return (baseTokenOutputAmount, fractionalTokenOutputAmount); } However, because the fractional token reserves are calculated from the wrapped LpToken token amount (line 28), any slippage in the NFT-to-fractional token quote will result in the fractional token pool taking up a larger percentage of the wrapping ratio",
        "yes,Reentrancy.The vulnerability is in buy and nftSell functions.The functions perform typical reentrancy tricks to ensure non-reentrancy. However, a depositor may still reenter the function before the balances are updated.",
        "yes,Precision loss.The vulnerability is in buyQuote and sellQuote functions.The buyQuote and sellQuote functions used IEEE 754 floating-point numbers and returned the fractionalTokenAmount used was multiplied by 1000 and then rounded down. This could lead to precision loss"
    ]
}