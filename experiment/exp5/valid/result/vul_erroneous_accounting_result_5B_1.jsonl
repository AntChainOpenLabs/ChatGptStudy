{
    "0": [
        "yes,Reentrancy.The vulnerability is in function borrow(   CrossMarginAccount storage account,   address borrowToken,   uint256 borrowAmount  ) internal {   if (!hasBorrowedToken(account, borrowToken)) { account.borrowTokens.push(borrowToken);   } else { account.borrowed[borrowToken] = Lending(lending())  .applyBorrowInterest(  account.borrowed[borrowToken],  borrowToken,  account.borrowedYieldQuotientsFP[borrowToken] );   }   account.borrowedYieldQuotientsFP[borrowToken] = Lending(lending()) .viewBorrowingYieldFP(borrowToken);    account.borrowed[borrowToken] += borrowAmount;   addHolding(account, borrowToken",
        "yes,Precision loss.The vulnerability is in   function belowMaintenanceThreshold(CrossMarginAccount storage account)   internal   returns (bool)  {   uint256 loan = loanInPeg(account, true);   uint256 holdings = holdingsInPeg(account, true);   return 100 * holdings >= liquidationThresholdPercent * loan;  }.The calculation (100 * holdings >= liquidationThresholdPercent * loan) cannot hold since the result of the division is too small.  This is likely due to the use of a less-precise decimals variable. In this contract, the liquidation threshold for each token is calculated based on the current available funds balance and all leveraged funds, keeping track of it with the variable userLiquidationThreshold. The usage of this variable in the belowMaintenanceThreshold function directly makes use of the percentage times the current value of all the funds, and it",
        "yes,Reentrancy.The vulnerability is in CrossMarginAccount.sol#loan.In the CrossMarginAccount contract, there is a reentrancy vulnerability when borrowing funds. If a borrower has a token-based lending channel in place with an adequate yield, an attacker could place excessive buy orders for chunks of the token borrowed. If the attacker is able to place enough buy orders to bump the market price, they can trigger the refundWithdrawals() function of the lending channel. By doing so, the attacker is able to collect back their deposits from the channel in a single transaction (i.e. a single withdraw token call), thereby significantly shortening the repayment length of their loan and effectively loaning money for free.",
        "yes,ID-related violations.The vulnerability is in addHolding and borrow functions.ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.CrossMarginAccount.addHolding() write access to amounts[token] without access restriction,CrossMarginAccount.borrow() write access to lender() ,aughtInPeg() .Without access restriction, anyone can set amount[token] to 0.",
        "yes,Price oracle manipulation.The vulnerability is in function addHolding(  CrossMarginAccount storage account,  address token,  uint256 depositAmount ).AMM price oracle manipulation.There is a price manipulation attack in the borrow and add-holding functions that allow any token to be borrowed, This enables arbitrary token liquidity ticks. The issue is that the amount of the borrowed token is determined using the borrow yield F% based on the last deposited block. The price at this block might be way different from the current price as the recorded block-time might be large and the price might have spiked or dipped. Thus, the deposited token amount that is used as a reference for the borrowed token amount is not correct, leading to the wrong amount of the borrowed token."
    ],
    "1": [
        "yes,Price oracle manipulation.The vulnerability is in calcSwapValueInToken function.AMM price oracle manipulation.The Utils.CalcSwapValueInToken and Utils.CalcSwapOutput value can be manipulated as these values are used to calculate the funds that are going to be lent on the Vader/USDV or the Routers/USDV pairing. Since the funding is done in the linked coin of ETH, if the value of USV is big enough, the funds will fluctuate a lot due to lack of liquidity compared to the amount being lent. An attacker can set up a large amount of USV on-chain with a flashloan provider and manipulate the swap value to act as a Market Maker, thus earning at least something.",
        "yes,Price oracle manipulation.The vulnerability is in calcSwapValueInBase(iSYNTH(collateralAsset).TOKEN(), _collateralAdjusted); // Calc swap value.AMM price oracle manipulation.The Utils.calcSwapValueInBase function calculates the swap value by calling iSYNTH(collateralAsset).TOKEN()->calcSwapValueInBase. This function uses a non-standard (not-in-snippet, non-coverable call) to break the tight link and recalculates the swap value by accessing the register of iSYNTH(collateralAsset). Because of this, an attacker with larger resources than honest their reserves of the collateral asset poses a significant risk to the price of the target token and the funds held in the contract.##",
        "yes,Price oracle manipulation.The vulnerability is in calcSwapOutput function.AMM price oracle manipulation.The getCollateralValueInBase function uses a fixed 150% collateral-for- BTC formula for swaps between base and collateral assets (line 368). Instead of using fixed percentages, pool output amounts should be calculated using the actual dynamic collateral ratio as retrieved from the oracle. The 150% ratio is derived from the historical ratio between the BTC loan pool and the VADER/USDV pairs. However, it's not clear why that 150% would remain in place when the VADER pool has dynamic Maker-style collateral ratio. Furthermore, the getCollateralValueInBase code assumes swaps between base assets (BTC) and collateral assets; the swap formula is specifically designed to handle BTC extensions to the collateral pool, but it's unclear why swaps in the opposite direction should then use the same formula. The swap function should be computed using the dynamic borrowing fees stored in the",
        "yes,Price oracle manipulation.The vulnerability is in calcSwapOutput function.AMM price oracle manipulation.The Utils.swapOutput function is used to calculate the swap output value. We observe that it uses the calcSwapOutput function from SwapOutputCompute.sol to compute the swap output. The latter is a big fat and unclear accounting expression, relying on the collaterals' contract cryptoeconomics. It is a perfect target for a price oracle manipulation attack, as we show in the following: \\#if(!VADER.isBare(VADER.SYMBOL())){ \\\\ uint _baseAmt = calcAsymmetricShare(VADER.TOKEN(), VADER.AMOUNT(), USDV.SYMBOL()); \\\\ uint _evmAmt = calcAsymmetricShare(USDV.TOKEN(), VADER.AMOUNT(), VADER",
        "yes,Price oracle manipulation.The vulnerability is in calcSwapOutput function.AMM price oracle manipulation.The Utils.swap.calcSwapOutput() function in Vader borrows its idea from the Vshort/Vlong swap of Bancor protocol . It is used to calculate the valuation ratio of two output tokens (base and token) according to the HHT algorithm . However, it has a lack of protection against a flash loan attack, attackers can use the asymmetric flash loan attack to manipulate the value of the two output tokens, and occasionally drain the funds in the trust fund wallet."
    ],
    "2": [
        "yes,Reentrancy.The vulnerability is in NFTXVaultUpgradeable.sol#redeem().If the vault allows redemptions of NFTs, users can place arbitrary NFTs into the vault for safekeeping, and then use the vault-enabled API (e.g. NFTXVault.redeem or similar) to withdraw their funds back to their wallet.",
        "yes,Reentrancy.The vulnerability is in NFTXVaultUpgradeable.sol#redeem.The function triger a reentrancy attack when the function is called, the backend (i.e. the real-world token contract) will be called recursively until the program runs out of stack and possibly leading to a loss of real funds.",
        "yes,ID-related violations.The vulnerability is in function redeem().ID can be arbitrarily set by users or lack of ID validation. ID can also be a project-specified variable (e.g., hash) or an address.Function redeem() can be called by anyone to redeem NFTs. NFTs can be redeemed to recipient without restrictions, resulting other NFTs being stolen, or wallet funds being drained if connected to a fee receiver, or possibly other attacks.",
        "yes,ID-related violations.The vulnerability is in  NFTXVaultUpgradeable.sol#redeem().Non-unique Asset IDs violate NFT standard (@0),Receiver can arbitrarily select NFTs to takeover,Keeloq engine should prevent replay attack but NFTs may be injected more than once (SignedOfferV5 becomes optional),also, NFTXVaultUpgradeable.sol#redeem() function is public, it may cause an NFT replay attack,",
        "yes,Reentrancy.The vulnerability is in NFTXVaultUpgradeable.sol#redeemTo.In the function NFTXVaultUpgradeable.sol#redeemTo, if the token being redeemed has a reentrancy guard, it allows reentrancy."
    ],
    "3": [
        "yes,Price oracle manipulation.The vulnerability is in refreshTimer scheduler.The refresh timer serves to regularly query the underlying asset price from the flash hook as the price cannot be trusted on an instantaneous basis and should be validated against a set of source/path hook history. The price is then exposed to the callsers through the _get() and _peek() function. However, these price retrieval functions are subject to the following manipulations: a) Locking up the funds in the contract by calling the self-destruct with a large amount of ISM hours, and then place many order at a locked up rate. b) Force the update of the price through various locking and callar methods. c) Take control of the assets deposited in the contract by calling the path function to change the path. Before digging into the details of the vulnerability, we should understand the place of these functions in the contracts. Following are the definition of these",
        "yes,Price oracle manipulation.The vulnerability is in   function _setPath(bytes6 base, bytes6 quote, bytes6[] memory path) internal {   bytes6 base_ = base;   for (uint256 p = 0; p < path.length; p++) { require (sources[base_][path[p]].source != address(0), \"Source not found\"); base_ = path[p];   }   paths[base][quote] = path;   emit PathSet(base, quote, path);  }.AMM price oracle manipulation.In the mentioned function, if the given base and the given quote are both valid, and the source for the given quote is indeed trusted, the internal state of the contract for that pair is updated, namely it adds a path to the corresponding quote. Unfortunately this update is not reverted in case the oracle is no longer considered trusted, which can",
        "yes,Reentrancy.The vulnerability is in peek function of CompositeMultioOracle.ListenReactor.This transaction will put an open order, allowing a user to sell as many units of the asset as he wants for the price given by the oracle provided that he makes the call with less than 748675655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655655",
        "yes,Price oracle manipulation.The vulnerability is in   function _peek(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)   private view returns (uint priceOut, uint updateTimeOut) {   Source memory source = sources[base][quote];   require (source.source != address(0), \"Source not found\");   (priceOut, updateTimeOut) = IOracle(source.source).peek(base, quote, 10 ** source.decimals);// Get price for one unit   priceOut = priceIn * priceOut / (10 ** source.decimals);// Fixed point according to decimals   updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;  // Take the oldest update time }.Arithmetic operation vulnerability. A hacker or an insider with permission to set the or",
        "yes,Reentrancy.The vulnerability is in   function _get(bytes6 base, bytes6 quote, uint256 priceIn, uint256 updateTimeIn)   private returns (uint priceOut, uint updateTimeOut)  {   Source memory source = sources[base][quote];   require (source.source != address(0), \"Source not found\");   (priceOut, updateTimeOut) = IOracle(source.source).get(base, quote, 10 ** source.decimals); // Get price for one unit   priceOut = priceIn * priceOut / (10 ** source.decimals);// Fixed point according to decimals   updateTimeOut = (updateTimeOut < updateTimeIn) ? updateTimeOut : updateTimeIn;  // Take the oldest update time  }.Other accounting errors. Losing funds during the (priceIn * priceOut / (10 **"
    ],
    "4": [
        "yes,Erroneous state updates.The vulnerability is in price_ = PricePoint( _microTick,  _macroTick,  computeDepth(_marketLiquidity, _ovlPrice) );.Calculations performed with incorrect numbers. The function fetchPricePoint() calculates the market liquidity with the following formula: uint marketLiquidity = (uint160(microWindow) << 128) / ( _liqs[0] - _liqs[1] ); Which is equivalent to the following code: uint marketLiquidity = uint160(_liqs[1]) - uint160(_liqs[0]); Which is equivalent of uint256(_marketLiquidity << 128) / 2e18 ; To compute the market liquidity in a meaningful way, one would need compute the volumes traded in both bids and asks at their respective tick-by-tick moments and divide them instead of using the ticks values directly. The",
        "yes,Price oracle manipulation.The vulnerability is in uint _ovlPrice = OracleLibraryV2.getQuoteAtTick( int24((_ticks[0] - _ticks[1]) / int56(int32(int(macroWindow)))), 1e18, ovl, eth );.AMM price oracle manipulation.In the fetchPricePoint function of the OverlayV1UniswapV3Market contract, the price is fetched from OracleLibraryV2 using the UniswapV3Pool. The OracleLibraryV2.getQuoteAtTick() requires an Array of _ticks and returns the uint _ovlPrice in Vatu. However, a malicious actor can manipulate the _ticks array to provide a desired _ovlPrice value. By supplying an _ovlPrice that closely matches the current Vatu price, the arbitrage bot that relies on this",
        "yes,Price oracle manipulation.The vulnerability is in price_ = PricePoint(uint24(_microTick),uint24(_macroTick),computeDepth(_marketLiquidity, uint128(_ovlPrice)));.Other accounting errors. The price of an LLS is computed by: price_ = PricePoint( uint24(_microTick), uint24(_macroTick), computeDepth(_marketLiquidity, uint128(_ovlPrice)) );. If _macroTick > 0, then _ovlPrice should be the price given by UniswapV3 (i.e. the market price; in ULS, this is the chain price realized by previous swaps), scaled by _awapScalingRatio. Instead, it is scaled by _priceFrameCap, which is never better than the chain price:",
        "yes,ID-related violations.The vulnerability is in price_ = PricePoint( _microTick,  _macroTick,  computeDepth(_marketLiquidity, _ovlPrice) );.Shared resource (e.g., token) without proper locks.Malicious markete can spoof user price point,The markete can spoof user price points by delaying the mothership feed for one tick. The implementation of the OverlayV1UniswapV3Market contract relies on the real-time (i.e., non-delayed) market feeds (_mothership.getPrice() and ovl.getPrice()). However, depending on the deployment configuration, it is possible that the _mothership.getPrice() and ovl.getPrice() are delayed (i.e., not updated in real-time), opening an opportunity for the malicious market to pull the order book and spoof user price points by delaying",
        "yes,Price oracle manipulation.The vulnerability is in int32() : \ufffd\ufffd. MM rules can be circumvented by submitting bids and asks with the same price (e.g., $10). Then, Zarios API will take the price as the common one. To exploit this feature, the hacker creates an anchor transaction of \ufffd\ufffd with a large amount of ETH which can flash on the screen as the price of tokens. Other traders could then be tricked into thinking that the price is this value, and place large orders at it. After obtaining a large quantity of the desired tokens, he/she then withdraws everything.The OverlayV1UniswapV3Market contract hooks into the UniswapV3Pool and calculates the price points in the underlying pool. However, the price points are calculated using underlying liquidity from the UniswapV3Pool, which is reflected in the finite tick size. A malicious user can manipulate this pool to make the price"
    ]
}