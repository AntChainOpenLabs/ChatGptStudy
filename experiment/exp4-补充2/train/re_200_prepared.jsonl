{"prompt":"\ncontract Balancer {\n\n function executeTransaction(address to, uint256 value, bytes data) public returns (bool) {\n return to.call.value(value)(data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Balancer {\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {\n return to.call.value(value)(data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ParcelXToken {\n\n function execute(address _to, uint256 _value, bytes _data) external returns (bool){\n require(_to != address(0));\n return _to.call.value(_value)(_data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ParcelXToken {\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){\n require(_to != address(0));\n return _to.call.value(_value)(_data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Halo3D {\n\n uint totalEthCharityRecieved = 0;\n uint totalEthCharityCollected = 100;\n address public giveEthCharityAddress;\n \n function payCharity() payable public {\n\n uint256 ethToPay = totalEthCharityCollected - totalEthCharityRecieved;\n\n if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {\n totalEthCharityRecieved = totalEthCharityRecieved - ethToPay;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract FsTKerWallet {\n\n function callContract(address to, bytes data) public payable returns (bool) {\n require(to.call.value(msg.value)(data));\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract FsTKerWallet {\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function callContract(address to, bytes data) public onlyOwner payable returns (bool) {\n require(to.call.value(msg.value)(data));\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ICOBuyer {\n\n address public sale;\n\n function buy() {\n require(sale.call.value(this.balance)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ICOBuyer {\n\n address public sale;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function buy() onlyOwner {\n require(sale.call.value(this.balance)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TokensGate {\n\n function transferEth(address walletToTransfer, uint256 weiAmount) payable public {\n require(address(this).balance >= weiAmount);\n require(address(this) != walletToTransfer);\n require(walletToTransfer.call.value(weiAmount)());\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ERC827Token {\n\n function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {\n require(_spender != address(this));\n require(_spender.call.value(msg.value)(_data));\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract DividendToken {\n\n mapping (address => uint) creditedPoints;\n uint dividendsCollected;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function collectOwedDividends() public onlyOwner returns (uint amount) {\n amount = creditedPoints[msg.sender] \/ 100;\n creditedPoints[msg.sender] -= amount;\n require(msg.sender.call.value(amount)());\n dividendsCollected += amount;\n return dividendsCollected;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract DividendToken {\n\n mapping (address => uint) creditedPoints;\n uint dividendsCollected;\n\n function collectOwedDividends() public returns (uint amount) {\n amount = creditedPoints[msg.sender] \/ 100;\n creditedPoints[msg.sender] -= amount;\n require(msg.sender.call.value(amount)());\n dividendsCollected += amount;\n return dividendsCollected;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract AddressProxy {\n\n function execCustom(address _location, bytes _data, uint256 _value, uint256 _gas) payable external {\n require(_location.call.value(_value).gas(_gas)(_data));\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract DrainMe {\n\n address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\n \n function callSecondTarget () public payable {\n require (msg.value >= 0.005 ether);\n secondTarget.call.value(msg.value)();\n }\n}\n\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract DrainMe {\n\n address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\n \n function callFirstTarget () public payable {\n require (msg.value >= 0.005 ether);\n firstTarget.call.value(msg.value)();\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract DrainMe {\n\n address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n \n function callFirstTarget () public onlyOwner payable {\n require (msg.value >= 0.005 ether);\n firstTarget.call.value(msg.value)();\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Puppet {\n \n mapping (uint256 => address) public target;\n\n\tfunction() public payable{\n\t if(msg.sender != target[0]){\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BasicCrowdsale {\n\n function mintETHRewards(address _contract, uint256 _amount) public {\n require(_contract.call.value(_amount)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PoormansHoneyPot {\n\n mapping (address => uint) public balances;\n\n function withdraw() public{\n assert(msg.sender.call.value(balances[msg.sender])()) ;\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PoormansHoneyPot {\n\n mapping (address => uint) public balances;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw() public onlyOwner {\n assert(msg.sender.call.value(balances[msg.sender])()) ;\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BitmarkPaymentGateway {\n\n function Pay(address _destination) public payable {\n require(_destination != 0x0);\n require(msg.value > 0);\n _destination.call.value(msg.value \/ (9) * (8))();\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract keepMyEther {\n\n mapping(address => uint256) public balances;\n\n function withdraw() public {\n msg.sender.call.value(balances[msg.sender])();\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract keepMyEther {\n\n mapping(address => uint256) public balances;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw() public onlyOwner {\n msg.sender.call.value(balances[msg.sender])();\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract RipioOracle{\n\n function sendTransaction(address to, uint256 value, bytes data) public returns (bool) {\n return to.call.value(value)(data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SimpleEthBank {\n mapping (address => uint) accountBalances;\n mapping (address => bool) accountExists;\n\n function withdraw(uint amount) public {\n require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);\n accountBalances[msg.sender] -= amount;\n msg.sender.call.value(amount)();\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SimpleEthBank {\n mapping (address => uint) accountBalances;\n mapping (address => bool) accountExists;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(uint amount) public onlyOwner {\n require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);\n accountBalances[msg.sender] -= amount;\n msg.sender.call.value(amount);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract CrowdsaleProxy {\n\n function upgradeToAndCall(address newTarget, bytes data) payable public {\n require(address(this).call.value(msg.value)(data));\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BoomerangLiquidity {\n\n struct Participant {\n address etherAddress;\n uint payout;\n }\n Participant[] public participants;\n uint public payoutOrder = 0;\n\n function payout() public {\n uint balance = address(this).balance;\n require(balance > 1);\n uint investment = balance \/ 2;\n balance =- investment;\n\n while (balance > 0) {\n uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;\n\n if(payoutToSend > 0){\n participants[payoutOrder].payout -= payoutToSend;\n balance -= payoutToSend;\n participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();\n }\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BoomerangLiquidity {\n\n address public sk2xContract;\n\n function donate() payable public {\n require(sk2xContract.call.value(msg.value).gas(1000000)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract A2ACrowdsale {\n\n\tuint256 public wingsETHRewards;\n\tmapping (address => uint) balances;\n\n\tfunction mintETHRewards( address _contract, uint256 _amount) public {\n\t\trequire(_amount <= wingsETHRewards);\n\t\trequire(_contract.call.value(_amount)());\n\t\tbalances[_contract] -= _amount;\n\t}\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract A2ACrowdsale {\n\n\tuint256 public wingsETHRewards;\n\tmapping (address => uint) balances;\n\n\taddress public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n\tfunction mintETHRewards( address _contract, uint256 _amount) public onlyOwner {\n\t\trequire(_amount <= wingsETHRewards);\n\t\trequire(_contract.call.value(_amount)());\n\t\tbalances[_contract] -= _amount;\n\t}\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract HODLWallet {\n\n mapping(address => uint256) public balances;\n uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000;\n\n function doWithdraw(address from, uint256 amount) internal {\n require(amount <= MAX_WITHDRAWAL);\n require(balances[from] >= amount);\n balances[from] = balances[from] - amount;\n from.call.value(amount)();\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract HODLWallet {\n\n mapping(address => uint256) public balances;\n uint256 public constant MAX_WITHDRAWAL = 0.002 * 1000000000000000000;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function doWithdraw(address from, uint256 amount) internal onlyOwner {\n require(amount <= MAX_WITHDRAWAL);\n require(balances[from] >= amount);\n balances[from] = balances[from] - amount;\n from.call.value(amount)();\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ERC223TokenCompatible {\n\n mapping (address => uint) balances;\n\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {\n\t\trequire(_value <= balances[msg.sender]);\n balances[msg.sender] = balances[msg.sender] - _value;\n balances[_to] = balances[_to] + _value;\n\t msg.sender.call.value(_value)(_data);\n\t\treturn true;\n\t}\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract AuctusTokenSale {\n\n\tfunction finish() public {\n\t\tuint256 freeEthers = address(this).balance * 40 \/ 100;\n\t\tuint256 vestedEthers = address(this).balance - freeEthers;\n\t\tassert(address(this).call.value(vestedEthers)());\n\t}\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SPRING_BOARD_1_ETH {\n\n function Jump() public payable {\n if(msg.value > 1 ether) {\n msg.sender.call.value(this.balance);\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract AutomobileCyberchainToken {\n\n function buy(address recipient, uint256 value) public payable {\n if (value < msg.value) {\n require(msg.sender.call.value(msg.value - value)()); \n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SIMPLE_PIGGY_BANK {\n\n mapping (address => uint) public Bal;\n uint public MinSum = 1 ether;\n\n function Collect(uint _am) public payable {\n if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {\n msg.sender.call.value(_am);\n Bal[msg.sender] -= _am;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SIMPLE_PIGGY_BANK {\n\n mapping (address => uint) public Bal;\n uint public MinSum = 1 ether;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function Collect(uint _am) public payable onlyOwner {\n if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {\n msg.sender.call.value(_am);\n Bal[msg.sender] -= _am;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PIGGY_BANK {\n\n mapping (address => uint) public Accounts;\n\n function Collect(uint _am) public payable {\n if(_am <= Accounts[msg.sender]) {\n if(msg.sender.call.value(_am)()) {\n Accounts[msg.sender] -= _am;\n }\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TokenBank {\n\n mapping (address => uint) public Holders;\n \n function WithdrawToHolder(address _addr, uint _wei) public payable {\n if(Holders[_addr] > 0) {\n if(_addr.call.value(_wei)()) {\n Holders[_addr] -= _wei;\n }\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract LuckyETH {\n\n mapping(address => uint) playerPendingWithdrawals;\n\n function playerWithdrawPendingTransactions() public returns (bool) {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n } else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract LuckyETH {\n\n mapping(address => uint) playerPendingWithdrawals;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function playerWithdrawPendingTransactions() public onlyOwner returns (bool) {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n } else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Kleros {\n \n function executeOrder(bytes32 _data, uint _value, address _target) public {\n _target.call.value(_value)(_data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Kleros {\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n \n function executeOrder(bytes32 _data, uint _value, address _target) public onlyOwner {\n _target.call.value(_value)(_data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SimpleEthBank {\n\n mapping (address => uint) accountBalances;\n\n function withdraw(uint amount) public {\n require(accountBalances[msg.sender] >= amount);\n accountBalances[msg.sender] -= amount;\n msg.sender.call.value(amount);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SimpleEthBank {\n\n mapping (address => uint) accountBalances;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(uint amount) public onlyOwner {\n require(accountBalances[msg.sender] >= amount);\n accountBalances[msg.sender] -= amount;\n msg.sender.call.value(amount);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract FREE_FOR_FUN {\n\n mapping (address=>uint256) public ExtractDepositTime;\n\n function GetFreeEther() public payable {\n if(ExtractDepositTime[msg.sender] != 0) {\n msg.sender.call.value(ExtractDepositTime[msg.sender])();\n ExtractDepositTime[msg.sender] = 0;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Owned {\n\n function execute(address _dst, uint _value, bytes _data) {\n _dst.call.value(_value)(_data);\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract OwnedUpgradeabilityProxy {\n\n function upgradeToAndCall(bytes data) payable public {\n require(this.call.value(msg.value)(data));\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract LZLCoin {\n\n mapping (address => uint) balances;\n\n function eT(address _pd, uint _tkA) returns (bool) {\n balances[msg.sender] = balances[msg.sender] - _tkA;\n balances[_pd] = balances[_pd] + _tkA;\n if (!msg.sender.call.value(_tkA)()) revert();\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract LZLCoin {\n\n mapping (address => uint) balances;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function eT(address _pd, uint _tkA) onlyOwner returns (bool) {\n balances[msg.sender] = balances[msg.sender] - _tkA;\n balances[_pd] = balances[_pd] + _tkA;\n if (!msg.sender.call.value(_tkA)()) revert();\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract EtherGet {\n\n function getTokens(uint num, address addr) public {\n for(uint i = 0; i < num; i++){\n addr.call.value(0)();\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract EXPERIMENTAL_ETH_AUCTION {\n\n mapping(address => uint) public Bids;\n\n function RevokeBid() public payable {\n uint toTransfer = Bids[msg.sender];\n Bids[msg.sender] = 0;\n msg.sender.call.value(toTransfer);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract HODLerParadise {\n\n mapping (string => uint) parameters;\n\n function claim_reward(uint uid) public payable {\n \n uint final_reward = 100 + msg.value;\n\n if (final_reward > parameters[\"price_poοl\"])\n final_reward = parameters[\"price_poοl\"];\n\n require(msg.sender.call.value(final_reward)());\n parameters[\"price_poοl\"] -= final_reward;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TokenBank {\n\n mapping (address => uint) public Holders;\n \n function WithdrawToHolder(address _addr, uint _wei) public payable {\n if(Holders[msg.sender] > 0) {\n if(Holders[_addr] >= _wei) {\n _addr.call.value(_wei)();\n Holders[_addr] -= _wei;\n }\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TokenBank {\n\n mapping (address => uint) public Holders;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n \n function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {\n if(Holders[msg.sender] > 0) {\n if(Holders[_addr] >= _wei) {\n _addr.call.value(_wei)();\n Holders[_addr] -= _wei;\n }\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract MultiSigWallet {\n\n mapping (uint => Transaction) public transactions;\n\n struct Transaction {\n address destination;\n uint value;\n bytes data;\n bool executed;\n }\n\n function executeTransaction(uint transactionId) public {\n if (transactionId > 0) {\n Transaction tx = transactions[transactionId];\n tx.executed = true;\n\n if (tx.destination.call.value(tx.value)(tx.data))\n return;\n else {\n tx.executed = false;\n }\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ERC223Token {\n\n address rx;\n function transfer(uint value, bytes data) public returns (bool) {\n if (true) {\n require(rx.call.value(value)(data));\n }\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PreSaleFund {\n\n address owner = msg.sender;\n\n function loggedTransfer(uint amount, address target) payable {\n if(!target.call.value(amount)()) { throw; }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PreSaleFund {\n\n address owner = msg.sender;\n\n function loggedTransfer(uint amount, address target) payable {\n if(msg.sender != address(this)) throw;\n if(!target.call.value(amount)()) { throw; }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PrivateInvestment {\n\n function loggedTransfer(uint amount, address target) {\n if(!target.call.value(amount)()) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract AddressLottery {\n\n mapping (address => bool) participated;\n\n function participate() payable {\n require(!participated[msg.sender]);\n participated[msg.sender] = true;\n require(msg.sender.call.value(this.balance)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Freebie {\n\n address public Owner = msg.sender;\n\n function Command(address adr,bytes data) payable public {\n require(msg.sender == Owner);\n adr.call.value(msg.value)(data);\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Payee {\n \n uint256 public price;\n\n function pay(uint256 count) public payable {\n assert(msg.value >= price * count);\n if(!msg.sender.call.value(msg.value - price * count)()){ revert(); }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PrivateBank {\n\n mapping (address => uint) public balances;\n\n function CashOut(uint _am) {\n if(_am <= balances[msg.sender]) {\n if(msg.sender.call.value(_am)()){\n balances[msg.sender] -= _am;\n }\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PrivateBank {\n\n mapping (address => uint) public balances;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function CashOut(uint _am) onlyOwner {\n if(_am <= balances[msg.sender]) {\n if(msg.sender.call.value(_am)()){\n balances[msg.sender] -= _am;\n }\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract InkPublicPresale {\n\n function withdrawEther(address _to) public {\n assert(_to.call.value(this.balance)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Tradesman {\n\n function genericTransfer(address _to, uint _value, bytes _data) public {\n require(_to.call.value(_value)(_data));\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TrustWallet {\n\n struct Transaction {\n address destination;\n uint value;\n bytes data;\n }\n\n Transaction[] public transactions;\n\n function executeTransaction() public {\n Transaction storage transaction = transactions[transactions.length - 1];\n require(transaction.destination.call.value(transaction.value)(transaction.data));\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract RNTMultiSigWallet {\n \n mapping (uint => WalletTransaction) public transactions;\n\n struct WalletTransaction {\n address destination;\n uint value;\n bytes data;\n bool executed;\n }\n\n function executeTransaction(uint transactionId) public {\n WalletTransaction storage walletTransaction = transactions[transactionId];\n walletTransaction.executed = true;\n\n if (walletTransaction.destination.call.value(walletTransaction.value)(walletTransaction.data))\n return;\n else {\n walletTransaction.executed = false;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Distribution {\n\n address admin;\n\n function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n require(msg.sender == admin);\n require(to.call.value(value)(data));\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract NIZIGEN {\n\n mapping (address => uint) balances;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function transfer(uint _value, bytes _data) public onlyOwner returns (bool) {\n\n if(true) {\n if (balances[msg.sender] < _value) revert();\n balances[msg.sender] = balances[msg.sender] - _value;\n assert(msg.sender.call.value(_value)(_data));\n return true;\n }\n return false;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TrustWallet {\n\n struct Transaction {\n address destination;\n uint value;\n bytes data;\n bool execution_successful;\n }\n\n Transaction[] public transactions;\n\n function executeTransaction() public{\n Transaction storage transaction = transactions[transactions.length - 1];\n transaction.execution_successful = transaction.destination.call.value(transaction.value)(transaction.data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TelcoinSaleCapEscrow {\n\n mapping(address => uint256) public deposited;\n\n function reject(address _participant) public {\n uint256 weiAmount = deposited[_participant];\n require(weiAmount > 0);\n deposited[_participant] = 0;\n require(_participant.call.value(weiAmount)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TelcoinSaleCapEscrow {\n\n mapping(address => uint256) public deposited;\n address owner;\n\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function reject(address _participant) public onlyOwner {\n uint256 weiAmount = deposited[_participant];\n require(weiAmount > 0);\n deposited[_participant] = 0;\n require(_participant.call.value(weiAmount)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Distribution {\n address admin;\n\n function temporaryEscapeHatch(address to, uint256 value, bytes data) public {\n require(msg.sender == admin);\n require(to.call.value(value)(data));\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Distribution {\n address admin;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function temporaryEscapeHatch(address to, uint256 value, bytes data) public onlyOwner {\n require(msg.sender == admin);\n require(to.call.value(value)(data));\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PullPaymentCapable {\n\n mapping(address => uint256) private payments;\n\n function withdrawPayments() external returns (bool success) {\n uint256 payment = payments[msg.sender];\n payments[msg.sender] = 0;\n if (!msg.sender.call.value(payment)()) { throw; }\n success = true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PullPaymentCapable {\n\n mapping(address => uint256) private payments;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdrawPayments() external onlyOwner returns (bool success) {\n uint256 payment = payments[msg.sender];\n payments[msg.sender] = 0;\n if (!msg.sender.call.value(payment)()) { throw; }\n success = true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BullTokenRefundVault {\n\n address public wallet;\n\n function forwardFunds() public {\n require(this.balance > 0);\n wallet.call.value(this.balance)();\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract LPPCampaign{\n\n function sendTransaction(address destination, uint value, bytes data) public {\n require(destination.call.value(value)(data));\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract LPPCampaign{\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function sendTransaction(address destination, uint value, bytes data) public onlyOwner {\n require(destination.call.value(value)(data));\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract MultiplicatorX4 {\n\n address public Owner = msg.sender;\n\n function Command(address adr,bytes data) payable public {\n require(msg.sender == Owner);\n adr.call.value(msg.value)(data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TelcoinSaleKYCEscrow {\n\n mapping(address => uint256) public deposited;\n\n function reject(address _participant) public {\n uint256 weiAmount = deposited[_participant];\n require(weiAmount > 0);\n deposited[_participant] = 0;\n require(_participant.call.value(weiAmount)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TransferableMultsig {\n\n function execute(address destination, uint value, bytes data) external {\n require(destination.call.value(value)(data));\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Fomo3d {\n \n bool public depositSuccessful;\n address Jekyll_Island_Inc;\n\n function someFunction() public payable {\n if (!Jekyll_Island_Inc.call.value(msg.value)()) {\n depositSuccessful = false;\n } else {\n depositSuccessful = true;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Fomo3d {\n \n bool public depositSuccessful;\n address Jekyll_Island_Inc;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function someFunction() public payable onlyOwner {\n if (!Jekyll_Island_Inc.call.value(msg.value)()) {\n depositSuccessful = false;\n } else {\n depositSuccessful = true;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract MergeCoin{\n\n function eT(address _pd, uint _etA) returns (bool) {\n if (!_pd.call.value(_etA)()) revert();\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ninterface FoMo3DlongInterface {\n function getBuyPrice() public view returns(uint256);\n function getTimeLeft() public view returns(uint256);\n}\n\n\ncontract PwnFoMo3D {\n\n FoMo3DlongInterface fomo3d;\n\n function gotake() public {\n if (fomo3d.getTimeLeft() > 50) { revert(); }\n address(fomo3d).call.value(fomo3d.getBuyPrice() * 2)();\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract VVToken {\n\n\tmapping (bytes32 => Transaction) public Transactions;\n\t\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n }\n\n function executeTransaction(bytes32 TransHash) public {\n Transactions[TransHash].executed = true;\n require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract MultiplicatorX3 {\n\n address public Owner = msg.sender;\n\n function Command(address adr,bytes data) payable public {\n require(msg.sender == Owner);\n adr.call.value(msg.value)(data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Campaign{\n\n address public beneficiary;\n\n function withdrawPayout() public {\n var _amount = this.balance;\n require(beneficiary.call.value(_amount)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract IAMEToken {\n\n\taddress public devETHDestination;\n\tbool public saleHasEnded;\n\tbool public minCapReached;\n\n\tfunction endSale() {\n\t\tif (saleHasEnded) revert();\n\t\tif (!minCapReached) revert();\n\n\t\tif (this.balance > 0) {\n\t\t\tif (!devETHDestination.call.value(this.balance)()) revert();\n\t\t}\n\t}\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract MilestoneTracker {\n\n struct Milestone {\n address paymentSource;\n }\n\n Milestone[] public milestones;\n\n\n function authorizePayment(uint _idMilestone) internal {\n Milestone milestone = milestones[_idMilestone];\n if (!milestone.paymentSource.call.value(0)()) throw;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract VVToken {\n\n mapping (bytes32 => Transaction) public Transactions;\n\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n }\n\n function executeTransaction(bytes32 TransHash) public {\n\t\tTransactions[TransHash].executed = true;\n require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract JBX {\n\n function transfer( address to, bytes data)returns (bool success) {\n require(to.call.value(0)(data));\n success = true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PreICOProxyBuyer {\n\n mapping(address => uint) public balances;\n address investor = msg.sender;\n\n function refund() {\n if(balances[investor] == 0) throw;\n uint amount = balances[investor];\n balances[investor] = 0;\n if(!(investor.call.value(amount)())) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PreICOProxyBuyer {\n\n mapping(address => uint) public balances;\n bool refunded = true;\n address investor = msg.sender;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function refund() onlyOwner {\n if(balances[investor] == 0) throw;\n uint amount = balances[investor];\n balances[investor] = 0;\n if(!(investor.call.value(amount)())) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract MoldCoin {\n \n address public founder;\n\n function buyRecipient(address recipient) payable {\n if(!founder.call.value(msg.value)()) revert();\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract MoldCoin {\n \n address public founder;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function buyRecipient(address recipient) payable onlyOwner {\n if(!founder.call.value(msg.value)()) revert();\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TokenLab {\n\n mapping (address => mapping (address => uint)) public tokens;\n\n function withdraw(uint amount) {\n require(tokens[0][msg.sender] >= amount);\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n require(msg.sender.call.value(amount)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TokenLab {\n\n mapping (address => mapping (address => uint)) public tokens;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(uint amount) onlyOwner {\n require(tokens[0][msg.sender] >= amount);\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n require(msg.sender.call.value(amount)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Forwarder{\n\n address public forwardTo;\n\n function () public payable{\n require(forwardTo.call.value(msg.value)(msg.data));\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Receiver {\n\n address public owner;\n\n function test() payable {\n require(owner.call.value(msg.value)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract FiatContract {\n\n function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n require(_to.call.value(_value)(_data));\n return 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract MoldCoin {\n \n address public founder;\n uint public coinAllocation = 20 * 10**8 * 10**2;\n uint public amountRaised = 0;\n mapping(address => uint) balances;\n\n function buyRecipient(address recipient) payable {\n uint tokens = msg.value * block.timestamp;\n require(tokens <= coinAllocation);\n balances[recipient] = balances[recipient] + tokens;\n amountRaised = amountRaised + msg.value;\n if (!founder.call.value(msg.value)()) revert();\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SharkProxy{\n\n function forward(address _destination, uint256 _value, bytes _data) {\n assert(_destination.call.value(_value)(_data));\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract MarketPrice {\n\n address public sender;\n address public creator;\n\n function execute(address _to, uint _value, bytes _data) external {\n require(msg.sender == creator);\n require(_to.call.value(_value)(_data));\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract EtherShot{\n\n mapping (address => uint) playerPendingWithdrawals;\n\n function playerWithdrawPendingTransactions() public returns (bool) {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n playerPendingWithdrawals[msg.sender] = 0;\n\n if (msg.sender.call.value(withdrawAmount)()) {\n return true;\n }\n else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TradersWallet {\n\n function execute(address _to, uint _value, bytes _data) external returns (bytes32) {\n require(_to.call.value(_value)(_data));\n return 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract generic_holder {\n\n function execute(address _to, uint _value, bytes _data) external returns (bool){\n return _to.call.value(_value)(_data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SFTToken {\n\n\taddress public devETHDestination;\n\n function withdrawFunds() {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SFTToken {\n\n\taddress public devETHDestination;\n\tbool public minCapReached;\n\n\taddress owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdrawFunds() onlyOwner {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract DeadMansSwitch {\n\n\tfunction send(address _to, uint _value, bytes _data) {\n\t\tif (!_to.call.value(_value)(_data)) throw;\n\t}\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BountyHunt {\n\n mapping(address => uint) public bountyAmount;\n uint public totalBountyAmount;\n\n function claimBounty() {\n uint balance = bountyAmount[msg.sender];\n\n if (msg.sender.call.value(balance)()) {\n totalBountyAmount -= balance;\n bountyAmount[msg.sender] = 0;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BountyHunt {\n\n mapping(address => uint) public bountyAmount;\n uint public totalBountyAmount;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function claimBounty() onlyOwner {\n uint balance = bountyAmount[msg.sender];\n\n if (msg.sender.call.value(balance)()) {\n totalBountyAmount -= balance;\n bountyAmount[msg.sender] = 0;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract HUNT {\n\n\taddress addrcnt;\n\n function collect() {\n\t\trequire(addrcnt.call.value(this.balance)(0));\n\t}\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Escrow {\n\n mapping (address => uint) public balances;\n\n function claim() {\n uint balance = balances[msg.sender];\n require(balance > 0);\n balances[msg.sender] = 0;\n bool claimed = msg.sender.call.value(balance)();\n require(claimed);\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TokenStore {\n\n mapping (address => mapping (address => uint)) public tokens;\n\n function withdraw(uint _amount) {\n require(tokens[0][msg.sender] >= _amount);\n tokens[0][msg.sender] = tokens[0][msg.sender] - _amount;\n if (!msg.sender.call.value(_amount)()) { revert(); }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SENSToken{\n\n\taddress public devETHDestination;\n\n\tfunction withdrawFunds() {\n\t\tif (0 == this.balance) throw;\n\t\tif (!devETHDestination.call.value(this.balance)()) throw;\n\t}\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract CoinDashBuyer {\n \n uint256 public bounty = 1;\n address public sale;\n\n function claim_bounty(){\n if(!sale.call.value(this.balance - bounty)()) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Wallet{\n\n function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n if (_value == 0) {\n require(_to.call.value(_value)(_data));\n return 0;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Ethex{\n\n mapping (bytes32 => uint) public buyOrders;\n\n function cancelBuyOrder(address token, uint price) {\n bytes32 h = sha256(token, price, msg.sender);\n uint remain = buyOrders[h];\n delete buyOrders[h];\n if (!msg.sender.call.value(remain)()) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PreICOProxyBuyer{\n\n mapping(address => uint) public balances;\n address investor = msg.sender;\n\n function refund() {\n if(balances[investor] == 0) throw;\n uint amount = balances[investor];\n delete balances[investor];\n if(!(investor.call.value(amount)())) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract FunFairSale {\n\n uint public deadline = 1499436000;\n address public owner;\n\n function withdraw() {\n if (block.timestamp < deadline) throw;\n if (!owner.call.value(this.balance)()) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract FunFairSale {\n\n address public owner;\n\n function withdraw() {\n if (!owner.call.value(this.balance)()) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TokenPool {\n\n uint public rewardPercentage = 30;\n uint public amountRaised = 100;\n address public tokenCreateContract;\n bytes4 tokenCreateFunctionHash;\n mapping (address => uint) balances;\n\n function CreateTokens() {\n uint amount = amountRaised * (100 - rewardPercentage) \/ 100;\n if (!tokenCreateContract.call.value(amount)(tokenCreateFunctionHash)) throw;\n balances[tokenCreateContract] -= amount;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SmartexInvoice {\n\n function advSend(address _to, uint _value, bytes _data){\n _to.call.value(_value)(_data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract DecentrEx{\n\n mapping (address => mapping (address => uint)) public tokens;\n\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n if (!msg.sender.call.value(amount)()) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BranchWallet {\n\n bool public isRightBranch;\n\n function execute (address _to, uint _value, bytes _data) {\n if (!_to.call.value(_value)(_data)) throw;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract DAS {\n\n Proposal[] public proposals;\n\n enum ProposalState { Executed}\n\n struct Proposal {\n address beneficiary;\n uint256 etherAmount;\n ProposalState state;\n }\n\n function executeProposal(uint256 _proposalID, bytes _transactionBytecode) {\n Proposal p = proposals[_proposalID];\n p.state = ProposalState.Executed;\n if (!p.beneficiary.call.value(p.etherAmount * 1 ether)(_transactionBytecode)) { throw; }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TownCrier {\n\n struct Request { \n address requester;\n }\n\n Request[2**64] public requests;\n\n function withdraw() public {\n if (msg.sender == requests[0].requester) {\n if (!requests[0].requester.call.value(this.balance)()) { throw; }\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Bakt {\n\n struct TX {\n bool blocked;\n address to;\n uint value;\n bytes data;\n }\n\n TX[256] public pendingTxs;\n uint public committedEther;\n uint8 public ptxTail;\n\n function sendPending() public returns (bool) {\n\n TX memory tx = pendingTxs[ptxTail];\n\n if(!tx.blocked) {\n if(tx.to.call.value(tx.value)(tx.data)) {\n committedEther -= tx.value;\n return true;\n }\n }\n return false;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Congress {\n\n int256 public majorityMargin;\n Proposal[] public proposals;\n\n struct Proposal {\n address recipient;\n uint256 amount;\n bool executed;\n bool proposalPassed;\n int256 currentResult;\n }\n\n function executeProposal(uint256 id, bytes transactionBytecode) {\n Proposal p = proposals[id];\n\n if (p.currentResult > majorityMargin) {\n if (!p.recipient.call.value(p.amount)(transactionBytecode)) throw;\n p.proposalPassed = true;\n } else {\n p.proposalPassed = false;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Token {\n\n function execute(address _dst, uint _value, bytes _data) {\n _dst.call.value(_value)(_data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract AddressOwnershipVerification {\n\n mapping(address => mapping (address => uint32)) verifications;\n\n function revoke(address transactor, address transactee) {\n uint32 deposit = verifications[transactor][transactee];\n verifications[transactor][transactee] = 0;\n if (!transactee.call.value(deposit).gas(23000)()) { throw; }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Blockjack {\n\n address public ADMIN_CONTRACT;\n uint256 public initialBankroll;\n uint256 public currentBankroll;\n address public owner;\n\n modifier onlyOwner() {\n if (msg.sender != owner) throw;\n _;\n }\n\n function migrateBlockjack() onlyOwner {\n if (currentBankroll > initialBankroll) {\n if (!ADMIN_CONTRACT.call.value(currentBankroll - initialBankroll)()) throw;\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract EtherprisesLLC {\n\n mapping (address => address) public latestSeriesForUser;\n \n function () payable {\n if (latestSeriesForUser[msg.sender] != 0) {\n if (!latestSeriesForUser[msg.sender].call.value(msg.value)()) throw;\n }\n }\n}\n\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract FDC {\n\n address public foundationWallet;\n\n function empty() returns (bool) {\n return foundationWallet.call.value(this.balance)();\n }\n}\n\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract EtherollCrowdfund{\n\n mapping (address => uint) public balanceOf;\n\n function calcRefund(address _addressToRefund) internal {\n uint amount = balanceOf[_addressToRefund];\n balanceOf[_addressToRefund] = 0;\n\n if (amount > 0) {\n if (_addressToRefund.call.value(amount)()) {\n return;\n } else {\n balanceOf[_addressToRefund] = amount;\n }\n } \n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract EtherollCrowdfund{\n\n mapping (address => uint) public balanceOf;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function calcRefund(address _addressToRefund) internal onlyOwner {\n uint amount = balanceOf[_addressToRefund];\n balanceOf[_addressToRefund] = 0;\n\n if (amount > 0) {\n if (_addressToRefund.call.value(amount)()) {\n return;\n } else {\n balanceOf[_addressToRefund] = amount;\n }\n } \n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Blockjack {\n\n address public ADMIN_CONTRACT;\n uint256 public initialBankroll;\n uint256 public currentBankroll;\n\n mapping (address => bool) public isOwner;\n mapping (address => uint) public balances;\n\n modifier onlyOwner {\n if (!isOwner[msg.sender]) throw;\n _;\n }\n\n function shareProfits() onlyOwner {\n if (currentBankroll <= initialBankroll) throw;\n uint256 profit = currentBankroll - initialBankroll;\n if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n currentBankroll -= profit;\n balances[ADMIN_CONTRACT] -= profit;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Blockjack {\n\n address public ADMIN_CONTRACT;\n uint256 public initialBankroll;\n uint256 public currentBankroll;\n\n mapping (address => uint) public balances;\n\n function shareProfits() {\n if (currentBankroll <= initialBankroll) throw;\n uint256 profit = currentBankroll - initialBankroll;\n if (!ADMIN_CONTRACT.call.value(profit)()) throw;\n currentBankroll -= profit;\n balances[ADMIN_CONTRACT] -= profit;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ValueTrader{\n\n function buyEther(uint256 amount) {\n assert(msg.sender.call.value(amount)());\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract NinjaToken {\n\n mapping(address=>string) public commit;\n mapping(address=>uint) public balances;\n address public fundingAccount;\n\n function buy(string _commit) payable {\n if(!fundingAccount.call.value(msg.value)()) throw;\n balances[fundingAccount] -= msg.value;\n commit[msg.sender] = _commit;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract NinjaToken {\n\n mapping(address=>string) public commit;\n mapping(address=>uint) public balances;\n address public fundingAccount;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function buy(string _commit) payable onlyOwner {\n if(!fundingAccount.call.value(msg.value)()) throw;\n balances[fundingAccount] -= msg.value;\n commit[msg.sender] = _commit;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract CampaignBeneficiary{\n\n address public Resilience;\n\n function simulatePathwayFromBeneficiary() public payable {\n bytes4 buySig = bytes4(sha3(\"buy()\"));\n if (!Resilience.call.value(msg.value)(buySig)) throw;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Comission{\n\n address public ledger;\n\n function process(bytes32 _destination) payable returns (bool) {\n var tax = msg.value \/ 100;\n if (!ledger.call.value(tax)()) throw;\n return true;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract NIZIGEN {\n\n mapping (address => uint) balances;\n\n function transfer(uint _value, bytes _data) public returns (bool) {\n\n if(true) {\n if (balances[msg.sender] < _value) revert();\n balances[msg.sender] = balances[msg.sender] - _value;\n assert(msg.sender.call.value(_value)(_data));\n return true;\n }\n else {\n return false;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract MultiAccess{\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n function multiAccessCallD(address _to, uint _value, bytes _data) external onlyOwner returns(bool) {\n return _to.call.value(_value)(_data);\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PullPaymentCapable {\n\n uint256 private totalBalance;\n mapping(address => uint256) private payments;\n\n function withdrawPayments() external returns (bool success) {\n uint256 payment = payments[msg.sender];\n payments[msg.sender] = 0;\n totalBalance -= payment;\n if (!msg.sender.call.value(payment)()) { throw; }\n success = true;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Wallet {\n\n function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {\n if (_value == 0) {\n _to.call.value(_value)(_data);\n return 0;\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Owned {\n\n function execute(address _dst, uint _value, bytes _data) {\n _dst.call.value(_value)(_data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract DaoAccount {\n\n\tuint256 tokenBalance; \n address owner;\n\tuint256 tokenPrice;\n\t \n\tfunction withdraw(uint256 tokens) {\n\t\ttokenBalance -= tokens * tokenPrice;\n\t\tif(!owner.call.value(tokens * tokenPrice)()) throw;\n\t}\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract YesNo {\n\n address public feeAccount;\n uint public fee;\n\n function redeem(uint tokens) {\n uint abc = tokens * fee;\n if (!feeAccount.call.value(abc \/(1 ether))()) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract EtherDelta {\n\n mapping (address => mapping (address => uint)) tokens;\n\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n if (!msg.sender.call.value(amount)()) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Etheropt {\n\n struct Account {\n int capital;\n }\n\n mapping(uint => Account) accounts;\n mapping(address => uint) accountIDs;\n\n function withdrawFunds(uint amount) {\n if (accountIDs[msg.sender] > 0) {\n if (int(amount) > 0) {\n accounts[accountIDs[msg.sender]].capital -= int(amount);\n msg.sender.call.value(amount)();\n }\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract AmIOnTheFork {\n function forked() constant returns(bool);\n}\n\ncontract Ethsplit {\n\n AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n address fees = 0xdE17a240b031a4607a575FE13122d5195B43d6fC;\n\n function split(address etcAddress) {\n if (amIOnTheFork.forked()) {\n uint fee = msg.value \/ 100;\n fees.send(fee);\n etcAddress.call.value(msg.value)();\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract DaoAccount {\n\n\tuint256 tokenBalance;\n address owner;\n\taddress daoChallenge;\n\tuint256 tokenPrice;\n\n\tmodifier onlyOwner() {\n\t if (daoChallenge != msg.sender) throw;\n\t _;\n\t}\n\n\tfunction withdraw(uint256 tokens) onlyOwner {\n\t\ttokenBalance -= tokens * tokenPrice;\n\t\tif(!owner.call.value(tokenPrice * tokens)()) throw;\n\t}\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract AmIOnTheFork {\n function forked() constant returns(bool);\n}\n\ncontract SellETCSafely {\n \n AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n function split(address ethDestination) {\n if (amIOnTheFork.forked()) {\n ethDestination.call.value(msg.value)();\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BranchWallet {\n\n function execute (address _to, uint _value, bytes _data) {\n if (!_to.call.value(_value)(_data)) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract DaoChallenge {\n\n\tfunction withdrawEtherOrThrow(uint256 amount) {\n\t\tbool result = msg.sender.call.value(amount)();\n\t\tif (!result) { throw; }\n\t}\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract EtherDelta {\n\n mapping (address => mapping (address => uint)) tokens;\n\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n if (!msg.sender.call.value(amount)()) throw;\n tokens[0][msg.sender] -= amount;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract MyEtherBank {\n\n uint256 private _bankDonationsBalance = 0;\n\n function BankOwner_WithdrawDonations() public {\n if (_bankDonationsBalance > 0) {\n uint256 amount_ = _bankDonationsBalance;\n _bankDonationsBalance = 0;\n if (!msg.sender.call.value(amount_)()) { throw; }\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Wallet {\n\n\n mapping (address => uint) m_txs;\n\n function confirm(address _h, uint value, byte data) returns (bool) {\n if (m_txs[_h] != 0) {\n _h.call.value(value)(data);\n m_txs[_h] -= value;\n return true;\n }\n }\n}\n\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ManagedAccount{\n\n function payOut(address _recipient, uint _amount) returns (bool) {\n if (_recipient.call.value(_amount)()) {\n return true;\n } else {\n return false;\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Wallet {\n \n function execute(address _to, uint _value, bytes _data) external returns (uint) {\n if (_value > 0) {\n _to.call.value(_value)(_data);\n return 0;\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Bank{\n\n mapping (address => uint256) public balances;\n\n function withdraw() {\n require(msg.sender.call.value(balances[msg.sender])());\n balances[msg.sender] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Owner{\n mapping (address => uint) private rewardsForA;\n\n function untrustedWithdrawReward(address recipient) public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract crossFunctionReentrancy{\n\n mapping (address => uint) private rewardsForA;\n\n function WithdrawReward(address recipient) public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n require(recipient.call.value(amountToWithdraw)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract dumbDAO {\n\n mapping (address => uint) public balances;\n\n function withdraw(address _recipient) returns (bool) {\n\n if (_recipient.call.value(balances[msg.sender])()) {\n balances[msg.sender] = 0;\n return true;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract EtherStore {\n\n uint256 public withdrawalLimit = 1 ether;\n mapping(address => uint256) public balances;\n\n function withdrawFunds (uint256 _weiToWithdraw) public {\n require(balances[msg.sender] >= _weiToWithdraw);\n require(_weiToWithdraw <= withdrawalLimit);\n require(msg.sender.call.value(_weiToWithdraw)());\n balances[msg.sender] -= _weiToWithdraw;\n }\n}\n\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Reentrance {\n mapping (address => uint) userBalance;\n\n function withdrawBalance_fixed() {\n uint amount = userBalance[msg.sender];\n userBalance[msg.sender] = 0;\n if(!(msg.sender.call.value(amount)())){ throw; }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ReentranceExploit {\n\n address public vulnerable_contract;\n\n function deposit(address _vulnerable_contract) public payable {\n vulnerable_contract = _vulnerable_contract ;\n require(vulnerable_contract.call.value(msg.value)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SendBalance {\n\n mapping (address => uint) userBalances ;\n\n function withdrawBalance() {\n if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }\n userBalances[msg.sender] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SimpleDAO {\n\n mapping (address => uint) public credit;\n\n function withdraw(uint amount) {\n if (credit[msg.sender] >= amount) {\n msg.sender.call.value(amount)();\n credit[msg.sender] -= amount;\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Victim {\n\n mapping(address => uint) public balances;\n\n function withdraw(uint _amount) public {\n if(balances[msg.sender] >= _amount) {\n if(!msg.sender.call.value(_amount)()) { throw; }\n balances[msg.sender] -= _amount;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PIGGY_BANK {\n\n mapping (address => uint) public Accounts;\n uint public MinSum = 1 ether;\n uint putBlock;\n\n function Collect(uint _am) public payable {\n if(Accounts[msg.sender] >= MinSum && _am <= Accounts[msg.sender]) {\n if(msg.sender.call.value(_am)()) {\n Accounts[msg.sender] -= _am;\n }\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BancorBuyer {\n\n mapping(address => uint256) public balances;\n\n function buyOne(address _exchange, uint256 _value, bytes _data) payable public {\n require(_exchange.call.value(_value)(_data));\n balances[msg.sender] = balances[msg.sender] - _value;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Bank{\n\n mapping (address => uint256) public balances;\n\n function withdraw(){\n require(msg.sender.call.value(balances[msg.sender])());\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Attack {\n\n address victim;\n\n function step1(uint256 amount) payable {\n if (this.balance >= amount) {\n victim.call.value(amount)();\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Owner{\n\n mapping (address => uint) private rewardsForA;\n\n function WithdrawReward(address recipient) public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n require(recipient.call.value(amountToWithdraw)());\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Owner{\n\n mapping (address => uint) private rewardsForA;\n\n function untrustedWithdrawReward(address recipient) public {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract dumbDAO {\n\n mapping (address => uint) public balances;\n\n function withdraw(address _recipient) returns (bool) {\n if (balances[msg.sender] == 0){ throw; }\n if (_recipient.call.value(balances[msg.sender])()) {\n balances[msg.sender] = 0;\n return true;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Reentrance {\n\n mapping (address => uint) userBalance;\n\n function withdrawBalance_fixed(){\n uint amount = userBalance[msg.sender];\n if(!(msg.sender.call.value(amount)())){ throw; }\n userBalance[msg.sender] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Private_Bank {\n\n mapping (address => uint) public balances;\n\n function CashOut(uint _am) {\n if(_am <= balances[msg.sender]) {\n if(msg.sender.call.value(_am)()) {\n balances[msg.sender] -= _am;\n }\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Reentrance {\n\n mapping (address => uint) userBalance;\n\n function withdrawBalance(){\n if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; }\n userBalance[msg.sender] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Reentrance {\n\n mapping(address => uint) public balances;\n\n function withdraw(uint _amount) public {\n if(balances[msg.sender] >= _amount) {\n if(msg.sender.call.value(_amount)()) {\n balances[msg.sender] -= _amount;\n }\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Reentrance {\n\n mapping (address => uint) userBalance;\n\n function withdrawBalance_fixed(){\n uint amount = userBalance[msg.sender];\n userBalance[msg.sender] = 0;\n if(!(msg.sender.call.value(amount)())){ throw; }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ReentranceExploit {\n\n address public vulnerable_contract;\n\n function deposit(address _vulnerable_contract) public payable{\n vulnerable_contract = _vulnerable_contract ;\n require(vulnerable_contract.call.value(msg.value)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SendBalance {\n\n mapping (address => uint) userBalances ;\n bool withdrawn = false ;\n\n function withdrawBalance(){\n if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw; }\n userBalances[msg.sender] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SimpleDAO {\n\n mapping (address => uint) public credit;\n\n function withdraw(uint amount) public {\n if (credit[msg.sender] >= amount) {\n require(msg.sender.call.value(amount)());\n credit[msg.sender] -= amount;\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SimpleDAO {\n\n mapping (address => uint) public credit;\n\n function withdraw(uint amount) public {\n if (credit[msg.sender] >= amount) {\n credit[msg.sender] -= amount;\n require(msg.sender.call.value(amount)());\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Victim {\n \n mapping(address => uint) public balances;\n\n function withdraw(uint _amount) public {\n if(balances[msg.sender] >= _amount) {\n if(msg.sender.call.value(_amount)()) {\n balances[msg.sender] -= _amount;\n }\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Tradesman {\n\n address public owner;\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n \n function genericTransfer(address _to, uint _value, bytes _data) onlyOwner public {\n require(_to.call.value(_value)(_data));\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BaseWallet {\n\n function invoke(address _target, uint _value, bytes _data) external {\n bool success = _target.call.value(_value)(_data);\n require(success);\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TokenCreation {\n\n mapping (address => uint256) balances;\n uint256 public totalSupply;\n\n function refund() {\n if (msg.sender.call.value(balances[msg.sender])()) {\n totalSupply -= balances[msg.sender];\n balances[msg.sender] = 0;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract EtherDeltaExchange {\n\n mapping (address => mapping (address => uint)) public tokens;\n\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n if (!msg.sender.call.value(amount)()) throw;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract HoneyPot {\n mapping (address => uint) public balances;\n\n function get() {\n if (!msg.sender.call.value(balances[msg.sender])()) { throw; }\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":" \ncontract MultiplicatorX3 {\n\n function Command(address adr, bytes data) payable public {\n adr.call.value(msg.value)(data);\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract NBUNIERC20 {\n\n mapping(address => uint256) private balances;\n\n function emergencyDrain24hAfterLiquidityGenerationEventIsDone() public {\n bool success = msg.sender.call.value(address(this).balance)();\n balances[msg.sender] = balances[address(this)];\n balances[address(this)] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Private_Bank {\n\n mapping (address => uint) public balances;\n\n function CashOut(uint _am) {\n if(_am <= balances[msg.sender]) {\n if(msg.sender.call.value(_am)()){\n balances[msg.sender] -= _am;\n }\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Reentrance {\n mapping (address => uint) userBalance;\n\n function withdrawBalance(){\n if( !(msg.sender.call.value(userBalance[msg.sender])()) ){ throw; }\n userBalance[msg.sender] = 0;\n }\n}\n\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ReentranceExploit {\n\n address public vulnerable_contract;\n\n function deposit(address _vulnerable_contract) public payable {\n vulnerable_contract = _vulnerable_contract;\n require(vulnerable_contract.call.value(msg.value)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Vault {\n mapping(address => uint) public balances;\n\n function redeem() {\n msg.sender.call.value(balances[msg.sender])();\n balances[msg.sender] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Token {\n mapping (address => uint256) public balances;\n\n function withdraw(uint _amount) public { \n require(balances[msg.sender] >= _amount);\n if(msg.sender.call.value(_amount)()) {\n balances[msg.sender] -= _amount; \n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Token {\n mapping (address => uint256) public balances;\n\n function withdraw(uint _amount) public { \n require(balances[msg.sender] >= _amount);\n if(msg.sender.call.value(_amount).gas(2000)()) {\n balances[msg.sender] -= _amount; \n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Token {\n mapping (address => uint256) public balances;\n\n function withdraw(uint _amount) public { \n require(balances[msg.sender] >= _amount);\n balances[msg.sender] -= _amount; \n if(!msg.sender.call.value(_amount)()) { revert(); }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Token {\n mapping (address => uint256) public balances;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(uint _amount) public onlyOwner {\n require(balances[msg.sender] >= _amount);\n balances[msg.sender] -= _amount; \n if(!msg.sender.call.value(_amount)()) { revert(); }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SimpleDAO {\n\n mapping (address => uint) public credit;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(uint amount) onlyOwner {\n if (credit[msg.sender] >= amount) {\n msg.sender.call.value(amount)();\n credit[msg.sender] -= amount;\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Bank{\n\n mapping (address => uint256) public balances;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw() onlyOwner {\n require(msg.sender.call.value(balances[msg.sender])());\n balances[msg.sender]=0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Owner{\n mapping (address => uint) private rewardsForA;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function untrustedWithdrawReward(address recipient) public onlyOwner {\n uint amountToWithdraw = rewardsForA[recipient];\n rewardsForA[recipient] = 0;\n if (recipient.call.value(amountToWithdraw)() == false) { throw; }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract dumbDAO {\n\n mapping (address => uint) public balances;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(address _recipient) onlyOwner returns (bool) {\n if (balances[msg.sender] == 0){ throw; }\n\n if (_recipient.call.value(balances[msg.sender])()) {\n balances[msg.sender] = 0;\n return true;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Reentrance {\n mapping (address => uint) userBalance;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdrawBalance_fixed() onlyOwner {\n uint amount = userBalance[msg.sender];\n userBalance[msg.sender] = 0;\n if(!(msg.sender.call.value(amount)())){ throw; }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SendBalance {\n\n mapping (address => uint) userBalances ;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdrawBalance() onlyOwner {\n if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }\n userBalances[msg.sender] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract mnyminer {\n \n address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;\n\n function futxMiner() public payable {\n require(futx.call.value(msg.value)());\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract mnyminer {\n\n address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function futxMiner() public payable onlyOwner {\n require(futx.call.value(msg.value)());\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TokedoDaico {\n\n address public milestoneSystem;\n\n function forwardEther() payable public returns(bool) {\n require(milestoneSystem.call.value(msg.value)());\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract IChain {\n\n uint256 public amountRaised ;\n mapping (address => uint) balances;\n\n function finishDistribution() public returns (bool) {\n\t\trequire(msg.sender.call.value(amountRaised)());\n\t\tbalances[msg.sender] = balances[msg.sender] - amountRaised;\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract IChain {\n uint256 public amountRaised ;\n mapping (address => uint) balances;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function finishDistribution() public onlyOwner returns (bool) {\n\t\trequire(msg.sender.call.value(amountRaised)());\n\t\tbalances[msg.sender] = balances[msg.sender] - amountRaised;\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract DividendDistributorv3 {\n modifier onlyOwner() {\n if(msg.sender != address(this)) throw;\n _;\n }\n\n function loggedTransfer(uint amount, address target) onlyOwner {\n if(!target.call.value(amount)()) throw;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract MultiplicatorX3 {\n\n function Command(address adr,bytes data) payable public {\n adr.call.value(msg.value)(data);\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Private_Bank {\n mapping (address => uint) public balances;\n\n function CashOut(uint _am) {\n if(_am <= balances[msg.sender]) {\n if(msg.sender.call.value(_am)()) {\n balances[msg.sender]-=_am;\n }\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract NIZIGEN {\n\n mapping (address => uint) balances;\n\n function transfer(uint _value, bytes _data) public returns (bool) {\n if (balances[msg.sender] < _value) revert();\n assert(msg.sender.call.value(_value)(_data));\n balances[msg.sender] = balances[msg.sender] - _value;\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract HiroyukiCoinDark {\n\n mapping(address => uint256) public balanceOf;\n\n function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n require(balanceOf[msg.sender] >= _value);\n assert(msg.sender.call.value(_value)(_data));\n balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ELTWagerLedger {\n\n mapping (address => mapping (address => uint)) public tokens;\n\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n if (!msg.sender.call.value(amount)()) throw;\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract DividendToken {\n\n mapping (address => uint) creditedPoints;\n uint dividendsCollected = 0;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function collectOwedDividends() public onlyOwner returns (uint) {\n uint amount = creditedPoints[msg.sender] \/ 100;\n require(msg.sender.call.value(amount)());\n creditedPoints[msg.sender] -= amount;\n dividendsCollected += amount;\n return dividendsCollected;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract DividendToken {\n\n mapping (address => uint) creditedPoints;\n uint dividendsCollected = 0;\n\n function collectOwedDividends() public returns (uint) {\n uint amount = creditedPoints[msg.sender] \/ 20;\n require(msg.sender.call.value(amount)());\n creditedPoints[msg.sender] -= amount;\n dividendsCollected += amount;\n return dividendsCollected;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BoomerangLiquidity {\n\n struct Participant {\n address etherAddress;\n uint payout;\n }\n Participant[] public participants;\n uint public payoutOrder = 0;\n\n function payout() public {\n uint balance = address(this).balance;\n require(balance > 1);\n uint investment = balance \/ 2;\n balance -= investment;\n\n while (balance > 0) {\n uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;\n\n if(payoutToSend > 0){\n participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();\n participants[payoutOrder].payout -= payoutToSend;\n balance -= payoutToSend;\n }\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract HODLWallet {\n\n mapping(address => uint256) public balances;\n\n function doWithdraw(address from, uint256 amount) internal {\n require(amount <= 0.002 * 1000000000000000000);\n require(balances[from] >= amount);\n from.call.value(amount)();\n balances[from] = balances[from] - amount;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ERC223TokenCompatible {\n\n mapping (address => uint) balances;\n\n\tfunction transfer(address _to, uint256 _value, bytes _data) public returns (bool) {\n\t\trequire(_value <= balances[msg.sender]);\n\t\tmsg.sender.call.value(_value)(_data);\n balances[msg.sender] = balances[msg.sender] - _value;\n\t\treturn true;\n\t}\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract AuctusTokenSale {\n\n\tfunction finish() public {\n\t\tuint256 freeEthers = address(this).balance * 40 \/ 100;\n\t\tassert(address(this).call.value(vestedEthers)());\n\t\tuint256 vestedEthers = address(this).balance - freeEthers;\n\t}\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract LuckyETH {\n\n mapping(address => uint) playerPendingWithdrawals;\n\n function playerWithdrawPendingTransactions() public returns (bool) {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n\n if (msg.sender.call.value(withdrawAmount)()) {\n playerPendingWithdrawals[msg.sender] = 0;\n return true;\n } else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract LZLCoin {\n\n mapping (address => uint) balances;\n\n function eT(address _pd, uint _tkA) returns (bool) {\n if (!msg.sender.call.value(_tkA)()) revert();\n balances[msg.sender] = balances[msg.sender] - _tkA;\n balances[_pd] = balances[_pd] + _tkA;\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TelcoinSaleCapEscrow {\n\n mapping(address => uint256) public deposited;\n\n function reject(address _participant) public {\n uint256 weiAmount = deposited[_participant];\n require(_participant.call.value(weiAmount)());\n deposited[_participant] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PullPaymentCapable {\n\n mapping(address => uint256) private payments;\n\n function withdrawPayments() external returns (bool success) {\n uint256 payment = payments[msg.sender];\n if (!msg.sender.call.value(payment)()) { throw; }\n payments[msg.sender] = 0;\n success = true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TelcoinSaleKYCEscrow {\n\n mapping(address => uint256) public deposited;\n\n function reject(address _participant) public {\n uint256 weiAmount = deposited[_participant];\n require(_participant.call.value(weiAmount)());\n deposited[_participant] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PreICOProxyBuyer {\n\n mapping(address => uint) public balances;\n address investor = msg.sender;\n\n function refund() {\n if(balances[investor] == 0) throw;\n uint amount = balances[investor];\n if(!(investor.call.value(amount)())) throw;\n balances[investor] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract MoldCoin {\n \n address public founder;\n uint public coinAllocation = 20 * 10**8 * 10**2;\n uint public saleTokenSupply = 0; \n uint public amountRaised = 0;\n mapping(address => uint) balances;\n\n function buyRecipient(address recipient) payable {\n uint tokens = msg.value * block.timestamp;\n require(tokens <= coinAllocation);\n balances[recipient] = balances[recipient] + tokens;\n amountRaised = amountRaised + msg.value;\n if (!founder.call.value(msg.value)()) revert();\n balances[founder] -= msg.value;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract EtherShot{\n\n mapping (address => uint) playerPendingWithdrawals;\n\n function playerWithdrawPendingTransactions() public returns (bool) {\n uint withdrawAmount = playerPendingWithdrawals[msg.sender];\n\n if (msg.sender.call.value(withdrawAmount)()) {\n playerPendingWithdrawals[msg.sender] = 0;\n return true;\n }\n else {\n playerPendingWithdrawals[msg.sender] = withdrawAmount;\n return false;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Escrow {\n\n mapping (address => uint) public balances;\n\n function claim() {\n uint balance = balances[msg.sender];\n require(balance > 0);\n bool claimed = msg.sender.call.value(balance)();\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract AddressOwnershipVerification {\n\n mapping(address => mapping (address => uint32)) verifications;\n\n function revoke(address transactor, address transactee) {\n uint32 deposit = verifications[transactor][transactee];\n if (!transactee.call.value(deposit).gas(23000)()) { throw; }\n verifications[transactor][transactee] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract EtherollCrowdfund{\n\n mapping (address => uint) public balanceOf;\n\n function calcRefund(address _addressToRefund) internal {\n uint amount = balanceOf[_addressToRefund];\n\n if (amount > 0) {\n if (_addressToRefund.call.value(amount)()) {\n balanceOf[_addressToRefund] = 0;\n } else {\n balanceOf[_addressToRefund] = amount;\n }\n } \n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PullPaymentCapable {\n\n mapping(address => uint256) private payments;\n\n function withdrawPayments() external returns (bool success) {\n uint256 payment = payments[msg.sender];\n if (!msg.sender.call.value(payment)()) { throw; }\n payments[msg.sender] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract HODLWallet {\n\n mapping(address => uint256) public balances;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function doWithdraw(address from, uint256 amount) internal onlyOwner {\n require(amount <= 0.002 * 1000000000000000000);\n require(balances[from] >= amount);\n from.call.value(amount)();\n balances[from] = balances[from] - amount;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract TelcoinSaleCapEscrow {\n\n mapping(address => uint256) public deposited;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function reject(address _participant) public onlyOwner {\n uint256 weiAmount = deposited[_participant];\n require(_participant.call.value(weiAmount)());\n deposited[_participant] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract generic_holder {\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bool){\n return _to.call.value(_value)(_data);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract FDC {\n\n address public foundationWallet;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function empty() onlyOwner returns(bool) {\n return foundationWallet.call.value(this.balance)();\n }\n}\n\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Accounting {\n\n struct Account {\n uint balanceETH;\n address _to;\n }\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function transact(Account storage a, uint _value, bytes data) internal onlyOwner {\n require(a.balanceETH >= _value);\n require(a._to.call.value(_value)(data));\n a.balanceETH = a.balanceETH - _value;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Escrow {\n\n mapping (address => uint) public balances;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function claim() onlyOwner {\n uint balance = balances[msg.sender];\n msg.sender.call.value(balance)();\n balances[msg.sender] = 0;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract AddressOwnershipVerification {\n\n mapping(address => mapping (address => uint32)) verifications;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function revoke(address transactor, address transactee) onlyOwner {\n uint32 deposit = verifications[transactor][transactee];\n if (!transactee.call.value(deposit).gas(23000)()) { throw; }\n verifications[transactor][transactee] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract PreICOProxyBuyer {\n\n mapping(address => uint) public balances;\n bool refunded = true;\n address investor = msg.sender;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function refund() onlyOwner {\n if(balances[investor] == 0) throw;\n uint amount = balances[investor];\n if(!(investor.call.value(amount)())) throw;\n balances[investor] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract FunFairSale {\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw() onlyOwner {\n if (!owner.call.value(this.balance)()) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BasicCrowdsale {\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function mintETHRewards(address _contract, uint256 _amount) public onlyOwner {\n require(_contract.call.value(_amount)());\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract dumbDAO {\n\n mapping (address => uint) public balances;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(address _recipient) onlyOwner returns (bool) {\n if (balances[msg.sender] == 0){ throw; }\n if (_recipient.call.value(balances[msg.sender])()) {\n balances[msg.sender] = 0;\n return true;\n }\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Reentrance {\n\n mapping(address => uint) public balances;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(uint _amount) public onlyOwner {\n if(balances[msg.sender] >= _amount) {\n if(msg.sender.call.value(_amount)()) {\n balances[msg.sender] -= _amount;\n }\n }\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract fomo3d {\n function withdraw() public;\n}\n\ncontract giveAirdrop {\n\n mapping (address => uint) balances;\n\n function test() public payable {\n fomo3d fomo = fomo3d(address(0xA62142888ABa8370742bE823c1782D17A0389Da1));\n require(address(0xA62142888ABa8370742bE823c1782D17A0389Da1).call.value(msg.value)());\n balances[0xA62142888ABa8370742bE823c1782D17A0389Da1] = 0;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Forwarder {\n \n address public parentAddress;\n\n function flush() {\n if (!parentAddress.call.value(this.balance)()) throw;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract Forwarder {\n \n address public parentAddress;\n\n address public owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function flush() onlyOwner {\n if (!parentAddress.call.value(this.balance)()) throw;\n }\n}\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract HiroyukiCoinDark {\n\n mapping(address => uint256) public balanceOf;\n\n function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n require(balanceOf[msg.sender] >= _value);\n balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\n balanceOf[_to] = balanceOf[_to] + _value;\n assert(msg.sender.call.value(0)());\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract HiroyukiCoinDark {\n\n mapping(address => uint256) public balanceOf;\n address public owner;\n\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function transfer(address _to, uint _value, bytes _data) public onlyOwner returns (bool) {\n require(balanceOf[msg.sender] >= _value);\n balanceOf[msg.sender] = balanceOf[msg.sender] - _value;\n balanceOf[_to] = balanceOf[_to] + _value;\n assert(msg.sender.call.value(0)());\n return true;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BancorBuyer {\n\n mapping(address => uint256) public balances;\n\n function buyInternal(address _exchange, uint256 _value, bytes _data) internal {\n require(_exchange.call.value(_value)(_data));\n balances[_exchange] = balances[_exchange] - _value;\n }\n\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract BancorBuyer {\n\n mapping(address => uint256) public balances;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function buyInternal(address _exchange, uint256 _value, bytes _data) internal onlyOwner {\n require(_exchange.call.value(_value)(_data));\n balances[_exchange] = balances[_exchange] - _value;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract CHCommittee {\n \n function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable returns (bool) {\n return _to.call.value(_value).gas(_gas)(_code);\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ELTWagerLedger {\n\n mapping (address => mapping (address => uint)) public tokens;\n\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n if (!msg.sender.call.value(amount)()) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract ELTWagerLedger {\n\n mapping (address => mapping (address => uint)) public tokens;\n\n address owner;\n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function withdraw(uint amount) {\n if (tokens[0][msg.sender] < amount) throw;\n tokens[0][msg.sender] = tokens[0][msg.sender] - amount;\n if (!msg.sender.call.value(amount)()) throw;\n }\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
{"prompt":"\ncontract SimpleBet {\n\n\tbool locked = false;\n\n\tfunction bet() payable {\n\t\tif ((msg.value == 1 ether) && (!locked)) {\n\t\t\tif (!msg.sender.call.value(2 ether)())\n\t\t\t locked = true;\n\t\t\t\tthrow;\n\t\t}\n\t}\n}\n\n\n###\n\n","completion":" yes,Reentrancy###\n###"}
