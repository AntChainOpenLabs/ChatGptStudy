{"prompt": "pragma solidity 0.8.10;\n\n\ncontract WorldFootball is Context, IERC20 { \n using SafeMath for uint256;\n using Address for address;\n\n address private _owner;\n\n event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n function owner() public view virtual returns (address) {\n  return _owner;\n }\n\n modifier onlyOwner() {\n  require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n  _;\n }\n\n function renounceOwnership() public virtual {\n  emit OwnershipTransferred(_owner, address(0));\n  _owner = address(0);\n }\n\n mapping (address => uint256) private _tOwned;\n mapping (address => mapping (address => uint256)) private _allowances;\n mapping (address => bool) public _isExcludedFromFee; \n\n address payable public Wallet_Game = payable(0x8a4fA360a46B9467f6b0decE101bBf9a99405C9C); \n address payable public Wallet_Dev = payable(0x15805a0F423c87Cc2293b4c5a3129a1A2F2E6118);\n address payable public constant Wallet_Burn = payable(0x000000000000000000000000000000000000dEaD); \n\n\n uint256 private constant MAX = ~uint256(0);\n uint8 private constant _decimals = 9;\n uint256 private _tTotal = 10**11 * 10**_decimals;\n string private constant _name = \"World Football\"; \n string private constant _symbol = unicode\"WOFO\"; \n\n uint8 private txCount = 0;\n uint8 private swapTrigger = 10; \n\n uint256 public _Tax_On_Buy = 12;\n uint256 public _Tax_On_Sell = 12;\n\n uint256 public Percent_Game = 50;\n uint256 public Percent_Dev = 30;\n uint256 public Percent_Burn = 0;\n uint256 public Percent_AutoLP = 20; \n  \n IUniswapV2Router02 public uniswapV2Router;\n address public uniswapV2Pair;\n bool public inSwapAndLiquify;\n bool public swapAndLiquifyEnabled = true;\n \n event SwapAndLiquifyEnabledUpdated(bool true_or_false);\n event SwapAndLiquify(\n  uint256 tokensSwapped,\n  uint256 ethReceived,\n  uint256 tokensIntoLiqudity\n  \n );\n \n modifier lockTheSwap {\n  inSwapAndLiquify = true;\n  _;\n  inSwapAndLiquify = false;\n }\n \n constructor () {\n\n  _owner = _msgSender();\n  emit OwnershipTransferred(address(0), _owner);\n\n  _tOwned[owner()] = _tTotal;\n  \n  IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); \n  //IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3); // Testnet\n  \n  uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n.createPair(address(this), _uniswapV2Router.WETH());\n  uniswapV2Router = _uniswapV2Router;\n\n  _isExcludedFromFee[owner()] = true;\n  _isExcludedFromFee[address(this)] = true;\n  _isExcludedFromFee[Wallet_Game] = true; \n  _isExcludedFromFee[Wallet_Burn] = true;\n\n  emit Transfer(address(0), owner(), _tTotal);\n\n }\n\n function name() public pure returns (string memory) {\n  return _name;\n }\n\n  function swapTokensForBNB(uint256 tokenAmount) private {\n\n  address[] memory path = new address[](2);\n  path[0] = address(this);\n  path[1] = uniswapV2Router.WETH();\n  _approve(address(this), address(uniswapV2Router), tokenAmount);\n  uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\ntokenAmount,\n0, \npath,\naddress(this),\nblock.timestamp\n  );\n }\n\n\n function addLiquidity(uint256 tokenAmount, uint256 BNBAmount) private {\n\n  _approve(address(this), address(uniswapV2Router), tokenAmount);\n  uniswapV2Router.addLiquidityETH{value: BNBAmount}(\naddress(this),\ntokenAmount,\n0, \n0,\nWallet_Burn, \nblock.timestamp\n  );\n } \n\n\n function _tokenTransfer(address sender, address recipient, uint256 tAmount, bool takeFee, bool isBuy) private {\n  \n  \n  if(!takeFee){\n\n_tOwned[sender] = _tOwned[sender]-tAmount;\n_tOwned[recipient] = _tOwned[recipient]+tAmount;\nemit Transfer(sender, recipient, tAmount);\n\nif(recipient == Wallet_Burn)\n_tTotal = _tTotal-tAmount;\n\n} else if (isBuy){\n\nuint256 buyFEE = tAmount*_Tax_On_Buy/100;\nuint256 tTransferAmount = tAmount-buyFEE;\n\n_tOwned[sender] = _tOwned[sender]-tAmount;\n_tOwned[recipient] = _tOwned[recipient]+tTransferAmount;\n_tOwned[address(this)] = _tOwned[address(this)]+buyFEE;\nemit Transfer(sender, recipient, tTransferAmount);\n\nif(recipient == Wallet_Burn)\n_tTotal = _tTotal-tTransferAmount;\n\n} else {\n\nuint256 sellFEE = tAmount*_Tax_On_Sell/100;\nuint256 tTransferAmount = tAmount-sellFEE;\n\n_tOwned[sender] = _tOwned[sender]-tAmount;\n_tOwned[recipient] = _tOwned[recipient]+tTransferAmount;\n_tOwned[address(this)] = _tOwned[address(this)]+sellFEE;\nemit Transfer(sender, recipient, tTransferAmount);\n\nif(recipient == Wallet_Burn)\n_tTotal = _tTotal-tTransferAmount;\n\n\n}\n\n }\n}\n\n###\n\n", "completion": "yes,ID-related violations###\n###"}
{"prompt": "constructor(address _WaToken, address _Token, address _governance) public {\n  require(_governance != ZERO_ADDRESS, \"TransmuterD8: 0 gov\");\n  governance = _governance;\n  WaToken = _WaToken;\n  Token = _Token;\n  TRANSMUTATION_PERIOD = 50;\n }\n\n\n function dividendsOwing(address account) public view returns (uint256) {\n  uint256 newDividendPoints = totalDividendPoints.sub(lastDividendPoints[account]);\n  return depositedWaTokens[account].mul(newDividendPoints).div(pointMultiplier);\n }\n\n modifier updateAccount(address account) {\n  uint256 owing = dividendsOwing(account);\n  if (owing > 0) {\nunclaimedDividends = unclaimedDividends.sub(owing);\ntokensInBucket[account] = tokensInBucket[account].add(owing);\n  }\n  lastDividendPoints[account] = totalDividendPoints;\n  _;\n }\n modifier checkIfNewUser() {\n  if (!userIsKnown[msg.sender]) {\nuserList[nextUser] = msg.sender;\nuserIsKnown[msg.sender] = true;\nnextUser++;\n  }\n  _;\n }\n\n modifier runPhasedDistribution() {\n  uint256 _lastDepositBlock = lastDepositBlock;\n  uint256 _currentBlock = block.number;\n  uint256 _toDistribute = 0;\n  uint256 _buffer = buffer;\n\n  if (_buffer > 0) {\n \nuint256 deltaTime = _currentBlock.sub(_lastDepositBlock);\n\nif(deltaTime >= TRANSMUTATION_PERIOD) {\n _toDistribute = _buffer;\n} else {\n\n if(_buffer.mul(deltaTime) > TRANSMUTATION_PERIOD)\n {\n  _toDistribute = _buffer.mul(deltaTime).div(TRANSMUTATION_PERIOD);\n }\n}\n\nif(_toDistribute > 0){\n\n buffer = _buffer.sub(_toDistribute);\n\n increaseAllocations(_toDistribute);\n}\n  }\n\n  lastDepositBlock = _currentBlock;\n  _;\n }\n modifier onlyWhitelisted() {\n  require(whiteList[msg.sender], \"TransmuterD8: !whitelisted\");\n  _;\n }\n modifier onlyGov() {\n  require(msg.sender == governance, \"TransmuterD8: !governance\");\n  _;\n }\n\n function distribute(address origin, uint256 amount) public onlyWhitelisted() runPhasedDistribution() {\n  IERC20Burnable(Token).safeTransferFrom(origin, address(this), amount);\n  buffer = buffer.add(amount);\n }\n function increaseAllocations(uint256 amount) internal {\n  if(totalSupplyWaTokens > 0 && amount > 0) {\ntotalDividendPoints = totalDividendPoints.add(\n amount.mul(pointMultiplier).div(totalSupplyWaTokens)\n);\nunclaimedDividends = unclaimedDividends.add(amount);\n  } else {\nbuffer = buffer.add(amount);\n  }\n }\n function userInfo(address user)\n  public\n  view\n  returns (\nuint256 depositedAl,\nuint256 pendingdivs,\nuint256 inbucket,\nuint256 realised\n  )\n {\n  uint256 _depositedAl = depositedWaTokens[user];\n  uint256 _toDistribute = buffer.mul(block.number.sub(lastDepositBlock)).div(TRANSMUTATION_PERIOD);\n  if(block.number.sub(lastDepositBlock) > TRANSMUTATION_PERIOD){\n_toDistribute = buffer;\n  }\n  uint256 _pendingdivs = _toDistribute.mul(depositedWaTokens[user]).div(totalSupplyWaTokens);\n  uint256 _inbucket = tokensInBucket[user].add(dividendsOwing(user));\n  uint256 _realised = realisedTokens[user];\n  return (_depositedAl, _pendingdivs, _inbucket, _realised);\n }\n function getMultipleUserInfo(uint256 from, uint256 to)\n  public\n  view\n  returns (address[] memory theUserList, uint256[] memory theUserData)\n {\n  uint256 i = from;\n  uint256 delta = to - from;\n  address[] memory _theUserList = new address[](delta); //user\n  uint256[] memory _theUserData = new uint256[](delta * 2); //deposited-bucket\n  uint256 y = 0;\n  uint256 _toDistribute = buffer.mul(block.number.sub(lastDepositBlock)).div(TRANSMUTATION_PERIOD);\n  if(block.number.sub(lastDepositBlock) > TRANSMUTATION_PERIOD){\n_toDistribute = buffer;\n  }\n  for (uint256 x = 0; x < delta; x += 1) {\n_theUserList[x] = userList[i];\n_theUserData[y] = depositedWaTokens[userList[i]];\n_theUserData[y + 1] = dividendsOwing(userList[i]).add(tokensInBucket[userList[i]]).add(_toDistribute.mul(depositedWaTokens[userList[i]]).div(totalSupplyWaTokens));\ny += 2;\ni += 1;\n  }\n  return (_theUserList, _theUserData);\n }\n function bufferInfo() public view returns (uint256 _toDistribute, uint256 _deltaBlocks, uint256 _buffer){\n  _deltaBlocks = block.number.sub(lastDepositBlock);\n  _buffer = buffer; \n  _toDistribute = _buffer.mul(_deltaBlocks).div(TRANSMUTATION_PERIOD);\n \n\n###\n\n", "completion": "yes,ID-related violations###\n###"}
{"prompt": "function setAUTO(IERC777 AUTO) external {\n  require(!_AUTOSet, \"SM: AUTO already set\");\n  _AUTOSet = true;\n  _AUTO = AUTO;\n }\n\n\n function getOracle() external view override returns (IOracle) {\n  return _oracle;\n }\n\n function getAUTOAddr() external view override returns (address) {\n  return address(_AUTO);\n }\n\n function getTotalStaked() external view override returns (uint) {\n  return _totalStaked;\n }\n\n function getStake(address staker) external view override returns (uint) {\n  return _stakerToStakedAmount[staker];\n }\n\n function getStakes() external view override returns (address[] memory) {\n  return _stakes;\n }\n\n function getStakesLength() external view override returns (uint) {\n  return _stakes.length;\n }\n\n function getStakesSlice(uint startIdx, uint endIdx) external view override returns (address[] memory) {\n  address[] memory slice = new address[](endIdx - startIdx);\n  uint sliceIdx = 0;\n  for (uint stakeIdx = startIdx; stakeIdx < endIdx; stakeIdx++) {\nslice[sliceIdx] = _stakes[stakeIdx];\nsliceIdx++;\n  }\n\n  return slice;\n }\n\n function getCurEpoch() public view override returns (uint96) {\n  return uint96((block.number / BLOCKS_IN_EPOCH) * BLOCKS_IN_EPOCH);\n }\n\n function getExecutor() external view override returns (Executor memory) {\n  return _executor;\n }\n\n function isCurExec(address addr) external view override returns (bool) {\n  Executor memory ex = _executor;\n  if (ex.forEpoch == getCurEpoch()) {\nif (ex.addr == addr) {\n return true;\n} else {\n return false;\n}\n  }\n  if (_stakes.length == 0) { return true; }\n\n  return false;\n }\n\n function getUpdatedExecRes() public view override returns (uint96 epoch, uint randNum, uint idxOfExecutor, address exec) {\n  epoch = getCurEpoch();\n  address[] memory stakes = _stakes;\n  if (_executor.forEpoch != epoch && stakes.length > 0) {\nrandNum = _oracle.getRandNum(epoch - 1);\nidxOfExecutor = randNum % stakes.length;\nexec = stakes[idxOfExecutor];\n  }\n }\n\n function updateExecutor() external override nonReentrant noFish returns (uint, uint, uint, address) {\n  return _updateExecutor();\n }\n\n function isUpdatedExec(address addr) external override nonReentrant noFish returns (bool) {\n  Executor memory ex = _executor;\n  if (ex.forEpoch == getCurEpoch()) {\nif (ex.addr == addr) {\n return true;\n} else {\n return false;\n}\n  } else {\n(, , , address exec) = _updateExecutor();\nif (exec == addr) { return true; }\n  }\n  if (_stakes.length == 0) { return true; }\n\n  return false;\n }\n\n function stake(uint numStakes) external nzUint(numStakes) nonReentrant updateExec noFish override {\n  uint amount = numStakes * STAN_STAKE;\n  _stakerToStakedAmount[msg.sender] += amount;\n  IERC777 AUTO = _AUTO;\n\n  uint balBefore = AUTO.balanceOf(address(this));\n  AUTO.operatorSend(msg.sender, address(this), amount, \"\", _stakingIndicator);\n  require(AUTO.balanceOf(address(this)) - balBefore == amount, \"SM: transfer bal check failed\");\n\n  for (uint i; i < numStakes; i++) {\n_stakes.push(msg.sender);\n  }\n\n  _totalStaked += amount;\n  emit Staked(msg.sender, amount);\n }\n\n function unstake(uint[] calldata idxs) external nzUintArr(idxs) nonReentrant updateExec noFish override {\n  uint amount = idxs.length * STAN_STAKE;\n  require(amount <= _stakerToStakedAmount[msg.sender], \"SM: not enough stake, peasant\");\n\n  for (uint i = 0; i < idxs.length; i++) {\nrequire(_stakes[idxs[i]] == msg.sender, \"SM: idx is not you\");\nrequire(idxs[i] < _stakes.length, \"SM: idx out of bounds\");\n_stakes[idxs[i]] = _stakes[_stakes.length-1];\n_stakes.pop();\n  }\n  \n  _stakerToStakedAmount[msg.sender] -= amount;\n  _AUTO.send(msg.sender, amount, _stakingIndicator);\n  _totalStaked -= amount;\n  emit Unstaked(msg.sender, amount);\n }\n\n function _updateExecutor() private returns (uint96 epoch, uint randNum, uint idxOfExecutor, address exec) {\n  (epoch, randNum, idxOfExecutor, exec) = getUpdatedExecRes();\n  if (exec != _ADDR_0) {\n_executor = Executor(exec, epoch);\n  }\n }\n\n modifier updateExec() {\n  _updateExecutor();\n  _;\n }\n\n modifier noFish() {\n  _;\n  require(_AUTO.balanceOf(address(this)) >= _totalStaked, \"SM: something fishy here\");\n }\n\n function tokensReceived(\n  address _operator,\n  address _from,\n  address _to,\n  uint256 _amount,\n  bytes calldata _data,\n  bytes calldata _operatorData\n ) external override {\n  require(msg.sender == address(_AUTO), \"SM: non-AUTO token\");\n  require(keccak256(_operatorData) == keccak256(_stakingIndicator), \"SM: sending by mistake\");\n }\n\n###\n\n", "completion": "yes,ID-related violations###\n###"}
{"prompt": " function owner() public view virtual returns (address) {\n  return _owner;\n }\n\n modifier onlyOwner() {\n  require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n  _;\n }\n\n function renounceOwnership() public virtual {\n  emit OwnershipTransferred(_owner, address(0));\n  _owner = address(0);\n }\n\n\n function _transfer(\n  address from,\n  address to,\n  uint256 amount\n ) private {\n  require(from != address(0) && to != address(0), \"ERR: Using 0 address!\");\n  require(amount > 0, \"Token value must be higher than zero.\");\n\n  if(\ntxCount >= swapTrigger && \n!inSwapAndLiquify &&\nfrom != uniswapV2Pair &&\nswapAndLiquifyEnabled \n)\n  {  \n\nuint256 contractTokenBalance = balanceOf(address(this));\ntxCount = 0;\nswapAndLiquify(contractTokenBalance);\n  }\n  \n  bool takeFee = true;\n  bool isBuy;\n  if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\ntakeFee = false;\n  } else {\n\nif(from == uniswapV2Pair){\n isBuy = true;\n}\n\ntxCount++;\n\n  }\n\n  _tokenTransfer(from, to, amount, takeFee, isBuy);\n\n }\n \n function sendToWallet(address payable wallet, uint256 amount) private {\nwallet.transfer(amount);\n\n  }\n\n\n function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n\nuint256 tokens_to_Burn = contractTokenBalance * Percent_Burn / 100;\n_tTotal = _tTotal - tokens_to_Burn;\n_tOwned[Wallet_Burn] = _tOwned[Wallet_Burn] + tokens_to_Burn;\n_tOwned[address(this)] = _tOwned[address(this)] - tokens_to_Burn; \n\nuint256 tokens_to_M = contractTokenBalance * Percent_Game / 100;\nuint256 tokens_to_D = contractTokenBalance * Percent_Dev / 100;\nuint256 tokens_to_LP_Half = contractTokenBalance * Percent_AutoLP / 200;\n\nuint256 balanceBeforeSwap = address(this).balance;\nswapTokensForBNB(tokens_to_LP_Half + tokens_to_M + tokens_to_D);\nuint256 BNB_Total = address(this).balance - balanceBeforeSwap;\n\nuint256 split_M = Percent_Game * 100 / (Percent_AutoLP + Percent_Game + Percent_Dev);\nuint256 BNB_M = BNB_Total * split_M / 100;\n\nuint256 split_D = Percent_Dev * 100 / (Percent_AutoLP + Percent_Game + Percent_Dev);\nuint256 BNB_D = BNB_Total * split_D / 100;\n\n\naddLiquidity(tokens_to_LP_Half, (BNB_Total - BNB_M - BNB_D));\nemit SwapAndLiquify(tokens_to_LP_Half, (BNB_Total - BNB_M - BNB_D), tokens_to_LP_Half);\n\nsendToWallet(Wallet_Game, BNB_M);\n\nBNB_Total = address(this).balance;\nsendToWallet(Wallet_Dev, BNB_Total);\n\n}\n\n function swapTokensForBNB(uint256 tokenAmount) private {\n\n  address[] memory path = new address[](2);\n  path[0] = address(this);\n  path[1] = uniswapV2Router.WETH();\n  _approve(address(this), address(uniswapV2Router), tokenAmount);\n  uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\ntokenAmount,\n0, \npath,\naddress(this),\nblock.timestamp\n  );\n }\n\n\n function addLiquidity(uint256 tokenAmount, uint256 BNBAmount) private {\n\n  _approve(address(this), address(uniswapV2Router), tokenAmount);\n  uniswapV2Router.addLiquidityETH{value: BNBAmount}(\naddress(this),\ntokenAmount,\n0, \n0,\nWallet_Burn, \nblock.timestamp\n  );\n } \n\n\n function _tokenTransfer(address sender, address recipient, uint256 tAmount, bool takeFee, bool isBuy) private {\n  \n  \n  if(!takeFee){\n\n_tOwned[sender] = _tOwned[sender]-tAmount;\n_tOwned[recipient] = _tOwned[recipient]+tAmount;\nemit Transfer(sender, recipient, tAmount);\n\nif(recipient == Wallet_Burn)\n_tTotal = _tTotal-tAmount;\n\n} else if (isBuy){\n\nuint256 buyFEE = tAmount*_Tax_On_Buy/100;\nuint256 tTransferAmount = tAmount-buyFEE;\n\n_tOwned[sender] = _tOwned[sender]-tAmount;\n_tOwned[recipient] = _tOwned[recipient]+tTransferAmount;\n_tOwned[address(this)] = _tOwned[address(this)]+buyFEE;\nemit Transfer(sender, recipient, tTransferAmount);\n\nif(recipient == Wallet_Burn)\n_tTotal = _tTotal-tTransferAmount;\n\n} else {\n\nuint256 sellFEE = tAmount*_Tax_On_Sell/100;\nuint256 tTransferAmount = tAmount-sellFEE;\n\n_tOwned[sender] = _tOwned[sender]-tAmount;\n_tOwned[recipient] = _tOwned[recipient]+tTransferAmount;\n_tOwned[address(this)] = _tOwned[address(this)]+sellFEE;\nemit Transfer(sender, recipient, tTransferAmount);\n\nif(recipient == Wallet_Burn)\n_tTotal = _tTotal-tTransferAmount;\n\n\n}\n\n }\n\n###\n\n", "completion": "yes,ID-related violations###\n###"}
{"prompt": "if (pair.factory() == v2Factory) {\nuint256 reserve0 = IBEP20(token0).balance0f( aggregator);\nuint256 reserve1 = IBEP20(token1).balance0f(_aggregator);\nprice =(reserve1 *10**decimalsIn) / reserve0;\n else if (pair.factory() == v3Factory){\nIUniswapV3Pool pool = IUniswapV3Pool( aggregator);\n(uint160 sqrtPricex96,,,,)= poo.sloto();}\n\n###\n\n", "completion": "yes,ID-related violations###\n###"}
